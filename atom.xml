<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Typecasting</title>
  
  <subtitle>write some articles about front-end dev,ui design,linux hacking and ai-cv.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://herotiga.github.io/"/>
  <updated>2022-05-30T07:36:45.167Z</updated>
  <id>https://herotiga.github.io/</id>
  
  <author>
    <name>Mason小王子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue组件通信的几种方式</title>
    <link href="https://herotiga.github.io/2022/05/28/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://herotiga.github.io/2022/05/28/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2022-05-28T06:25:49.000Z</published>
    <updated>2022-05-30T07:36:45.167Z</updated>
    
    <content type="html"><![CDATA[<p>组件的数据有三种形态：props，data，computed。</p><p>下面的方法要么是通过某种方法使得组件之间直接通信，要么是使用了第三方作为中转。</p><a id="more"></a><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="props-emit"><a href="#props-emit" class="headerlink" title="props/$emit"></a>props/$emit</h2><p>可以实现父子组件之间的通信。</p><p>父组件通过 <code>props</code> 向子组件传递数据。</p><p>子组件通过 <code>$emit</code> 触发事件向父组件传递数据，父组件通过 <code>v-on</code> 监听这个事件从而获取子组件传递的数据。</p><p>代码省略。</p><h2 id="事件中心"><a href="#事件中心" class="headerlink" title="事件中心"></a>事件中心</h2><p>可以实现任何组件之间的通信。</p><p>通过new一个空的Vue实例作为事件中心，相当于是一个发布订阅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发指定事件并携带数据</span></span><br><span class="line">Event.$emit(eventName, data);</span><br><span class="line"><span class="comment">// 监听指定事件并获取数据</span></span><br><span class="line">Event.$on(eventName, (data) =&gt; &#123;</span><br><span class="line">    <span class="comment">// get data</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>可以实现任何组件之间的通信。</p><ul><li>state存储数据，不能直接操作state，需要通过vuex的方法集操作state。</li><li>组件通过mutations操作state中的数据。</li><li>actions用于异步操作，最终提交mutations操作。</li></ul><p>vuex数据持久化到localStorage。</p><ul><li>将vuex数据持久化到locaStorage前要先<code>JSON.stringify()</code>为字符串。</li><li>将localStorage中的数据取出时要<code>JSON.parse()</code>为数组。</li></ul><h2 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="attrs/listeners"></a>attrs/listeners</h2><p>hexo将标题两个 <code>$</code> 包裹的部分渲染为了数学公式故而没写美元符号。</p><p><code>$attrs</code> 对象：包含了父组件传递了但是子组件props中没有暴露的属性。<br><code>$listeners</code> 对象：存放的是父组件中绑定的非原生事件。</p><h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h2><p>祖父组件通过provide向后代组件传递变量。<br>后代组件通过inject来注入变量。<br>祖父组件provide的变量是不会变动的。</p><p>使用 <code>Vue.observable</code> 可以实现组件组件provide变量改变后，后代组件inject的变量也能响应式的改变呢。</p><h2 id="parent-children-ref"><a href="#parent-children-ref" class="headerlink" title="parent, children, ref"></a>parent, children, ref</h2><p><code>$parent</code> 和 <code>$children</code> 用于访问父子组件实例。</p><p><code>ref</code> 用于普通元素就是指向该DOM，如果用于组件就是指向组件实例，可以直接获取组件实例的所有数据方法。</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ol><li><a href="https://segmentfault.com/a/1190000019208626">https://segmentfault.com/a/1190000019208626</a></li><li><a href="https://vue3js.cn/interview/vue/communication.html">https://vue3js.cn/interview/vue/communication.html</a></li><li><a href="https://www.jianshu.com/p/2e5973fe1223">https://www.jianshu.com/p/2e5973fe1223</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件的数据有三种形态：props，data，computed。&lt;/p&gt;
&lt;p&gt;下面的方法要么是通过某种方法使得组件之间直接通信，要么是使用了第三方作为中转。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue模板的编译原理</title>
    <link href="https://herotiga.github.io/2022/05/26/Vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>https://herotiga.github.io/2022/05/26/Vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-25T23:44:43.000Z</published>
    <updated>2022-05-26T00:55:04.257Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的编译就是将 <code>template</code> 模板转化成 <code>render</code> 函数的过程。</p><p>再通过 <code>render</code> 函数生成最新的vnode，再用vnode去渲染页面。</p><a id="more"></a><p>模板编译过程：</p><ol><li>将模板解析为AST（抽象语法树），可以看做是解析器。</li><li>遍历AST，标记静态节点，可以看做是优化器。</li><li>使用AST生成<code>render</code>函数，可以看做是代码生成器。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue的编译就是将 &lt;code&gt;template&lt;/code&gt; 模板转化成 &lt;code&gt;render&lt;/code&gt; 函数的过程。&lt;/p&gt;
&lt;p&gt;再通过 &lt;code&gt;render&lt;/code&gt; 函数生成最新的vnode，再用vnode去渲染页面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer-11-旋转数组的最小数字</title>
    <link href="https://herotiga.github.io/2022/05/25/%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://herotiga.github.io/2022/05/25/%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2022-05-25T04:21:30.000Z</published>
    <updated>2022-05-25T04:42:49.906Z</updated>
    
    <content type="html"><![CDATA[<p>难度：简单</p><a id="more"></a><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3, 4, 5, 1, 2] 为 [1, 2, 3, 4, 5] 的一次旋转，该数组的最小值为 1。  </p><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>示例 1：</p><pre><code>输入：numbers = [3, 4, 5, 1, 2]输出：1</code></pre><p>示例 2：</p><pre><code>输入：numbers = [2, 2, 2, 0, 1]输出：0</code></pre><p>提示：</p><ul><li>n == numbers.length</li><li>1 &lt;= n &lt;= 5000</li><li>-5000 &lt;= numbers[i] &lt;= 5000</li><li>numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>遍历数组，直到找到一个index，其元素值小于前面的一个元素值，如果没有则返回第一个元素值。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>看代码</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = numbers.length;</span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &gt; numbers[i + <span class="number">1</span>]) <span class="keyword">return</span> numbers[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = numbers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="built_in">Number</span>.parseInt((right - left) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h2><pre><code>注意：被旋转的数组后半部分最后一个值小于等于前半部分第一个值。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;难度：简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://herotiga.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://herotiga.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>node.js学习笔记（ongoing）</title>
    <link href="https://herotiga.github.io/2022/05/22/nodejs-note/"/>
    <id>https://herotiga.github.io/2022/05/22/nodejs-note/</id>
    <published>2022-05-22T10:49:51.000Z</published>
    <updated>2022-05-30T11:21:13.045Z</updated>
    
    <content type="html"><![CDATA[<p>未整理完毕。</p><a id="more"></a><!-- ## ref1. https://www.runoob.com/nodejs/nodejs-tutorial.html -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;未整理完毕。&lt;/p&gt;
    
    </summary>
    
    
      <category term="node.js" scheme="https://herotiga.github.io/categories/node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>洗牌算法之Knuth-Shuffle算法</title>
    <link href="https://herotiga.github.io/2022/05/12/Knuth-Shuffle/"/>
    <id>https://herotiga.github.io/2022/05/12/Knuth-Shuffle/</id>
    <published>2022-05-12T00:59:10.000Z</published>
    <updated>2022-05-19T10:58:32.613Z</updated>
    
    <content type="html"><![CDATA[<p>看到好多公众号里写的洗牌算法有问题。</p><a id="more"></a><p>比如，最常见的一种是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法的问题在于 <code>Math.random() - 0.5</code> 会导致左边的元素会堆积在左边，右边的元素会堆积在右边，尽管数组在被洗牌后看起来像是被打乱了。</p><p>洗牌算法的核心应该是找到一个映射方法，将数组中原来的元素value随机放置到数组中一个新的index上。</p><h2 id="Knuth-Shuffle算法"><a href="#Knuth-Shuffle算法" class="headerlink" title="Knuth-Shuffle算法"></a>Knuth-Shuffle算法</h2><p>关于Knuth-Shuffle，CSDN等博客基本写的都有问题。</p><p>我的理解如下：</p><ol><li>一个长度为n的数组，设置一个指针rightPos放在最右边。</li><li>随机选取包含该rightPos在内的前n个元素的其中一个元素，将rightPos元素与其交换，这样可以保证rightPos元素有几率留在原位置。</li><li>rightPos左移一位，重复第2步直到rightPos为0。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  改变原数组并返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> len = <span class="keyword">this</span>.length, i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 指针index</span></span><br><span class="line">        <span class="keyword">let</span> rightPos = i;</span><br><span class="line">        <span class="comment">// 随机选取前i+1个元素的index</span></span><br><span class="line">        <span class="keyword">let</span> randomPos = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 交换两个元素</span></span><br><span class="line">        [<span class="keyword">this</span>[randomPos], <span class="keyword">this</span>[rightPos]] = [<span class="keyword">this</span>[rightPos], <span class="keyword">this</span>[randomPos]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].shuffle();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到好多公众号里写的洗牌算法有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://herotiga.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://herotiga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>MySQL架构</title>
    <link href="https://herotiga.github.io/2022/05/05/mysql%E6%9E%B6%E6%9E%84/"/>
    <id>https://herotiga.github.io/2022/05/05/mysql%E6%9E%B6%E6%9E%84/</id>
    <published>2022-05-05T14:54:11.000Z</published>
    <updated>2022-05-30T08:14:59.507Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL架构</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/herotiga/cdn@master/img/article/mysql-arch.jpg" alt="mysql-arch"></p><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>连接池的作用是复用连接，避免频繁 create, destroy。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析器就是解析 SQL 语句。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器会分析 SQL 语句并对其优化。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行器会调用存储引擎的接口来执行 SQL 语句。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL 有多重存储引擎，用于不同场景。</p><ul><li>InnoDB(最常用)</li><li>MyISAM</li><li>Memory</li><li>CSV</li><li>Archive</li><li>Blackhole</li><li>Merge</li><li>Federated</li><li>Example</li></ul><p>存储引擎就是 MySQL 对于内存和磁盘的读写策略。</p><p>InnoDB 包括了：Buffer Pool(数据存储在其中)和 Log Buffer</p><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>MySQL 服务器的内存基本都会分配给 Buffer Pool，可以提升 MySQL 的性能。</p><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>Buffer Pool 以页为单位存储。</p><p>一页包含了：</p><ul><li>上一页，下一页两个指针</li><li>User Record(真正存储信息的地方，是一行一行的数据)</li><li>其余字段</li></ul><p>其余字段包含了：</p><ul><li>Infimum 和 Supremum：此页中最大和最小的记录，用于做初步判断。</li><li>Page Directory：页面目录，用于快速查找记录。</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>InnoDB 底层采用的存储结构是 B 树和 B+树。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新数据时，数据不一定在 buffer pool 中，因为不可能数据库中所有的数据都一直在内存中。</p><p>对于聚簇索引：如果数据不在 buffer pool 中，就会将其先加载到内存中再更新。</p><p>对于非聚簇索引：change buffer。</p><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>MySQL 使用的 LRU 算法的改进版，改进 LRU 算法是为了避免缓冲池污染（先前在 buffer pool 中的页被全部换出去，造成性能下降）</p><h2 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h2><p>用于存储即将被写入到磁盘中的日志。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL架构&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://herotiga.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步编程</title>
    <link href="https://herotiga.github.io/2022/05/05/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://herotiga.github.io/2022/05/05/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-05T12:08:40.000Z</published>
    <updated>2022-05-19T10:58:30.969Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript异步编程的进化历程：callback -&gt; Promise -&gt; Generator -&gt; async/await</p><p>异步的意思是该代码与其他代码的关系是异步执行的，而在该代码自己内部是同步执行的。</p><a id="more"></a><h2 id="回调函数（callback）"><a href="#回调函数（callback）" class="headerlink" title="回调函数（callback）"></a>回调函数（callback）</h2><p>回调函数是js中常见的异步编程方式，比如定时器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会先执行f1的代码，再将传入的f2作为回调函数执行。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// f1 code</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure><p>除了 <code>setTimeout</code> 之外，还有 <code>XMLHttpRequest</code> 也使用了回调函数编写异步任务。</p><h2 id="事件监听（EventListener）"><a href="#事件监听（EventListener）" class="headerlink" title="事件监听（EventListener）"></a>事件监听（EventListener）</h2><p>比如由f1运行一段任务，任务完成后触发一个事件。<br>f2监听这个事件，监听到了就运行任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给f1绑定事件和触发函数f2</span></span><br><span class="line">f1.on(<span class="string">'event_name'</span>, f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行f1的任务，完成后触发事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// f1 code</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        f1.trigger(<span class="string">'event_name'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布-订阅（publish-subscribe）"><a href="#发布-订阅（publish-subscribe）" class="headerlink" title="发布/订阅（publish/subscribe）"></a>发布/订阅（publish/subscribe）</h2><p>有一个信号中心，生产者发布信号（publish）到信号中心，消费者订阅信号中心的信号（subscribe）。</p><p>消费者还可以取消订阅信号（unsubscribe）。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><code>Promise</code> 可以将回调套娃的代码变为扁平的顺序结构。</p><p>Promise对象的状态只能从pending到resolve或者从pending到reject。</p><p>注意： <code>then()</code> 接受两个参数，第一个参数是resolve时调用的函数，第二个参数是reject时调用的函数。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise的参数是一个函数，这个函数会被异步执行</span></span><br><span class="line"><span class="comment">// Promise中的resolve()和reject()用于向then传递参数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then中可以使用return向后面的then传递参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 捕获异常，前面的运行中有任何异常都会直接跳到这里</span></span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最终运行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>jQuery异步编程API：</p><p>基于Promise的when, then, done, fail</p><p>参考我之前写的：<a href="/2018/09/16/jquery-when-done-then/">jQuery的when, then, done, fail</a></p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p><code>Generator</code> 用于创建迭代器(iterator)。</p><p>关于iterator：</p><ul><li>iterator为不同的可迭代的对象提供统一的访问接口。</li><li>可以按照次序迭代可迭代对象。</li><li>可以用for…of语句迭代。</li><li>iterator内有next方法，next内有value（当前迭代的值）和done（是否迭代完成）属性。</li></ul><p>创建迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用next方法</span></span><br><span class="line">iter.next();</span><br></pre></td></tr></table></figure><p>创建Generator并使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Generator,执行后返回一个iterator对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是一个iterator</span></span><br><span class="line"><span class="keyword">let</span> iter = createGenerator();</span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>Generator可以在运行过程中使用 <code>yield</code> 多次return，故而可以异步编程。</p><p>注意：Generator需要配合 <code>yield</code> 和 <code>*</code> 使用。</p><h2 id="异步函数（async-await）"><a href="#异步函数（async-await）" class="headerlink" title="异步函数（async/await）"></a>异步函数（async/await）</h2><p>async/await是JavaScript异步编程的终极解决方案。</p><p>异步函数的返回值是一个Promise对象。</p><p>在异步函数内部，可以使用 <code>await</code> 命令等待一个Promise对象处理的结果（await也可以等待其他数据类型的字面量），再顺序往下执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"asyncFunction"</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> promiseData = <span class="keyword">await</span> asyncFunction();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"helloAsync"</span>);</span><br><span class="line">&#125;</span><br><span class="line">helloAsync();</span><br><span class="line"><span class="comment">// asyncFunction</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></table></figure><p>e.g.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"3"</span>);</span><br><span class="line"><span class="comment">//打印： 1 2 3 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"3"</span>);</span><br><span class="line"><span class="comment">//打印： 3 1 2</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://www.runoob.com/w3cnote/es6-promise.html">https://www.runoob.com/w3cnote/es6-promise.html</a></li><li><a href="https://www.runoob.com/js/js-promise.html">https://www.runoob.com/js/js-promise.html</a></li><li><a href="https://www.runoob.com/js/js-async.html">https://www.runoob.com/js/js-async.html</a></li><li><a href="https://www.runoob.com/w3cnote/es6-async.html">https://www.runoob.com/w3cnote/es6-async.html</a></li><li><a href="https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html</a></li><li><a href="https://mp.weixin.qq.com/s/tGfC5XVuWXuSbG7wFLuaag">https://mp.weixin.qq.com/s/tGfC5XVuWXuSbG7wFLuaag</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript异步编程的进化历程：callback -&amp;gt; Promise -&amp;gt; Generator -&amp;gt; async/await&lt;/p&gt;
&lt;p&gt;异步的意思是该代码与其他代码的关系是异步执行的，而在该代码自己内部是同步执行的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>列出页面上出现次数前n的标签名</title>
    <link href="https://herotiga.github.io/2022/05/02/%E5%88%97%E5%87%BA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%89%8Dn%E7%9A%84%E6%A0%87%E7%AD%BE%E5%90%8D/"/>
    <id>https://herotiga.github.io/2022/05/02/%E5%88%97%E5%87%BA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%89%8Dn%E7%9A%84%E6%A0%87%E7%AD%BE%E5%90%8D/</id>
    <published>2022-05-02T11:22:01.000Z</published>
    <updated>2022-05-19T10:58:30.968Z</updated>
    
    <content type="html"><![CDATA[<p>使用原生js列出页面上出现次数前n的标签名。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>获取页面上所有标签。</li><li>遍历标签，获取每个标签的标签名，如果第一次出现就置位1否则自增1.</li><li>列出页面上出现次数前n的标签名。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getTopNTagNames = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> doms = <span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>);</span><br><span class="line">    <span class="keyword">let</span> countMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = doms.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tagName = doms[i].tagName.toLowerCase();</span><br><span class="line">        countMap[tagName] ? countMap[tagName]++ : countMap[tagName] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> topN = <span class="built_in">Object</span>.entries(countMap).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b[<span class="number">1</span>] - a[<span class="number">1</span>]).slice(<span class="number">0</span>, n);</span><br><span class="line">    topN.map(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">        arr[index] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> topN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用原生js列出页面上出现次数前n的标签名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>《JavaScript语言精粹》读书笔记</title>
    <link href="https://herotiga.github.io/2022/04/29/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://herotiga.github.io/2022/04/29/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-29T05:53:00.000Z</published>
    <updated>2022-05-19T10:58:32.616Z</updated>
    
    <content type="html"><![CDATA[<p>做点笔记。</p><a id="more"></a><h2 id="精华"><a href="#精华" class="headerlink" title="精华"></a>精华</h2><p>null</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>避免使用<code>/* */</code>来写注释，使用<code>//</code>写注释。</li><li>js不允许获取对象属性的时候使用点运算获取属性名为js保留字的属性。</li><li>超过js数字表示极限的值都会被认为是<code>Infinity</code>。</li><li>字符串不可被改变。</li><li>falsy：<code>false</code>,             <code>null</code>,             <code>undefined</code>,             <code>&#39;&#39;</code>,             <code>0</code>,             <code>NaN</code>。</li><li>truthy：不是以上falsy的都属于truthy。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>对象中的属性名如果不是合法的变量名，则需要用括号包裹。</li><li>对象中的属性名如果是合法的变量名，则可以用<code>.</code>代替<code>[&quot;&quot;]</code>。</li><li>可以使用<code>||</code>给一个默认值。</li><li><code>var a = b = c = {}</code>三个变量都指向同一个对象，<code>var a = {}, b = {}, c = {}</code>三个变量指向不同的对象。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数也是对象，可以被保存在变量、对象、数组中。</li><li>函数也可以作为参数或者返回值。</li><li>一个函数可以定义在另一个函数里，里层函数可以获取外层函数中的局部变量以沟通函数和函数外，称之为闭包。</li><li>调用函数的时候会中断当前执行的函数，将控制权交给新函数并给新函数传参。</li><li>函数出了接受形参，还接受<code>this</code>和<code>arguments</code>这两个参数。</li><li>当函数被保存在对象中的一个属性中时，就叫做对象的方法。</li><li><code>this</code>的指向。</li><li>构造函数首字母大写，并且只能<code>new</code>调用。</li><li><code>arguments</code>其实是一个类数组对象。</li><li>函数总是会有返回值，如果没有指定返回值则返回<code>undefined</code>。</li><li>如果函数被调用时前面有<code>new</code>，且返回值不是对象，则返回<code>this</code>。</li></ul><p>在 <code>Function</code> 原型链上添加一个原型方法method，用于给函数对象添加方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.prototype[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prototype[name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>js没有尾递归优化，深度递归可能栈溢出。</li><li>尾递归：是一种在函数最后执行递归调用语句的特殊形式的递归。</li><li>尽量在文件或者函数顶部申明用到的所有变量。</li><li>回调函数可以异步处理数据。</li><li>级联：将没有<code>return</code>的函数返回<code>this</code>就可以创造级联，也就是链式调用。</li><li>柯里化</li><li>记忆: 存储中间结果来优化算法，比如可以优化斐波那契数列的递归算法。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>不同于其他语言使用类来继承，js使用原型<code>prototype</code>来继承。</li><li>构造函数要以大写开头。</li><li>尽量使用对象而不是参数序列来作为传入的参数。</li></ul><p>这章有些地方没看懂，有时间再看一遍。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>给数组添加非index的属性名不会改变数组的<code>length</code>。</li></ul><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>null</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>null</p><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>null</p><h2 id="优美的特性"><a href="#优美的特性" class="headerlink" title="优美的特性"></a>优美的特性</h2><p>null</p><h2 id="附录A：毒瘤"><a href="#附录A：毒瘤" class="headerlink" title="附录A：毒瘤"></a>附录A：毒瘤</h2><ul><li>全局变量</li><li>作用域</li><li>自动插入分号</li><li>保留字（引用对象中的属性名恰好和保留字一样时需要用<code>obj[&#39;property&#39;]</code>的方式引用）</li><li><code>typeof()</code></li><li><code>parseInt()</code></li><li>浮点数不精确（可以通过先乘以一个数变为整数，运算完了再除回来）</li><li><code>NaN</code></li><li>伪数组</li><li>Falsy</li><li><code>hasOwnProperty()</code></li><li>对象</li></ul><h2 id="附录B：糟粕"><a href="#附录B：糟粕" class="headerlink" title="附录B：糟粕"></a>附录B：糟粕</h2><ul><li>不要用<code>==</code>和<code>!=</code></li><li>不要用<code>with</code></li><li>不要用<code>eval</code>，同理也不应该用<code>Function</code>构造器，也不要给<code>setTimeout</code>和<code>setInterval</code>传字符串参数。</li><li>不要用<code>continue</code></li><li>注意<code>switch</code>穿越</li><li>尽量不用<code>++</code>和<code>--</code></li><li>位运算符在js中实际运行很慢。</li><li>包装对象，不要使用<code>new</code>创建包装对象，直接申明字面量即可。</li><li>使用首字母大写命名构造函数，使用<code>new</code>掉用构造函数。</li><li>不要使用<code>void</code></li></ul><h2 id="附录C：JSLint"><a href="#附录C：JSLint" class="headerlink" title="附录C：JSLint"></a>附录C：JSLint</h2><p>null</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做点笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>python3学习笔记(ongoing)</title>
    <link href="https://herotiga.github.io/2022/04/20/python3-note/"/>
    <id>https://herotiga.github.io/2022/04/20/python3-note/</id>
    <published>2022-04-19T16:19:17.000Z</published>
    <updated>2022-05-19T10:58:32.614Z</updated>
    
    <content type="html"><![CDATA[<p>初学python，不想一上来就直接写helloworld，了解一门语言的发展和语言的特性也是非常重要的，所以笔记会比较详细。</p><p>python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。<br>python具有很强的可读性。<br>python3相对python2是较大的一个升级并且没有考虑向下兼容。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>python是解释型语言</li><li>python是交互式语言</li><li>python是面向对象的语言</li><li>python是初学者的语言</li></ul><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><blockquote><p>Python 2.0 于 2000 年 10 月 16 日发布，增加了实现完整的垃圾回收，并且支持 Unicode。<br>Python 3.0 于 2008 年 12 月 3 日发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性后来也被移植到旧的Python 2.6/2.7版本。<br>Python 3.0 版本，常被称为 Python 3000，或简称 Py3k。相对于 Python 的早期版本，这是一个较大的升级。<br>Python 2.7 被确定为最后一个 Python 2.x 版本，它除了支持 Python 2.x 语法外，还支持部分 Python 3.1 语法。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>易于学习</li><li>易于阅读</li><li>易于维护</li><li>广泛的标准库</li><li>交互模式</li><li>可移植</li><li>可扩展</li><li>数据库</li><li>GUI编程</li><li>可嵌入</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>运行速度较慢</li><li>国内使用较少</li><li>中文文档少</li></ul><h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><ul><li>云计算</li><li>web</li><li>科学计算、人工智能</li><li>运维</li><li>金融</li><li>GUI</li><li>爬虫</li><li>等等还有很多</li></ul><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>查看python版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -V</span><br></pre></td></tr></table></figure><p>可以输入 <code>python3</code> 命令进入交互式编程界面。</p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">print(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure><p>python解释器建议写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br></pre></td></tr></table></figure><p>将上面的代码保存为HelloWorld.py，然后使用python3命令运行。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h3><blockquote><p>python官网：<a href="https://www.python.org/">https://www.python.org/</a></p></blockquote><p>在官网下载源码编译安装或者直接下载安装包即可，macos和linux可以使用包管理器安装。</p><h3 id="运行python"><a href="#运行python" class="headerlink" title="运行python"></a>运行python</h3><ol><li>交互解释运行（python命令，ipython）</li><li>python命令运行文件</li><li>IDE、编辑器中运行（pycharm，vscode）</li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ol><li>必须以字母或者下划线_开头。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>大小写敏感。</li><li>在python3中，可以用ASCII字符作为标识符包括汉字。</li></ol><p>python标识符保留字：</p><p>使用下面的方法查询保留的关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">keyword.kwlist</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h3><p>python使用缩进来表示代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"True"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure><h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>[], {}, ()中使用多行语句不需要斜杠。</p><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><ul><li>int: 1</li><li>bool: True, False</li><li>float: 1.23</li><li>complex: 1 + 2j、 1.1 + 2.2j</li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Mason'</span></span><br><span class="line">name = <span class="string">"Mason"</span></span><br><span class="line">full_name = <span class="string">'''my name is</span></span><br><span class="line"><span class="string">Mason'''</span></span><br><span class="line">full_name = <span class="string">"""my name is</span></span><br><span class="line"><span class="string">Mason"""</span></span><br></pre></td></tr></table></figure><ul><li>单行字符串使用单引号或者双引号包裹。</li><li>多行字符串使用三引号<code>&#39;&#39;&#39;</code>或者<code>&quot;&quot;&quot;</code>包裹。</li><li>转义字符<code>\</code>，使用<code>r</code>可以阻止转义。</li><li>字符串使用<code>+</code>拼接，可以使用<code>*</code>重复字符串。</li><li>字符串两种索引方式：从左往右（0开始），从右往左（最右边的索引是-1）。</li><li>字符串中的字符不能改变。</li><li>python中只有字符串没有字符。</li></ul><p>阻止转义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'hello\nworld'</span>)</span><br><span class="line">print(<span class="string">r'hello\nworld'</span>)</span><br></pre></td></tr></table></figure><p>截取字符：变量[头下标: 尾下标: 步长]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Mason'</span></span><br><span class="line">print(name[<span class="number">0</span>])</span><br><span class="line">print(name[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">print(name[<span class="number">0</span>:])</span><br><span class="line">print(name[<span class="number">0</span>:<span class="number">-1</span>])</span><br><span class="line">print(name[<span class="number">0</span>:<span class="number">-1</span>:<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>函数之间、类方法之间、类和函数入口之间都要用空行隔开，便于区分。</p><h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input(<span class="string">'\n\n请输入并以回车结束'</span>)</span><br></pre></td></tr></table></figure><h3 id="多条语句"><a href="#多条语句" class="headerlink" title="多条语句"></a>多条语句</h3><p>使用分号分隔多条语句。</p><h3 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h3><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> exp1:</span><br><span class="line">    suite</span><br><span class="line"><span class="keyword">elif</span> exp2:</span><br><span class="line">    suite</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    suite</span><br></pre></td></tr></table></figure><h3 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h3><p>print输出默认换行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Mason'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认换行</span></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加参数不换行</span></span><br><span class="line">print(name, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="import和from…import"><a href="#import和from…import" class="headerlink" title="import和from…import"></a>import和from…import</h3><p>使用import和from…import来导入模块。</p><p>导入模块： <code>import module</code></p><p>导入模块中的一个函数： <code>from module import function</code></p><p>导入模块中的多个函数： <code>from module import function1, function2, function3</code></p><p>导入模块中的全部函数： <code>from module import *</code></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>python中的数据类型不需要声明，直接赋值。<br>python中的变量是弱类型的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Mason'</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">balance = <span class="number">10000.5</span></span><br></pre></td></tr></table></figure><h3 id="赋值多个变量"><a href="#赋值多个变量" class="headerlink" title="赋值多个变量"></a>赋值多个变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>还有类似es解构赋值的赋值方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="string">'mason'</span>, <span class="number">1</span>, <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><ul><li>Number：数字</li><li>String：字符串</li><li>List：列表</li><li>Tuple：元祖</li><li>Set：集合</li><li>Dictionary：字典</li></ul><p>注意布尔型属于Number类型。</p><p>其中，分为可变数据类型和不可变数据类型</p><p>可变类型：Number, String, Tuple<br>不可变类型：List, Set, Dictionary</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>分为：int（长整型）, float, bool, complex</p><p>使用 <code>type()</code> 可以查询变量指向的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line"><span class="comment"># 其他类型&lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用 <code>isinstance()</code> 判断类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isinstance(<span class="number">1</span>, int)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>两者的区别： <code>type()</code> 不会认为子类是一种父类类型，而 <code>isinstance()</code> 会认为是。</p><p>bool是int的子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">issubclass(bool, int) </span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="literal">True</span> == <span class="number">1</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="literal">False</span> == <span class="number">0</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="literal">True</span> + <span class="number">1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="literal">False</span> + <span class="number">1</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>删除变量引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> myname</span><br><span class="line"><span class="keyword">del</span> myname, age</span><br></pre></td></tr></table></figure><p>数学计算：</p><p>使用： <code>+</code> （加法）, <code>-</code> （减法）, <code>*</code> （乘法）, <code>/</code> （除法，得到浮点数）, <code>//</code> （除法，得到整数）, <code>%</code> （求余数）, <code>**</code> （乘方）</p><p>complex类型：是复数，由实部和虚部组成 <code>a+bj</code> ，或者 <code>complex(a, b)</code> ，a和b都是浮点型。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>省略的部分笔记参考上一章节。</p><p>反斜杠还可以作为续行符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'my name is\</span></span><br><span class="line"><span class="string">Mason</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"><span class="comment"># my name is Mason</span></span><br></pre></td></tr></table></figure><p>也可以使用三引号跨行。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List（列表）就是数组，形如 <code>[&#39;abc&#39;, 123, False]</code> 。</p><p>空列表： <code>[]</code></p><p>List中的每一个元素可以是任何类型。</p><p>截取List中的元素的方法和上面的String截取方式一样。</p><p>List中的+和*：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'abc'</span>, <span class="number">123</span>]</span><br><span class="line">lsit2 = [<span class="number">345</span>, <span class="string">'efg'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用乘号可以重复</span></span><br><span class="line">print(list1*<span class="number">2</span>)</span><br><span class="line"><span class="comment"># ['abc', 123, 'abc', 123]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List可以通过加号拼接</span></span><br><span class="line">print(list1 + list2)</span><br><span class="line"><span class="comment"># ['abc', 123, 345, 'efg']</span></span><br></pre></td></tr></table></figure><p>List中的元素可以改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># [0, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>:<span class="number">4</span>] = [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># [0, 7, 7, 7, 5, 6]</span></span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>:<span class="number">-1</span>] = []</span><br><span class="line"><span class="comment"># [0, 6]</span></span><br></pre></td></tr></table></figure><p>List也可以像String一样设置步长来跳着选取元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">print(list[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># [1, 3, 5]</span></span><br></pre></td></tr></table></figure><p>翻转句子词语顺序实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 翻转句子词序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(sentence)</span>:</span></span><br><span class="line">    <span class="comment"># 先将句子通过空格分割为List</span></span><br><span class="line">    sentenceList = sentence.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 翻转句子sentenceList</span></span><br><span class="line">    reversedSentenceList = sentenceList[<span class="number">-1</span>::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再将reversedSentenceList转为String并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(reversedSentenceList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment"># WTF</span></span><br><span class="line">    s = <span class="string">'my name is Mason'</span></span><br><span class="line">    print(reverseWords(s))  <span class="comment"># Mason is name my</span></span><br></pre></td></tr></table></figure><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>Tuple与List类似，不过元组中的元素不能修改，而且放在小括号()中，使用逗号隔开。<br>Tuple的其他用法和List一致。</p><p>字符串可以看成是一种特殊的元组。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple = (<span class="number">123</span>, <span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure><p>空元组： <code>()</code></p><p>一个元素的元组这样写： <code>(10,)</code></p><p>一个元素的列表可以这样写： <code>[10]</code></p><p>String, List, Tuple都属于序列。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合（Set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>Set可以用于成员关系测试和删除重复元素。</p><p>创建空的Set只能用 <code>set()</code></p><p>创建一个Set：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newSet = &#123;elem1, elem2, elem3&#125;</span><br><span class="line"></span><br><span class="line">newSet = set(elem1)</span><br></pre></td></tr></table></figure><p>Set实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set去重</span></span><br><span class="line">newSet = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>&#125;</span><br><span class="line">print(newSet)   <span class="comment"># &#123;'a', 'b', 'c', 'd'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一个值是否是Set的成员</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">in</span> newSet:</span><br><span class="line">    print(<span class="string">'true'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'false'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set的集合运算</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集运算</span></span><br><span class="line">print(a &amp; b)</span><br><span class="line"><span class="comment"># 并集运算</span></span><br><span class="line">print(a | b)</span><br><span class="line"><span class="comment"># 差集运算</span></span><br><span class="line">print(a - b)</span><br><span class="line"><span class="comment"># a和b中不同时存在的元素，相当于a-b和b-a的并集</span></span><br><span class="line">print(a ^ b)</span><br><span class="line">print(a-b | b-a)</span><br></pre></td></tr></table></figure><h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h3><p>字典是无序对象的集合，就相当于js里面的对象。<br>字典使用{}包裹，里面是键值对。<br>key必须是不可变类型String, Number, Tuple，且key必须唯一。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个字典并向里面添加键值对</span></span><br><span class="line">dict = &#123;&#125;</span><br><span class="line">dict[<span class="string">'name'</span>] = <span class="string">'mason'</span></span><br><span class="line">dict[<span class="number">1</span>] = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接赋值一个字典</span></span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'mason'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典</span></span><br><span class="line">print(dict[<span class="string">'name'</span>])</span><br><span class="line">print(dict(<span class="number">1</span>))</span><br><span class="line">print(dict.keys())</span><br><span class="line">print(dict.values())</span><br></pre></td></tr></table></figure><p>可以使用 <code>dict()</code> 构建字典，传入参数为序列。</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p><code>int(x [,base])</code> : 将x转换为一个整数</p><p><code>float(x)</code> : 将x转换到一个浮点数</p><p><code>complex(real [,imag])</code> : 创建一个复数</p><p><code>str(x)</code> : 将对象 x 转换为字符串</p><p><code>repr(x)</code> : 将对象 x 转换为表达式字符串</p><p><code>eval(str)</code> : 用来计算在字符串中的有效Python表达式, 并返回一个对象</p><p><code>tuple(s)</code> : 将序列 s 转换为一个元组</p><p><code>list(s)</code> : 将序列 s 转换为一个列表</p><p><code>set(s)</code> : 转换为可变集合</p><p><code>dict(d)</code> : 创建一个字典。d 必须是一个 (key, value)元组序列。</p><p><code>frozenset(s)</code> : 转换为不可变集合</p><p><code>chr(x)</code> : 将一个整数转换为一个字符</p><p><code>ord(x)</code> : 将一个字符转换为它的整数值</p><p><code>hex(x)</code> : 将一个整数转换为一个十六进制字符串</p><p><code>oct(x)</code> : 将一个整数转换为一个八进制字符串</p><h2 id="数据类型转换-1"><a href="#数据类型转换-1" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul><li>隐式转换（自动）</li></ul><ol><li>两个不同数据类型之间进行运算的时候，python会自动将低精度数据类型转换为高精度数据类型。</li><li>将数字和字符串进行加法操作会报错。</li></ol><ul><li>显式转换（手动）</li></ul><p>参考上一张最后的api。</p><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><!-- https://www.runoob.com/python3/python-comprehensions.html --><p>推导式是一种数据处理方式，可以将一个数据序列转为另一个数据序列。</p><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line"></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><p>实例：过滤掉小于等于3的数并返回新的List</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">nums_filtered = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num &gt; <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>实例：将一个List通过字典推导式转为Dictionary</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">'abc'</span>,<span class="string">'abcd'</span>, <span class="string">'abcde'</span>]</span><br><span class="line"></span><br><span class="line">dict = &#123;key:len(key) <span class="keyword">for</span> key <span class="keyword">in</span> list&#125;</span><br><span class="line"><span class="comment"># &#123;'abc': 3, 'abcd': 4, 'abcde': 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> Sequence &#125;</span><br><span class="line"></span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> Sequence <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure><p>实例：计算集合中元素的平方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set = &#123;item**<span class="number">2</span> <span class="keyword">for</span> item <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br><span class="line"><span class="comment"># &#123;1,4,9&#125;</span></span><br></pre></td></tr></table></figure><h3 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> Sequence )</span><br><span class="line"></span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> Sequence <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure><p>元组推导式返回的是生成器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tuple_object是生成器对象</span></span><br><span class="line">tuple_object = (item <span class="keyword">for</span> item <span class="keyword">in</span> rrange(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成器对象转为元组</span></span><br><span class="line">tuple(tuple_object)</span><br></pre></td></tr></table></figure><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行python脚本</span></span><br><span class="line">python3 main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予脚本执行权限</span></span><br><span class="line">chmod +x main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./main.py</span><br></pre></td></tr></table></figure><h2 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>python中有以下运算符。</p><ul><li>算术运算符：+ - * / % ** //</li><li>比较运算符：== != &gt; &gt;= &lt; &lt;=</li><li>赋值运算符：= += -= <em>= /= %= *</em>= //= :=(海象运算符)</li><li>逻辑运算符：and or not</li><li>位运算符：&amp; | ^ ~ &lt;&lt; &gt;&gt;</li><li>成员运算符：in, not in, 支持List，String，Tuple</li><li>身份运算符<ul><li>is：判断两个变量是否是同一个对象的引用，a is b，相当于id(a)==id(b)。</li><li>is not：参上</li><li>id()：用于获取变量的内存地址。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">a <span class="keyword">is</span> b </span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>is用于判断两个变量引用对象是否为同一个，==用于判断引用变量的值是否相等。</p><ul><li>运算符优先级：参考<a href="https://www.runoob.com/python3/python3-basic-operators.html">https://www.runoob.com/python3/python3-basic-operators.html</a></li></ul><p>注意and比or优先级高。</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>要引入math包：import math</p><p>下面的api都要用math.round()的形式写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">3.14</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量对于对象的引用</span></span><br><span class="line"><span class="keyword">del</span> a,b</span><br></pre></td></tr></table></figure><p>Number的类型：</p><ul><li>int：整形或者说可以作为long使用，bool型是int的子类型。</li><li>float</li><li>complex：复数，<code>a+bj</code>或者<code>complex(a, b)</code>，其中a和b都是float。</li></ul><h3 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h3><ul><li>int()</li><li>float()</li><li>complex()</li></ul><h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><p>参考之前的章节。</p><p>交互模式中，最后被输出的表达式结果会被赋值给_。</p><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul><li>sqrt()：开方</li><li>abs()</li><li>ceil()</li><li>floor()</li><li>round(x, n)：四舍五入精确到n位</li><li>cmp(x, y)</li><li>exp(x)</li><li>pow(x, y)</li><li>fabs()</li><li>log()</li><li>log10()</li><li>max(x1, x2, …xn)</li><li>min(x1, x2, …xn)</li><li>modf(x)：返回x的整数部分和小数部分。</li></ul><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><ul><li>choice()：从参数序列中随机挑选一个，<code>random.choice(range(10))</code></li><li>randrange(start, stop, step)：从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</li><li>random()：生成一个随机数，范围[0, 1)</li><li>seed()</li><li>shuffle(list)：将list打乱随机排列。</li><li>uniform(x, y)：随机生成一个[x, y]之间的实数。</li></ul><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>就是各种正弦余弦，反正弦反余弦。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>pi：圆周率π</li><li>e：自然常数e</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>和之前字符串重复的地方不作笔记。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul><li><code>\</code>在行尾：作为续行符</li><li><code>\\</code>：反斜杠</li><li><code>\&#39;</code>：单引号</li><li><code>\a</code>：响铃</li><li><code>\b</code>：退格</li><li><code>\000</code>：空</li><li><code>\n</code>：换行</li><li><code>\t</code>：横向制表符</li><li><code>\v</code>：纵向制表符</li><li><code>\r</code>：替换符，将r之后的字符串逐一替换r之前的字符串。</li><li><code>\f</code>：换页</li></ul><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><ul><li>+：拼接字符串。</li><li>*：重复字符串。</li><li>[]：获取字符串下标对应的字符。</li><li>[start:end]：截取字符串。</li><li>in：成员运算符，判断字符是否在字符串中。</li><li>not in</li><li>r/R：表示raw原始字符串，用于避免转义。</li><li>%：字符串格式化</li></ul><p>字符串格式化实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"我叫%s今年%d岁!"</span> % (<span class="string">'mason'</span>, <span class="number">11</span>))</span><br><span class="line"><span class="comment"># 我叫mason今年11岁</span></span><br></pre></td></tr></table></figure><ul><li>%c：格式化字符及其ASCII码</li><li>%s：格式化字符串</li><li>%d：格式化整数</li><li>%u：格式化无符号整型</li><li>%o：格式化无符号八进制数</li><li>%x：格式化无符号十六进制数</li><li>%X：格式化无符号十六进制数（大写）</li><li>%f：格式化浮点数字，可指定小数点后的精度</li><li>%e：用科学计数法格式化浮点数</li><li>%E：作用同%e，用科学计数法格式化浮点数</li><li>%g：%f和%e的简写</li><li>%G：%f和%E的简写</li><li>%p：用十六进制数格式化变量的地址</li></ul><h3 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h3><p>三引号可以让字符串跨多行。</p><h3 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h3><p>f-string是新的格式化字符串的方法。</p><p>用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'mason'</span></span><br><span class="line">print(<span class="string">f'my name is <span class="subst">&#123;name&#125;</span>, and <span class="subst">&#123;<span class="number">10</span>+<span class="number">10</span>&#125;</span> years old'</span>)</span><br></pre></td></tr></table></figure><p>3.8以上版本可以用=来拼接运算式和运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f'<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>=&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># 1+2=3</span></span><br></pre></td></tr></table></figure><h3 id="unicode字符串"><a href="#unicode字符串" class="headerlink" title="unicode字符串"></a>unicode字符串</h3><p>用到的时候查表。</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>随用随查：<a href="https://www.runoob.com/python3/python3-string.html">https://www.runoob.com/python3/python3-string.html</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://www.runoob.com/python3/python3-tutorial.html">https://www.runoob.com/python3/python3-tutorial.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学python，不想一上来就直接写helloworld，了解一门语言的发展和语言的特性也是非常重要的，所以笔记会比较详细。&lt;/p&gt;
&lt;p&gt;python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。&lt;br&gt;python具有很强的可读性。&lt;br&gt;python3相对python2是较大的一个升级并且没有考虑向下兼容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://herotiga.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>红墨水和蓝墨水混合问题</title>
    <link href="https://herotiga.github.io/2022/03/02/%E7%BA%A2%E5%A2%A8%E6%B0%B4%E5%92%8C%E8%93%9D%E5%A2%A8%E6%B0%B4%E6%B7%B7%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <id>https://herotiga.github.io/2022/03/02/%E7%BA%A2%E5%A2%A8%E6%B0%B4%E5%92%8C%E8%93%9D%E5%A2%A8%E6%B0%B4%E6%B7%B7%E5%90%88%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-02T12:54:30.000Z</published>
    <updated>2022-05-19T10:58:30.970Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到个特别有意思的红墨水蓝墨水混合问题：</p><p>题：有一瓶红墨水，一瓶蓝墨水，从红墨水舀一勺到蓝瓶里，搅匀后再舀一勺到红瓶里。<br>问：此时红墨水里含蓝墨水的量和蓝墨水里含红墨水的量关系是什么？大于、小于、等于？</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/herotiga/cdn@master/img/article/red-blue.png" alt=""></p><p>这个题目本身看起来不是一个难题，如果你通过取特殊值计算的结果来判断就不好，因为不具备普遍性。</p><p>如果我们<strong>从状态变化的角度</strong>来看这个问题，可以发现这个问题可以看做是状态的迁移。</p><p><strong>初始态</strong>：红墨水和蓝墨水体积相等，红墨水中不含蓝墨水，蓝墨水中也不含红墨水。<br><strong>最终态</strong>：红墨水瓶中的水和蓝墨水瓶中的水体积依然相等，红墨水瓶中含蓝墨水，蓝墨水瓶中也含红墨水。</p><p>我们不关注两次舀水的过程，单单从状态变化的角度来看，可以发现初始态和最终态两个瓶子中的水的体积都相等，发生变化的是红墨水瓶子中多了蓝墨水而少了红墨水，蓝墨水瓶子中多了红墨水而少了蓝墨水。</p><p>而其实红墨水瓶子中多了的蓝墨水来自于蓝墨水瓶，少了的红墨水去到了蓝墨水瓶，而两者的体积是相等的，无论第一次舀水后是否搅匀，最终红墨水瓶中含有的蓝墨水永远等于蓝墨水瓶中含有的红墨水。</p><!-- https://yanhaijing.com/math/2017/03/23/red-blue-ink/ -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看到个特别有意思的红墨水蓝墨水混合问题：&lt;/p&gt;
&lt;p&gt;题：有一瓶红墨水，一瓶蓝墨水，从红墨水舀一勺到蓝瓶里，搅匀后再舀一勺到红瓶里。&lt;br&gt;问：此时红墨水里含蓝墨水的量和蓝墨水里含红墨水的量关系是什么？大于、小于、等于？&lt;/p&gt;
    
    </summary>
    
    
      <category term="math" scheme="https://herotiga.github.io/categories/math/"/>
    
    
  </entry>
  
  <entry>
    <title>解析let和const声明的变量不在window下的原因</title>
    <link href="https://herotiga.github.io/2022/01/14/let%E5%92%8Cconst%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/"/>
    <id>https://herotiga.github.io/2022/01/14/let%E5%92%8Cconst%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/</id>
    <published>2022-01-14T09:06:04.000Z</published>
    <updated>2022-05-19T10:58:32.614Z</updated>
    
    <content type="html"><![CDATA[<p>使用es5中 <code>var</code> 命令声明的变量可以在 <code>window</code> 下找到，比如：</p><p><code>var myName = &#39;mason&#39;</code> ，可以使用 <code>window.myName</code> 访问到。</p><p>但是使用es6的 <code>let</code> 和 <code>const</code> 声明的变量却没有在window下，这是为什么呢？</p><a id="more"></a><hr><p>这里就要说到<code>window</code>对象和 <code>global</code> 对象。</p><p>对于window和global的看法，之前一直都是：window是浏览器的顶层对象，global是node的顶层对象。</p><p>但是其实window是global在浏览器的代理，window是global的一部分。<br>我们使用var声明的变量会被挂载到window下。</p><p>而let和const声明的变量会被挂载到 <code>script</code> 对象下，script和global是同一层级的。</p><p><img src="https://cdn.jsdelivr.net/gh/herotiga/cdn@master/img/article/script%E5%AF%B9%E8%B1%A1.png" alt="script对象"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用es5中 &lt;code&gt;var&lt;/code&gt; 命令声明的变量可以在 &lt;code&gt;window&lt;/code&gt; 下找到，比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var myName = &amp;#39;mason&amp;#39;&lt;/code&gt; ，可以使用 &lt;code&gt;window.myName&lt;/code&gt; 访问到。&lt;/p&gt;
&lt;p&gt;但是使用es6的 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明的变量却没有在window下，这是为什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL on Mac</title>
    <link href="https://herotiga.github.io/2021/12/20/mysql-on-mac/"/>
    <id>https://herotiga.github.io/2021/12/20/mysql-on-mac/</id>
    <published>2021-12-20T00:47:06.000Z</published>
    <updated>2022-05-30T11:46:32.798Z</updated>
    
    <content type="html"><![CDATA[<p>mac上安装和使用MySQL。</p><a id="more"></a><h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><p>MySQL 官网下载：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>清华 tuna 下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/">https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/</a></p><p>homebrew 安装： <code>brew install mysql@5.7  mysql-client@5.7</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动MySQL</span></span><br><span class="line">mysql.server start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭MySQL</span></span><br><span class="line">mysql.server stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启MySQL</span></span><br><span class="line">mysql.server restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h2><p>注意：所有的sql语句都需要在末尾加上分号。</p><ol><li>展示所有的database：<code>SHOW DATABASES;</code></li><li>选择一个database：<code>use DATABASE_NAME</code>，然后就可以操作数据库了。</li></ol><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>数据库可视化：Navicat(支持 MySQL、MariaDB、MongoDB、SQL Server、Oracle、PostgreSQL 和 SQLite)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac上安装和使用MySQL。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://herotiga.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>防抖(debounce)和节流(throttle)</title>
    <link href="https://herotiga.github.io/2021/12/18/debounce-and-throttle/"/>
    <id>https://herotiga.github.io/2021/12/18/debounce-and-throttle/</id>
    <published>2021-12-18T02:17:10.000Z</published>
    <updated>2022-05-19T10:58:32.616Z</updated>
    
    <content type="html"><![CDATA[<p>防抖和节流的目的都是希望一段时间内不要密集调用callback。</p><p>应用场景：滚动（防抖），搜索（节流）</p><a id="more"></a><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p>有些事件比如 resize, scroll, mousemove 等会被持续的触发，导致 <code>callback</code> 被高频调用，这就要用到防抖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate true 表立即执行，false 表非立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line"></span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait);</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。</p><p>时间戳版和定时器版的节流函数的区别是：时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数节流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>type 1 表时间戳版，2 表定时器版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                previous = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    timeout = <span class="literal">null</span>;</span><br><span class="line">                    func.apply(context, args);</span><br><span class="line">                &#125;, wait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防抖是控制次数，节流是控制频率。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><a href="https://segmentfault.com/a/1190000018428170">简版 debounce 和 throttle</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;防抖和节流的目的都是希望一段时间内不要密集调用callback。&lt;/p&gt;
&lt;p&gt;应用场景：滚动（防抖），搜索（节流）&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js中的垃圾回收机制(Garbage Collection)和内存泄漏(Memory Leak)</title>
    <link href="https://herotiga.github.io/2021/12/18/js%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://herotiga.github.io/2021/12/18/js%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2021-12-18T02:14:30.000Z</published>
    <updated>2022-05-19T10:58:32.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收机制（Garbage-Collection）"><a href="#垃圾回收机制（Garbage-Collection）" class="headerlink" title="垃圾回收机制（Garbage Collection）"></a>垃圾回收机制（Garbage Collection）</h2><p>js 有自动垃圾回收机制（GC），GC 会周期性的清理不使用的变量所占用的内存空间。 不同浏览器的 GC 机制都不同，不同环境的 GC 机制也不同。</p><a id="more"></a><p>不使用的变量主要是指局部变量，GC 会在局部变量使用完后等到下一个 GC 周期时释放该变量所占用的内存空间（在堆或者栈中）。</p><p>GC 判断变量是否需要被释放是通过标记清除（更为常用）和引用计数。</p><p>手动解除内存占用，就是将变量赋值为 null： <code>var_name = null;</code></p><h3 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h3><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>GC 会给所有进入环境（指的是全局环境或者局部）的变量（发生在变量声明时）打上标记“进入环境”，在变量离开环境时将其标记为“离开环境“，GC 会在下一个 GC 周期时释放被标记为离开环境的变量所占用的内存。</p><p>不同浏览器标记清除的策略略有不同。</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>GC 统计变量值的引用数量，引用计数变为 0 则表明该变量所占用的内存可以被释放，这样 GC 会在下一次运行的时候回收该内存空间。</p><p>故而，只声明了但是没有被使用的变量的引用计数为 1，所以也会造成内存泄漏。</p><p>引用计数会带来一个问题：循环引用。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">    a.pro = b; <span class="comment">// a引用了b</span></span><br><span class="line">    b.pro = a; <span class="comment">// b引用了a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>上面的代码运行结果是 a 和 b 的引用计数都为 2，a 和 b 的引用计数都无法降为 0，故而造成了这部分内存始终无法被 GC 释放，随着 <code>fn</code> 被多次调用，a 和 b 所占用的内存就会线性增长，造成内存泄漏。</p><p><strong>IE7&amp;8 中有部分对象不是 js 原生对象而是 COM 对象，COM 对象的垃圾回收机制采用的就是引用计数策略。故而在 IE7&amp;8 中访问 COM 对象如果存在循环引用就会导致内存泄漏。</strong></p><p>循环引用的解决方法：在变量使用完后手动破坏变量之间的互相引用关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">    a.pro = b; <span class="comment">// a引用了b</span></span><br><span class="line">    b.pro = a; <span class="comment">// b引用了a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line"></span><br><span class="line">    a.pro = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h3 id="垃圾回收策略优化"><a href="#垃圾回收策略优化" class="headerlink" title="垃圾回收策略优化"></a>垃圾回收策略优化</h3><p>GC 在其运行期间会造成浏览器无响应。 需要优化 GC 策略来缩短无响应 duration。</p><h4 id="优化策略一：分代回收（Generation-GC）"><a href="#优化策略一：分代回收（Generation-GC）" class="headerlink" title="优化策略一：分代回收（Generation GC）"></a>优化策略一：分代回收（Generation GC）</h4><p>和 JVM GC 策略一样。</p><p>js 将待回收的变量分为临时（young generation）和持久（tenured generation），多回收 young generation，少回收 tenured generation，从而减少了整体回收的变量。</p><p>变量在 young generation 和 tenured generation 之间的迁转移需要额外的开销。</p><h4 id="优化策略二：增量回收"><a href="#优化策略二：增量回收" class="headerlink" title="优化策略二：增量回收"></a>优化策略二：增量回收</h4><p>增量回收的策略就是每次只回收一点，提高回收的频率。</p><p>这种方法可以使每次回收的时间很短，但是带来了回收的次数很频繁。</p><h2 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h2><p>内存泄漏：不再用到的变量占着内存并且没有被释放。</p><h3 id="不合法的全局变量"><a href="#不合法的全局变量" class="headerlink" title="不合法的全局变量"></a>不合法的全局变量</h3><p>原因 1：未声明的变量或者 this 创建的变量会引发内存泄漏。 解决方法：1. 避免申明全局变量。 2. 使用严格模式。</p><p>原因 2：vue 单页面中声明全局变量在切换页面时没有释放。 解决方法：卸载页面时销毁引用，销毁引用并不能回收内存，而是让变量脱离执行环境从而可以让 GC 在下一次执行的时候回其收内存。</p><p>vue 中的其他内存泄漏的情况：<a href="https://segmentfault.com/a/1190000012738358#item-5">https://segmentfault.com/a/1190000012738358#item-5</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">destroyed() &#123;</span><br><span class="line">    <span class="built_in">window</span>.variate_name = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>原因：闭包保持它的变量一直在内存中，故而使用闭包的时候要注意内存泄漏。 解决方法：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对 DOM 的引用。</p><h3 id="定时器和事件监听"><a href="#定时器和事件监听" class="headerlink" title="定时器和事件监听"></a>定时器和事件监听</h3><p>卸载页面之前需要清除定时器和事件监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy() &#123;</span><br><span class="line">    <span class="comment">// 清除定时器</span></span><br><span class="line">    <span class="comment">// 清除事件监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><ol><li>DOM 引用了对象作为其属性或者样式。</li><li>将 DOM 赋值给了一个变量，最后要给变量赋值 null。</li></ol><h2 id="WeakMap和WeakSet-解决内存泄漏"><a href="#WeakMap和WeakSet-解决内存泄漏" class="headerlink" title="WeakMap和WeakSet 解决内存泄漏"></a>WeakMap和WeakSet 解决内存泄漏</h2><p>es6 提供了 WaekMap 和 WeakSet 来解决引用带来的内存泄漏。</p><figure class="highlight js"><figcaption><span>WeakMap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"example"</span>); </span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">"some information"</span>); </span><br><span class="line">wm.get(element); <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure><p>GC 会忽略 <code>wm</code> 对于 <code>element</code> 的引用，故而 <code>element</code> 实际的引用计数为 1。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><a href="https://www.jb51.net/article/187661.htm">https://www.jb51.net/article/187661.htm</a></li><li><a href="https://segmentfault.com/a/1190000012738358">https://segmentfault.com/a/1190000012738358</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;垃圾回收机制（Garbage-Collection）&quot;&gt;&lt;a href=&quot;#垃圾回收机制（Garbage-Collection）&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收机制（Garbage Collection）&quot;&gt;&lt;/a&gt;垃圾回收机制（Garbage Collection）&lt;/h2&gt;&lt;p&gt;js 有自动垃圾回收机制（GC），GC 会周期性的清理不使用的变量所占用的内存空间。 不同浏览器的 GC 机制都不同，不同环境的 GC 机制也不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>合并两个升序数组</title>
    <link href="https://herotiga.github.io/2021/12/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://herotiga.github.io/2021/12/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-12-18T02:00:16.000Z</published>
    <updated>2022-05-19T10:58:32.615Z</updated>
    
    <content type="html"><![CDATA[<p>难度：简单</p><a id="more"></a><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>合并两个升序数组，返回合并后的数组，合并后的数组依然为升序，元素不能重复。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>方法一：从前往后一次对比两个数组的元素，小的 <code>push</code> 到新数组。</p><p>方法二：先拼接两个数组，再去重，最后排序。</p><p>排序导致了该方法效率低。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> list2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">mergeLists(list1, list2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergeLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> L1_LEN = l1.length;</span><br><span class="line">    <span class="keyword">const</span> L2_LEN = l2.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!L1_LEN) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (!L2_LEN) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = [];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1_LEN &amp;&amp; j &lt; L2_LEN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1[i] &lt; l2[j]) &#123;</span><br><span class="line">            target.push(l1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1[i] &gt; l2[j]) &#123;</span><br><span class="line">            target.push(l2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target.push(l1[i]);</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">        target = target.concat(l2.slice(j));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target = target.concat(l1.slice(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> list2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">mergeLists(list1, list2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergeLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l1.length) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (!l2.length) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = l1.concat(l2);</span><br><span class="line">    target = [...new <span class="built_in">Set</span>(target)];</span><br><span class="line">    <span class="keyword">return</span> target.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;难度：简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://herotiga.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://herotiga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>分布式session</title>
    <link href="https://herotiga.github.io/2021/12/07/%E5%88%86%E5%B8%83%E5%BC%8Fsession/"/>
    <id>https://herotiga.github.io/2021/12/07/%E5%88%86%E5%B8%83%E5%BC%8Fsession/</id>
    <published>2021-12-07T01:09:38.000Z</published>
    <updated>2022-05-19T10:58:30.970Z</updated>
    
    <content type="html"><![CDATA[<p>在传统的单体应用中，后台只需要根据session获取用户身份的和信息既可。在集群中也只需要将用户的请求通过一种hash算法均匀的映射到多台服务器（且每次都映射到同一台服务器）既可，。而在分布式的应用中如何处理session呢？</p><a id="more"></a><p>一个分布式的应用是由多个模块构成，模块可能不在一个服务器上，一个模块可能也部署了集群，如何保证集群+分布式应用上的session可用呢。</p><h2 id="策略一：粘性session"><a href="#策略一：粘性session" class="headerlink" title="策略一：粘性session"></a>策略一：粘性session</h2><p>粘性session就是将用户的请求绑定到一台服务器上。</p><p>实现过程：</p><ol><li>负载均衡服务器将用户的请求通过哈希算法均匀的映射到服务器上。</li><li>以后每次该用户的请求都会被负载均衡服务器转发到这个服务器上。</li><li>这样用户的session就会存储在一台服务器上。</li></ol><h2 id="策略二：session复制"><a href="#策略二：session复制" class="headerlink" title="策略二：session复制"></a>策略二：session复制</h2><p>session复制就是对session增删改之后会将session广播给其他模块以保证session同步。</p><h2 id="策略三：session共享"><a href="#策略三：session共享" class="headerlink" title="策略三：session共享"></a>策略三：session共享</h2><p>通过redis、memcached共享session。</p><h3 id="方案一：redis"><a href="#方案一：redis" class="headerlink" title="方案一：redis"></a>方案一：redis</h3><p>对于session的分布式，就是模块之间的session共享，将session放入缓存就实现了session的共享。</p><p>可以通过redis实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">"session"</span>, json);</span><br></pre></td></tr></table></figure><p>其他模块读取缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String json = redisTemplate.opsForValue().get(<span class="string">"session"</span>);</span><br></pre></td></tr></table></figure><h3 id="方案二：SpringSession"><a href="#方案二：SpringSession" class="headerlink" title="方案二：SpringSession"></a>方案二：SpringSession</h3><p>Spring提供了SpringSession组件来解决模块之间的session共享。</p><ol><li>在两个模块中都引入SpringSession依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>application.yml配置session用redis保存</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:  session:</span></span><br><span class="line">    <span class="attr">store-type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动类加<code>@EnableRedisHttpSession</code>注解</li></ol><h2 id="策略四：session持久化"><a href="#策略四：session持久化" class="headerlink" title="策略四：session持久化"></a>策略四：session持久化</h2><p>创建一个数据库存储session。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在传统的单体应用中，后台只需要根据session获取用户身份的和信息既可。在集群中也只需要将用户的请求通过一种hash算法均匀的映射到多台服务器（且每次都映射到同一台服务器）既可，。而在分布式的应用中如何处理session呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://herotiga.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>js对象判空的几种方法</title>
    <link href="https://herotiga.github.io/2021/12/06/js%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%A9%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://herotiga.github.io/2021/12/06/js%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%A9%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2021-12-06T07:09:47.000Z</published>
    <updated>2022-05-19T10:58:30.970Z</updated>
    
    <content type="html"><![CDATA[<p>js无法直接比较一个对象是否为空( <code>obj === {}</code> 永远为 <code>false</code> )，原因是js在对比两者时是比对的两者的内存地址，而 <code>{}</code> 放在js引擎新分配的内存地址中，故而两者永远不相等。</p><a id="more"></a><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isEmpty = (<span class="built_in">Object</span>.getOwnPropertyNames(obj).length === <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isEmpty = (<span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmpty = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">JSON</span>.stringify(obj) === <span class="string">"&#123;&#125;"</span></span><br></pre></td></tr></table></figure><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmpty = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmpty = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Reflect</span>.ownKeys(obj).length === <span class="number">0</span> &amp;&amp; obj.constructor === <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><h2 id="jQuery中的isEmptyObject"><a href="#jQuery中的isEmptyObject" class="headerlink" title="jQuery中的isEmptyObject()"></a>jQuery中的isEmptyObject()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isEmpty = $.isEmptyObject(obj);</span><br></pre></td></tr></table></figure><p><em>updated on: 2021-12-06</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js无法直接比较一个对象是否为空( &lt;code&gt;obj === {}&lt;/code&gt; 永远为 &lt;code&gt;false&lt;/code&gt; )，原因是js在对比两者时是比对的两者的内存地址，而 &lt;code&gt;{}&lt;/code&gt; 放在js引擎新分配的内存地址中，故而两者永远不相等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>require和import的区别</title>
    <link href="https://herotiga.github.io/2021/11/25/require%E5%92%8Cimport/"/>
    <id>https://herotiga.github.io/2021/11/25/require%E5%92%8Cimport/</id>
    <published>2021-11-25T06:30:05.000Z</published>
    <updated>2022-05-19T10:58:30.970Z</updated>
    
    <content type="html"><![CDATA[<p><code>require</code> 和 <code>import</code> 都是引入模块。</p><a id="more"></a><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>require是赋值过程，过程就是将对象数字字符串赋值给变量，import是结构过程，浏览器不支持import，node中会被编译为require。</li><li>require是AMD规范，import是ES6规范。</li><li>require在运行时调用，所以require可以用在任何地方，import在编译时调用，所以import要写在文件顶部。</li></ol><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><a href="https://www.zhihu.com/question/56820346">https://www.zhihu.com/question/56820346</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 都是引入模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>vue3中引入jquery</title>
    <link href="https://herotiga.github.io/2021/11/17/vue%E4%B8%AD%E5%BC%95%E5%85%A5jquery/"/>
    <id>https://herotiga.github.io/2021/11/17/vue%E4%B8%AD%E5%BC%95%E5%85%A5jquery/</id>
    <published>2021-11-17T09:35:57.000Z</published>
    <updated>2022-05-19T10:58:32.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装jquery"><a href="#安装jquery" class="headerlink" title="安装jquery"></a>安装jquery</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.x版本</span></span><br><span class="line">cnpm i jquery@1.12.4 -S</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="编辑vue-config-js文件"><a href="#编辑vue-config-js文件" class="headerlink" title="编辑vue.config.js文件"></a>编辑vue.config.js文件</h2><p>根目录下创建vue.config.js文件：</p><figure class="highlight js"><figcaption><span>vue.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">                $:<span class="string">"jquery"</span>,</span><br><span class="line">                jQuery:<span class="string">"jquery"</span>,</span><br><span class="line">                <span class="string">"windows.jQuery"</span>:<span class="string">"jquery"</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在组件中引用：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br></pre></td></tr></table></figure><h2 id="另一种方法"><a href="#另一种方法" class="headerlink" title="另一种方法"></a>另一种方法</h2><p>ref: <a href="https://blog.nickschnee.ch/vuejquery/">https://blog.nickschnee.ch/vuejquery/</a></p><ol><li>先安装jquery模块</li><li>在<code>main.js</code>中：</li></ol><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jQuery <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"></span><br><span class="line">global.$ = jQuery</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Vue.prototype.$ = jquery</span><br></pre></td></tr></table></figure><p>这样就可以全局使用<code>$</code>了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装jquery&quot;&gt;&lt;a href=&quot;#安装jquery&quot; class=&quot;headerlink&quot; title=&quot;安装jquery&quot;&gt;&lt;/a&gt;安装jquery&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;figcaption&gt;&lt;span&gt;bash&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 1.x版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cnpm i jquery@1.12.4 -S&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
</feed>
