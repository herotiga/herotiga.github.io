<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Typecasting</title>
  
  <subtitle>write some articles about front-end dev,ui design,linux hacking and ai-cv.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://herotiga.github.io/"/>
  <updated>2024-05-14T13:27:40.475Z</updated>
  <id>https://herotiga.github.io/</id>
  
  <author>
    <name>Mason小王子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Next.js开发笔记</title>
    <link href="https://herotiga.github.io/2024/04/26/Nextjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://herotiga.github.io/2024/04/26/Nextjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-25T17:01:13.000Z</published>
    <updated>2024-05-14T13:27:40.475Z</updated>
    
    <content type="html"><![CDATA[<!-- https://www.bilibili.com/video/BV14t4y187Kk/?spm_id_from=333.337.search-card.all.click&vd_source=8c53c6425ea22c2a5a35c21ddac6a601 --><p>Next.js是基于react的一个全栈框架，提供的功能和Nuxt.js基本一样。</p><a id="more"></a><p>Next.js主要是为了解决react的如下问题：</p><ul><li>js环境</li><li>首屏加载慢</li><li>安全问题</li><li>SEO</li></ul><p>Next.js通过将渲染这个过程移动到服务端（将生成DOM放在服务端完成）来解决以上问题，也就是SSR。</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest project-name</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="https://gcore.jsdelivr.net/gh/herotiga/cdn@master/img/article/nextjs-catalogue.png" alt="nextjs目录结构"></p><h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><p>pages下创建文件即可生成对应的路由配置。</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>可以在pages目录下创建文件名，文件名是变量的形式<code>[param].ts</code>。</p><p>比如，如果想获取一个article页面的参数id，可以在article下定义名为<code>[id].ts</code>的文件，然后在这个文件内可以使用<code>useRouter</code>来获取id。</p><h2 id="SSR-amp-SSG"><a href="#SSR-amp-SSG" class="headerlink" title="SSR &amp; SSG"></a>SSR &amp; SSG</h2><p>这里有3个重要的方法。</p><ul><li><p>getServerSideProps：服务端渲染，在请求时运行</p></li><li><p>getStaticProps：服务端生成，生成静态页面时运行</p></li><li><p>getStaticPaths：服务端生成，生成静态页面时运行</p></li></ul><h3 id="声明SSR页面"><a href="#声明SSR页面" class="headerlink" title="声明SSR页面"></a>声明SSR页面</h3><p>在页面组件内添加一个<code>getServerSideProps</code>函数。</p><figure class="highlight plain"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常的页面组件</span><br><span class="line">const Post &#x3D; (&#123;data&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;div&gt;&#123; data &#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将该页面声明为SSR页面，下方函数是在服务端执行的</span><br><span class="line">export async function getServerSideProps(context) &#123;</span><br><span class="line">    &#x2F;&#x2F; 取出id</span><br><span class="line">    const &#123; id &#125; &#x3D; context.query</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据id查询接口</span><br><span class="line">    const res &#x3D; await fetch(&#96;&#x2F;article&#x2F;$&#123;id&#125;&#96;).then(data &#x3D;&gt; data.json())</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的props会被传入到上方组件中</span><br><span class="line">        props: &#123;</span><br><span class="line">            data: res,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明SSG页面"><a href="#声明SSG页面" class="headerlink" title="声明SSG页面"></a>声明SSG页面</h3><p>如果将以上代码的<code>getServerSideProps</code>改为<code>getStaticProps</code>，那么代码会在build的时候运行，此时文件会变为在build时渲染出来。</p><p>但是我们不知道用户会访问哪个id，所以需要搭配<code>getStaticPaths</code>来使用，getStaticPaths就是用来枚举用户可能访问的id。</p><p>下面生成一些用户可能访问的id：</p><figure class="highlight plain"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常的页面组件</span><br><span class="line">const Post &#x3D; (&#123;data&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;div&gt;&#123; data &#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将该页面声明为SSR页面，下方函数是在服务端执行的</span><br><span class="line">export async function getStaticProps(context) &#123;</span><br><span class="line">    &#x2F;&#x2F; 取出id</span><br><span class="line">    const &#123; id &#125; &#x3D; context.query</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据id查询接口</span><br><span class="line">    const res &#x3D; await fetch(&#96;&#x2F;article&#x2F;$&#123;id&#125;&#96;).then(data &#x3D;&gt; data.json())</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的props会被传入到上方组件中</span><br><span class="line">        props: &#123;</span><br><span class="line">            data: res,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面会在build阶段生成id从1到100的页面</span><br><span class="line">export async function getStaticPaths() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        paths: _.range(1, 100).map((id) &#x3D;&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                params: &#123;</span><br><span class="line">                    id: id + &#39;&#39;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; id未命中时退化为SSR</span><br><span class="line">        fallback: &#39;blocking&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallback</code>的取值还有：false（404），true（退化到CSR）。</p><h3 id="增量静态生成（ISR）"><a href="#增量静态生成（ISR）" class="headerlink" title="增量静态生成（ISR）"></a>增量静态生成（ISR）</h3><h4 id="自动重新生成"><a href="#自动重新生成" class="headerlink" title="自动重新生成"></a>自动重新生成</h4><p>添加<code>revalidate</code>参数，表示这个静态页面最多可存活的秒数，如果当用户请求页面时这个页面已经生成了超过10s则会重新生成该页面。可以用来保证静态页面是最新的。</p><figure class="highlight plain"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常的页面组件</span><br><span class="line">const Post &#x3D; (&#123;data&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;div&gt;&#123; data &#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将该页面声明为SSR页面，下方函数是在服务端执行的</span><br><span class="line">export async function getStaticProps(context) &#123;</span><br><span class="line">    &#x2F;&#x2F; 取出id</span><br><span class="line">    const &#123; id &#125; &#x3D; context.query</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据id查询接口</span><br><span class="line">    const res &#x3D; await fetch(&#96;&#x2F;article&#x2F;$&#123;id&#125;&#96;).then(data &#x3D;&gt; data.json())</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的props会被传入到上方组件中</span><br><span class="line">        props: &#123;</span><br><span class="line">            data: res,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 最多存活10s</span><br><span class="line">        revalidate: 10,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面会在build阶段生成id从1到100的页面</span><br><span class="line">export async function getStaticPaths() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        paths: _.range(1, 100).map((id) &#x3D;&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                params: &#123;</span><br><span class="line">                    id: id + &#39;&#39;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; id未命中时退化为SSR</span><br><span class="line">        fallback: &#39;blocking&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手动重新生成"><a href="#手动重新生成" class="headerlink" title="手动重新生成"></a>手动重新生成</h4><p>手动调用<code>revalidate</code>方法即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- https://www.bilibili.com/video/BV14t4y187Kk/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8c53c6425ea22c2a5a35c21ddac6a601 --&gt;

&lt;p&gt;Next.js是基于react的一个全栈框架，提供的功能和Nuxt.js基本一样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://herotiga.github.io/categories/react/"/>
    
    
  </entry>
  
  <entry>
    <title>Nuxt.js开发笔记</title>
    <link href="https://herotiga.github.io/2024/04/25/Nuxtjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://herotiga.github.io/2024/04/25/Nuxtjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-25T15:32:19.000Z</published>
    <updated>2024-04-27T16:19:06.427Z</updated>
    
    <content type="html"><![CDATA[<p>Nuxt.js是基于vue的一个全栈（这里全栈的意思是支持CSR和SSR）开发框架或者说开发套件，支持SSR（服务端渲染）、SSG（静态站点生成）、SPA（单页面应用），它提供了vue不提供的路由、缓存、接口服务、SSR，并对开发场景做了大量优化，开箱即用。</p><a id="more"></a><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-nuxt-app my-app</span><br></pre></td></tr></table></figure><h2 id="FileBased（文件即路由）"><a href="#FileBased（文件即路由）" class="headerlink" title="FileBased（文件即路由）"></a>FileBased（文件即路由）</h2><p>只需要在pages下创建vue文件，即可访问，Nuxt.js会自动根据文件名注册路由。还支持路由嵌套、路由参数。</p><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>vue项目都是在客户端渲染的，导致我们的页面不能完整的被搜索引擎爬取收录，这个时候就可以搭建服务端渲染（SSR）来解决这个问题。</p><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>在Nuxt.js中实现SEO只需要使用Nuxt.js提供的SEO接口：</p><figure class="highlight html"><figcaption><span>vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line">useSeoMeta(&#123;</span><br><span class="line"><span class="actionscript">    title: <span class="string">'电商'</span>,</span></span><br><span class="line"><span class="actionscript">    description: <span class="string">'描述'</span>,</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务端渲染接口数据"><a href="#服务端渲染接口数据" class="headerlink" title="服务端渲染接口数据"></a>服务端渲染接口数据</h3><h4 id="fetch"><a href="#fetch" class="headerlink" title="$fetch"></a>$fetch</h4><p>Nuxt.js内置了<code>$fetch</code>，可以代替axios。</p><h4 id="useAsyncData"><a href="#useAsyncData" class="headerlink" title="useAsyncData"></a>useAsyncData</h4><p><code>useAsyncData</code>是用于获取接口数据的方法，需要结合<code>$fetch</code>使用。</p><figure class="highlight html"><figcaption><span>vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line">useSeoMeta(&#123;</span><br><span class="line"><span class="actionscript">    title: <span class="string">'电商'</span>,</span></span><br><span class="line"><span class="actionscript">    description: <span class="string">'描述'</span>,</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> list = ref([])</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> useAsyncData(</span></span><br><span class="line"><span class="actionscript">  <span class="string">'id'</span>, <span class="comment">// 需要给定唯一的id</span></span></span><br><span class="line">  () =&gt;</span><br><span class="line"><span class="actionscript">    $fetch(<span class="string">'https://xxx.xxx.com'</span>, &#123;</span></span><br><span class="line">      headers: &#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">// ...</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  &#123;</span><br><span class="line"><span class="actionscript">    pick: [<span class="string">'data'</span>], <span class="comment">// 选择返回对象中想要的属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// lazy: false, // 这里默认为false 会阻塞路由渲染，（一定要等到数据请求回来后才会跳转路由）</span></span></span><br><span class="line"><span class="actionscript">    lazy: <span class="literal">true</span> <span class="comment">// 不会阻塞路由跳转，但是会导致跳转后无数据，需要通过watch监听数据后赋值</span></span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">list.value = data.value</span><br><span class="line">watch(data, () =&gt; &#123;</span><br><span class="line">    list.value = data.value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果对于获取的数据不需要处理，则无需监听可以在获取到data后直接渲染到页面上。</p><p>这样就可以像CSR一样使用data来渲染页面了。</p><p>此时接口的数据是在服务端完成的渲染，这样对于SEO友好，并且可以解决首屏加载慢的问题，因为页面都已经在服务端渲染好了。</p><h4 id="useFetch"><a href="#useFetch" class="headerlink" title="useFetch"></a>useFetch</h4><p><code>useFetch</code>是useAsyncData的语法糖，它不需要传入id。</p><figure class="highlight html"><figcaption><span>vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line">useSeoMeta(&#123;</span><br><span class="line"><span class="actionscript">    title: <span class="string">'电商'</span>,</span></span><br><span class="line"><span class="actionscript">    description: <span class="string">'描述'</span>,</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> useFetch(</span></span><br><span class="line"><span class="actionscript">    <span class="string">'https://a.com/xxx'</span>,</span></span><br><span class="line">    &#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">// ...</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        transform: <span class="function"><span class="params">res</span> =&gt;</span> res.data.list, <span class="comment">// 选择返回对象中想要的属性</span></span></span><br><span class="line"><span class="actionscript">        lazy: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="useLazyFetch"><a href="#useLazyFetch" class="headerlink" title="useLazyFetch"></a>useLazyFetch</h4><p><code>useLazyFetch</code>是lazy为true的useFetch。</p><h3 id="服务端接口"><a href="#服务端接口" class="headerlink" title="服务端接口"></a>服务端接口</h3><p>Nuxt.js还可以写自己的服务端接口。</p><p>比如在server目录下创建api目录，目录下创建接口文件，可以直接读取数据库。实现了一个真实的api接口。</p><h2 id="组件自动导入"><a href="#组件自动导入" class="headerlink" title="组件自动导入"></a>组件自动导入</h2><p>Nuxt.js中如果要使用一个组件，不需要再导入这个组件了，可以直接使用。</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Nuxt.js可以使用中间件（middleware）来实现比如鉴权等功能。</p><ol><li><p>创建中间件</p></li><li><p>在具体页面组件中使用中间件。</p></li></ol><figure class="highlight html"><figcaption><span>vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line">definePageMeta(&#123;</span><br><span class="line"><span class="actionscript">    middleware: <span class="string">'middlewareName'</span>,</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">useSeoMeta(&#123;</span><br><span class="line"><span class="actionscript">    title: <span class="string">'电商'</span>,</span></span><br><span class="line"><span class="actionscript">    description: <span class="string">'描述'</span>,</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> useFetch(<span class="string">'https://a.com/xxx'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了这些之外，Nuxt.js还支持页面渲染配置、过渡动画、状态管理、单元测试等等，以及社区资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nuxt.js是基于vue的一个全栈（这里全栈的意思是支持CSR和SSR）开发框架或者说开发套件，支持SSR（服务端渲染）、SSG（静态站点生成）、SPA（单页面应用），它提供了vue不提供的路由、缓存、接口服务、SSR，并对开发场景做了大量优化，开箱即用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://herotiga.github.io/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Express路由配置</title>
    <link href="https://herotiga.github.io/2024/04/21/Express%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/"/>
    <id>https://herotiga.github.io/2024/04/21/Express%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</id>
    <published>2024-04-21T02:22:41.000Z</published>
    <updated>2024-04-22T04:51:28.931Z</updated>
    
    <content type="html"><![CDATA[<p>服务器端路由是指：服务器端根据客户端请求的不同路径、http方法来执行不同的处理逻辑。</p><a id="more"></a><h2 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置路由，第一个参数是路径，第二个参数是处理函数</span></span><br><span class="line">server.get(<span class="string">'/'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">'/about'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">'about'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">server.listen(port, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server started on port 3333'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="动态路由配置"><a href="#动态路由配置" class="headerlink" title="动态路由配置"></a>动态路由配置</h2><p>动态路由是指：路径中带有参数的路由。</p><p>在express中，可以使用<code>:param</code>来定义动态参数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.get(<span class="string">'/user/:userId'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> userId = req.params.userId</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据userId处理逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模块化管理路由"><a href="#模块化管理路由" class="headerlink" title="模块化管理路由"></a>模块化管理路由</h2><p>一般不会将路由直接写在server中，可以将所有的路由划分模块，然后引入。</p><p>创建模块化路由的步骤</p><ol><li>创建路由模块文件。</li><li>调用<code>express.Router()</code>创建路由对象。</li><li>在路由对象上挂载具体的路由。</li><li>使用<code>module.exports</code>向外共享路由对象。</li><li>使用<code>server.use()</code>注册路由模块。</li></ol><p>代码实例，先创建路由模块，比如这里创建了user相关的两个路由：</p><figure class="highlight ts"><figcaption><span>userRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载具体路由</span></span><br><span class="line">router.get(<span class="string">'/user/list'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理路由</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/user/add'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理路由</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外导出路由</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>在创建server的文件中导入上面的模块：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">'./userRouter'</span>)</span><br><span class="line"><span class="comment">// 注册路由模块</span></span><br><span class="line">server.use(userRouter)</span><br><span class="line">server.listen(<span class="number">80</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'server started on port 80'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为模块添加前缀</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处省略其他代码</span></span><br><span class="line">server.use(<span class="string">'/api'</span>, userRouter)</span><br></pre></td></tr></table></figure><h2 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h2><p>除了静态路由和动态路由之外，还可以使用路由中间件来拦截路由并进行处理。</p><p>路由中间件是一个函数，它可以访问请求对象 (req)、响应对象 (res) 和应用中的下一个中间件函数 (next)。中间件函数可以执行各种任务，如修改请求和响应对象、执行身份验证、日志记录等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行一些处理</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了中间件函数'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行下一个中间件函数或者路由处理函数</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>下面定义了一个错误处理中间件，发生错误时会打印错误信息，向客户端返回一个500状态码和响应。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line"></span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'服务器错误'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="处理跨域"><a href="#处理跨域" class="headerlink" title="处理跨域"></a>处理跨域</h2><p>客户端在发送请求之前会先发送一个<code>OPTIONS</code>请求，用于试探服务器是否能接受请求。如果服务端响应404、403、500就会停止继续请求。</p><p>下面的代码是处理这种情况的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server.all(<span class="string">'*'</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'*'</span>)</span><br><span class="line">    res.header(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req.method.toLowerCase() === <span class="string">'options'</span>) &#123;</span><br><span class="line">        res.send(<span class="number">200</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理跨域</span></span><br><span class="line">server.all(<span class="string">'*'</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'*'</span>)</span><br><span class="line">    res.header(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> (req.method.toLowerCase() === <span class="string">'options'</span>) &#123;</span><br><span class="line">        res.send(<span class="number">200</span>)  <span class="comment">//让options尝试请求快速结束</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line">server.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了中间件函数'</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态路由</span></span><br><span class="line">server.get(<span class="string">'/users/:userId/books/:bookId'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> userId = req.params.userId</span><br><span class="line">    <span class="keyword">const</span> bookId = req.params.bookId</span><br><span class="line">    res.send(<span class="string">`User ID: <span class="subst">$&#123;userId&#125;</span>, Book ID: <span class="subst">$&#123;bookId&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 错误处理中间件</span></span><br><span class="line">server.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'服务器错误'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">server.listen(<span class="number">3333</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server started on port 3333'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器端路由是指：服务器端根据客户端请求的不同路径、http方法来执行不同的处理逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="express" scheme="https://herotiga.github.io/categories/express/"/>
    
    
  </entry>
  
  <entry>
    <title>SQLite中的数据类型</title>
    <link href="https://herotiga.github.io/2023/09/21/SQLite%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://herotiga.github.io/2023/09/21/SQLite%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-09-21T07:49:28.000Z</published>
    <updated>2023-11-13T03:33:02.992Z</updated>
    
    <content type="html"><![CDATA[<p><code>SQLite</code> 采用动态数据类型，插入什么数据类型就是什么数据类型，但最终插入表中的数据只能是以下五种类型。</p><a id="more"></a><h2 id="SQLite中的数据类型"><a href="#SQLite中的数据类型" class="headerlink" title="SQLite中的数据类型"></a>SQLite中的数据类型</h2><ol><li>NULL: 空值</li><li>INTEGER: 有符号的整型</li><li>REAL: 浮点数</li><li>TEXT: 字符串</li><li>BLOB: 二进制对象</li></ol><h2 id="Affinity类型"><a href="#Affinity类型" class="headerlink" title="Affinity类型"></a>Affinity类型</h2><p>Affinity类型就是建议类型。</p><p>在插入数据时，SQLite会根据你传入的值来转为建议类型，如果不能转，则使用你传入的数据类型进行存储。</p><p>Boolean类型会被存储为0(false)或者1(true)。</p><p>Date类型会被存储为TEXT, REAL, INTEGER。</p><h2 id="常见SQL数据库数据类型和SQLite数据类型对照"><a href="#常见SQL数据库数据类型和SQLite数据类型对照" class="headerlink" title="常见SQL数据库数据类型和SQLite数据类型对照"></a>常见SQL数据库数据类型和SQLite数据类型对照</h2><ol><li>INTEGER: INT, INTEGER, TINYINT, SMALLINT, MEDIUMINT, BIGINT, UNSIGNED BIG INT</li><li>REAL: REAL, FLOAT, DOUBLE, DOUBLE PRECISION</li><li>TEXT: CHARACTER, VARCHAR, VARYING CHARACTER, NCHAR, NATIVE CHARACTER, NVARCHAR, TEXT, CLOB</li><li>NUMERIC: NUMERIC, DECIMAL, BOOLEAN, DATE, DATETIME</li><li>BLOB: BLOB</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SQLite&lt;/code&gt; 采用动态数据类型，插入什么数据类型就是什么数据类型，但最终插入表中的数据只能是以下五种类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQLite" scheme="https://herotiga.github.io/categories/SQLite/"/>
    
    
  </entry>
  
  <entry>
    <title>fastjson学习笔记</title>
    <link href="https://herotiga.github.io/2023/09/07/fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://herotiga.github.io/2023/09/07/fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-07T06:55:48.000Z</published>
    <updated>2023-09-25T13:35:01.526Z</updated>
    
    <content type="html"><![CDATA[<p><code>fastjson</code> 是一个java的JSON序列化库，用于在java对象和JSON之间的互相转换。</p><p>fastjson可以将java对象转为JSON（序列化），也可以将JSON转为java对象（反序列化）。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在maven项目的 <code>pom.xml</code> 文件中配置fastjson依赖。</p><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.58<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>引入fastjson和相关包</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONArray;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br></pre></td></tr></table></figure><p>fastjson的入口类是 <code>com.alibaba.fastjson.JSON</code>，提供了两个方法：</p><ul><li><code>JSON.toJSONString</code></li><li><code>JSON.parseObject</code></li></ul><ol><li>创建JSON对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">"name"</span>, <span class="string">"Mason"</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>将List转为JSON</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造List</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;string&gt;();</span><br><span class="line">lsit.add(<span class="string">"item1"</span>);</span><br><span class="line">lsit.add(<span class="string">"item2"</span>);</span><br><span class="line">lsit.add(<span class="string">"item3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：先把List转为JSONArray，再使用toString()转为JSON</span></span><br><span class="line">JSONArray jsonArray = <span class="keyword">new</span> JSONArray(list);</span><br><span class="line">String json = jsonArray.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：使用JSON.toJSONString()直接将List转为JSON</span></span><br><span class="line">String json = JSON.toJSONString(list);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;fastjson&lt;/code&gt; 是一个java的JSON序列化库，用于在java对象和JSON之间的互相转换。&lt;/p&gt;
&lt;p&gt;fastjson可以将java对象转为JSON（序列化），也可以将JSON转为java对象（反序列化）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://herotiga.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈hooks</title>
    <link href="https://herotiga.github.io/2023/08/02/hooks/"/>
    <id>https://herotiga.github.io/2023/08/02/hooks/</id>
    <published>2023-08-02T09:06:23.000Z</published>
    <updated>2024-04-18T02:39:22.034Z</updated>
    
    <content type="html"><![CDATA[<!--     https://baijiahao.baidu.com/s?id=1727232708471611959&wfr=spider&for=pc --><p>Vue3和React16.8都已经支持了 <code>hooks</code> 作为组件编写的方式。</p><a id="more"></a><p>什么是hooks？</p><article class="message is-info"><div class="message-body"><p>钩子编程是通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为钩子(hooks)。</p></div></article><h2 id="React中的hooks"><a href="#React中的hooks" class="headerlink" title="React中的hooks"></a>React中的hooks</h2><p>React只能在函数组件中使用hooks。</p><p>React中的hooks指的是以 <code>use</code> 开头的一系列方法，可以让我们避开class component写法，在函数式组件中完成全部的开发。</p><p>hooks函数以 <code>use</code> 开头是计算机中对于hooks约定俗成的写法。</p><h2 id="Vue中的hooks"><a href="#Vue中的hooks" class="headerlink" title="Vue中的hooks"></a>Vue中的hooks</h2><p>Vue只能在 <code>setup</code> 中使用hooks。</p><p>Vue中的hooks指的是以 <code>use</code> 开头的方法，他们提供了组件复用状态管理等能力，除此之外，Vue的组合式API也是一种hooks。</p><h2 id="hooks的优点"><a href="#hooks的优点" class="headerlink" title="hooks的优点"></a>hooks的优点</h2><ol><li>hooks可以将业务逻辑清晰划分解耦。</li><li>hooks可复用性高、状态逻辑复用清晰，可以替代 <code>mixin</code>。</li><li>避免了class组件需要频繁使用 <code>bind</code> 的麻烦。</li></ol><h2 id="React-hooks实例"><a href="#React-hooks实例" class="headerlink" title="React hooks实例"></a>React hooks实例</h2><figure class="highlight plain"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">const Demo &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建name状态和set方法</span><br><span class="line">    const [name, setName] &#x3D; useState(&#39;&#39;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理副作用</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">            console.log(name)</span><br><span class="line">        &#125;,</span><br><span class="line">        [name]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 依赖name动态计算message</span><br><span class="line">    const message &#x3D; useMemo(() &#x3D;&gt; &#123;</span><br><span class="line">        return &#96;my name is $&#123;name&#125;&#96;</span><br><span class="line">    &#125;, [name])</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt; &#123;message&#125; &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Demo</span><br></pre></td></tr></table></figure><h2 id="Vue-hooks实例"><a href="#Vue-hooks实例" class="headerlink" title="Vue hooks实例"></a>Vue hooks实例</h2><figure class="highlight html"><figcaption><span>vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; computed, ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> name = ref(<span class="string">''</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> message = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">return</span> <span class="string">`my name is <span class="subst">$&#123;name.value&#125;</span>`</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h2><p>自定义hook是一种重用状态逻辑的方法。</p><p>下面以react hook为例，如何自定义一个hook：</p><ol><li>给hook命名：以use开头。</li><li>编写函数：写一个普通的函数，函数内可以使用其他的hook。</li><li>使用写好的hook：在其他组件中可以使用编写好的hook，在组件中可以使用它返回的任何状态和函数。</li></ol><p>自定义react hook实例：</p><figure class="highlight plain"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义Hook：用于追踪和更新计数</span><br><span class="line">function useCounter(initialCount) &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(initialCount)</span><br><span class="line"></span><br><span class="line">  const increment &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setCount(prevCount &#x3D;&gt; prevCount + 1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const decrement &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setCount(prevCount &#x3D;&gt; prevCount - 1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123; count, increment, decrement &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在组件中使用自定义Hook</span><br><span class="line">function CounterComponent() &#123;</span><br><span class="line">  const &#123; count, increment, decrement &#125; &#x3D; useCounter(0)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;increment&#125;&gt;Increment&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;decrement&#125;&gt;Decrement&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default CounterComponent</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol><li><a href="https://mp.weixin.qq.com/s/a1A7b6nzqNpZuv8KkN8nug">https://mp.weixin.qq.com/s/a1A7b6nzqNpZuv8KkN8nug</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- 

    https://baijiahao.baidu.com/s?id=1727232708471611959&amp;wfr=spider&amp;for=pc

 --&gt;

&lt;p&gt;Vue3和React16.8都已经支持了 &lt;code&gt;hooks&lt;/code&gt; 作为组件编写的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://herotiga.github.io/categories/react/"/>
    
      <category term="vue" scheme="https://herotiga.github.io/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript中type（类型别名）和interface（接口）的区别</title>
    <link href="https://herotiga.github.io/2023/06/20/typescript%E4%B8%ADtype%E5%92%8Cinterface%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://herotiga.github.io/2023/06/20/typescript%E4%B8%ADtype%E5%92%8Cinterface%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-06-20T08:17:04.000Z</published>
    <updated>2023-06-25T03:26:26.085Z</updated>
    
    <content type="html"><![CDATA[<p><code>type</code> 和 <code>interface</code> 存在着很大的相同点，也存在不同点。</p><p>整理一下两者的基本概念、相同点、区别。</p><a id="more"></a><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type就是类型别名，type可以表示基本类型、对象、联合类型、元组、交集。</p><h3 id="定义类型别名"><a href="#定义类型别名" class="headerlink" title="定义类型别名"></a>定义类型别名</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">type</span> name = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> age = <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">type</span> id = <span class="built_in">string</span> | <span class="built_in">number</span></span><br></pre></td></tr></table></figure><h3 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">    name: <span class="string">'wang'</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，type中的类型也可以是其他已经定义的类型别名。</p><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>interface就是接口。</p><p>interface只能描述对象的类型。</p><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，interface中的类型也可以是其他已经定义的接口。</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ol><li>都可以用来描述对象类型。</li><li>都可以用来描述函数。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type描述函数的入参类型和返回值类型</span></span><br><span class="line"><span class="keyword">type</span> FunctionType = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface描述函数的入参类型和返回值类型</span></span><br><span class="line"><span class="keyword">interface</span> FunctionInterface &#123;</span><br><span class="line">    (a: numnber, b: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>都可以实现继承</li></ol><p>type可以继承type，interface可以继承interface。<br>同时，type和interface也可以相互继承。</p><p>type通过 <code>&amp;</code> 继承type或者interface。<br>interface通过 <code>extends</code> 继承type或者interface。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type继承type</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engineer = Person &amp; &#123;</span><br><span class="line">    occupation: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface继承interface</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Engineer <span class="keyword">extends</span> Person &#123;</span><br><span class="line">   occupation: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type继承interface</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engineer = Person &amp; &#123;</span><br><span class="line">    occupation: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface继承type</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Engineer <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    occupation: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>都可以使用可选属性 <code>[propName] ?: [type]</code></li></ol><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ol><li>type可以基本类型、联合类型、元组类型而interface不可以。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述元组</span></span><br><span class="line"><span class="keyword">type</span> Item = [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li>定义多个同名的interface可以合并，而定义多个同名的type会报错。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优先用interface。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;interface&lt;/code&gt; 存在着很大的相同点，也存在不同点。&lt;/p&gt;
&lt;p&gt;整理一下两者的基本概念、相同点、区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ts" scheme="https://herotiga.github.io/categories/ts/"/>
    
    
  </entry>
  
  <entry>
    <title>解决浏览器自动填充密码框的问题</title>
    <link href="https://herotiga.github.io/2023/06/16/%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E5%AF%86%E7%A0%81%E6%A1%86%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://herotiga.github.io/2023/06/16/%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E5%AF%86%E7%A0%81%E6%A1%86%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-06-16T06:01:52.000Z</published>
    <updated>2023-08-06T14:48:48.003Z</updated>
    
    <content type="html"><![CDATA[<p>做项目的时候遇到了浏览器自动填充了密码框的问题。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>创建完密码框后给密码框一个 <code>readonly=&#39;true&#39;</code> 属性，在 <code>focus</code> 的时候再将 <code>readonly</code> 设为 <code>false</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="https://gcore.jsdelivr.net/gh/herotiga/cdn@master/img/article/Vue%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E5%AF%86%E7%A0%81%E6%A1%86%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="code"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做项目的时候遇到了浏览器自动填充了密码框的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://herotiga.github.io/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>前端下载文件的几种方案</title>
    <link href="https://herotiga.github.io/2023/06/12/%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
    <id>https://herotiga.github.io/2023/06/12/%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/</id>
    <published>2023-06-12T06:42:14.000Z</published>
    <updated>2023-06-12T08:36:07.690Z</updated>
    
    <content type="html"><![CDATA[<p>梳理一下前端下载文件的几种方案。</p><a id="more"></a><hr><h2 id="方案一：a标签下载"><a href="#方案一：a标签下载" class="headerlink" title="方案一：a标签下载"></a>方案一：a标签下载</h2><p>创建a标签，手动触发点击事件下载。</p><p>创建的a标签形如：<code>&lt;a href=&quot;file_url&quot; download=&quot;file_name&quot;&gt;file_title&lt;/a&gt;</code>。</p><p><code>download</code> 属性只在同源下生效。</p><figure class="highlight ts"><figcaption><span>ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a标签下载</span></span><br><span class="line"><span class="comment"> * @param file 来自接口返回的blob或者文件路径</span></span><br><span class="line"><span class="comment"> * @param fileName 文件名</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span>(<span class="params">file: Blob | <span class="built_in">string</span>, fileName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = (file <span class="keyword">instanceof</span> Blob) ? <span class="built_in">window</span>.URL.createObjectURL(<span class="keyword">new</span> Blob([file])) : file</span><br><span class="line">    <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">    a.style.display = <span class="string">'none'</span></span><br><span class="line">    a.href = url</span><br><span class="line">    a.download = fileName</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(a)</span><br><span class="line">    a.click()</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(a)</span><br><span class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案二：window-open"><a href="#方案二：window-open" class="headerlink" title="方案二：window.open"></a>方案二：window.open</h2><p><code>window.open</code> 可以直接调用浏览器的下载。</p><h2 id="方案三：使用插件"><a href="#方案三：使用插件" class="headerlink" title="方案三：使用插件"></a>方案三：使用插件</h2><p>可以使用js-file-downloader：<a href="https://www.npmjs.com/package/js-file-downloader">https://www.npmjs.com/package/js-file-downloader</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JsFileDownloader <span class="keyword">from</span> <span class="string">'js-file-downloader'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileUrl = <span class="string">'http://...'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> JsFileDownloader(&#123;</span><br><span class="line">    url: fileUrl</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下载完毕回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梳理一下前端下载文件的几种方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ts" scheme="https://herotiga.github.io/categories/ts/"/>
    
    
  </entry>
  
  <entry>
    <title>生成UUID</title>
    <link href="https://herotiga.github.io/2023/06/02/JS%E7%94%9F%E6%88%90UUID/"/>
    <id>https://herotiga.github.io/2023/06/02/JS%E7%94%9F%E6%88%90UUID/</id>
    <published>2023-06-02T06:29:40.000Z</published>
    <updated>2023-06-12T02:09:07.080Z</updated>
    
    <content type="html"><![CDATA[<p>ts生成UUID</p><a id="more"></a><figure class="highlight ts"><figcaption><span>ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUUID = (): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> TEMP_URL = URL.createObjectURL(<span class="keyword">new</span> Blob())</span><br><span class="line">  <span class="keyword">const</span> UUID = TEMP_URL.toString()</span><br><span class="line">  URL.revokeObjectURL(TEMP_URL) <span class="comment">//释放这个url</span></span><br><span class="line">  <span class="keyword">return</span> UUID.substring(UUID.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ts生成UUID&lt;/p&gt;
    
    </summary>
    
    
      <category term="ts" scheme="https://herotiga.github.io/categories/ts/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程</title>
    <link href="https://herotiga.github.io/2023/05/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://herotiga.github.io/2023/05/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-05-14T03:59:56.000Z</published>
    <updated>2023-05-29T02:25:49.209Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中可以通过创建多线程来达到并发编程的目的。</p><a id="more"></a><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>Java中的线程（Thread）的<font color="red">生命周期</font>是这样的：</p><ol><li>实例化一个线程对象后，线程处于新建状态，等待进入就绪状态。</li><li>调用<code>start()</code>后，线程进入就绪状态，等待被JVM的线程调度器调度进入运行状态。</li><li>调用<code>run()</code>后，线程进入运行状态，运行状态的线程可能进入阻塞状态、就绪状态、死亡状态。</li><li>运行状态的线程如果调用了<code>sleep()</code>或者<code>suspend()</code>后会失去所有资源，线程进入阻塞状态，阻塞状态的线程在睡眠时间到后或者获得资源后会重新进入就绪状态。</li><li>run()执行完毕、调用<code>stop()</code>、调用<code>destroy()</code>，线程会进入死亡状态。</li></ol><p>线程进入阻塞状态有三种情况：</p><ol><li>等待阻塞状态：运行状态的线程调用<code>wait()</code>进入等待阻塞状态。</li><li>同步阻塞状态：运行状态的线程获取<code>synchronized</code>同步锁失败（同步锁被其他线程占用）会进入同步阻塞状态。</li><li>其他阻塞状态：线程调用<code>sleep()</code>、<code>join()</code>IO请求，线程会进入阻塞状态，当sleep超时或者join终止或者超时，或者IO完毕，线程会重新进入就绪状态等待被JVM调度。</li></ol><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每个线程都有一个优先级，默认优先级 <code>NORM_PRIORITY（5）</code> 。</p><p>JVM根据线程优先级调度资源。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Java提供三种方法创建线程：</p><ol><li>实现 <code>Runnable</code> 接口。</li><li>继承 <code>Thread</code> 类。</li><li>实现 <code>Callable</code> 和 <code>Future</code> 接口来创建线程。</li></ol><h3 id="实现Runnable接口来创建线程"><a href="#实现Runnable接口来创建线程" class="headerlink" title="实现Runnable接口来创建线程"></a>实现Runnable接口来创建线程</h3><figure class="highlight java"><figcaption><span>ThreadDemo.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Thread t;</span><br><span class="line">   <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造方法</span></span><br><span class="line">   RunnableDemo(String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(<span class="string">"Creating "</span> +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 实现run，线程进入运行状态</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Running "</span> +  threadName );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread: "</span> + threadName + <span class="string">", "</span> + i);</span><br><span class="line">            <span class="comment">// sleep</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(<span class="string">"Thread "</span> +  threadName + <span class="string">" interrupted."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Thread "</span> +  threadName + <span class="string">" exiting."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 实现start，线程进入就绪状态</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Starting "</span> +  threadName );</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">         t = <span class="keyword">new</span> Thread (<span class="keyword">this</span>, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      RunnableDemo R1 = <span class="keyword">new</span> RunnableDemo( <span class="string">"Thread-1"</span>);</span><br><span class="line">      R1.start();</span><br><span class="line">      </span><br><span class="line">      RunnableDemo R2 = <span class="keyword">new</span> RunnableDemo( <span class="string">"Thread-2"</span>);</span><br><span class="line">      R2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承Thread类来创建线程"><a href="#继承Thread类来创建线程" class="headerlink" title="继承Thread类来创建线程"></a>继承Thread类来创建线程</h3><p>继承<code>Thread</code>类，其他代码相同。</p><h3 id="实现Callable和Future接口来创建线程"><a href="#实现Callable和Future接口来创建线程" class="headerlink" title="实现Callable和Future接口来创建线程"></a>实现Callable和Future接口来创建线程</h3><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中可以通过创建多线程来达到并发编程的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://herotiga.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="https://herotiga.github.io/2023/05/10/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>https://herotiga.github.io/2023/05/10/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2023-05-10T14:18:56.000Z</published>
    <updated>2024-04-25T14:55:24.445Z</updated>
    
    <content type="html"><![CDATA[<p>乐观锁和悲观锁是在并发控制中常用的两种策略。</p><p>他们用于处理在多个进程同时访问共享资源时的情况。</p><a id="more"></a><h2 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a>悲观锁（Pessimistic Locking）</h2><p>概念：悲观锁会假定发生并发冲突，所以在访问资源之前会获取锁，在使用期间保持锁定状态。</p><p>优点：悲观锁是一个有序队列，不存在冲突所以没有重试开销，可以处理并发冲突高的场景，保证了数据一致性和完整性。<br>缺点：悲观锁可能会导致队列堵塞、并发度偏低。</p><h2 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h2><p>概念：乐观锁会假定不会发生并发冲突，所以在访问共享资源的时候不会立刻上锁，而是在执行更新操作时检查是否发生了冲突（检查数据是否发生了变动），如果发生了冲突，则重读数据重新执行更新操作。</p><p>那么乐观锁怎么知道是否发生了冲突呢，可以通过给记录加一个version字段来判断数据是否冲突。比如多个进程使用乐观锁操作同一个记录的amount字段时候，每个进程会先获取该记录的amount字段和version字段，然后执行业务操作，最后在写入的时候再获取一下verison字段，如果和之前一样则表示无冲突，则写入新的amount并更新version。如果version和之前不同，则回退并重新执行获取amount和version继续往下。</p><p>优点：任务不会堵塞，并发度高。<br>缺点：处理冲突的开销高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择使用悲观锁还是乐观锁取决于应用场景和性能要求。</p><p>悲观锁适用于并发冲突概率较高的情况，保证数据的一致性和完整性。<br>而乐观锁适用于并发冲突概率较低的情况，可以提高系统的并发性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;乐观锁和悲观锁是在并发控制中常用的两种策略。&lt;/p&gt;
&lt;p&gt;他们用于处理在多个进程同时访问共享资源时的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://herotiga.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>NUC8i7BEH Hackintosh</title>
    <link href="https://herotiga.github.io/2022/12/12/NUC8i7BEH-Hackintosh/"/>
    <id>https://herotiga.github.io/2022/12/12/NUC8i7BEH-Hackintosh/</id>
    <published>2022-12-12T15:41:46.000Z</published>
    <updated>2024-04-02T14:32:09.842Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间我的MBP 2018 13inch（i5-8259u, 16G, 256G）在干活的时候各种卡顿，风扇无故狂转，所以打算搞个黑苹果写代码用。</p><p>于是在闲鱼上收了个 <code>NUC8i7BEH</code> ，配了两条光威的16G DDR4 3200的内存（镁光颗粒），买了一块1T的西数SN570。</p><p>然后将硬盘分了三个区，一个windows，一个esp分区，一个macOS分区，安装了最新的 <code>Ventura</code> 和最新的 <code>windows 11</code> 。</p><p>未来一两年这就是我的开发机器了。</p><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="MacBook-Pro-2018-13inch"><a href="#MacBook-Pro-2018-13inch" class="headerlink" title="MacBook Pro 2018 13inch"></a>MacBook Pro 2018 13inch</h3><pre><code>wangwei@192.168.0.102 --------------------- OS: macOS 13.1 22C65 x86_64 Host: MacBookPro15,2 Kernel: 22.2.0 Uptime: 7 hours, 6 mins Packages: 41 (brew) Shell: zsh 5.8.1 Resolution: 2560x1440@2x DE: Aqua WM: Quartz Compositor WM Theme: Blue (Light) Terminal: HyperTerm Terminal Font: Menlo CPU: Intel i5-8259U (8) @ 2.30GHz GPU: Intel Iris Plus Graphics 655 Memory: 11553MiB / 16384MiB </code></pre><h3 id="NUC8i7BEH"><a href="#NUC8i7BEH" class="headerlink" title="NUC8i7BEH"></a>NUC8i7BEH</h3><blockquote><p>机器规格：<br><a href="https://ark.intel.com/content/www/cn/zh/ark/products/126140/intel-nuc-kit-nuc8i7beh.html">https://ark.intel.com/content/www/cn/zh/ark/products/126140/intel-nuc-kit-nuc8i7beh.html</a></p></blockquote><pre><code>wangwei@NUC8i7BEH.local ----------------------- OS: macOS 13.0.1 22A400 x86_64 Host: Hackintosh (SMBIOS: Macmini8,1) Kernel: 22.1.0 Uptime: 5 hours, 33 mins Packages: 17 (brew) Shell: zsh 5.8.1 Resolution: 2560x1440 DE: Aqua WM: Quartz Compositor WM Theme: Blue (Light) Terminal: HyperTerm Terminal Font: Menlo CPU: Intel i7-8559U (8) @ 2.70GHz GPU: Intel Iris Plus Graphics 655 Memory: 16556MiB / 32768MiB </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间我的MBP 2018 13inch（i5-8259u, 16G, 256G）在干活的时候各种卡顿，风扇无故狂转，所以打算搞个黑苹果写代码用。&lt;/p&gt;
&lt;p&gt;于是在闲鱼上收了个 &lt;code&gt;NUC8i7BEH&lt;/code&gt; ，配了两条光威的16G DDR4 3200的内存（镁光颗粒），买了一块1T的西数SN570。&lt;/p&gt;
&lt;p&gt;然后将硬盘分了三个区，一个windows，一个esp分区，一个macOS分区，安装了最新的 &lt;code&gt;Ventura&lt;/code&gt; 和最新的 &lt;code&gt;windows 11&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;未来一两年这就是我的开发机器了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mac" scheme="https://herotiga.github.io/categories/mac/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序实现watch</title>
    <link href="https://herotiga.github.io/2022/11/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0watch/"/>
    <id>https://herotiga.github.io/2022/11/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0watch/</id>
    <published>2022-11-20T12:54:14.000Z</published>
    <updated>2023-04-24T03:44:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近做需求需要实现一个按钮根据页面字段来</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做需求需要实现一个按钮根据页面字段来&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="https://herotiga.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序生命周期</title>
    <link href="https://herotiga.github.io/2022/11/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://herotiga.github.io/2022/11/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-11-18T11:59:44.000Z</published>
    <updated>2023-04-24T03:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;


      
    
    </summary>
    
    
      <category term="小程序" scheme="https://herotiga.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序适配iphone底部任务条</title>
    <link href="https://herotiga.github.io/2022/10/31/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%82%E9%85%8Diphone%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%9D%A1/"/>
    <id>https://herotiga.github.io/2022/10/31/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%82%E9%85%8Diphone%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%9D%A1/</id>
    <published>2022-10-31T03:48:39.000Z</published>
    <updated>2023-04-28T06:17:28.939Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序适配iphone底部任务条。</p><a id="more"></a><h2 id="获取底部安全距离并添加到globalData"><a href="#获取底部安全距离并添加到globalData" class="headerlink" title="获取底部安全距离并添加到globalData"></a>获取底部安全距离并添加到globalData</h2><p>app.js:</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  globalData: &#123;</span><br><span class="line">    bottomLift: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onLaunch() &#123;</span><br><span class="line">    wx.getSystemInfo(&#123;</span><br><span class="line">      success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.globalData.bottomLift = res.screenHeight - res.safeArea.bottom</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在页面js中引入"><a href="#在页面js中引入" class="headerlink" title="在页面js中引入"></a>在页面js中引入</h2><p>页面中使用：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">     bottomLift: app.globalData.bottomLift</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在wxml中使用"><a href="#在wxml中使用" class="headerlink" title="在wxml中使用"></a>在wxml中使用</h2><p>然后就可以在页面中需要的地方使用这个<code>bottomLift</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序适配iphone底部任务条。&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="https://herotiga.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue的作用域插槽(slot)</title>
    <link href="https://herotiga.github.io/2022/10/21/Vue%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD(slot)/"/>
    <id>https://herotiga.github.io/2022/10/21/Vue%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD(slot)/</id>
    <published>2022-10-21T07:08:59.000Z</published>
    <updated>2023-08-06T14:48:48.004Z</updated>
    
    <content type="html"><![CDATA[<p>父组件中向子组件的slot插入内容一般只能使用父组件本身的数据，如果想要在父组件中使用子组件中的数据作为内容插入子组件的slot该怎么办。</p><p>这个时候就要用到作用域插槽了。</p><a id="more"></a><h2 id="procedure"><a href="#procedure" class="headerlink" title="procedure"></a>procedure</h2><ol><li>子组件写好slot标签，父组件写好v-slot。</li><li>子组件slot标签绑定属性（属性名无所谓），属性值为子组件的data中的变量。</li><li>父组件以<code>#slotname=&quot;childvalue&quot;</code>的形式接收到子组件中的数据。</li><li>父组件在v-slot标签内使用<code></code>的方式向子组件slot中插入数据。</li></ol><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>child.vue:</p><figure class="highlight html"><figcaption><span>child.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">:d</span>=<span class="string">"name"</span>&gt;</span>备用内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            name: <span class="string">'Mason'</span>,</span></span><br><span class="line">            age: 22</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>parent.vue:</p><figure class="highlight html"><figcaption><span>parent.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> #<span class="attr">default</span>=<span class="string">"childData"</span>&gt;</span></span><br><span class="line">        &#123;&#123; childData.name &#125;&#125;</span><br><span class="line">        &#123;&#123; chileData.age &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;父组件中向子组件的slot插入内容一般只能使用父组件本身的数据，如果想要在父组件中使用子组件中的数据作为内容插入子组件的slot该怎么办。&lt;/p&gt;
&lt;p&gt;这个时候就要用到作用域插槽了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://herotiga.github.io/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-17.19-消失的两个数字</title>
    <link href="https://herotiga.github.io/2022/09/27/leetcode-17-19-%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>https://herotiga.github.io/2022/09/27/leetcode-17-19-%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</id>
    <published>2022-09-27T09:02:53.000Z</published>
    <updated>2023-04-28T06:22:22.055Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://leetcode.cn/problems/missing-two-lcci/">https://leetcode.cn/problems/missing-two-lcci/</a></p><p>难度：困难</p><a id="more"></a><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？</p><p>以任意顺序返回这两个数字均可。</p><p>示例 1:</p><pre><code>输入: [1]输出: [2,3]</code></pre><p>示例 2:</p><pre><code>输入: [2,3]输出: [1,4]</code></pre><p>提示：nums.length &lt;= 30000</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>先给原数组排序，再对排序完的数组进行判断是否存在缺失数字，如果存在就push进res数组直到res数组满了，如果不存在就往两边搜索。</p><h3 id="求差集"><a href="#求差集" class="headerlink" title="求差集"></a>求差集</h3><p>时间复杂度和空间复杂度都比较高。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingTwo = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先对于nums做升序排序</span></span><br><span class="line">    <span class="keyword">let</span> sortedNums = nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sortedNumsLen = sortedNums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描sortedNums中是否存在缺的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sortedNums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = sortedNums[i];</span><br><span class="line">        <span class="keyword">let</span> next = sortedNums[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (cur + <span class="number">1</span> !== next) &#123;</span><br><span class="line">            res.push(cur+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果仍然有缺失的数字则往两边搜索</span></span><br><span class="line">    <span class="comment">// 向左搜索</span></span><br><span class="line">    <span class="keyword">if</span> (res.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> head = sortedNums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; head - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res.push(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向右搜索</span></span><br><span class="line">    <span class="keyword">if</span> (res.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> tail = sortedNums[sortedNumsLen - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里需要保存一下res.length当前的值，因为for循环体内改变了res.length</span></span><br><span class="line">        <span class="keyword">let</span> resLen = res.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; (<span class="number">2</span> - resLen); i++) &#123;</span><br><span class="line">            res.push(tail + i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="求差集-1"><a href="#求差集-1" class="headerlink" title="求差集"></a>求差集</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingTwo = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先对于nums做升序排序</span></span><br><span class="line">    <span class="keyword">let</span> sortedNums = nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sortedNumsLen = sortedNums.length;</span><br><span class="line">    <span class="keyword">let</span> correctNums = <span class="keyword">new</span> <span class="built_in">Array</span>(sortedNumsLen+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充对照的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = correctNums.length; i &lt; len; i++) &#123;</span><br><span class="line">        correctNums[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sortedNumsSet = <span class="keyword">new</span> <span class="built_in">Set</span>(sortedNums);</span><br><span class="line">    <span class="keyword">let</span> correctNumsSet = <span class="keyword">new</span> <span class="built_in">Set</span>(correctNums);</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> correctNums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sortedNumsSet.has(item)) &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><p>向右搜索的for循环应该先保存一下<code>res.length</code>（见代码）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://leetcode.cn/problems/missing-two-lcci/&quot;&gt;https://leetcode.cn/problems/missing-two-lcci/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度：困难&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithms" scheme="https://herotiga.github.io/categories/algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue2和Vue3数据绑定实现原理的变化</title>
    <link href="https://herotiga.github.io/2022/09/14/Vue2%E5%92%8CVue3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>https://herotiga.github.io/2022/09/14/Vue2%E5%92%8CVue3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E5%8F%98%E5%8C%96/</id>
    <published>2022-09-14T02:28:56.000Z</published>
    <updated>2023-08-06T14:48:47.982Z</updated>
    
    <content type="html"><![CDATA[<p>Vue数据绑定的实现原理从Vue2的 <code>Object.defineProperty()</code> 对象属性劫持改为了Vue3的 <code>Proxy</code> 数据代理。</p><a id="more"></a><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><p><code>Object.defineProperty()</code> 可以对于对象的已有属性进行监听、劫持、修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue数据绑定的实现原理从Vue2的 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 对象属性劫持改为了Vue3的 &lt;code&gt;Proxy&lt;/code&gt; 数据代理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://herotiga.github.io/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>在Vue2中给data中的属性添加新属性的方法</title>
    <link href="https://herotiga.github.io/2022/09/14/%E7%BB%99Vue2%E7%9A%84data%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://herotiga.github.io/2022/09/14/%E7%BB%99Vue2%E7%9A%84data%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2022-09-14T01:43:45.000Z</published>
    <updated>2023-08-06T14:48:47.831Z</updated>
    
    <content type="html"><![CDATA[<p>由于Vue2的双向绑定是基于 <code>Object.defineProperty()</code> 的，这个方法只能监听 <code>data</code> 里面已经存在的属性，并不能对于新添加的属性进行监听，故而直接给data添加新属性是无法被vue监听到并绑定到页面上的。</p><p>这里注意：是没办法添加data下的一级属性的，必须事先定义。</p><p>下面是几种给data中的属性添加新属性的方法。</p><a id="more"></a><h2 id="set"><a href="#set" class="headerlink" title="$set()"></a>$set()</h2><p>可以使用 <code>Vue.set(target, key, value)</code> 或者 <code>this.$set(target, key, value)</code> 来给data添加新属性。</p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>可以通过重新赋值的方式添加属性。</p><p>example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        msg: &#123;</span><br><span class="line">            name: <span class="string">'mason'</span>,</span><br><span class="line">            age: <span class="number">22</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    updateMsg() &#123;</span><br><span class="line">        <span class="comment">// 右边是一个新的对象，vue检测到msg地址的变化会更新msg</span></span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.msg, &#123;<span class="attr">gender</span>: <span class="string">'male'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="$forceUpdate()"></a>$forceUpdate()</h2><p>不建议使用这个方法！</p><p><code>$forceUpdate()</code> 可以强制更新vue实例。</p><p>example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        msg: &#123;</span><br><span class="line">            name: <span class="string">'mason'</span>,</span><br><span class="line">            age: <span class="number">22</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    updateMsg() &#123;</span><br><span class="line">        <span class="keyword">this</span>.msg.gender = <span class="string">'male'</span>;</span><br><span class="line">        <span class="keyword">this</span>.$forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于Vue2的双向绑定是基于 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 的，这个方法只能监听 &lt;code&gt;data&lt;/code&gt; 里面已经存在的属性，并不能对于新添加的属性进行监听，故而直接给data添加新属性是无法被vue监听到并绑定到页面上的。&lt;/p&gt;
&lt;p&gt;这里注意：是没办法添加data下的一级属性的，必须事先定义。&lt;/p&gt;
&lt;p&gt;下面是几种给data中的属性添加新属性的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://herotiga.github.io/categories/vue/"/>
    
    
  </entry>
  
</feed>
