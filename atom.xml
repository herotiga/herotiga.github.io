<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Typecasting</title>
  
  <subtitle>write some articles about front-end dev,ui design,linux hacking and ai-cv.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://herotiga.github.io/"/>
  <updated>2024-09-07T15:10:20.815Z</updated>
  <id>https://herotiga.github.io/</id>
  
  <author>
    <name>Mason小王子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微前端架构方案——qiankun</title>
    <link href="https://herotiga.github.io/2024/09/07/micro-frontend-qiankun/"/>
    <id>https://herotiga.github.io/2024/09/07/micro-frontend-qiankun/</id>
    <published>2024-09-07T07:47:23.000Z</published>
    <updated>2024-09-07T15:10:20.815Z</updated>
    
    <content type="html"><![CDATA[<p>qiankun是基于Single-SPA的微前端实现库。</p><p>qiankun中的每一个微前端应用都有自己独立的生命周期和上下文环境，每个微前端内可以使用自己的技术栈。</p><a id="more"></a><h2 id="qiankun的核心设计理念"><a href="#qiankun的核心设计理念" class="headerlink" title="qiankun的核心设计理念"></a>qiankun的核心设计理念</h2><ul><li><p><strong>简单</strong>：qiankun对于开发者而言就是一个类似jQuery的库，只需要调用几个qiankun的API就可以完成应用的微前端改造。qiankun使用HTML entry和沙箱设计，接入微应用就像使用iframe一样简单。</p></li><li><p><strong>解耦以及技术栈无关</strong>：微前端的核心目标是将巨石应用拆解成多个可以自治的松耦合微应用，qiankun使用这一原则。qiankun的HTML entry、沙箱、应用间通信等确保了微应用可以独立开发独立运行。</p></li></ul><h2 id="qiankun如何在项目中使用"><a href="#qiankun如何在项目中使用" class="headerlink" title="qiankun如何在项目中使用"></a>qiankun如何在项目中使用</h2><h3 id="主应用中注册微应用"><a href="#主应用中注册微应用" class="headerlink" title="主应用中注册微应用"></a>主应用中注册微应用</h3><ol><li>安装qiankun</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S qiankun</span><br></pre></td></tr></table></figure><ol start="2"><li>在主应用中注册微应用</li></ol><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerMicroApps, start &#125; <span class="keyword">from</span> <span class="string">'qiankun'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册多个微应用</span></span><br><span class="line">registerMicroApps([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 微应用的名称，唯一</span></span><br><span class="line">    name: <span class="string">'react app'</span>,</span><br><span class="line">    <span class="comment">// 微应用的入口</span></span><br><span class="line">    entry: <span class="string">'//localhost:7100'</span>,</span><br><span class="line">    <span class="comment">// 微应用的容器节点id</span></span><br><span class="line">    container: <span class="string">'#yourContainer'</span>,</span><br><span class="line">    <span class="comment">// 微应用的匹配规则</span></span><br><span class="line">    activeRule: <span class="string">'/yourActiveRule'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'vue app'</span>,</span><br><span class="line">    entry: &#123; <span class="attr">scripts</span>: [<span class="string">'//localhost:7100/main.js'</span>] &#125;,</span><br><span class="line">    container: <span class="string">'#yourContainer2'</span>,</span><br><span class="line">    activeRule: <span class="string">'/yourActiveRule2'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>浏览器的URL发生变化后，qiankun会自动匹配规则，所有<code>activeRule</code>规则（路由匹配）匹配上的微应用都会被插入到指定的container中，同时一次调用微应用暴露出的生命周期钩子。</p><p>如果微应用不是直接跟路由关联的时候，你也可以选择手动加载微应用的方式：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loadMicroApp &#125; <span class="keyword">from</span> <span class="string">'qiankun'</span>;</span><br><span class="line"></span><br><span class="line">loadMicroApp(&#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  entry: <span class="string">'//localhost:7100'</span>,</span><br><span class="line">  container: <span class="string">'#yourContainer'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="微应用"><a href="#微应用" class="headerlink" title="微应用"></a>微应用</h3><p>微应用不需要额外安装任何其他依赖即可接入qiankun主应用。</p><ol><li>导出相应的生命周期钩子</li></ol><p>微应用需要在自己的入口js(通常就是你配置的webpack的entry js)导出bootstrap、mount、unmount三个生命周期钩子，以供主应用在适当的时机调用。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span></span><br><span class="line"><span class="comment"> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'react app bootstraped'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, props.container ? props.container.querySelector(<span class="string">'#root'</span>) : <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(</span><br><span class="line">    props.container ? props.container.querySelector(<span class="string">'#root'</span>) : <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'update props'</span>, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置微应用的打包工具</li></ol><p>除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置：</p><p>webpack v5:</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> packageName = <span class="built_in">require</span>(<span class="string">'./package.json'</span>).name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    library: <span class="string">`<span class="subst">$&#123;packageName&#125;</span>-[name]`</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">    chunkLoadingGlobal: <span class="string">`webpackJsonp_<span class="subst">$&#123;packageName&#125;</span>`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>webpack v4:</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> packageName = <span class="built_in">require</span>(<span class="string">'./package.json'</span>).name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    library: <span class="string">`<span class="subst">$&#123;packageName&#125;</span>-[name]`</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">    jsonpFunction: <span class="string">`webpackJsonp_<span class="subst">$&#123;packageName&#125;</span>`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://qiankun.umijs.org/zh">https://qiankun.umijs.org/zh</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;qiankun是基于Single-SPA的微前端实现库。&lt;/p&gt;
&lt;p&gt;qiankun中的每一个微前端应用都有自己独立的生命周期和上下文环境，每个微前端内可以使用自己的技术栈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://herotiga.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>微前端架构</title>
    <link href="https://herotiga.github.io/2024/09/07/micro-frontend-arch/"/>
    <id>https://herotiga.github.io/2024/09/07/micro-frontend-arch/</id>
    <published>2024-09-07T02:56:13.000Z</published>
    <updated>2024-09-07T14:14:26.220Z</updated>
    
    <content type="html"><![CDATA[<article class="message is-info"><div class="message-body"><p><strong>微前端</strong>是一种前端架构。</p><p>类似于后端的微服务架构，微前端就是将传统的SPA拆分为多个独立的前端模块，每个模块内可以使用不同的技术栈，多个模块可以由多个团队独立开发、测试、部署。</p></div></article><a id="more"></a><h2 id="微前端的核心思想"><a href="#微前端的核心思想" class="headerlink" title="微前端的核心思想"></a>微前端的核心思想</h2><ul><li><p><strong>模块化</strong>：每个微前端模块都是独立的，可以使用自己的技术栈、依赖、部署流程。</p></li><li><p><strong>独立性</strong>：不同的微前端模块可以由多个团队各自独立开发，互不干扰。</p></li><li><p><strong>灵活集成</strong>：最终可以由多个模块集成到一个页面上。</p></li><li><p><strong>隔离性</strong>：每个模块避免相互依赖。</p></li></ul><h2 id="微前端的优势"><a href="#微前端的优势" class="headerlink" title="微前端的优势"></a>微前端的优势</h2><ul><li><p><strong>模块可以独立开发和部署</strong>：各个团队可以独立开发和部署不同的微前端模块。</p></li><li><p><strong>每个模块技术栈各自独立</strong>：不同的微前端模块可以选择不同的技术栈。</p></li><li><p><strong>可渐进式升级</strong>：可以渐进的重写原有代码。</p></li><li><p><strong>可维护性高</strong>：微前端架构使得整个系统易于维护。</p></li></ul><h2 id="微前端的实现方式"><a href="#微前端的实现方式" class="headerlink" title="微前端的实现方式"></a>微前端的实现方式</h2><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>iframe嵌入页面，每个页面是一个单独的应用。这个方案性能很差，iframe之间很难通信。</p><h3 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h3><p>Web Components是浏览器原生支持的组件方案，允许创建自定义元素。</p><h3 id="Module-Federation"><a href="#Module-Federation" class="headerlink" title="Module Federation"></a>Module Federation</h3><p>webpack5引入了Module Federation来做微前端。</p><p>Module Federation允许不同的前端模块动态加载其他模块的代码。</p><h3 id="基于路由分发"><a href="#基于路由分发" class="headerlink" title="基于路由分发"></a>基于路由分发</h3><p>可以使用不同的路由区分不同的微前端模块，基于路由分发请求到微前端模块。</p><h3 id="Single-SPA"><a href="#Single-SPA" class="headerlink" title="Single-SPA"></a>Single-SPA</h3><p>Single-SPA框架允许多个微前端同时在一个页面运行，支持三大框架。</p><p>Single-SPA是将不同的微前端应用通过路由进行管理（先注册所有应用的路由，根据URL匹配应用），使得每个微前端应用可以独立加载、渲染、卸载。</p><p>Single-SPA支持React、Vue、Angular。</p><h3 id="qiankun"><a href="#qiankun" class="headerlink" title="qiankun"></a>qiankun</h3><p>qiankun基于Single-SPA做了优化，支持在同一个页面中挂载多个微前端应用，提供了简单地API和开箱即用的方案。</p><p>实际开发中一般选择qiankun做微前端。</p>]]></content>
    
    <summary type="html">
    
      &lt;article class=&quot;message is-info&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;&lt;strong&gt;微前端&lt;/strong&gt;是一种前端架构。&lt;/p&gt;
&lt;p&gt;类似于后端的微服务架构，微前端就是将传统的SPA拆分为多个独立的前端模块，每个模块内可以使用不同的技术栈，多个模块可以由多个团队独立开发、测试、部署。&lt;/p&gt;
&lt;/div&gt;&lt;/article&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://herotiga.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>前后端项目是如何部署的</title>
    <link href="https://herotiga.github.io/2024/09/06/application-deploy-flow/"/>
    <id>https://herotiga.github.io/2024/09/06/application-deploy-flow/</id>
    <published>2024-09-05T16:07:52.000Z</published>
    <updated>2024-09-07T15:52:48.468Z</updated>
    
    <content type="html"><![CDATA[<p>之前公司的前后端部署流程是这样的：</p><ol><li>本地推送feature分支到远端gitlab。</li><li>在gitlab将feature分支merge到目标分支比如test分支（test分支上挂有任务）。</li><li>merge完成后会触发任务，任务包括这几个阶段：<br> 3.1 运行测试任务。<br> 3.2 构建项目和编译目标代码。<br> 3.3 将Dockerfile（镜像）以及编译出的代码推送到目标服务器。<br> 3.4 在目标服务器上构建出Docker容器，启动Docker容器。</li></ol><a id="more"></a><h2 id="前端应用部署"><a href="#前端应用部署" class="headerlink" title="前端应用部署"></a>前端应用部署</h2><ol><li><p>打包前端应用<br>前端应用最终会被打包成一些静态文件：html, css, js, jpg等格式。通常这些文件是在dist/目录下。</p></li><li><p>上传文件到服务器<br>将这些静态文件通过ftp、scp上传到服务器。</p></li><li><p>配置web服务器<br>配置web服务器，将上一步服务器上的静态文件目录设置为根目录，并处理未匹配到的路由。</p></li></ol><p>比如，nginx配置：</p><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your-domain.com;</span><br><span class="line"></span><br><span class="line">    # 将对于路由&#x2F;的请求匹配到&#x2F;path&#x2F;to&#x2F;dist目录下的index.html</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root &#x2F;path&#x2F;to&#x2F;dist;</span><br><span class="line">        index index.html;</span><br><span class="line">        # 将未能匹配到的路由请求路由到index.html</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后端应用部署"><a href="#后端应用部署" class="headerlink" title="后端应用部署"></a>后端应用部署</h2><ol><li>打包微服务应用</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前公司的前后端部署流程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地推送feature分支到远端gitlab。&lt;/li&gt;
&lt;li&gt;在gitlab将feature分支merge到目标分支比如test分支（test分支上挂有任务）。&lt;/li&gt;
&lt;li&gt;merge完成后会触发任务，任务包括这几个阶段：&lt;br&gt; 3.1 运行测试任务。&lt;br&gt; 3.2 构建项目和编译目标代码。&lt;br&gt; 3.3 将Dockerfile（镜像）以及编译出的代码推送到目标服务器。&lt;br&gt; 3.4 在目标服务器上构建出Docker容器，启动Docker容器。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>RPC学习笔记</title>
    <link href="https://herotiga.github.io/2024/09/04/RPC/"/>
    <id>https://herotiga.github.io/2024/09/04/RPC/</id>
    <published>2024-09-04T15:55:27.000Z</published>
    <updated>2024-09-07T07:56:05.997Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许程序在不同的地址空间中调用另一个程序的函数，就像调用本地函数一样。通过RPC，开发人员可以构建分布式系统，其中程序可以在不同的计算机或网络节点上运行，但仍能相互通信并调用对方的服务或方法。</p></blockquote><a id="more"></a><h2 id="RPC工作流程"><a href="#RPC工作流程" class="headerlink" title="RPC工作流程"></a>RPC工作流程</h2><ol><li>客户端发起调用：客户端调用一个本地的代理函数（stub），并将参数传给它。</li><li>序列化参数：客户端stub将参数序列化。</li><li>发送请求：将请求发送到被调用的远程服务器。</li><li>远程服务器处理请求：远程服务器收到请求后反序列化参数，调用本地的目标函数。</li><li>远程服务器返回调用结果：远程服务器执行完函数后，将执行结果序列化并返回给客户端。</li><li>客户端接收结果：客户端接受到远程服务器的响应，然后反序列化结果，最后将它返回给最初调用的程序。</li></ol><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><p>主流的RPC框架有：</p><ul><li>gRPC</li><li>Dubbo</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许程序在不同的地址空间中调用另一个程序的函数，就像调用本地函数一样。通过RPC，开发人员可以构建分布式系统，其中程序可以在不同的计算机或网络节点上运行，但仍能相互通信并调用对方的服务或方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://herotiga.github.io/categories/Java/"/>
    
      <category term="RPC" scheme="https://herotiga.github.io/categories/RPC/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis在实际业务中的使用场景</title>
    <link href="https://herotiga.github.io/2024/09/04/Redis%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://herotiga.github.io/2024/09/04/Redis%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2024-09-04T14:24:35.000Z</published>
    <updated>2024-09-04T15:36:20.111Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是一个高性能的KV内存数据库，实际业务中有很多使用场景。</p><a id="more"></a><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li>可以将高频访问的数据缓存到Redis以降低后端数据库压力。</li><li>可以将查询耗时长的查询结果缓存到Redis避免重复查询。</li></ul><h2 id="会话存储"><a href="#会话存储" class="headerlink" title="会话存储"></a>会话存储</h2><p>在分布式系统中Redis可以用来存储用户会话数据，从而使不同的服务器可以共享用户的会话数据。</p><h2 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h2><p>Redis可以设置键的过期时间，适合存储需要自动过期的数据，比如验证码、临时令牌。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>在分布式系统中，使用Redis的原子操作可以实现分布式锁，确保多个进程或者服务不会同时操作同一个资源。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li>Redis支持发布/订阅模式，可以作为简单的消息队列使用。</li><li>可以使用Redis的列表数据结构实现任务队列，适合处理需要排队执行的任务。</li></ul><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>Redis可以实现延迟任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis是一个高性能的KV内存数据库，实际业务中有很多使用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://herotiga.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL中UPDATE和INSERT在加锁上有什么区别</title>
    <link href="https://herotiga.github.io/2024/09/04/mysql-update-insert-lock-diff/"/>
    <id>https://herotiga.github.io/2024/09/04/mysql-update-insert-lock-diff/</id>
    <published>2024-09-04T08:07:37.000Z</published>
    <updated>2024-09-04T08:20:32.775Z</updated>
    
    <content type="html"><![CDATA[<p>在MySQL中，<code>UPDATE</code>和<code>INSERT</code>在加锁上有一些区别。</p><a id="more"></a><h2 id="锁的范围"><a href="#锁的范围" class="headerlink" title="锁的范围"></a>锁的范围</h2><ul><li>UPDATE</li></ul><p>使用UPDATE只会对需要更新的一行或者多行进行加锁，加的是行锁。</p><p>如果还使用了<code>WHERE</code>则还会加上间隙锁，锁住范围内不存在的索引项之间的间隙防止其他事务插入新行。</p><ul><li>INSERT</li></ul><p>INSERT不会加行锁，它会对插入位置加上插入意向锁（Insert Intention Lock）以防止并发插入时死锁。</p><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><ul><li>UPDATE</li></ul><p>UPDATE会使用排他锁锁住需要更新的行。</p><ul><li>INSERT</li></ul><p>INSERT会使用排他锁来保证数据一致性，插入完成后释放锁。</p><h2 id="锁的冲突"><a href="#锁的冲突" class="headerlink" title="锁的冲突"></a>锁的冲突</h2><ul><li>UPDATE</li></ul><p>UPDATE会使用排他锁，故而可能导致锁等待或者死锁。</p><ul><li>INSERT</li></ul><p>并发INSERT时一般不会发生锁冲突。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在MySQL中，&lt;code&gt;UPDATE&lt;/code&gt;和&lt;code&gt;INSERT&lt;/code&gt;在加锁上有一些区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://herotiga.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL中的锁</title>
    <link href="https://herotiga.github.io/2024/09/04/mysql-lock/"/>
    <id>https://herotiga.github.io/2024/09/04/mysql-lock/</id>
    <published>2024-09-04T07:27:08.000Z</published>
    <updated>2024-09-04T10:35:57.817Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL中有哪些锁？这些锁的作用又是什么？</p><p>MySQL中的锁按照颗粒度从粗到细分为：</p><ul><li>全局锁</li><li>表级锁</li><li>行级锁</li></ul><a id="more"></a><article class="message is-info"><div class="message-body"><p>SQL分类：</p><ol><li><p>DDL(Data Definition Language)数据定义语言：用来操作数据库、表、列等。常用语句：CREATE、ALTER、DROP。</p></li><li><p>DML(Data Manipulation Language)数据操作语言：用来操作数据库中表里的数据。常用语句：INSERT、 UPDATE、DELETE。</p></li><li><p>DCL(Data Control Language)数据控制语言：用来操作访问权限和安全级别。常用语句：GRANT、DENY。</p></li><li><p>DQL(Data Query Language)数据查询语言：用来查询数据。常用语句：SELECT。</p></div></article></li></ol><h2 id="全局锁（Global-Lock）"><a href="#全局锁（Global-Lock）" class="headerlink" title="全局锁（Global Lock）"></a>全局锁（Global Lock）</h2><p>全局锁会锁住整个数据库并且数据库处于只读状态，只能进行DQL操作不能进行DDL（包括定义、改变表结构、数据类型、表之间链接的操作）和DML操作，适用于需要保证数据一致性的场景比如数据备份。</p><p>数据备份加锁步骤：</p><ol><li>加全局锁，之后只能进行DQL操作。<figure class="highlight sql"><figcaption><span>SQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>;</span><br></pre></td></tr></table></figure></li><li>使用mysqldump备份数据库。<figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --user user --password database_name --result-file=path/to/file.sql</span><br></pre></td></tr></table></figure></li><li>备份完成后解开全局锁。<figure class="highlight sql"><figcaption><span>SQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure></li><li>正常进行DDL、DML、DQL操作。</li></ol><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁分为：</p><ul><li>表锁</li><li>元数据锁</li><li>意向锁</li></ul><h3 id="表锁（Table-Lock）"><a href="#表锁（Table-Lock）" class="headerlink" title="表锁（Table Lock）"></a>表锁（Table Lock）</h3><figure class="highlight sql"><figcaption><span>SQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给表加锁</span></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> table_name [<span class="keyword">READ</span> | WRITE]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure><p>表锁锁的是整张表，表所细分为读锁和写锁。</p><ul><li>读锁（Read Lock）</li></ul><p>多个事务可以同时读表，但是无法写。</p><ul><li>写锁（Write Lock）</li></ul><p>一个事务在获取到写锁后其他事务无法读写这张表，等到写锁被释放其他事务才可以继续读写。</p><h3 id="元数据锁（Meta-Data-Lock）"><a href="#元数据锁（Meta-Data-Lock）" class="headerlink" title="元数据锁（Meta Data Lock）"></a>元数据锁（Meta Data Lock）</h3><p>元数据锁锁定的是表结构（包括表定义、索引定义），当执行改变表结构的操作（ALTER TABLE、DROP TABLE）时MySQL会自动给表加上元数据锁以防止并发的DDL操作（比如CREATE、ALTER、DROP）和DML（比如INSERT、UPDATE、DELETE）操作发生冲突。</p><h3 id="意向锁（Intention-Lock）"><a href="#意向锁（Intention-Lock）" class="headerlink" title="意向锁（Intention Lock）"></a>意向锁（Intention Lock）</h3><p>意向锁是MySQL自动加的。</p><p>意向锁不会阻塞其他事务的表锁操作，只是用来表明某个事务打算对某些行加锁。</p><p>意向共享锁（Intention Shared Lock）：当一个事务想要在某些行上加共享锁时，首先需要在表级别加意向共享锁。</p><p>意向排他锁（Intention Exclusive Lock）：当一个事务想要在某些行上加排他锁时，首先需要在表级别加意向排他锁。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是粒度最小的锁，是针对于索引字段加的锁，只对于当前操作的一行或者多行进行加锁。</p><p>行级锁操作粒度最小，并发度高。但是加锁开销最大，可能出现死锁。</p><p>行级锁分为：</p><ul><li>行锁</li><li>间隙锁</li><li>临键锁</li></ul><h3 id="行锁（Row-Lock）"><a href="#行锁（Row-Lock）" class="headerlink" title="行锁（Row Lock）"></a>行锁（Row Lock）</h3><p>行锁锁定表中的一行或者多行。</p><p>因为行锁只锁定特定的行，所以不影响整张表，是innoDB主要的锁类型。</p><p>行锁分为：</p><ul><li>共享锁</li></ul><p>如果给行加上共享锁，那么其他事务将不可获得排他锁，其他事务只能获取共享锁并且只能读这些行。</p><ul><li>排他锁</li></ul><p>只允许获取到排他锁的事务读写，其他事务将不能获取到共享锁和排他锁直到排他锁被释放。</p><h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><p>当用范围条件而不是相等条件索引数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做间隙。间隙锁帮我们解决幻读问题。</p><h3 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h3><p>临键锁是行锁与间隙锁的组合，它的锁定范围既包含行又包含索引区间。</p><h2 id="自增锁（AUTO-INC-Lock）"><a href="#自增锁（AUTO-INC-Lock）" class="headerlink" title="自增锁（AUTO-INC Lock）"></a>自增锁（AUTO-INC Lock）</h2><p>如果一个表中含有自增字段，MySQL会使用自增锁来确保并发插入操作时自增字段的唯一性和有序性。</p><p>自增锁在事务提交时释放。</p><h2 id="外键锁（Foreign-Key-Lock）"><a href="#外键锁（Foreign-Key-Lock）" class="headerlink" title="外键锁（Foreign Key Lock）"></a>外键锁（Foreign Key Lock）</h2><p>使用外键约束时，innoDB会对相关行加锁确保父表中的行在存在关联的子表行时不会被删除或者更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL中有哪些锁？这些锁的作用又是什么？&lt;/p&gt;
&lt;p&gt;MySQL中的锁按照颗粒度从粗到细分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局锁&lt;/li&gt;
&lt;li&gt;表级锁&lt;/li&gt;
&lt;li&gt;行级锁&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://herotiga.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js高并发方案</title>
    <link href="https://herotiga.github.io/2024/09/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://herotiga.github.io/2024/09/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2024-09-01T16:15:44.000Z</published>
    <updated>2024-09-02T03:42:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js高并发方案</p><a id="more"></a><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Node.js是单线程的，可以利用Cluster模块创建多个子进程来利用多核CPU，子进程共享相同的端口，平均分发请求，提高并发处理能力。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>常用的反向代理服务器有Nginx和HAProxy。</p><ul><li>Nginx</li></ul><p>使用Nginx作为反向代理服务器，将请求分发给多个Node.js实例。</p><p>还可以用Nginx处理静态文件、SSL卸载以减轻Node.js的压力。</p><ul><li>HAProxy</li></ul><p>HAProxy也可以做负载均衡。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列的作用有：解耦服务，异步任务处理，缓冲突发流量。</p><p>常用RabbitMQ、Kafka。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>将频繁访问的数据写入内存。</p><p>可以使用内存数据库Redis、Memcached，将高频访问的数据写入内存数据库以提高响应速度。</p><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>服务端设置HTTP header的某些字段来减少客户端对服务端的请求，可以降低服务端压力。</p><ul><li>Cache-Control</li><li>ETag</li></ul><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>通过主从复制将数据库读写操作分离，在从库读取，在主库写入。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>确保查询语句有合适的索引，避免全表扫描。</p><h3 id="分库分表（Database-Sharding-amp-Table-Sharding）"><a href="#分库分表（Database-Sharding-amp-Table-Sharding）" class="headerlink" title="分库分表（Database Sharding &amp; Table Sharding）"></a>分库分表（Database Sharding &amp; Table Sharding）</h3><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>分库就是将数据分散到多个数据库中。</p><p>分库又分为垂直分库和水平分库。</p><ul><li>垂直分库</li></ul><p>根据业务模块的不同，将数据按照业务模块的不同拆分到多个数据库中。优点是不同模块的读写操作互不影响。</p><p>比如，在电商系统中，可以将用户模块的数据放在一个数据库中，将订单模块数据放在另一个数据库中。</p><ul><li>水平分库</li></ul><p>将同一个表的数据按照某种规则拆分到多个数据库中。优点是可以均衡数据量和访问压力。</p><p>比如，在电商系统中，将用户表中的数据按照用户ID范围或者哈希值拆分到多个数据库中。</p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>分表就是将一张表的数据分散到多张表中。</p><p>分表又分为垂直分表和水平分表。</p><ul><li>垂直分表</li></ul><p>将表中字段较多的表按照字段拆分为多张表。</p><p>比如，把用户表拆分为基本信息和扩展信息两张表，减少了表的宽度提高了查询效率。</p><ul><li>水平分表</li></ul><p>将同一张表的数据按照行拆分到多张表中。</p><p>比如，按照用户ID将用户表分为user_01和user_02等多张表，解决了单张表数据量过大导致的性能问题。</p><h4 id="如何分库分表"><a href="#如何分库分表" class="headerlink" title="如何分库分表"></a>如何分库分表</h4><ul><li>选择分片键（Shard Key）</li></ul><p>分库分表需要选择一个合理的分片键，这会影响数据的分布和性能。</p><p>一般选择主键、时间戳，或者均匀分布数据的字段（常用UUID）作为分片键。</p><ul><li>路由策略</li></ul><p>分库分表后，路由是需要知道访问的数据在哪个库或者表中。</p><ul><li>事务处理</li></ul><p>分库分表后，事务中可能会出现跨库、跨表的情况。可以使用分布式事务、最终一致性等机制解决。</p><ul><li>数据迁移和扩容</li></ul><p>数据迁移：在单库单表的基础上分库分表，需要进行数据迁移，可以编写脚本或者使用工具将数据迁移到新的分库分表架构中。</p><p>扩容：随着数据量的增长，需要考虑动态扩展数据库或者表的数量。</p><h4 id="分库分表中间件"><a href="#分库分表中间件" class="headerlink" title="分库分表中间件"></a>分库分表中间件</h4><ul><li>Mycat：分库分表中间件。</li><li>ShardingSphere：分库分表中间件，支持分布式事务。</li><li>TDDL：分布式数据库层，可以分库分表。</li></ul><p>如果使用了Sequelize，还可以安装插件支持分库分表：</p><ul><li>Sharding插件</li><li>自定义ORM扩展：在ORM中自定义模型的数据库连接或查询方法，实现对不同数据库或表的访问。</li></ul><h4 id="性能监控和优化"><a href="#性能监控和优化" class="headerlink" title="性能监控和优化"></a>性能监控和优化</h4><p>分库分表架构建立后，需要持续监控新架构的系统性能以及根据监控调整分库分表策略。</p><h4 id="Node-js分库分表简单实现"><a href="#Node-js分库分表简单实现" class="headerlink" title="Node.js分库分表简单实现"></a>Node.js分库分表简单实现</h4><p>下面的实例将用户信息分散到了两个数据库中。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql2/promise'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个数据库的配置信息</span></span><br><span class="line"><span class="keyword">const</span> dbConfigs = [</span><br><span class="line">    &#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">user</span>: <span class="string">'root'</span>, <span class="attr">password</span>: <span class="string">'password'</span>, <span class="attr">database</span>: <span class="string">'db1'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">user</span>: <span class="string">'root'</span>, <span class="attr">password</span>: <span class="string">'password'</span>, <span class="attr">database</span>: <span class="string">'db2'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个数据库创建连接池</span></span><br><span class="line"><span class="keyword">const</span> pools = dbConfigs.map(<span class="function"><span class="params">config</span> =&gt;</span> mysql.createPool(config));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据id将用户请求分散到多个数据库上，计算数据库偏移量</span></span><br><span class="line"><span class="keyword">const</span> getShard = <span class="function">(<span class="params">id</span>) =&gt;</span> id % dbConfigs.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="keyword">async</span> (userId) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 选择id为分片键</span></span><br><span class="line">    <span class="keyword">const</span> shard = getShard(userId);</span><br><span class="line">    <span class="keyword">const</span> pool = pools[shard];</span><br><span class="line">    <span class="keyword">const</span> conn = <span class="keyword">await</span> pool.getConnection();</span><br><span class="line">    <span class="keyword">const</span> [rows] = <span class="keyword">await</span> conn.query(<span class="string">'SELECT * FROM users WHERE id = ?'</span>, [userId]);</span><br><span class="line">    conn.release();</span><br><span class="line">    <span class="keyword">return</span> rows[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">getUser(<span class="number">1234456</span>).then(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(user)).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br></pre></td></tr></table></figure><h2 id="性能监控和调优"><a href="#性能监控和调优" class="headerlink" title="性能监控和调优"></a>性能监控和调优</h2><p>监控工具：PM2，New Relic，Datadog</p><h2 id="服务器扩展"><a href="#服务器扩展" class="headerlink" title="服务器扩展"></a>服务器扩展</h2><ul><li>垂直扩展</li></ul><p>提升服务器硬件配置。</p><ul><li>水平扩展</li></ul><p>增加服务器数量。</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>使用CDN缓存静态资源。</p><h2 id="限流和降级"><a href="#限流和降级" class="headerlink" title="限流和降级"></a>限流和降级</h2><ul><li>限流</li></ul><p>限制流量避免系统宕机。</p><ul><li>降级</li></ul><p>系统压力较大时可以关闭部分非核心服务，有限保证核心服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js高并发方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>在Node.js项目微服务架构中使用Kafka通信</title>
    <link href="https://herotiga.github.io/2024/08/31/nodejs-kafka/"/>
    <id>https://herotiga.github.io/2024/08/31/nodejs-kafka/</id>
    <published>2024-08-31T15:32:21.000Z</published>
    <updated>2024-08-31T16:09:28.411Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka相比于RabbitMQ性能更好。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Kafka客户端库"><a href="#安装Kafka客户端库" class="headerlink" title="安装Kafka客户端库"></a>安装Kafka客户端库</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S kafkajs</span><br></pre></td></tr></table></figure><h3 id="配置Kafka-broker集群"><a href="#配置Kafka-broker集群" class="headerlink" title="配置Kafka broker集群"></a>配置Kafka broker集群</h3><p>通常会使用多个Kafka代理（broker）构成集群。</p><p>Kafka broker集群可以提高系统的可用性和吞吐量。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kafka = <span class="keyword">new</span> Kafka(&#123;</span><br><span class="line">  clientId: <span class="string">'my-app'</span>,</span><br><span class="line">  brokers: [<span class="string">'broker1:9092'</span>, <span class="string">'broker2:9092'</span>],</span><br><span class="line">  <span class="comment">// 重试机制</span></span><br><span class="line">  retry: &#123;</span><br><span class="line">    retries: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h2><p>Kafka生产者向Topic发送消息：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Kafka &#125; = <span class="built_in">require</span>(<span class="string">'kafkajs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Kafka实例并指定Kafka代理（broker）的地址</span></span><br><span class="line"><span class="keyword">const</span> kafka = <span class="keyword">new</span> Kafka(&#123;</span><br><span class="line">  clientId: <span class="string">'my-app'</span>,</span><br><span class="line">  brokers: [<span class="string">'localhost:9092'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个生产者</span></span><br><span class="line"><span class="keyword">const</span> producer = kafka.producer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 连接生产者</span></span><br><span class="line">  <span class="keyword">await</span> producer.connect();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送一条消息到指定的主题</span></span><br><span class="line">  <span class="keyword">await</span> producer.send(&#123;</span><br><span class="line">    topic: <span class="string">'test-topic'</span>,</span><br><span class="line">    messages: [</span><br><span class="line">      &#123; <span class="attr">value</span>: <span class="string">'Hello KafkaJS user!'</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开连接</span></span><br><span class="line">  <span class="keyword">await</span> producer.disconnect();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run().catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><h2 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h2><p>Kafka消费者从Topic中读取消息并消费：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Kafka &#125; = <span class="built_in">require</span>(<span class="string">'kafkajs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Kafka实例并指定Kafka代理（broker）的地址</span></span><br><span class="line"><span class="keyword">const</span> kafka = <span class="keyword">new</span> Kafka(&#123;</span><br><span class="line">  clientId: <span class="string">'my-app'</span>,</span><br><span class="line">  brokers: [<span class="string">'localhost:9092'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个消费者并指定消费的组ID</span></span><br><span class="line"><span class="keyword">const</span> consumer = kafka.consumer(&#123; <span class="attr">groupId</span>: <span class="string">'test-group'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 连接消费者</span></span><br><span class="line">  <span class="keyword">await</span> consumer.connect();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 订阅主题</span></span><br><span class="line">  <span class="keyword">await</span> consumer.subscribe(&#123; <span class="attr">topic</span>: <span class="string">'test-topic'</span>, <span class="attr">fromBeginning</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理消息</span></span><br><span class="line">  <span class="keyword">await</span> consumer.run(&#123;</span><br><span class="line">    eachMessage: <span class="keyword">async</span> (&#123; topic, partition, message &#125;) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(&#123;</span><br><span class="line">        partition,</span><br><span class="line">        offset: message.offset,</span><br><span class="line">        value: message.value.toString(),</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run().catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kafka相比于RabbitMQ性能更好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>在Node.js项目微服务架构中使用RabbitMQ通信</title>
    <link href="https://herotiga.github.io/2024/08/31/nodejs-rabbitmq/"/>
    <id>https://herotiga.github.io/2024/08/31/nodejs-rabbitmq/</id>
    <published>2024-08-31T11:21:47.000Z</published>
    <updated>2024-08-31T15:32:09.738Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列（MQ）可以让系统中不同部分的应用程序或者不同的微服务之间进行异步通信。</p><p>Node.js常用的MQ有RabbitMQ、Kafka、或Redis等。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="搭建RabbitMQ服务器"><a href="#搭建RabbitMQ服务器" class="headerlink" title="搭建RabbitMQ服务器"></a>搭建RabbitMQ服务器</h3><p>构建一个RabbitMQ服务器的Docker容器并暴露服务端口。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure><p>5672端口是RabbitMQ的默认通信端口，15672端口是web管理界面的端口。</p><h3 id="安装amqplib包"><a href="#安装amqplib包" class="headerlink" title="安装amqplib包"></a>安装amqplib包</h3><p>在Node.js项目中安装amqplib：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S amqplib</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="连接RabbitMQ服务器并发送消息到队列"><a href="#连接RabbitMQ服务器并发送消息到队列" class="headerlink" title="连接RabbitMQ服务器并发送消息到队列"></a>连接RabbitMQ服务器并发送消息到队列</h3><p>创建一个消息生产者，连接RabbitMQ并发送消息到队列：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib/callback_api'</span>);</span><br><span class="line"></span><br><span class="line">amqp.connect(<span class="string">'amqp://localhost'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error0, connection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error0) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个通道</span></span><br><span class="line">  connection.createChannel(<span class="function"><span class="keyword">function</span>(<span class="params">error1, channel</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = <span class="string">'task_queue'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个队列</span></span><br><span class="line">    channel.assertQueue(queue, &#123;</span><br><span class="line">      durable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息到队列</span></span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line">    channel.sendToQueue(queue, Buffer.from(msg), &#123;</span><br><span class="line">      persistent: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">" [x] Sent '%s'"</span>, msg);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭连接</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    connection.close();</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="从队列中消费消息"><a href="#从队列中消费消息" class="headerlink" title="从队列中消费消息"></a>从队列中消费消息</h3><p>创建一个消息消费者，从消息队列中取出消息并消费：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib/callback_api'</span>);</span><br><span class="line"></span><br><span class="line">amqp.connect(<span class="string">'amqp://localhost'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error0, connection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error0) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  connection.createChannel(<span class="function"><span class="keyword">function</span>(<span class="params">error1, channel</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = <span class="string">'task_queue'</span>;</span><br><span class="line"></span><br><span class="line">    channel.assertQueue(queue, &#123;</span><br><span class="line">      durable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    channel.prefetch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">" [*] Waiting for messages in %s. To exit press CTRL+C"</span>, queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费消息</span></span><br><span class="line">    channel.consume(queue, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> secs = msg.content.toString().split(<span class="string">'.'</span>).length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">" [x] Received %s"</span>, msg.content.toString());</span><br><span class="line"></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">" [x] Done"</span>);</span><br><span class="line">        channel.ack(msg);</span><br><span class="line">      &#125;, secs * <span class="number">1000</span>);</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      noAck: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ol><li>队列持久化</li></ol><p>消息消费者连接队列时开启<code>durable: true</code>可以实现队列持久化。</p><ol start="2"><li>消息持久化</li></ol><p>消息生产者发送消息时开启<code>persistent: true</code>可以实现消息持久化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列（MQ）可以让系统中不同部分的应用程序或者不同的微服务之间进行异步通信。&lt;/p&gt;
&lt;p&gt;Node.js常用的MQ有RabbitMQ、Kafka、或Redis等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js项目实现微服务架构</title>
    <link href="https://herotiga.github.io/2024/08/31/nodejs-microservices/"/>
    <id>https://herotiga.github.io/2024/08/31/nodejs-microservices/</id>
    <published>2024-08-30T16:28:18.000Z</published>
    <updated>2024-09-02T08:43:52.508Z</updated>
    
    <content type="html"><![CDATA[<p>微服务是一种软件架构风格，在这种架构中，应用程序被构建为一组小的、独立的服务，每个服务负责处理特定的业务功能。这些服务可以独立开发、部署和扩展，并通过轻量级的通信机制（通常是 HTTP API）进行互相通信。</p><a id="more"></a><hr><h2 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h2><ol><li><p>模块化：每个微服务都是一个独立的模块，负责特定的业务功能。不同的团队可以独立地开发和维护不同的微服务。</p></li><li><p>独立部署：微服务可以独立部署和更新，而不必影响其他服务。这使得应用程序更具灵活性，能够快速响应变化。</p></li><li><p>技术多样性：不同的微服务可以使用不同的编程语言、数据库和技术栈，选择最适合其功能的技术。</p></li><li><p>可扩展性：由于微服务是独立的，特定的微服务可以独立扩展，从而优化资源利用。</p></li><li><p>容错性：因为微服务是分布式的，如果一个服务出现故障，通常不会导致整个系统崩溃。</p></li></ol><hr><h2 id="Node-js实现微服务"><a href="#Node-js实现微服务" class="headerlink" title="Node.js实现微服务"></a>Node.js实现微服务</h2><h3 id="将应用拆分为多个服务"><a href="#将应用拆分为多个服务" class="headerlink" title="将应用拆分为多个服务"></a>将应用拆分为多个服务</h3><p>首先，将单体应用拆分为多个独立的微服务。每个微服务应专注于一个特定的业务功能，例如用户管理、订单处理、支付等。</p><p>每个微服务可能会拥有自己的数据库，以实现服务之间的解耦。</p><p>数据库可能需要分片或者复制以提高性能和容错性。</p><p>在微服务之间或微服务与数据库之间使用缓存层（如 Redis、Memcached）来加速数据访问和减少数据库负载。</p><p>使用分布式数据库（如 Cassandra、CockroachDB）来存储和管理海量数据。</p><p>对于文件或大数据对象，可以使用分布式对象存储（如 AWS S3、MinIO）来存储和访问。</p><h3 id="使用独立的代码库和包管理"><a href="#使用独立的代码库和包管理" class="headerlink" title="使用独立的代码库和包管理"></a>使用独立的代码库和包管理</h3><p>每个微服务应当拥有自己的代码库和独立的<code>package.json</code>文件。这使得它们可以独立管理依赖项，并能够使用不同的 Node.js 版本或第三方库。</p><h3 id="选择合适的通信方式"><a href="#选择合适的通信方式" class="headerlink" title="选择合适的通信方式"></a>选择合适的通信方式</h3><p>微服务之间需要通信。</p><p>微服务常见的通信方式：</p><ul><li>HTTP/RESTfull API：每个微服务暴露 RESTfull API 供其他服务调用。</li><li>消息队列（MQ）：可以使用 MQ 来异步传递消息，常用的 MQ 有 RabbitMQ、Apache Kafka、Redis Streams 等。</li><li>gRPC：是一种 RPC（远程过程调用）框架，适合高性能通信场景。</li></ul><h3 id="选择合适的-web-框架构建-RESTfull-微服务"><a href="#选择合适的-web-框架构建-RESTfull-微服务" class="headerlink" title="选择合适的 web 框架构建 RESTfull 微服务"></a>选择合适的 web 框架构建 RESTfull 微服务</h3><p>比如 Express 或者 Koa.js 等。</p><h3 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h3><p>可以使用微服务注册和发现工具来管理与发现这些微服务。</p><p>常用的：Consul、Eureka、etcd</p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>每个微服务拥有自己的配置，可以使用配置管理工具来管理配置。</p><p>常用的：Consul、Vault</p><h3 id="日志记录和监控"><a href="#日志记录和监控" class="headerlink" title="日志记录和监控"></a>日志记录和监控</h3><p>常用的日志聚合工具：ELK（Elasticsearch, Logstash, Kibana）</p><p>常用的监控工具：Prometheus、Grafana</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>可以将每个微服务打包成 Docker 容器，再使用 Docker Compose 或者 K8s 自动化部署、扩展、管理这些容器。</p><p>CI/CD：使用 Jenkins、GitLab CI、CircleCI 等工具实现自动化的构建、测试和部署流程。</p><p>蓝绿部署/金丝雀发布：在发布新版本时，采用蓝绿部署或金丝雀发布策略，减少发布风险。</p><h3 id="负载均衡和代理"><a href="#负载均衡和代理" class="headerlink" title="负载均衡和代理"></a>负载均衡和代理</h3><p>微服务层之间需要使用负载均衡器来实现流量分发，以实现高可用性和容错性。</p><p>常用的负载均衡器：HAProxy、Nginx、AWS ELB</p><p>还需要使用反向代理来分发来自 API 网关的请求到适当的微服务，常用 Nginx 反向代理。</p><h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h3><p>可以使用 API 网关来统一管理和路由所有微服务的请求。</p><p>API 网关可以处理请求路由、认证、限流。</p><p>常用的 API 网关：Nginx、Kong、Express Gateway 等。</p><h3 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h3><p>在分布式系统中可能会出现某个微服务失效。</p><p>可以使用熔断器比如 opossum 来防止级联故障，确保在某个微服务失败时，系统其他部分仍然可用。</p><hr><h2 id="Node-js微服务简单实例"><a href="#Node-js微服务简单实例" class="headerlink" title="Node.js微服务简单实例"></a>Node.js微服务简单实例</h2><ol><li>为微服务创建一个目录，用于存放所有的微服务。</li></ol><p>微服务项目目录结构：</p><pre><code>my-microservices-project/├── api-gateway/│   ├── package.json│   ├── index.js├── user-service/│   ├── package.json│   ├── index.js├── order-service/│   ├── package.json│   ├── index.js├── docker-compose.yml└── README.md</code></pre><ol start="2"><li><p>为每个微服务创建一个目录。</p></li><li><p>每个微服务拥有自己的目录以及<code>package.json</code>文件。</p></li></ol><figure class="highlight json"><figcaption><span>user-service/package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"user-service"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.17.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写微服务，每个微服务都相当于是一个Node.js项目。</li></ol><figure class="highlight js"><figcaption><span>user-service/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json([&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Alice'</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`User service running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>API Gateway</li></ol><p>创建<code>api-gateway/index.js</code>文件，用于路由客户端的请求到对应的微服务。</p><figure class="highlight js"><figcaption><span>api-gateway/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> proxy = httpProxy.createProxyServer();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    proxy.web(req, res, &#123; <span class="attr">target</span>: <span class="string">'http://localhost:3001'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/orders'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    proxy.web(req, res, &#123; <span class="attr">target</span>: <span class="string">'http://localhost:3002'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`API Gateway running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>启动微服务</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动gateway</span></span><br><span class="line"><span class="built_in">cd</span> api-gateway</span><br><span class="line">npm install</span><br><span class="line">node index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动user-service服务</span></span><br><span class="line"><span class="built_in">cd</span> user-service</span><br><span class="line">npm install</span><br><span class="line">node index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动order-service服务</span></span><br><span class="line"><span class="built_in">cd</span> order-service</span><br><span class="line">npm install</span><br><span class="line">node index.js</span><br></pre></td></tr></table></figure><p>现在api-gateway和微服务已经运行了：</p><ul><li><code>http://localhost:3000</code>：运行了api-gateway，它将客户端请求路由到对应的微服务。</li><li><code>http://localhost:3001</code>：运行了user-service服务。</li><li><code>http://localhost:3002</code>：运行了order-service服务。</li></ul><ol start="7"><li>测试微服务</li></ol><p>使用postman或者cURL测试微服务。</p><ol start="8"><li>微服务容器化</li></ol><p>为每个服务创建<code>Dockerfile</code>文件，然后使用Docker Compose或者K8s来编排这些服务的容器。</p><p>这里使用Docker Compose。</p><p>第一步：为每个服务创建Dockerfile文件</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"index.js"</span>]</span></span><br></pre></td></tr></table></figure><p>第二步：使用Docker Compose，创建docker-compose.yml文件来编排服务容器</p><figure class="highlight yaml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">user-service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3001:3001"</span></span><br><span class="line">  <span class="attr">order-service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3002:3002"</span></span><br><span class="line">  <span class="attr">api-gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./api-gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br></pre></td></tr></table></figure><p>第三步：启动所有服务</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务是一种软件架构风格，在这种架构中，应用程序被构建为一组小的、独立的服务，每个服务负责处理特定的业务功能。这些服务可以独立开发、部署和扩展，并通过轻量级的通信机制（通常是 HTTP API）进行互相通信。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Kubernetes(K8s)学习笔记</title>
    <link href="https://herotiga.github.io/2024/08/30/kubernetes-k8s-notes/"/>
    <id>https://herotiga.github.io/2024/08/30/kubernetes-k8s-notes/</id>
    <published>2024-08-30T07:47:19.000Z</published>
    <updated>2024-08-30T15:02:16.970Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes(K8s)用于自动化部署、扩展和管理容器化应用程序。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>一个独立的、轻量级的可运行的包，包含应用程序和它的所有依赖。</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是K8s中的最小部署单位，他可以包含一个或者多个容器。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node就是K8s集群中的一台机器，可以包含一个或者多个Pod。</p><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>Cluster就是由多个Node组成的集群。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service为一组Pod提供持久的IP地址和负载均衡功能，使得Pod可以稳定的被外部访问。</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace是K8s中的逻辑隔离单元，用于将集群中的资源划分到不同的虚拟子集。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment定义应用程序的部署方式和策略，支持滚动更新和回滚操作。</p><h2 id="安装K8s"><a href="#安装K8s" class="headerlink" title="安装K8s"></a>安装K8s</h2><h3 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h3><p>Minikube是本地的K8s集群，用于开发和测试。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Minikube</span></span><br><span class="line">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Minikube</span></span><br><span class="line">minikube start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Minikube状态</span></span><br><span class="line">minikube status</span><br></pre></td></tr></table></figure><h3 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h3><p>kubectl是用于管理集群的命令行工具。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装kubectl</span></span><br><span class="line">curl -LO <span class="string">"https://dl.k8s.io/release/<span class="variable">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl"</span></span><br><span class="line">chmod +x kubectl</span><br><span class="line">sudo mv kubectl /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line">kubectl version --client</span><br></pre></td></tr></table></figure><h2 id="创建K8s部署（Deployment）"><a href="#创建K8s部署（Deployment）" class="headerlink" title="创建K8s部署（Deployment）"></a>创建K8s部署（Deployment）</h2><p>创建Deployment：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个nginx部署</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建的Deployment和Pod</span></span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>暴露服务：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对外暴露nginx部署</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=NodePort --port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看部署的服务信息</span></span><br><span class="line">kubectl get service nginx</span><br><span class="line">kubectl get services</span><br><span class="line">minikube service nginx --url</span><br></pre></td></tr></table></figure><h2 id="扩展和更新"><a href="#扩展和更新" class="headerlink" title="扩展和更新"></a>扩展和更新</h2><h3 id="扩展Pod副本数"><a href="#扩展Pod副本数" class="headerlink" title="扩展Pod副本数"></a>扩展Pod副本数</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment nginx --replicas=3</span><br></pre></td></tr></table></figure><h3 id="更新容器镜像"><a href="#更新容器镜像" class="headerlink" title="更新容器镜像"></a>更新容器镜像</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment/nginx nginx=nginx:1.19</span><br></pre></td></tr></table></figure><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx</span><br></pre></td></tr></table></figure><h3 id="删除服务和部署"><a href="#删除服务和部署" class="headerlink" title="删除服务和部署"></a>删除服务和部署</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete service nginx</span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes(K8s)用于自动化部署、扩展和管理容器化应用程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://herotiga.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="https://herotiga.github.io/2024/08/30/docker-notes/"/>
    <id>https://herotiga.github.io/2024/08/30/docker-notes/</id>
    <published>2024-08-30T07:00:57.000Z</published>
    <updated>2024-09-04T14:16:30.342Z</updated>
    
    <content type="html"><![CDATA[<p><code>Docker</code>是容器化平台，可以构建、打包、部署和运行应用程序。</p><p>Docker可以将应用程序及依赖打包成一个轻量级的便于移植的容器，然后部署到支持Docker的平台。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参照官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>Docker镜像是一个只读的模板，包含了创建Docker容器的指令。</p><p>还可以基于一个镜像来创建另一个镜像并在此基础上添加一些自定义配置。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>Docker容器是一个独立的环境，它基于Docker镜像创建而来，Docker容器是镜像的实例，容器包含了应用程序及其运行时。</p><p>容器之间是相互隔离的，每个容器都有自己的文件系统。可以将容器看作是轻量的、便于移植的虚拟机。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile是一个文本文件，包含了一系列指令，他告诉Docker如何构建镜像。</p><h3 id="Docker-Volume"><a href="#Docker-Volume" class="headerlink" title="Docker Volume"></a>Docker Volume</h3><p>Docker Volume是Docker提供的持久化存储机制。</p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>Docker Hub是一个存储Docker镜像的公共仓库，可以上传或者下载镜像。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker版本</span></span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull &lt;image_name&gt;</span><br><span class="line"><span class="comment"># 例如：拉取最新的Ubuntu镜像</span></span><br><span class="line">docker pull ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -it --name &lt;container_name&gt; &lt;image_name&gt;</span><br><span class="line"><span class="comment"># 例如：运行一个基于Ubuntu的容器</span></span><br><span class="line">docker run -it --name my_ubuntu ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop &lt;container_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start &lt;container_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入运行中的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container_name&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm &lt;container_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>在项目目录下创建一个Dockerfile来创建镜像。</p><p>Dockerfile：</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的Node.js镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制项目文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用程序的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"app.js"</span>]</span></span><br></pre></td></tr></table></figure><p>带有TypeScript编译阶段的Dockerfile：</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建阶段</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span> AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设项目使用 TypeScript，首先编译</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产阶段</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/package*.json ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/dist ./dist</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/node_modules ./node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"dist/app.js"</span>]</span></span><br></pre></td></tr></table></figure><p>那么，上面的<code>RUN</code>和<code>CMD</code>有什么区别？</p><p>RUN是在image文件的构建阶段执行的，CMD是在容器启动后执行的。<br>一个Dockerfile可以包含多个RUN，但是只能包含一个CMD。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .代表Dockerfile所在目录</span></span><br><span class="line">docker build -t my-node-app .</span><br></pre></td></tr></table></figure><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地的3000端口映射到容器的3000端口</span></span><br><span class="line">docker run -p 3000:3000 my-node-app</span><br></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>比如对于数据库容器，每次部署数据库容器都会删除原来的容器，故而容器内的数据也会被删除。</p><p>可以将数据库的数据目录挂载到主机的一个目录（或者说映射），这样就不会在部署新容器后丢失数据。</p><p><img src="https://gcore.jsdelivr.net/gh/herotiga/cdn@master/img/article/docker-volume.webp" alt="Docker Volume"></p><h3 id="使用Docker-Volume"><a href="#使用Docker-Volume" class="headerlink" title="使用Docker Volume"></a>使用Docker Volume</h3><ol><li>创建Docker Volume</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create mysql_data</span><br></pre></td></tr></table></figure><ol start="2"><li>启动MySQL并挂载Volume到容器内目录</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将mysql_data这个卷挂载到容器内的/var/lib/mysql，这个目录是MySQL数据库默认的存储位置</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=my-secret-pw \</span><br><span class="line">  -v mysql_data:/var/lib/mysql \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure><h3 id="使用主机目录挂载"><a href="#使用主机目录挂载" class="headerlink" title="使用主机目录挂载"></a>使用主机目录挂载</h3><p>还可以直接将主机上的一个目录挂载到容器的MySQL数据存储目录。</p><ol><li>创建主机目录</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /my/mysql_data</span><br></pre></td></tr></table></figure><ol start="2"><li>启动MySQL容器并挂载目录</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=my-secret-pw \</span><br><span class="line">  -v /my/own/datadir:/var/lib/mysql \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose是一个用于定义和管理多容器Docker应用的工具。也可以使用k8s管理Docker容器。</p><p>可以使用<code>docker-compose.yml</code>文件来定义应用的服务、网络和卷等。</p><figure class="highlight yml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-node-app</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br></pre></td></tr></table></figure><p>构建并启动<code>docker-compose.yml</code>中的所有服务：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line">docker-compose up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止应用</span></span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.docker.com/">https://www.docker.com/</a></li><li><a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;是容器化平台，可以构建、打包、部署和运行应用程序。&lt;/p&gt;
&lt;p&gt;Docker可以将应用程序及依赖打包成一个轻量级的便于移植的容器，然后部署到支持Docker的平台。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://herotiga.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js开发笔记——Mongoose（ODM库）</title>
    <link href="https://herotiga.github.io/2024/08/29/nodejs-odm-mongoose/"/>
    <id>https://herotiga.github.io/2024/08/29/nodejs-odm-mongoose/</id>
    <published>2024-08-29T10:40:32.000Z</published>
    <updated>2024-08-30T06:33:32.757Z</updated>
    
    <content type="html"><![CDATA[<p><code>Mongoose</code>是 Node.js的ODM库。</p><p>和Sequelize类似，Mongoose提供了node.js对于MongoDB进行操作的便利。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S mongoose</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>连接MongoDB</li></ol><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"></span><br><span class="line">mongoose</span><br><span class="line">  .connect(<span class="string">"mongodb://localhost:27017/mydatabase"</span>, &#123;</span><br><span class="line">    useNewUrlParser: <span class="literal">true</span>,</span><br><span class="line">    useUnifiedTopology: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Connected to MongoDB"</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(<span class="string">"Could not connect to MongoDB..."</span>, err));</span><br></pre></td></tr></table></figure><ol start="2"><li>定义Schema</li></ol><p>Mongoose中使用Schema来定义文档结构。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    age: <span class="built_in">Number</span>,</span><br><span class="line">    email: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">unique</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    created_at: &#123; <span class="attr">type</span>: <span class="built_in">Date</span>, <span class="attr">default</span>: <span class="built_in">Date</span>.now &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>创建模型Model</li></ol><p>使用以上创建好的Schema来创建模型Model。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>, userSchema);</span><br></pre></td></tr></table></figure><ol start="4"><li>创建和保存</li></ol><p>使用上面创建好的Model可以对数据进行CRUD。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建user记录</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">    name: <span class="string">'John Doe'</span>,</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">    email: <span class="string">'johndoe@example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存user记录</span></span><br><span class="line">user.save()</span><br><span class="line">    .then(<span class="function"><span class="params">doc</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User saved:'</span>, doc))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error saving user:'</span>, err));</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭连接</li></ol><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connection.close();</span><br></pre></td></tr></table></figure><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><ul><li>Create</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">    name: <span class="string">'John Doe'</span>,</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">    email: <span class="string">'johndoe@example.com'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Read</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.findOne(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User found:'</span>, user))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error finding user:'</span>, err));</span><br><span class="line"></span><br><span class="line">User.find(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Users found:'</span>, users))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error finding users:'</span>, err));</span><br></pre></td></tr></table></figure><ul><li>Update</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User.updateOne(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">31</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User updated:'</span>, result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error updating user:'</span>, err));</span><br><span class="line"></span><br><span class="line">User.updateMany(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">31</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User updated:'</span>, result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error updating user:'</span>, err));</span><br><span class="line"></span><br><span class="line">User.findByIdAndUpdate(userId, &#123; <span class="attr">age</span>: <span class="number">27</span> &#125;, &#123; <span class="attr">new</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Updated user:'</span>, user))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error updating user:'</span>, err));</span><br></pre></td></tr></table></figure><ul><li>Delete</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.deleteOne(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User deleted:'</span>, result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error deleting user:'</span>, err));</span><br><span class="line"></span><br><span class="line">User.findByIdAndDelete(userId)</span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Deleted user:'</span>, user))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error deleting user:'</span>, err));</span><br></pre></td></tr></table></figure><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Mongoose还支持使用中间件（middleware）来执行一些预处理或后处理操作。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在保存之前执行一些代码</span></span><br><span class="line">userSchema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Before saving a user'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mongoosejs.net/">https://mongoosejs.net/</a></li><li><a href="https://mongoosejs.com/">https://mongoosejs.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Mongoose&lt;/code&gt;是 Node.js的ODM库。&lt;/p&gt;
&lt;p&gt;和Sequelize类似，Mongoose提供了node.js对于MongoDB进行操作的便利。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js开发笔记——Sequelize（ORM库）</title>
    <link href="https://herotiga.github.io/2024/08/29/nodejs-orm-sequelize/"/>
    <id>https://herotiga.github.io/2024/08/29/nodejs-orm-sequelize/</id>
    <published>2024-08-29T02:37:10.000Z</published>
    <updated>2024-08-29T11:07:46.533Z</updated>
    
    <content type="html"><![CDATA[<p>在 Node.js 项目中可以使用<code>Sequelize</code>这个<code>ORM</code>（对象关系映射）库来将项目中的 Model 和数据库表进行映射以及可以让我们可以使用 JavaScript 的对象和方法来操作数据库（CRUD），而不必编写原生 SQL 语句。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-Sequelize"><a href="#安装-Sequelize" class="headerlink" title="安装 Sequelize"></a>安装 Sequelize</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S sequelize</span><br></pre></td></tr></table></figure><h3 id="安装对应数据库驱动"><a href="#安装对应数据库驱动" class="headerlink" title="安装对应数据库驱动"></a>安装对应数据库驱动</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装MySQL驱动</span></span><br><span class="line">npm install -S mysql2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装PostgreSQL驱动</span></span><br><span class="line">npm install -S pg pg-hstore</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装SQLite驱动</span></span><br><span class="line">npm install -S sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装MSSQL驱动</span></span><br><span class="line">npm install -S tedious</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装MariaDB驱动</span></span><br><span class="line">npm install -S mariadb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Oracle数据库驱动</span></span><br><span class="line">npm install -S oracledb</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Sequelize提供的大多数方法都是异步的，会返回<code>Promise</code>，所以可以使用Promise API。</p><h3 id="创建-Sequelize-实例"><a href="#创建-Sequelize-实例" class="headerlink" title="创建 Sequelize 实例"></a>创建 Sequelize 实例</h3><p>创建一个Sequelize实例并连接到数据库：</p><figure class="highlight js"><figcaption><span>models/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Sequelize &#125; = <span class="built_in">require</span>(<span class="string">"sequelize"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Sequelize实例，连接到MySQL数据库</span></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">"database_name"</span>, <span class="string">"username"</span>, <span class="string">"password"</span>, &#123;</span><br><span class="line">  host: <span class="string">"localhost"</span>,</span><br><span class="line">  dialect: <span class="string">"mysql"</span>, <span class="comment">// 选择数据库类型：'mysql' | 'postgres' | 'sqlite' | 'mssql'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试连接是否成功</span></span><br><span class="line">sequelize</span><br><span class="line">  .authenticate()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Connection has been established successfully."</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Unable to connect to the database:"</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出Sequelize实例变量</span></span><br><span class="line"><span class="built_in">module</span>.exports = sequelize;</span><br></pre></td></tr></table></figure><h3 id="定义模型（Model）"><a href="#定义模型（Model）" class="headerlink" title="定义模型（Model）"></a>定义模型（Model）</h3><p>在 Sequelize 中，模型代表数据库中的表。<br>可以通过定义模型来映射数据库表及其字段。</p><figure class="highlight js"><figcaption><span>models/user.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; DataTypes &#125; = <span class="built_in">require</span>(<span class="string">"sequelize"</span>);</span><br><span class="line"><span class="comment">// 引入前面创建的 Sequelize 实例</span></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="built_in">require</span>(<span class="string">"./index"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义User模型</span></span><br><span class="line"><span class="keyword">const</span> User = sequelize.define(</span><br><span class="line">  <span class="string">"User"</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">      unique: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    email: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">      unique: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    tableName: <span class="string">"users"</span>, <span class="comment">// 自定义表名，如果不指定，Sequelize 会自动将模型名转换为复数形式作为表名</span></span><br><span class="line">    timestamps: <span class="literal">true</span>, <span class="comment">// 自动添加 createdAt 和 updatedAt 字段</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = User;</span><br></pre></td></tr></table></figure><h3 id="同步模型与数据库"><a href="#同步模型与数据库" class="headerlink" title="同步模型与数据库"></a>同步模型与数据库</h3><p>在项目启动时同步模型和数据库。</p><p>在项目入口 js 文件中添加：</p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelize = <span class="built_in">require</span>(<span class="string">"./models/index"</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">"./models/user"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步模型</span></span><br><span class="line">sequelize</span><br><span class="line">  .sync(&#123; <span class="attr">force</span>: <span class="literal">false</span> &#125;) <span class="comment">// &#123; force: true &#125; 会先删除表然后重新创建（慎用）</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Database &amp; tables created!"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to sync database:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h3><p>可以调用模型的 CRUD 方法操作数据库。</p><ul><li>Create</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User.create(&#123;</span><br><span class="line">  username: <span class="string">"john_doe"</span>,</span><br><span class="line">  password: <span class="string">"secret123"</span>,</span><br><span class="line">  email: <span class="string">"john@example.com"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"User created:"</span>, user.toJSON());</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to create user:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>Read</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">User.findOne(&#123; <span class="attr">where</span>: &#123; <span class="attr">username</span>: <span class="string">"john_doe"</span> &#125; &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"User found:"</span>, user.toJSON());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"User not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to find user:"</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">User.findAll()</span><br><span class="line">  .then(<span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"All users:"</span>, <span class="built_in">JSON</span>.stringify(users, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to find users:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>Update</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.update(&#123; <span class="attr">password</span>: <span class="string">"newpassword123"</span> &#125;, &#123; <span class="attr">where</span>: &#123; <span class="attr">username</span>: <span class="string">"john_doe"</span> &#125; &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">rowsUpdated</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Number of rows updated:"</span>, rowsUpdated);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to update user:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>Delete</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.destroy(&#123; <span class="attr">where</span>: &#123; <span class="attr">username</span>: <span class="string">"john_doe"</span> &#125; &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">rowsDeleted</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Number of rows deleted:"</span>, rowsDeleted);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to delete user:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>默认情况下，Sequelize将记录控制台执行的每个SQL查询。可以使用<code>options.logging</code>参数来自定义每次 Sequelize记录某些内容时将执行的函数。默认值为<code>console.log</code>，使用该值时仅显示日志函数调用的第一个参数。例如，对于查询日志记录，第一个参数是原始查询，第二个参数(默认情况下是隐藏的)是Sequelize对象。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">'sqlite::memory:'</span>, &#123;</span><br><span class="line">  <span class="comment">// 选择一种日志记录参数</span></span><br><span class="line">  logging: <span class="built_in">console</span>.log,                  <span class="comment">// 默认值,显示日志函数调用的第一个参数</span></span><br><span class="line">  logging: <span class="function">(<span class="params">...msg</span>) =&gt;</span> <span class="built_in">console</span>.log(msg), <span class="comment">// 显示所有日志函数调用参数</span></span><br><span class="line">  logging: <span class="literal">false</span>,                        <span class="comment">// 禁用日志记录</span></span><br><span class="line">  logging: <span class="function"><span class="params">msg</span> =&gt;</span> logger.debug(msg),     <span class="comment">// 使用自定义记录器(例如Winston 或 Bunyan),显示第一个参数</span></span><br><span class="line">  logging: logger.debug.bind(logger)     <span class="comment">// 使用自定义记录器的另一种方法,显示所有消息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="关系映射"><a href="#关系映射" class="headerlink" title="关系映射"></a>关系映射</h3><p>Sequelize 支持定义表之间的关系（一对一、一对多、多对多）。</p><p>定义<code>User</code>和<code>Post</code>之间为一对多的关系：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Post = sequelize.define(<span class="string">"Post"</span>, &#123;</span><br><span class="line">  title: DataTypes.STRING,</span><br><span class="line">  content: DataTypes.TEXT,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对多关系：一个用户可以有多个帖子</span></span><br><span class="line">User.hasMany(Post);</span><br><span class="line">Post.belongsTo(User);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在同步时，Sequelize 会自动设置外键</span></span><br><span class="line">sequelize.sync();</span><br></pre></td></tr></table></figure><h3 id="查询生成器"><a href="#查询生成器" class="headerlink" title="查询生成器"></a>查询生成器</h3><p>Sequelize 支持复杂的查询构建与聚合操作，可以轻松实现分页、排序、分组等操作。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User.findAll(&#123;</span><br><span class="line">  where: &#123; <span class="attr">email</span>: &#123; [Op.like]: <span class="string">"%@example.com"</span> &#125; &#125;,</span><br><span class="line">  order: [[<span class="string">"createdAt"</span>, <span class="string">"DESC"</span>]],</span><br><span class="line">  limit: <span class="number">10</span>,</span><br><span class="line">  offset: <span class="number">20</span>,</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Paged users:"</span>, <span class="built_in">JSON</span>.stringify(users, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to retrieve users:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="事务处理（Transactions）"><a href="#事务处理（Transactions）" class="headerlink" title="事务处理（Transactions）"></a>事务处理（Transactions）</h3><p>通过<code>sequelize.transaction()</code>来管理事务，确保操作的原子性。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sequelize</span><br><span class="line">  .transaction(<span class="keyword">async</span> (t) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.create(</span><br><span class="line">      &#123;</span><br><span class="line">        username: <span class="string">"jane_doe"</span>,</span><br><span class="line">        password: <span class="string">"password123"</span>,</span><br><span class="line">        email: <span class="string">"jane@example.com"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">transaction</span>: t &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Post.create(</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">"Jane's first post"</span>,</span><br><span class="line">        content: <span class="string">"This is Jane's first post"</span>,</span><br><span class="line">        userId: user.id,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">transaction</span>: t &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Transaction has been committed"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Transaction has been rolled back:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="验证与钩子（Hooks）"><a href="#验证与钩子（Hooks）" class="headerlink" title="验证与钩子（Hooks）"></a>验证与钩子（Hooks）</h3><p>Sequelize 提供内置的验证机制，并允许你定义生命周期钩子，在模型操作前后执行代码。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = sequelize.define(</span><br><span class="line">  <span class="string">"User"</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">      unique: <span class="literal">true</span>,</span><br><span class="line">      validate: &#123;</span><br><span class="line">        len: [<span class="number">4</span>, <span class="number">20</span>], <span class="comment">// 验证用户名长度在 4 到 20 个字符之间</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    hooks: &#123;</span><br><span class="line">      beforeCreate: <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在创建用户前对密码进行哈希处理</span></span><br><span class="line">        user.password = hashPassword(user.password);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="配置与环境变量"><a href="#配置与环境变量" class="headerlink" title="配置与环境变量"></a>配置与环境变量</h3><p>可以通过环境变量或配置文件管理不同环境下的数据库连接配置：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(</span><br><span class="line">  process.env.DB_NAME,</span><br><span class="line">  process.env.DB_USER,</span><br><span class="line">  process.env.DB_PASSWORD,</span><br><span class="line">  &#123;</span><br><span class="line">    host: process.env.DB_HOST,</span><br><span class="line">    dialect: <span class="string">"mysql"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="迁移与种子数据"><a href="#迁移与种子数据" class="headerlink" title="迁移与种子数据"></a>迁移与种子数据</h3><p>Sequelize CLI工具支持数据库迁移和种子数据管理。可以通过命令行生成和应用迁移来管理数据库的演进。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize-cli init</span><br><span class="line">npx sequelize-cli model:generate --name User --attributes username:string,email:string</span><br><span class="line">npx sequelize-cli db:migrate</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.sequelize.cn/">https://www.sequelize.cn/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Node.js 项目中可以使用&lt;code&gt;Sequelize&lt;/code&gt;这个&lt;code&gt;ORM&lt;/code&gt;（对象关系映射）库来将项目中的 Model 和数据库表进行映射以及可以让我们可以使用 JavaScript 的对象和方法来操作数据库（CRUD），而不必编写原生 SQL 语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Tree-Shaking是什么？</title>
    <link href="https://herotiga.github.io/2024/08/26/Tree-Shaking/"/>
    <id>https://herotiga.github.io/2024/08/26/Tree-Shaking/</id>
    <published>2024-08-25T16:39:48.000Z</published>
    <updated>2024-08-27T01:38:43.592Z</updated>
    
    <content type="html"><![CDATA[<p><code>Tree-Shaking</code>是一种代码优化技术，其通过删除未使用的代码来减少最终打包出来的文件的大小，从而提高程序的加载速度和性能。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在webpack5的<code>production</code>环境中默认开启了Tree-Shaking功能，也就是build出来的代码会删除无用的代码。</p><p>无用的代码包括下面几类：</p><ul><li>不可能执行的代码</li><li>定义了但是没有引用的变量</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.webpackjs.com/guides/tree-shaking/#root">https://www.webpackjs.com/guides/tree-shaking/#root</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Tree-Shaking&lt;/code&gt;是一种代码优化技术，其通过删除未使用的代码来减少最终打包出来的文件的大小，从而提高程序的加载速度和性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="https://herotiga.github.io/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>Android开发笔记</title>
    <link href="https://herotiga.github.io/2024/07/08/Android-notes/"/>
    <id>https://herotiga.github.io/2024/07/08/Android-notes/</id>
    <published>2024-07-08T06:38:53.000Z</published>
    <updated>2024-09-02T17:09:52.149Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发笔记</p><a id="more"></a><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>阅读Java文档。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>阅读Kotlin文档。</p><h2 id="Android应用结构和基本组件"><a href="#Android应用结构和基本组件" class="headerlink" title="Android应用结构和基本组件"></a>Android应用结构和基本组件</h2><p>包括四大基本组件Activity、Service、BroadcastReceiver、ContentProvider以及Fragment、Intent、View、Layout、Resources、Manifest等。</p><p>可以查看Android官方文档学习。</p><h2 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h2><p>包括官方文档和Material Design。</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>包括SharedPreferences、读写文件、SQLite本地数据库、Room持久库。</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>包括Retrofit和Volley等库。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>包括内存管理、电池优化、响应速度优化等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android开发笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://herotiga.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Learning MongoDB</title>
    <link href="https://herotiga.github.io/2024/06/28/MongoDB-notes/"/>
    <id>https://herotiga.github.io/2024/06/28/MongoDB-notes/</id>
    <published>2024-06-28T14:17:15.000Z</published>
    <updated>2024-08-25T10:40:15.912Z</updated>
    
    <content type="html"><![CDATA[<p><code>MongoDB</code> is a type of NoSQL database suitable for storing large-scale data.</p><p>MongoDB is a document based database, the data is stored in a JSON-like document format.</p><p>MongoDB uses Collections to organize documents, and each document is composed of key-value pairs.</p><a id="more"></a><h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><ol><li><p>Database: A container for storing data, similar to a database in relational database.</p></li><li><p>Collection: A collection in database, similar to a table in relational database.</p></li><li><p>Document: A data record in a collection, similar to a row in relational database, stored in BSON format.</p></li></ol><article class="message is-info"><div class="message-body"><p>MongoDB stores data as a document, with a data structure consisting of key-value pairs. The document is similar to a JSON object, and field values can contain other documents, arrays, and document arrays.</p></div></article><p>mapping:</p><table><thead><tr><th>SQL Concept</th><th>MongoDB Concept</th><th>Remark</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>database</td></tr><tr><td>table</td><td>collection</td><td>databse table/collection</td></tr><tr><td>row</td><td>document</td><td>data record</td></tr><tr><td>column</td><td>field</td><td>data field</td></tr><tr><td>index</td><td>index</td><td>index</td></tr><tr><td>table joins</td><td></td><td>MongoDB not supported</td></tr><tr><td>primary key</td><td>primary key</td><td>MongoDB will set _id to primary key</td></tr></tbody></table><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install community edition</span></span><br><span class="line">brew install mongodb-community</span><br><span class="line"></span><br><span class="line"><span class="comment"># start on startup</span></span><br><span class="line">brew services start mongodb-community</span><br></pre></td></tr></table></figure><h2 id="MongoDB-Shell"><a href="#MongoDB-Shell" class="headerlink" title="MongoDB Shell"></a>MongoDB Shell</h2><article class="message is-info"><div class="message-body"><p>MongoDB Shell is a interactive interface provided by official, allowing users to interact with the MongoDB database, execute commands, and operate the database.</p><p>The MongoDB Shell is based on JavaScript and allows users to operate the MongoDB database directly from the command line or within scripts using the JavaScript language.</p></div></article><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start mongo shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># in older versions</span></span><br><span class="line">mongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># in the new version</span></span><br><span class="line">mongosh</span><br><span class="line"></span><br><span class="line"><span class="comment"># connect to a remote mongodb server</span></span><br><span class="line">mongosh --host &lt;hostname&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure><h2 id="Basic-Operations"><a href="#Basic-Operations" class="headerlink" title="Basic Operations"></a>Basic Operations</h2><figure class="highlight bash"><figcaption><span>mongosh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show current database</span></span><br><span class="line">db;</span><br><span class="line"></span><br><span class="line"><span class="comment"># show database list</span></span><br><span class="line">show dbs;</span><br><span class="line"></span><br><span class="line"><span class="comment"># switch to the specified database</span></span><br><span class="line">use &lt;db_name&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute query operation</span></span><br><span class="line">db.&lt;collection_name&gt;.find();</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert a document</span></span><br><span class="line">db.&lt;collection_name&gt;.insertOne(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># update a document</span></span><br><span class="line">db.&lt;collection_name&gt;.updateOne(&#123;...&#125;, &#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete a document</span></span><br><span class="line">db.&lt;collection_name&gt;.deleteOne(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit shell</span></span><br><span class="line">quit()</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="MongoDB-Tools"><a href="#MongoDB-Tools" class="headerlink" title="MongoDB Tools"></a>MongoDB Tools</h2><ol><li>MongoDB Compass: A free GUI tool.</li><li>Navicat: A paid GUI tool.</li><li>Studio 3T: A paid GUI tool, with a good CRUD operations experience.</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.mongodb.com/docs/manual/introduction/">https://www.mongodb.com/docs/manual/introduction/</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;MongoDB&lt;/code&gt; is a type of NoSQL database suitable for storing large-scale data.&lt;/p&gt;
&lt;p&gt;MongoDB is a document based database, the data is stored in a JSON-like document format.&lt;/p&gt;
&lt;p&gt;MongoDB uses Collections to organize documents, and each document is composed of key-value pairs.&lt;/p&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="https://herotiga.github.io/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js开发笔记——EventEmitter</title>
    <link href="https://herotiga.github.io/2024/06/03/EventEmitter/"/>
    <id>https://herotiga.github.io/2024/06/03/EventEmitter/</id>
    <published>2024-06-03T05:23:20.000Z</published>
    <updated>2024-08-25T17:09:09.075Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js使用的是事件驱动模型。</p><p>可以通过<code>EventEmitter</code>来实现事件的监听和触发，Node.js中其他的异步API也都是通过继承EventEmitter实现的。</p><a id="more"></a><h2 id="addListener-removeListener"><a href="#addListener-removeListener" class="headerlink" title="addListener/removeListener"></a>addListener/removeListener</h2><p>为指定的事件添加一个监听器，可以为同一个事件添加多个监听器。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> events = <span class="built_in">require</span>(<span class="string">'node:events'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建EventEmitter实例</span></span><br><span class="line"><span class="keyword">const</span> ee = <span class="keyword">new</span> events.EventEmitter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为同一个事件添加多个监听器</span></span><br><span class="line">ee.addListener(<span class="string">'event_name'</span>, handler1)</span><br><span class="line">ee.addListener(<span class="string">'event_name'</span>, handler2)</span><br><span class="line">ee.addListener(<span class="string">'event_name'</span>, handler3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件上指定的监听器</span></span><br><span class="line">ee.removeListener(<span class="string">'event_name'</span>, handler1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件上所有的监听器</span></span><br><span class="line">ee.removeAllListener(<span class="string">'event_name'</span>)</span><br></pre></td></tr></table></figure><h2 id="on-emit"><a href="#on-emit" class="headerlink" title="on/emit"></a>on/emit</h2><p>on方法和addListener是一样的，on是简写。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听事件，可以接受参数</span></span><br><span class="line">ee.on(<span class="string">'event_name'</span>, (arg1, arg2, ...) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，可以携带参数</span></span><br><span class="line">ee.emit(<span class="string">'event_name'</span>, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><p>可以使用once为事件添加单词监听器，监听器最多只会执行一次。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ee.once(<span class="string">'event_name'</span>, handler)</span><br></pre></td></tr></table></figure><h2 id="setMaxListeners-defaultMaxListeners"><a href="#setMaxListeners-defaultMaxListeners" class="headerlink" title="setMaxListeners/defaultMaxListeners"></a>setMaxListeners/defaultMaxListeners</h2><p>EventEmitter默认限制了给同一个事件最大只能添加10个监听器，使用setMaxListeners可以指定限制数量。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ee.setMaxListeners(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>或者可以直接设置默认最大数量：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为0解除限制</span></span><br><span class="line">ee.defaultMaxListeners = <span class="number">0</span></span><br><span class="line">ee.defaultMaxListeners = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="listeners"><a href="#listeners" class="headerlink" title="listeners"></a>listeners</h2><p>获取指定事件上绑定的所有的监听器。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listeners = ee.listeners(<span class="string">'event_name'</span>)</span><br></pre></td></tr></table></figure><h2 id="newListener事件"><a href="#newListener事件" class="headerlink" title="newListener事件"></a>newListener事件</h2><p>EventEmitter中的特殊事件。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ee.on(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Event name: <span class="subst">$&#123;event&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Listener function: <span class="subst">$&#123;listener&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="removeListener事件"><a href="#removeListener事件" class="headerlink" title="removeListener事件"></a>removeListener事件</h2><p>EventEmitter中的特殊事件。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ee.on(<span class="string">'removeListener'</span>, (event, listener) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Event name: <span class="subst">$&#123;event&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Listener function: <span class="subst">$&#123;listener&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h2><p>EventEmitter中的特殊事件。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ee.on(<span class="string">'error'</span>, (arg1, arg2, ...) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ee.emit(<span class="string">'error'</span>, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>在实际使用时，我们一般通过自定义类继承EventEmitter来实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js使用的是事件驱动模型。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;EventEmitter&lt;/code&gt;来实现事件的监听和触发，Node.js中其他的异步API也都是通过继承EventEmitter实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么计算机无法产生真随机数</title>
    <link href="https://herotiga.github.io/2024/06/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%97%A0%E6%B3%95%E4%BA%A7%E7%94%9F%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>https://herotiga.github.io/2024/06/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%97%A0%E6%B3%95%E4%BA%A7%E7%94%9F%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0/</id>
    <published>2024-06-01T15:28:07.000Z</published>
    <updated>2024-08-25T06:12:24.276Z</updated>
    
    <content type="html"><![CDATA[<p>为什么计算机无法产生真随机数？</p><a id="more"></a><hr><h2 id="为什么计算机只能产生伪随机数"><a href="#为什么计算机只能产生伪随机数" class="headerlink" title="为什么计算机只能产生伪随机数"></a>为什么计算机只能产生伪随机数</h2><p>现有计算机编程语言中产生随机数的算法都是<strong>伪随机数生成器</strong>（PRNG）。</p><h3 id="算法是确定的"><a href="#算法是确定的" class="headerlink" title="算法是确定的"></a>算法是确定的</h3><p>计算机的随机数是由特定算法产生的，然而这些算法是确定的，对于这些算法输入相同的参数就会输出相同的结果。</p><p>故而随机数这个结果是由输入值确定的，所以计算机产生的是<strong>伪随机数</strong>（Pseudo-random Number）。</p><p>一般使用的算法有线性<strong>同余生成器</strong>（LCG）或<strong>梅森旋转器</strong>（Mersenne Twister）。</p><h3 id="算法输出的结果是有限的"><a href="#算法输出的结果是有限的" class="headerlink" title="算法输出的结果是有限的"></a>算法输出的结果是有限的</h3><p>由于计算机存在浮点数精度限制以及数字长度限制，所以输入到算法后输入的随机数也一定是精度有限的和长度有限的。</p><h3 id="种子值决定了算法输出的结果"><a href="#种子值决定了算法输出的结果" class="headerlink" title="种子值决定了算法输出的结果"></a>种子值决定了算法输出的结果</h3><p>伪随机数生成器产生的结果只依赖于种子值和算法，所以如果种子值是可以预测的，那么产生的随机数自然也是可以预测的。</p><hr><h2 id="如何产生真随机数"><a href="#如何产生真随机数" class="headerlink" title="如何产生真随机数"></a>如何产生真随机数</h2><p>获得一个<strong>真随机数生成器</strong>（TRNG）的关键在于如何获得一个不可预测的种子值，那么如何获得一个不可预测的种子值呢？</p><p>计算机作为一个由数字电路构成的二进制电路是高度可预测的，故而计算机本身是无法产生随机的种子值的。</p><p><strong>想要获得不可预测的种子值只能通过随机的物理事件。</strong></p><p>在现有的物理学体系中可以产生随机事件的方式有下面几种：</p><h3 id="热噪声"><a href="#热噪声" class="headerlink" title="热噪声"></a>热噪声</h3><p>热噪声是由导体内电子的热运动引起的随机电流或电压波动。通过测量这些波动，可以产生随机数。<br>例如，一个电阻器或半导体器件在工作时会产生热噪声，通过放大和量化这些信号就可以得到随机数。</p><h3 id="光电二极管噪声"><a href="#光电二极管噪声" class="headerlink" title="光电二极管噪声"></a>光电二极管噪声</h3><p>光电二极管在没有光照的情况下内部任然会有热运动和量子效应产生的噪声，通过放大和量化这些信号可以得到随机数。</p><h3 id="量子力学中的不确定性"><a href="#量子力学中的不确定性" class="headerlink" title="量子力学中的不确定性"></a>量子力学中的不确定性</h3><p>根据海森堡不确定性原理，量子的位置和动量不能同时被精确测量，这两个量是随机的。<br>量子的波函数坍塌是随机的。<br>光量子在通过一个半反半透镜时是反射还是透过是随机的。<br>光量子在通过量子分束器时通过的路径是随机的。</p><h3 id="放射性元素衰变"><a href="#放射性元素衰变" class="headerlink" title="放射性元素衰变"></a>放射性元素衰变</h3><p>放射性元素的衰变间隔是随机的。</p><h3 id="激光相位噪声"><a href="#激光相位噪声" class="headerlink" title="激光相位噪声"></a>激光相位噪声</h3><p>激光产生的光具有内在的量子噪声，通过放大和量化光信号可以得到随机数。</p><h3 id="混沌系统"><a href="#混沌系统" class="headerlink" title="混沌系统"></a>混沌系统</h3><p>作为经典物理学中的最后一朵乌云，混沌系统对于初始条件的微小变化可以导致系统一段时间后具有完全不可预测的特性，可以量化后产生随机数。混沌系统比如湍流、混沌震荡器。</p><p>使用以上随机事件进行量化后作为种子值输入算法即可获取到真随机数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么计算机无法产生真随机数？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://herotiga.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
</feed>
