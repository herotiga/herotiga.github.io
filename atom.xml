<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Typecasting</title>
  
  <subtitle>write some articles about front-end dev,ui design,linux hacking and ai-cv.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://herotiga.github.io/"/>
  <updated>2022-06-03T06:54:55.288Z</updated>
  <id>https://herotiga.github.io/</id>
  
  <author>
    <name>Mason小王子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue中使用Lodash实现防抖和节流</title>
    <link href="https://herotiga.github.io/2022/06/03/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8Lodash%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://herotiga.github.io/2022/06/03/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8Lodash%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2022-06-03T06:50:45.000Z</published>
    <updated>2022-06-03T06:54:55.288Z</updated>
    
    <content type="html"><![CDATA[<p>Lodash实现防抖和节流。</p><a id="more"></a><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>为了实现lodash组件独立，需要在 <code>created</code> 中添加函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">'save-button'</span>, &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="comment">// 使用 Lodash 实现防抖</span></span><br><span class="line">        <span class="keyword">this</span>.debouncedClick = _.debounce(<span class="keyword">this</span>.click, <span class="number">500</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    unmounted() &#123;</span><br><span class="line">        <span class="comment">// 移除组件时，取消定时器</span></span><br><span class="line">        <span class="keyword">this</span>.debouncedClick.cancel()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        click() &#123;</span><br><span class="line">            <span class="comment">// ... 响应点击 ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click="debouncedClick"&gt;</span></span><br><span class="line"><span class="string">      Save</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lodash实现防抖和节流。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue模板表达式中所能访问的全局变量</title>
    <link href="https://herotiga.github.io/2022/06/03/Vue%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E6%89%80%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <id>https://herotiga.github.io/2022/06/03/Vue%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E6%89%80%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</id>
    <published>2022-06-03T06:34:33.000Z</published>
    <updated>2022-06-03T06:48:54.839Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的模板表达式是放在沙盒中的，只能访问一个受限的全局变量列表。</p><p>具体在模板表达式中可以访问到哪些全局变量，如下。</p><a id="more"></a><p>code: <a href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3">https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; makeMap &#125; <span class="keyword">from</span> <span class="string">'./makeMap'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GLOBALS_WHITE_LISTED =</span><br><span class="line">  <span class="string">'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,'</span> +</span><br><span class="line">  <span class="string">'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,'</span> +</span><br><span class="line">  <span class="string">'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isGloballyWhitelisted = <span class="comment">/*#__PURE__*/</span> makeMap(GLOBALS_WHITE_LISTED)</span><br></pre></td></tr></table></figure><p>同时，使用模板时应该遵守一条原则：模板中的表达式不应该有副作用，比如更改数据或者触发异步进程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue的模板表达式是放在沙盒中的，只能访问一个受限的全局变量列表。&lt;/p&gt;
&lt;p&gt;具体在模板表达式中可以访问到哪些全局变量，如下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>JSX语法</title>
    <link href="https://herotiga.github.io/2022/06/02/jsx%E8%AF%AD%E6%B3%95/"/>
    <id>https://herotiga.github.io/2022/06/02/jsx%E8%AF%AD%E6%B3%95/</id>
    <published>2022-06-02T08:40:01.000Z</published>
    <updated>2022-06-02T11:58:11.091Z</updated>
    
    <content type="html"><![CDATA[<p>JSX是JavaScript的扩展语法，react使用JSX代替JavaScript。</p><p>使用JSX需要引入babel。</p><a id="more"></a><h2 id="JSX语法规则"><a href="#JSX语法规则" class="headerlink" title="JSX语法规则"></a>JSX语法规则</h2><ol><li>创建VDOM不能用引号包裹html代码。</li><li>标签中使用<code>{}</code>包裹js表达式。</li><li>用<code>className</code>代替<code>class</code>，用<code>htmlFor</code>代替<code>for</code>。</li><li>标签style属性的值要用两对花括号包裹，花括号中间是属性名:属性值的写法，用逗号隔开。</li><li>只能有一个根标签。</li><li>所有标签都要闭合。</li><li>react对于大写开头的标签会渲染对应的组件，对于正常的html标签不作处理。</li></ol><h2 id="如何创建虚拟DOM（VDOM）"><a href="#如何创建虚拟DOM（VDOM）" class="headerlink" title="如何创建虚拟DOM（VDOM）"></a>如何创建虚拟DOM（VDOM）</h2><p>一般使用JSX创建VDOM。</p><ol><li>使用JSX创建虚拟DOM</li></ol><p>使用babel解析JSX语法。</p><figure class="highlight jsx"><figcaption><span>JSX</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建VDOM</span></span><br><span class="line"><span class="keyword">const</span> VDOM = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;data.id.toLowerCase()&#125;</span>&gt;</span>hello, it's me!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// react渲染VDOM</span></span><br><span class="line">ReactDOM.render(VDOM, <span class="built_in">document</span>.getElementById(<span class="string">"container_id"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载VDOM</span></span><br><span class="line">ReactDOM.unmountComponentAtNode(<span class="built_in">document</span>.getElementById(<span class="string">"container_id"</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li>使用js创建VDOM</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.createElement的三个参数分别是：标签名，标签属性，内容</span></span><br><span class="line"><span class="keyword">const</span> VDOM = React.createElement(<span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">"container_id"</span>&#125;, <span class="string">"hello, it's me!"</span>);</span><br></pre></td></tr></table></figure><h2 id="模块和组件"><a href="#模块和组件" class="headerlink" title="模块和组件"></a>模块和组件</h2><p>react的模块和组件思想和vue一样。</p><p>react组件分为函数式组件和类式组件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSX是JavaScript的扩展语法，react使用JSX代替JavaScript。&lt;/p&gt;
&lt;p&gt;使用JSX需要引入babel。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://herotiga.github.io/categories/react/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue中的updated和$nextTick</title>
    <link href="https://herotiga.github.io/2022/06/02/Vue%E4%B8%AD%E7%9A%84updated%E5%92%8C$nextTick/"/>
    <id>https://herotiga.github.io/2022/06/02/Vue%E4%B8%AD%E7%9A%84updated%E5%92%8C$nextTick/</id>
    <published>2022-06-02T02:31:44.000Z</published>
    <updated>2022-06-02T02:53:36.141Z</updated>
    
    <content type="html"><![CDATA[<p><code>updated</code> 和 <code>$nextTick</code> 的区别是什么？</p><p>网上资料有限，等有时间详细阅读一下官网这部分的文档。</p><a id="more"></a><h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><p>范围：全局</p><p>用途：数据变更导致虚拟dom被重新渲染，updated用于组件被重新渲染后调用。</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>范围：局部</p><p>用途：传入一个回调函数，会在下次dom更新循环之后时执行，一般用于更新了数据之后要立刻获取的情况。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>两者都是在dom更新后用于操作dom或者获取数据。</p><p>不同的是，updated发生在dom渲染后，$nextTick发生在渲染前。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;updated&lt;/code&gt; 和 &lt;code&gt;$nextTick&lt;/code&gt; 的区别是什么？&lt;/p&gt;
&lt;p&gt;网上资料有限，等有时间详细阅读一下官网这部分的文档。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue2和Vue3组件生命周期对比</title>
    <link href="https://herotiga.github.io/2022/06/02/Vue2%E5%92%8CVue3%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AF%B9%E6%AF%94/"/>
    <id>https://herotiga.github.io/2022/06/02/Vue2%E5%92%8CVue3%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AF%B9%E6%AF%94/</id>
    <published>2022-06-02T02:23:13.000Z</published>
    <updated>2022-06-03T06:08:14.682Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的生命周期其实就是Vue从初始化到最终被销毁期间的一系列重要节点。</p><p>可以在生命周期钩子函数中写一写代码执行一些操作。</p><p>Vue3的组件生命周期相比于Vue2发生了以下变化。</p><a id="more"></a><h2 id="Vue2组件生命周期"><a href="#Vue2组件生命周期" class="headerlink" title="Vue2组件生命周期"></a>Vue2组件生命周期</h2><ol><li>beforeCreate():实例在内存中被创建出来，还没有初始化好data和methods属性。</li><li>create():实例已经在内存中创建，已经初始化好data和method，此时还没有开始编译模板。</li><li>beforeMount():已经完成了模板的编译，还没有挂载到页面中。</li><li>mounted()：将编译好的模板挂载到页面指定的容器中显示。</li><li>beforeUpdate():状态更新之前执行函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为还没有开始重新渲染DOM节点。</li><li>updated():此时data中的状态值和界面上显示的数据都已经完成了跟新，界面已经被重新渲染好了！</li><li>beforeDestroy():实例被销毁之前。</li><li>destroyed():实例销毁后调用，Vue实例指示的所有东西都会解绑，所有的事件监听器都会被移除,所有的子实例也都会被销毁。组件已经被完全销毁，此时组建中所有data、methods、以及过滤器，指令等，都已经不可用了。</li></ol><h2 id="Vue3组件生命周期"><a href="#Vue3组件生命周期" class="headerlink" title="Vue3组件生命周期"></a>Vue3组件生命周期</h2><ol><li>setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method</li><li>onBeforeMount() : 组件挂载到节点上之前执行的函数。</li><li>onMounted() : 组件挂载完成后执行的函数。</li><li>onBeforeUpdate(): 组件更新之前执行的函数。</li><li>onUpdated(): 组件更新完成之后执行的函数。</li><li>onBeforeUnmount(): 组件卸载之前执行的函数。</li><li>onUnmounted(): 组件卸载完成后执行的函数</li><li>onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行。</li><li>onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。</li><li>onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。</li></ol><p><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="Vue3生命周期"></p><h2 id="横向对比"><a href="#横向对比" class="headerlink" title="横向对比"></a>横向对比</h2><pre><code>Vue2--------------vue3beforeCreate  -&gt; setup()created       -&gt; setup()beforeMount   -&gt; onBeforeMountmounted       -&gt; onMountedbeforeUpdate  -&gt; onBeforeUpdateupdated       -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed     -&gt; onUnmountedactivated     -&gt; onActivateddeactivated   -&gt; onDeactivatederrorCaptured -&gt; onErrorCaptured</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue的生命周期其实就是Vue从初始化到最终被销毁期间的一系列重要节点。&lt;/p&gt;
&lt;p&gt;可以在生命周期钩子函数中写一写代码执行一些操作。&lt;/p&gt;
&lt;p&gt;Vue3的组件生命周期相比于Vue2发生了以下变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>防止SQL注入</title>
    <link href="https://herotiga.github.io/2022/05/31/%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/"/>
    <id>https://herotiga.github.io/2022/05/31/%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-05-31T12:13:13.000Z</published>
    <updated>2022-05-31T12:24:39.016Z</updated>
    
    <content type="html"><![CDATA[<p>SQL注入是指用户在表单中提交恶意SQL语句企图欺骗后台执行恶意SQL。</p><p>为了防止出现SQL注入，我们假定用户的输入不安全并且需要对用户的输入做处理。</p><a id="more"></a><h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><ol><li>对用户的输入进行校验、限制。</li><li>不要动态拼装SQL。</li><li>不要使用管理员权限操作数据库，做好账号权限划分。</li><li>对于敏感信息进行加密或者hash。</li><li>封装异常返回信息，伪装内部错误信息。</li><li>采用SQL辅助检测工具。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL注入是指用户在表单中提交恶意SQL语句企图欺骗后台执行恶意SQL。&lt;/p&gt;
&lt;p&gt;为了防止出现SQL注入，我们假定用户的输入不安全并且需要对用户的输入做处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://herotiga.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL和NoSQL的区别和优缺点</title>
    <link href="https://herotiga.github.io/2022/05/31/sql-and-nosql/"/>
    <id>https://herotiga.github.io/2022/05/31/sql-and-nosql/</id>
    <published>2022-05-30T23:27:36.000Z</published>
    <updated>2022-05-31T00:04:40.163Z</updated>
    
    <content type="html"><![CDATA[<p>关系型数据库：Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL、MariaDB、Sybase、PostgreSQL、OceanBase、SqLite等。</p><p>非关系型数据库：Cloudant、MongoDB、Redis、HBase、Memcached等。</p><a id="more"></a><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>关系型数据库：建立在关系数据模型的基础上（由一张张二维的表和表之间的关系组成），借助集合代数等运算处理数据，比如使用了选择、投影、连接、并、交、差、除、增删查改等数学方法来实现对数据的存储和查询。可以用SQL语句在一个或者多个table中做复杂的数据查询。</li><li>非关系型数据库：可以是键值对(key, value)、文件、图片等，无需SQL解析，性能非常高，不适合复杂查询，用于超大规模数据的存储。</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ol><li>关系型数据库：易于维护，可以用SQL做复杂的查询，安全性高。读写性能差，高并发读写下磁盘IO大，表结构固定故而不灵活，</li><li>非关系型数据库：性能非常高，数据无耦合，易于横向扩展。不支持SQL，无事务处理，数据结构复杂造成复杂查询较为困难，</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关系型数据库：Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL、MariaDB、Sybase、PostgreSQL、OceanBase、SqLite等。&lt;/p&gt;
&lt;p&gt;非关系型数据库：Cloudant、MongoDB、Redis、HBase、Memcached等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="database" scheme="https://herotiga.github.io/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue组件通信的几种方式</title>
    <link href="https://herotiga.github.io/2022/05/28/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://herotiga.github.io/2022/05/28/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2022-05-28T06:25:49.000Z</published>
    <updated>2022-05-30T07:36:45.167Z</updated>
    
    <content type="html"><![CDATA[<p>组件的数据有三种形态：props，data，computed。</p><p>下面的方法要么是通过某种方法使得组件之间直接通信，要么是使用了第三方作为中转。</p><a id="more"></a><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="props-emit"><a href="#props-emit" class="headerlink" title="props/$emit"></a>props/$emit</h2><p>可以实现父子组件之间的通信。</p><p>父组件通过 <code>props</code> 向子组件传递数据。</p><p>子组件通过 <code>$emit</code> 触发事件向父组件传递数据，父组件通过 <code>v-on</code> 监听这个事件从而获取子组件传递的数据。</p><p>代码省略。</p><h2 id="事件中心"><a href="#事件中心" class="headerlink" title="事件中心"></a>事件中心</h2><p>可以实现任何组件之间的通信。</p><p>通过new一个空的Vue实例作为事件中心，相当于是一个发布订阅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发指定事件并携带数据</span></span><br><span class="line">Event.$emit(eventName, data);</span><br><span class="line"><span class="comment">// 监听指定事件并获取数据</span></span><br><span class="line">Event.$on(eventName, (data) =&gt; &#123;</span><br><span class="line">    <span class="comment">// get data</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>可以实现任何组件之间的通信。</p><ul><li>state存储数据，不能直接操作state，需要通过vuex的方法集操作state。</li><li>组件通过mutations操作state中的数据。</li><li>actions用于异步操作，最终提交mutations操作。</li></ul><p>vuex数据持久化到localStorage。</p><ul><li>将vuex数据持久化到locaStorage前要先<code>JSON.stringify()</code>为字符串。</li><li>将localStorage中的数据取出时要<code>JSON.parse()</code>为数组。</li></ul><h2 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="attrs/listeners"></a>attrs/listeners</h2><p>hexo将标题两个 <code>$</code> 包裹的部分渲染为了数学公式故而没写美元符号。</p><p><code>$attrs</code> 对象：包含了父组件传递了但是子组件props中没有暴露的属性。<br><code>$listeners</code> 对象：存放的是父组件中绑定的非原生事件。</p><h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h2><p>祖父组件通过provide向后代组件传递变量。<br>后代组件通过inject来注入变量。<br>祖父组件provide的变量是不会变动的。</p><p>使用 <code>Vue.observable</code> 可以实现组件组件provide变量改变后，后代组件inject的变量也能响应式的改变呢。</p><h2 id="parent-children-ref"><a href="#parent-children-ref" class="headerlink" title="parent, children, ref"></a>parent, children, ref</h2><p><code>$parent</code> 和 <code>$children</code> 用于访问父子组件实例。</p><p><code>ref</code> 用于普通元素就是指向该DOM，如果用于组件就是指向组件实例，可以直接获取组件实例的所有数据方法。</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ol><li><a href="https://segmentfault.com/a/1190000019208626">https://segmentfault.com/a/1190000019208626</a></li><li><a href="https://vue3js.cn/interview/vue/communication.html">https://vue3js.cn/interview/vue/communication.html</a></li><li><a href="https://www.jianshu.com/p/2e5973fe1223">https://www.jianshu.com/p/2e5973fe1223</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件的数据有三种形态：props，data，computed。&lt;/p&gt;
&lt;p&gt;下面的方法要么是通过某种方法使得组件之间直接通信，要么是使用了第三方作为中转。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue模板的编译原理</title>
    <link href="https://herotiga.github.io/2022/05/26/Vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>https://herotiga.github.io/2022/05/26/Vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-25T23:44:43.000Z</published>
    <updated>2022-05-26T00:55:04.257Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的编译就是将 <code>template</code> 模板转化成 <code>render</code> 函数的过程。</p><p>再通过 <code>render</code> 函数生成最新的vnode，再用vnode去渲染页面。</p><a id="more"></a><p>模板编译过程：</p><ol><li>将模板解析为AST（抽象语法树），可以看做是解析器。</li><li>遍历AST，标记静态节点，可以看做是优化器。</li><li>使用AST生成<code>render</code>函数，可以看做是代码生成器。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue的编译就是将 &lt;code&gt;template&lt;/code&gt; 模板转化成 &lt;code&gt;render&lt;/code&gt; 函数的过程。&lt;/p&gt;
&lt;p&gt;再通过 &lt;code&gt;render&lt;/code&gt; 函数生成最新的vnode，再用vnode去渲染页面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue是如何实现双向数据绑定的</title>
    <link href="https://herotiga.github.io/2022/05/25/Vue%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84/"/>
    <id>https://herotiga.github.io/2022/05/25/Vue%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84/</id>
    <published>2022-05-25T11:13:29.000Z</published>
    <updated>2022-06-02T01:58:33.495Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的双向数据绑定是通过数据劫持+发布订阅实现的。</p><p>其核心是通过 <code>Object.defineProperty()</code> 中的get和set来实现在数据更新时将新数据发送给使用该数据的地方。</p><a id="more"></a><p>具体实现方法是：</p><ol><li>model =&gt; view：在set中将newValue赋值给view。</li><li>view =&gt; model：监听view中数据，将newValue赋值给model。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue的双向数据绑定是通过数据劫持+发布订阅实现的。&lt;/p&gt;
&lt;p&gt;其核心是通过 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 中的get和set来实现在数据更新时将新数据发送给使用该数据的地方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue.js" scheme="https://herotiga.github.io/categories/vue-js/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer-11-旋转数组的最小数字</title>
    <link href="https://herotiga.github.io/2022/05/25/%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://herotiga.github.io/2022/05/25/%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2022-05-25T04:21:30.000Z</published>
    <updated>2022-05-25T04:42:49.906Z</updated>
    
    <content type="html"><![CDATA[<p>难度：简单</p><a id="more"></a><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3, 4, 5, 1, 2] 为 [1, 2, 3, 4, 5] 的一次旋转，该数组的最小值为 1。  </p><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>示例 1：</p><pre><code>输入：numbers = [3, 4, 5, 1, 2]输出：1</code></pre><p>示例 2：</p><pre><code>输入：numbers = [2, 2, 2, 0, 1]输出：0</code></pre><p>提示：</p><ul><li>n == numbers.length</li><li>1 &lt;= n &lt;= 5000</li><li>-5000 &lt;= numbers[i] &lt;= 5000</li><li>numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>遍历数组，直到找到一个index，其元素值小于前面的一个元素值，如果没有则返回第一个元素值。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>看代码</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = numbers.length;</span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &gt; numbers[i + <span class="number">1</span>]) <span class="keyword">return</span> numbers[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = numbers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="built_in">Number</span>.parseInt((right - left) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h2><pre><code>注意：被旋转的数组后半部分最后一个值小于等于前半部分第一个值。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;难度：简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://herotiga.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://herotiga.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>node.js学习笔记（ongoing）</title>
    <link href="https://herotiga.github.io/2022/05/22/nodejs-note/"/>
    <id>https://herotiga.github.io/2022/05/22/nodejs-note/</id>
    <published>2022-05-22T10:49:51.000Z</published>
    <updated>2022-05-30T11:21:13.045Z</updated>
    
    <content type="html"><![CDATA[<p>未整理完毕。</p><a id="more"></a><!-- ## ref1. https://www.runoob.com/nodejs/nodejs-tutorial.html -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;未整理完毕。&lt;/p&gt;
    
    </summary>
    
    
      <category term="node.js" scheme="https://herotiga.github.io/categories/node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>洗牌算法之Knuth-Shuffle算法</title>
    <link href="https://herotiga.github.io/2022/05/12/Knuth-Shuffle/"/>
    <id>https://herotiga.github.io/2022/05/12/Knuth-Shuffle/</id>
    <published>2022-05-12T00:59:10.000Z</published>
    <updated>2022-05-19T10:58:32.613Z</updated>
    
    <content type="html"><![CDATA[<p>看到好多公众号里写的洗牌算法有问题。</p><a id="more"></a><p>比如，最常见的一种是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法的问题在于 <code>Math.random() - 0.5</code> 会导致左边的元素会堆积在左边，右边的元素会堆积在右边，尽管数组在被洗牌后看起来像是被打乱了。</p><p>洗牌算法的核心应该是找到一个映射方法，将数组中原来的元素value随机放置到数组中一个新的index上。</p><h2 id="Knuth-Shuffle算法"><a href="#Knuth-Shuffle算法" class="headerlink" title="Knuth-Shuffle算法"></a>Knuth-Shuffle算法</h2><p>关于Knuth-Shuffle，CSDN等博客基本写的都有问题。</p><p>我的理解如下：</p><ol><li>一个长度为n的数组，设置一个指针rightPos放在最右边。</li><li>随机选取包含该rightPos在内的前n个元素的其中一个元素，将rightPos元素与其交换，这样可以保证rightPos元素有几率留在原位置。</li><li>rightPos左移一位，重复第2步直到rightPos为0。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  改变原数组并返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> len = <span class="keyword">this</span>.length, i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 指针index</span></span><br><span class="line">        <span class="keyword">let</span> rightPos = i;</span><br><span class="line">        <span class="comment">// 随机选取前i+1个元素的index</span></span><br><span class="line">        <span class="keyword">let</span> randomPos = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 交换两个元素</span></span><br><span class="line">        [<span class="keyword">this</span>[randomPos], <span class="keyword">this</span>[rightPos]] = [<span class="keyword">this</span>[rightPos], <span class="keyword">this</span>[randomPos]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].shuffle();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到好多公众号里写的洗牌算法有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://herotiga.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://herotiga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>MySQL架构</title>
    <link href="https://herotiga.github.io/2022/05/05/mysql%E6%9E%B6%E6%9E%84/"/>
    <id>https://herotiga.github.io/2022/05/05/mysql%E6%9E%B6%E6%9E%84/</id>
    <published>2022-05-05T14:54:11.000Z</published>
    <updated>2022-05-30T08:14:59.507Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL架构</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/herotiga/cdn@master/img/article/mysql-arch.jpg" alt="mysql-arch"></p><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>连接池的作用是复用连接，避免频繁 create, destroy。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析器就是解析 SQL 语句。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器会分析 SQL 语句并对其优化。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行器会调用存储引擎的接口来执行 SQL 语句。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL 有多重存储引擎，用于不同场景。</p><ul><li>InnoDB(最常用)</li><li>MyISAM</li><li>Memory</li><li>CSV</li><li>Archive</li><li>Blackhole</li><li>Merge</li><li>Federated</li><li>Example</li></ul><p>存储引擎就是 MySQL 对于内存和磁盘的读写策略。</p><p>InnoDB 包括了：Buffer Pool(数据存储在其中)和 Log Buffer</p><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>MySQL 服务器的内存基本都会分配给 Buffer Pool，可以提升 MySQL 的性能。</p><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>Buffer Pool 以页为单位存储。</p><p>一页包含了：</p><ul><li>上一页，下一页两个指针</li><li>User Record(真正存储信息的地方，是一行一行的数据)</li><li>其余字段</li></ul><p>其余字段包含了：</p><ul><li>Infimum 和 Supremum：此页中最大和最小的记录，用于做初步判断。</li><li>Page Directory：页面目录，用于快速查找记录。</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>InnoDB 底层采用的存储结构是 B 树和 B+树。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新数据时，数据不一定在 buffer pool 中，因为不可能数据库中所有的数据都一直在内存中。</p><p>对于聚簇索引：如果数据不在 buffer pool 中，就会将其先加载到内存中再更新。</p><p>对于非聚簇索引：change buffer。</p><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>MySQL 使用的 LRU 算法的改进版，改进 LRU 算法是为了避免缓冲池污染（先前在 buffer pool 中的页被全部换出去，造成性能下降）</p><h2 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h2><p>用于存储即将被写入到磁盘中的日志。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL架构&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://herotiga.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步编程</title>
    <link href="https://herotiga.github.io/2022/05/05/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://herotiga.github.io/2022/05/05/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-05T12:08:40.000Z</published>
    <updated>2022-06-02T01:03:33.586Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript异步编程的进化历程：callback -&gt; Promise -&gt; Generator -&gt; async/await</p><p>异步的意思是该代码与其他代码的关系是异步执行的，而在该代码自己内部是同步执行的。</p><a id="more"></a><p>js的异步机制：</p><blockquote><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol></blockquote><h2 id="回调函数（callback）"><a href="#回调函数（callback）" class="headerlink" title="回调函数（callback）"></a>回调函数（callback）</h2><p>回调函数是js中常见的异步编程方式，比如定时器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会先执行f1的代码，再将传入的f2作为回调函数执行。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// f1 code</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure><p>除了 <code>setTimeout</code> 之外，还有 <code>XMLHttpRequest</code> 也使用了回调函数编写异步任务。</p><h2 id="事件监听（EventListener）"><a href="#事件监听（EventListener）" class="headerlink" title="事件监听（EventListener）"></a>事件监听（EventListener）</h2><p>比如由f1运行一段任务，任务完成后触发一个事件。<br>f2监听这个事件，监听到了就运行任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给f1绑定事件和触发函数f2</span></span><br><span class="line">f1.on(<span class="string">'event_name'</span>, f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行f1的任务，完成后触发事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// f1 code</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        f1.trigger(<span class="string">'event_name'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布-订阅（publish-subscribe）"><a href="#发布-订阅（publish-subscribe）" class="headerlink" title="发布/订阅（publish/subscribe）"></a>发布/订阅（publish/subscribe）</h2><p>有一个信号中心，生产者发布信号（publish）到信号中心，消费者订阅信号中心的信号（subscribe）。</p><p>消费者还可以取消订阅信号（unsubscribe）。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><code>Promise</code> 可以将回调套娃的代码变为扁平的顺序结构。</p><p>Promise对象的状态只能从pending到resolve或者从pending到reject。</p><p>注意： <code>then()</code> 接受两个参数，第一个参数是resolve时调用的函数，第二个参数是reject时调用的函数。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise的参数是一个函数，这个函数会被异步执行</span></span><br><span class="line"><span class="comment">// Promise中的resolve()和reject()用于向then传递参数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then中可以使用return向后面的then传递参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 捕获异常，前面的运行中有任何异常都会直接跳到这里</span></span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最终运行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>jQuery异步编程API：</p><p>基于Promise的when, then, done, fail</p><p>参考我之前写的：<a href="/2018/09/16/jquery-when-done-then/">jQuery的when, then, done, fail</a></p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p><code>Generator</code> 用于创建迭代器(iterator)。</p><p>关于iterator：</p><ul><li>iterator为不同的可迭代的对象提供统一的访问接口。</li><li>可以按照次序迭代可迭代对象。</li><li>可以用for…of语句迭代。</li><li>iterator内有next方法，next内有value（当前迭代的值）和done（是否迭代完成）属性。</li></ul><p>创建迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用next方法</span></span><br><span class="line">iter.next();</span><br></pre></td></tr></table></figure><p>创建Generator并使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Generator,执行后返回一个iterator对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是一个iterator</span></span><br><span class="line"><span class="keyword">let</span> iter = createGenerator();</span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>Generator可以在运行过程中使用 <code>yield</code> 多次return，故而可以异步编程。</p><p>注意：Generator需要配合 <code>yield</code> 和 <code>*</code> 使用。</p><h2 id="异步函数（async-await）"><a href="#异步函数（async-await）" class="headerlink" title="异步函数（async/await）"></a>异步函数（async/await）</h2><p>async/await是JavaScript异步编程的终极解决方案。</p><p>异步函数的返回值是一个Promise对象。</p><p>在异步函数内部，可以使用 <code>await</code> 命令等待一个Promise对象处理的结果（await也可以等待其他数据类型的字面量），再顺序往下执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"asyncFunction"</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> promiseData = <span class="keyword">await</span> asyncFunction();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"helloAsync"</span>);</span><br><span class="line">&#125;</span><br><span class="line">helloAsync();</span><br><span class="line"><span class="comment">// asyncFunction</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></table></figure><p>e.g.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"3"</span>);</span><br><span class="line"><span class="comment">//打印： 1 2 3 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"3"</span>);</span><br><span class="line"><span class="comment">//打印： 3 1 2</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://www.runoob.com/w3cnote/es6-promise.html">https://www.runoob.com/w3cnote/es6-promise.html</a></li><li><a href="https://www.runoob.com/js/js-promise.html">https://www.runoob.com/js/js-promise.html</a></li><li><a href="https://www.runoob.com/js/js-async.html">https://www.runoob.com/js/js-async.html</a></li><li><a href="https://www.runoob.com/w3cnote/es6-async.html">https://www.runoob.com/w3cnote/es6-async.html</a></li><li><a href="https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html</a></li><li><a href="https://mp.weixin.qq.com/s/tGfC5XVuWXuSbG7wFLuaag">https://mp.weixin.qq.com/s/tGfC5XVuWXuSbG7wFLuaag</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript异步编程的进化历程：callback -&amp;gt; Promise -&amp;gt; Generator -&amp;gt; async/await&lt;/p&gt;
&lt;p&gt;异步的意思是该代码与其他代码的关系是异步执行的，而在该代码自己内部是同步执行的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>列出页面上出现次数前n的标签名</title>
    <link href="https://herotiga.github.io/2022/05/02/%E5%88%97%E5%87%BA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%89%8Dn%E7%9A%84%E6%A0%87%E7%AD%BE%E5%90%8D/"/>
    <id>https://herotiga.github.io/2022/05/02/%E5%88%97%E5%87%BA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%89%8Dn%E7%9A%84%E6%A0%87%E7%AD%BE%E5%90%8D/</id>
    <published>2022-05-02T11:22:01.000Z</published>
    <updated>2022-05-19T10:58:30.968Z</updated>
    
    <content type="html"><![CDATA[<p>使用原生js列出页面上出现次数前n的标签名。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>获取页面上所有标签。</li><li>遍历标签，获取每个标签的标签名，如果第一次出现就置位1否则自增1.</li><li>列出页面上出现次数前n的标签名。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getTopNTagNames = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> doms = <span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>);</span><br><span class="line">    <span class="keyword">let</span> countMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = doms.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tagName = doms[i].tagName.toLowerCase();</span><br><span class="line">        countMap[tagName] ? countMap[tagName]++ : countMap[tagName] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> topN = <span class="built_in">Object</span>.entries(countMap).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b[<span class="number">1</span>] - a[<span class="number">1</span>]).slice(<span class="number">0</span>, n);</span><br><span class="line">    topN.map(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">        arr[index] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> topN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用原生js列出页面上出现次数前n的标签名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>《JavaScript语言精粹》读书笔记</title>
    <link href="https://herotiga.github.io/2022/04/29/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://herotiga.github.io/2022/04/29/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-29T05:53:00.000Z</published>
    <updated>2022-05-19T10:58:32.616Z</updated>
    
    <content type="html"><![CDATA[<p>做点笔记。</p><a id="more"></a><h2 id="精华"><a href="#精华" class="headerlink" title="精华"></a>精华</h2><p>null</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>避免使用<code>/* */</code>来写注释，使用<code>//</code>写注释。</li><li>js不允许获取对象属性的时候使用点运算获取属性名为js保留字的属性。</li><li>超过js数字表示极限的值都会被认为是<code>Infinity</code>。</li><li>字符串不可被改变。</li><li>falsy：<code>false</code>,             <code>null</code>,             <code>undefined</code>,             <code>&#39;&#39;</code>,             <code>0</code>,             <code>NaN</code>。</li><li>truthy：不是以上falsy的都属于truthy。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>对象中的属性名如果不是合法的变量名，则需要用括号包裹。</li><li>对象中的属性名如果是合法的变量名，则可以用<code>.</code>代替<code>[&quot;&quot;]</code>。</li><li>可以使用<code>||</code>给一个默认值。</li><li><code>var a = b = c = {}</code>三个变量都指向同一个对象，<code>var a = {}, b = {}, c = {}</code>三个变量指向不同的对象。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数也是对象，可以被保存在变量、对象、数组中。</li><li>函数也可以作为参数或者返回值。</li><li>一个函数可以定义在另一个函数里，里层函数可以获取外层函数中的局部变量以沟通函数和函数外，称之为闭包。</li><li>调用函数的时候会中断当前执行的函数，将控制权交给新函数并给新函数传参。</li><li>函数出了接受形参，还接受<code>this</code>和<code>arguments</code>这两个参数。</li><li>当函数被保存在对象中的一个属性中时，就叫做对象的方法。</li><li><code>this</code>的指向。</li><li>构造函数首字母大写，并且只能<code>new</code>调用。</li><li><code>arguments</code>其实是一个类数组对象。</li><li>函数总是会有返回值，如果没有指定返回值则返回<code>undefined</code>。</li><li>如果函数被调用时前面有<code>new</code>，且返回值不是对象，则返回<code>this</code>。</li></ul><p>在 <code>Function</code> 原型链上添加一个原型方法method，用于给函数对象添加方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.prototype[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prototype[name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>js没有尾递归优化，深度递归可能栈溢出。</li><li>尾递归：是一种在函数最后执行递归调用语句的特殊形式的递归。</li><li>尽量在文件或者函数顶部申明用到的所有变量。</li><li>回调函数可以异步处理数据。</li><li>级联：将没有<code>return</code>的函数返回<code>this</code>就可以创造级联，也就是链式调用。</li><li>柯里化</li><li>记忆: 存储中间结果来优化算法，比如可以优化斐波那契数列的递归算法。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>不同于其他语言使用类来继承，js使用原型<code>prototype</code>来继承。</li><li>构造函数要以大写开头。</li><li>尽量使用对象而不是参数序列来作为传入的参数。</li></ul><p>这章有些地方没看懂，有时间再看一遍。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>给数组添加非index的属性名不会改变数组的<code>length</code>。</li></ul><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>null</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>null</p><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>null</p><h2 id="优美的特性"><a href="#优美的特性" class="headerlink" title="优美的特性"></a>优美的特性</h2><p>null</p><h2 id="附录A：毒瘤"><a href="#附录A：毒瘤" class="headerlink" title="附录A：毒瘤"></a>附录A：毒瘤</h2><ul><li>全局变量</li><li>作用域</li><li>自动插入分号</li><li>保留字（引用对象中的属性名恰好和保留字一样时需要用<code>obj[&#39;property&#39;]</code>的方式引用）</li><li><code>typeof()</code></li><li><code>parseInt()</code></li><li>浮点数不精确（可以通过先乘以一个数变为整数，运算完了再除回来）</li><li><code>NaN</code></li><li>伪数组</li><li>Falsy</li><li><code>hasOwnProperty()</code></li><li>对象</li></ul><h2 id="附录B：糟粕"><a href="#附录B：糟粕" class="headerlink" title="附录B：糟粕"></a>附录B：糟粕</h2><ul><li>不要用<code>==</code>和<code>!=</code></li><li>不要用<code>with</code></li><li>不要用<code>eval</code>，同理也不应该用<code>Function</code>构造器，也不要给<code>setTimeout</code>和<code>setInterval</code>传字符串参数。</li><li>不要用<code>continue</code></li><li>注意<code>switch</code>穿越</li><li>尽量不用<code>++</code>和<code>--</code></li><li>位运算符在js中实际运行很慢。</li><li>包装对象，不要使用<code>new</code>创建包装对象，直接申明字面量即可。</li><li>使用首字母大写命名构造函数，使用<code>new</code>掉用构造函数。</li><li>不要使用<code>void</code></li></ul><h2 id="附录C：JSLint"><a href="#附录C：JSLint" class="headerlink" title="附录C：JSLint"></a>附录C：JSLint</h2><p>null</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做点笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>python3学习笔记(ongoing)</title>
    <link href="https://herotiga.github.io/2022/04/20/python3-note/"/>
    <id>https://herotiga.github.io/2022/04/20/python3-note/</id>
    <published>2022-04-19T16:19:17.000Z</published>
    <updated>2022-05-19T10:58:32.614Z</updated>
    
    <content type="html"><![CDATA[<p>初学python，不想一上来就直接写helloworld，了解一门语言的发展和语言的特性也是非常重要的，所以笔记会比较详细。</p><p>python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。<br>python具有很强的可读性。<br>python3相对python2是较大的一个升级并且没有考虑向下兼容。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>python是解释型语言</li><li>python是交互式语言</li><li>python是面向对象的语言</li><li>python是初学者的语言</li></ul><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><blockquote><p>Python 2.0 于 2000 年 10 月 16 日发布，增加了实现完整的垃圾回收，并且支持 Unicode。<br>Python 3.0 于 2008 年 12 月 3 日发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性后来也被移植到旧的Python 2.6/2.7版本。<br>Python 3.0 版本，常被称为 Python 3000，或简称 Py3k。相对于 Python 的早期版本，这是一个较大的升级。<br>Python 2.7 被确定为最后一个 Python 2.x 版本，它除了支持 Python 2.x 语法外，还支持部分 Python 3.1 语法。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>易于学习</li><li>易于阅读</li><li>易于维护</li><li>广泛的标准库</li><li>交互模式</li><li>可移植</li><li>可扩展</li><li>数据库</li><li>GUI编程</li><li>可嵌入</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>运行速度较慢</li><li>国内使用较少</li><li>中文文档少</li></ul><h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><ul><li>云计算</li><li>web</li><li>科学计算、人工智能</li><li>运维</li><li>金融</li><li>GUI</li><li>爬虫</li><li>等等还有很多</li></ul><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>查看python版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -V</span><br></pre></td></tr></table></figure><p>可以输入 <code>python3</code> 命令进入交互式编程界面。</p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">print(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure><p>python解释器建议写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br></pre></td></tr></table></figure><p>将上面的代码保存为HelloWorld.py，然后使用python3命令运行。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h3><blockquote><p>python官网：<a href="https://www.python.org/">https://www.python.org/</a></p></blockquote><p>在官网下载源码编译安装或者直接下载安装包即可，macos和linux可以使用包管理器安装。</p><h3 id="运行python"><a href="#运行python" class="headerlink" title="运行python"></a>运行python</h3><ol><li>交互解释运行（python命令，ipython）</li><li>python命令运行文件</li><li>IDE、编辑器中运行（pycharm，vscode）</li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ol><li>必须以字母或者下划线_开头。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>大小写敏感。</li><li>在python3中，可以用ASCII字符作为标识符包括汉字。</li></ol><p>python标识符保留字：</p><p>使用下面的方法查询保留的关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">keyword.kwlist</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h3><p>python使用缩进来表示代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"True"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure><h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>[], {}, ()中使用多行语句不需要斜杠。</p><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><ul><li>int: 1</li><li>bool: True, False</li><li>float: 1.23</li><li>complex: 1 + 2j、 1.1 + 2.2j</li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Mason'</span></span><br><span class="line">name = <span class="string">"Mason"</span></span><br><span class="line">full_name = <span class="string">'''my name is</span></span><br><span class="line"><span class="string">Mason'''</span></span><br><span class="line">full_name = <span class="string">"""my name is</span></span><br><span class="line"><span class="string">Mason"""</span></span><br></pre></td></tr></table></figure><ul><li>单行字符串使用单引号或者双引号包裹。</li><li>多行字符串使用三引号<code>&#39;&#39;&#39;</code>或者<code>&quot;&quot;&quot;</code>包裹。</li><li>转义字符<code>\</code>，使用<code>r</code>可以阻止转义。</li><li>字符串使用<code>+</code>拼接，可以使用<code>*</code>重复字符串。</li><li>字符串两种索引方式：从左往右（0开始），从右往左（最右边的索引是-1）。</li><li>字符串中的字符不能改变。</li><li>python中只有字符串没有字符。</li></ul><p>阻止转义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'hello\nworld'</span>)</span><br><span class="line">print(<span class="string">r'hello\nworld'</span>)</span><br></pre></td></tr></table></figure><p>截取字符：变量[头下标: 尾下标: 步长]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Mason'</span></span><br><span class="line">print(name[<span class="number">0</span>])</span><br><span class="line">print(name[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">print(name[<span class="number">0</span>:])</span><br><span class="line">print(name[<span class="number">0</span>:<span class="number">-1</span>])</span><br><span class="line">print(name[<span class="number">0</span>:<span class="number">-1</span>:<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>函数之间、类方法之间、类和函数入口之间都要用空行隔开，便于区分。</p><h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input(<span class="string">'\n\n请输入并以回车结束'</span>)</span><br></pre></td></tr></table></figure><h3 id="多条语句"><a href="#多条语句" class="headerlink" title="多条语句"></a>多条语句</h3><p>使用分号分隔多条语句。</p><h3 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h3><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> exp1:</span><br><span class="line">    suite</span><br><span class="line"><span class="keyword">elif</span> exp2:</span><br><span class="line">    suite</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    suite</span><br></pre></td></tr></table></figure><h3 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h3><p>print输出默认换行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Mason'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认换行</span></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加参数不换行</span></span><br><span class="line">print(name, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h3 id="import和from…import"><a href="#import和from…import" class="headerlink" title="import和from…import"></a>import和from…import</h3><p>使用import和from…import来导入模块。</p><p>导入模块： <code>import module</code></p><p>导入模块中的一个函数： <code>from module import function</code></p><p>导入模块中的多个函数： <code>from module import function1, function2, function3</code></p><p>导入模块中的全部函数： <code>from module import *</code></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>python中的数据类型不需要声明，直接赋值。<br>python中的变量是弱类型的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Mason'</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">balance = <span class="number">10000.5</span></span><br></pre></td></tr></table></figure><h3 id="赋值多个变量"><a href="#赋值多个变量" class="headerlink" title="赋值多个变量"></a>赋值多个变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>还有类似es解构赋值的赋值方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="string">'mason'</span>, <span class="number">1</span>, <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><ul><li>Number：数字</li><li>String：字符串</li><li>List：列表</li><li>Tuple：元祖</li><li>Set：集合</li><li>Dictionary：字典</li></ul><p>注意布尔型属于Number类型。</p><p>其中，分为可变数据类型和不可变数据类型</p><p>可变类型：Number, String, Tuple<br>不可变类型：List, Set, Dictionary</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>分为：int（长整型）, float, bool, complex</p><p>使用 <code>type()</code> 可以查询变量指向的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line"><span class="comment"># 其他类型&lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用 <code>isinstance()</code> 判断类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isinstance(<span class="number">1</span>, int)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>两者的区别： <code>type()</code> 不会认为子类是一种父类类型，而 <code>isinstance()</code> 会认为是。</p><p>bool是int的子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">issubclass(bool, int) </span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="literal">True</span> == <span class="number">1</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="literal">False</span> == <span class="number">0</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="literal">True</span> + <span class="number">1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="literal">False</span> + <span class="number">1</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>删除变量引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> myname</span><br><span class="line"><span class="keyword">del</span> myname, age</span><br></pre></td></tr></table></figure><p>数学计算：</p><p>使用： <code>+</code> （加法）, <code>-</code> （减法）, <code>*</code> （乘法）, <code>/</code> （除法，得到浮点数）, <code>//</code> （除法，得到整数）, <code>%</code> （求余数）, <code>**</code> （乘方）</p><p>complex类型：是复数，由实部和虚部组成 <code>a+bj</code> ，或者 <code>complex(a, b)</code> ，a和b都是浮点型。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>省略的部分笔记参考上一章节。</p><p>反斜杠还可以作为续行符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'my name is\</span></span><br><span class="line"><span class="string">Mason</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"><span class="comment"># my name is Mason</span></span><br></pre></td></tr></table></figure><p>也可以使用三引号跨行。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List（列表）就是数组，形如 <code>[&#39;abc&#39;, 123, False]</code> 。</p><p>空列表： <code>[]</code></p><p>List中的每一个元素可以是任何类型。</p><p>截取List中的元素的方法和上面的String截取方式一样。</p><p>List中的+和*：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'abc'</span>, <span class="number">123</span>]</span><br><span class="line">lsit2 = [<span class="number">345</span>, <span class="string">'efg'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用乘号可以重复</span></span><br><span class="line">print(list1*<span class="number">2</span>)</span><br><span class="line"><span class="comment"># ['abc', 123, 'abc', 123]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List可以通过加号拼接</span></span><br><span class="line">print(list1 + list2)</span><br><span class="line"><span class="comment"># ['abc', 123, 345, 'efg']</span></span><br></pre></td></tr></table></figure><p>List中的元素可以改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># [0, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>:<span class="number">4</span>] = [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># [0, 7, 7, 7, 5, 6]</span></span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>:<span class="number">-1</span>] = []</span><br><span class="line"><span class="comment"># [0, 6]</span></span><br></pre></td></tr></table></figure><p>List也可以像String一样设置步长来跳着选取元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">print(list[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># [1, 3, 5]</span></span><br></pre></td></tr></table></figure><p>翻转句子词语顺序实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 翻转句子词序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(sentence)</span>:</span></span><br><span class="line">    <span class="comment"># 先将句子通过空格分割为List</span></span><br><span class="line">    sentenceList = sentence.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 翻转句子sentenceList</span></span><br><span class="line">    reversedSentenceList = sentenceList[<span class="number">-1</span>::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再将reversedSentenceList转为String并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(reversedSentenceList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment"># WTF</span></span><br><span class="line">    s = <span class="string">'my name is Mason'</span></span><br><span class="line">    print(reverseWords(s))  <span class="comment"># Mason is name my</span></span><br></pre></td></tr></table></figure><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>Tuple与List类似，不过元组中的元素不能修改，而且放在小括号()中，使用逗号隔开。<br>Tuple的其他用法和List一致。</p><p>字符串可以看成是一种特殊的元组。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple = (<span class="number">123</span>, <span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure><p>空元组： <code>()</code></p><p>一个元素的元组这样写： <code>(10,)</code></p><p>一个元素的列表可以这样写： <code>[10]</code></p><p>String, List, Tuple都属于序列。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合（Set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>Set可以用于成员关系测试和删除重复元素。</p><p>创建空的Set只能用 <code>set()</code></p><p>创建一个Set：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newSet = &#123;elem1, elem2, elem3&#125;</span><br><span class="line"></span><br><span class="line">newSet = set(elem1)</span><br></pre></td></tr></table></figure><p>Set实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set去重</span></span><br><span class="line">newSet = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>&#125;</span><br><span class="line">print(newSet)   <span class="comment"># &#123;'a', 'b', 'c', 'd'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一个值是否是Set的成员</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">in</span> newSet:</span><br><span class="line">    print(<span class="string">'true'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'false'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set的集合运算</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集运算</span></span><br><span class="line">print(a &amp; b)</span><br><span class="line"><span class="comment"># 并集运算</span></span><br><span class="line">print(a | b)</span><br><span class="line"><span class="comment"># 差集运算</span></span><br><span class="line">print(a - b)</span><br><span class="line"><span class="comment"># a和b中不同时存在的元素，相当于a-b和b-a的并集</span></span><br><span class="line">print(a ^ b)</span><br><span class="line">print(a-b | b-a)</span><br></pre></td></tr></table></figure><h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h3><p>字典是无序对象的集合，就相当于js里面的对象。<br>字典使用{}包裹，里面是键值对。<br>key必须是不可变类型String, Number, Tuple，且key必须唯一。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个字典并向里面添加键值对</span></span><br><span class="line">dict = &#123;&#125;</span><br><span class="line">dict[<span class="string">'name'</span>] = <span class="string">'mason'</span></span><br><span class="line">dict[<span class="number">1</span>] = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接赋值一个字典</span></span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'mason'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典</span></span><br><span class="line">print(dict[<span class="string">'name'</span>])</span><br><span class="line">print(dict(<span class="number">1</span>))</span><br><span class="line">print(dict.keys())</span><br><span class="line">print(dict.values())</span><br></pre></td></tr></table></figure><p>可以使用 <code>dict()</code> 构建字典，传入参数为序列。</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p><code>int(x [,base])</code> : 将x转换为一个整数</p><p><code>float(x)</code> : 将x转换到一个浮点数</p><p><code>complex(real [,imag])</code> : 创建一个复数</p><p><code>str(x)</code> : 将对象 x 转换为字符串</p><p><code>repr(x)</code> : 将对象 x 转换为表达式字符串</p><p><code>eval(str)</code> : 用来计算在字符串中的有效Python表达式, 并返回一个对象</p><p><code>tuple(s)</code> : 将序列 s 转换为一个元组</p><p><code>list(s)</code> : 将序列 s 转换为一个列表</p><p><code>set(s)</code> : 转换为可变集合</p><p><code>dict(d)</code> : 创建一个字典。d 必须是一个 (key, value)元组序列。</p><p><code>frozenset(s)</code> : 转换为不可变集合</p><p><code>chr(x)</code> : 将一个整数转换为一个字符</p><p><code>ord(x)</code> : 将一个字符转换为它的整数值</p><p><code>hex(x)</code> : 将一个整数转换为一个十六进制字符串</p><p><code>oct(x)</code> : 将一个整数转换为一个八进制字符串</p><h2 id="数据类型转换-1"><a href="#数据类型转换-1" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul><li>隐式转换（自动）</li></ul><ol><li>两个不同数据类型之间进行运算的时候，python会自动将低精度数据类型转换为高精度数据类型。</li><li>将数字和字符串进行加法操作会报错。</li></ol><ul><li>显式转换（手动）</li></ul><p>参考上一张最后的api。</p><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><!-- https://www.runoob.com/python3/python-comprehensions.html --><p>推导式是一种数据处理方式，可以将一个数据序列转为另一个数据序列。</p><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line"></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><p>实例：过滤掉小于等于3的数并返回新的List</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">nums_filtered = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num &gt; <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>实例：将一个List通过字典推导式转为Dictionary</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">'abc'</span>,<span class="string">'abcd'</span>, <span class="string">'abcde'</span>]</span><br><span class="line"></span><br><span class="line">dict = &#123;key:len(key) <span class="keyword">for</span> key <span class="keyword">in</span> list&#125;</span><br><span class="line"><span class="comment"># &#123;'abc': 3, 'abcd': 4, 'abcde': 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> Sequence &#125;</span><br><span class="line"></span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> Sequence <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure><p>实例：计算集合中元素的平方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set = &#123;item**<span class="number">2</span> <span class="keyword">for</span> item <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br><span class="line"><span class="comment"># &#123;1,4,9&#125;</span></span><br></pre></td></tr></table></figure><h3 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> Sequence )</span><br><span class="line"></span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> Sequence <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure><p>元组推导式返回的是生成器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tuple_object是生成器对象</span></span><br><span class="line">tuple_object = (item <span class="keyword">for</span> item <span class="keyword">in</span> rrange(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成器对象转为元组</span></span><br><span class="line">tuple(tuple_object)</span><br></pre></td></tr></table></figure><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行python脚本</span></span><br><span class="line">python3 main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予脚本执行权限</span></span><br><span class="line">chmod +x main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">./main.py</span><br></pre></td></tr></table></figure><h2 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>python中有以下运算符。</p><ul><li>算术运算符：+ - * / % ** //</li><li>比较运算符：== != &gt; &gt;= &lt; &lt;=</li><li>赋值运算符：= += -= <em>= /= %= *</em>= //= :=(海象运算符)</li><li>逻辑运算符：and or not</li><li>位运算符：&amp; | ^ ~ &lt;&lt; &gt;&gt;</li><li>成员运算符：in, not in, 支持List，String，Tuple</li><li>身份运算符<ul><li>is：判断两个变量是否是同一个对象的引用，a is b，相当于id(a)==id(b)。</li><li>is not：参上</li><li>id()：用于获取变量的内存地址。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">a <span class="keyword">is</span> b </span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>is用于判断两个变量引用对象是否为同一个，==用于判断引用变量的值是否相等。</p><ul><li>运算符优先级：参考<a href="https://www.runoob.com/python3/python3-basic-operators.html">https://www.runoob.com/python3/python3-basic-operators.html</a></li></ul><p>注意and比or优先级高。</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>要引入math包：import math</p><p>下面的api都要用math.round()的形式写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">3.14</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量对于对象的引用</span></span><br><span class="line"><span class="keyword">del</span> a,b</span><br></pre></td></tr></table></figure><p>Number的类型：</p><ul><li>int：整形或者说可以作为long使用，bool型是int的子类型。</li><li>float</li><li>complex：复数，<code>a+bj</code>或者<code>complex(a, b)</code>，其中a和b都是float。</li></ul><h3 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h3><ul><li>int()</li><li>float()</li><li>complex()</li></ul><h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><p>参考之前的章节。</p><p>交互模式中，最后被输出的表达式结果会被赋值给_。</p><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul><li>sqrt()：开方</li><li>abs()</li><li>ceil()</li><li>floor()</li><li>round(x, n)：四舍五入精确到n位</li><li>cmp(x, y)</li><li>exp(x)</li><li>pow(x, y)</li><li>fabs()</li><li>log()</li><li>log10()</li><li>max(x1, x2, …xn)</li><li>min(x1, x2, …xn)</li><li>modf(x)：返回x的整数部分和小数部分。</li></ul><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><ul><li>choice()：从参数序列中随机挑选一个，<code>random.choice(range(10))</code></li><li>randrange(start, stop, step)：从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</li><li>random()：生成一个随机数，范围[0, 1)</li><li>seed()</li><li>shuffle(list)：将list打乱随机排列。</li><li>uniform(x, y)：随机生成一个[x, y]之间的实数。</li></ul><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>就是各种正弦余弦，反正弦反余弦。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>pi：圆周率π</li><li>e：自然常数e</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>和之前字符串重复的地方不作笔记。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul><li><code>\</code>在行尾：作为续行符</li><li><code>\\</code>：反斜杠</li><li><code>\&#39;</code>：单引号</li><li><code>\a</code>：响铃</li><li><code>\b</code>：退格</li><li><code>\000</code>：空</li><li><code>\n</code>：换行</li><li><code>\t</code>：横向制表符</li><li><code>\v</code>：纵向制表符</li><li><code>\r</code>：替换符，将r之后的字符串逐一替换r之前的字符串。</li><li><code>\f</code>：换页</li></ul><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><ul><li>+：拼接字符串。</li><li>*：重复字符串。</li><li>[]：获取字符串下标对应的字符。</li><li>[start:end]：截取字符串。</li><li>in：成员运算符，判断字符是否在字符串中。</li><li>not in</li><li>r/R：表示raw原始字符串，用于避免转义。</li><li>%：字符串格式化</li></ul><p>字符串格式化实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"我叫%s今年%d岁!"</span> % (<span class="string">'mason'</span>, <span class="number">11</span>))</span><br><span class="line"><span class="comment"># 我叫mason今年11岁</span></span><br></pre></td></tr></table></figure><ul><li>%c：格式化字符及其ASCII码</li><li>%s：格式化字符串</li><li>%d：格式化整数</li><li>%u：格式化无符号整型</li><li>%o：格式化无符号八进制数</li><li>%x：格式化无符号十六进制数</li><li>%X：格式化无符号十六进制数（大写）</li><li>%f：格式化浮点数字，可指定小数点后的精度</li><li>%e：用科学计数法格式化浮点数</li><li>%E：作用同%e，用科学计数法格式化浮点数</li><li>%g：%f和%e的简写</li><li>%G：%f和%E的简写</li><li>%p：用十六进制数格式化变量的地址</li></ul><h3 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h3><p>三引号可以让字符串跨多行。</p><h3 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h3><p>f-string是新的格式化字符串的方法。</p><p>用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'mason'</span></span><br><span class="line">print(<span class="string">f'my name is <span class="subst">&#123;name&#125;</span>, and <span class="subst">&#123;<span class="number">10</span>+<span class="number">10</span>&#125;</span> years old'</span>)</span><br></pre></td></tr></table></figure><p>3.8以上版本可以用=来拼接运算式和运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f'<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>=&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># 1+2=3</span></span><br></pre></td></tr></table></figure><h3 id="unicode字符串"><a href="#unicode字符串" class="headerlink" title="unicode字符串"></a>unicode字符串</h3><p>用到的时候查表。</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>随用随查：<a href="https://www.runoob.com/python3/python3-string.html">https://www.runoob.com/python3/python3-string.html</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://www.runoob.com/python3/python3-tutorial.html">https://www.runoob.com/python3/python3-tutorial.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学python，不想一上来就直接写helloworld，了解一门语言的发展和语言的特性也是非常重要的，所以笔记会比较详细。&lt;/p&gt;
&lt;p&gt;python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。&lt;br&gt;python具有很强的可读性。&lt;br&gt;python3相对python2是较大的一个升级并且没有考虑向下兼容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://herotiga.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>红墨水和蓝墨水混合问题</title>
    <link href="https://herotiga.github.io/2022/03/02/%E7%BA%A2%E5%A2%A8%E6%B0%B4%E5%92%8C%E8%93%9D%E5%A2%A8%E6%B0%B4%E6%B7%B7%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <id>https://herotiga.github.io/2022/03/02/%E7%BA%A2%E5%A2%A8%E6%B0%B4%E5%92%8C%E8%93%9D%E5%A2%A8%E6%B0%B4%E6%B7%B7%E5%90%88%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-02T12:54:30.000Z</published>
    <updated>2022-05-19T10:58:30.970Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到个特别有意思的红墨水蓝墨水混合问题：</p><p>题：有一瓶红墨水，一瓶蓝墨水，从红墨水舀一勺到蓝瓶里，搅匀后再舀一勺到红瓶里。<br>问：此时红墨水里含蓝墨水的量和蓝墨水里含红墨水的量关系是什么？大于、小于、等于？</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/herotiga/cdn@master/img/article/red-blue.png" alt=""></p><p>这个题目本身看起来不是一个难题，如果你通过取特殊值计算的结果来判断就不好，因为不具备普遍性。</p><p>如果我们<strong>从状态变化的角度</strong>来看这个问题，可以发现这个问题可以看做是状态的迁移。</p><p><strong>初始态</strong>：红墨水和蓝墨水体积相等，红墨水中不含蓝墨水，蓝墨水中也不含红墨水。<br><strong>最终态</strong>：红墨水瓶中的水和蓝墨水瓶中的水体积依然相等，红墨水瓶中含蓝墨水，蓝墨水瓶中也含红墨水。</p><p>我们不关注两次舀水的过程，单单从状态变化的角度来看，可以发现初始态和最终态两个瓶子中的水的体积都相等，发生变化的是红墨水瓶子中多了蓝墨水而少了红墨水，蓝墨水瓶子中多了红墨水而少了蓝墨水。</p><p>而其实红墨水瓶子中多了的蓝墨水来自于蓝墨水瓶，少了的红墨水去到了蓝墨水瓶，而两者的体积是相等的，无论第一次舀水后是否搅匀，最终红墨水瓶中含有的蓝墨水永远等于蓝墨水瓶中含有的红墨水。</p><!-- https://yanhaijing.com/math/2017/03/23/red-blue-ink/ -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看到个特别有意思的红墨水蓝墨水混合问题：&lt;/p&gt;
&lt;p&gt;题：有一瓶红墨水，一瓶蓝墨水，从红墨水舀一勺到蓝瓶里，搅匀后再舀一勺到红瓶里。&lt;br&gt;问：此时红墨水里含蓝墨水的量和蓝墨水里含红墨水的量关系是什么？大于、小于、等于？&lt;/p&gt;
    
    </summary>
    
    
      <category term="math" scheme="https://herotiga.github.io/categories/math/"/>
    
    
  </entry>
  
  <entry>
    <title>解析let和const声明的变量不在window下的原因</title>
    <link href="https://herotiga.github.io/2022/01/14/let%E5%92%8Cconst%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/"/>
    <id>https://herotiga.github.io/2022/01/14/let%E5%92%8Cconst%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/</id>
    <published>2022-01-14T09:06:04.000Z</published>
    <updated>2022-05-19T10:58:32.614Z</updated>
    
    <content type="html"><![CDATA[<p>使用es5中 <code>var</code> 命令声明的变量可以在 <code>window</code> 下找到，比如：</p><p><code>var myName = &#39;mason&#39;</code> ，可以使用 <code>window.myName</code> 访问到。</p><p>但是使用es6的 <code>let</code> 和 <code>const</code> 声明的变量却没有在window下，这是为什么呢？</p><a id="more"></a><hr><p>这里就要说到<code>window</code>对象和 <code>global</code> 对象。</p><p>对于window和global的看法，之前一直都是：window是浏览器的顶层对象，global是node的顶层对象。</p><p>但是其实window是global在浏览器的代理，window是global的一部分。<br>我们使用var声明的变量会被挂载到window下。</p><p>而let和const声明的变量会被挂载到 <code>script</code> 对象下，script和global是同一层级的。</p><p><img src="https://cdn.jsdelivr.net/gh/herotiga/cdn@master/img/article/script%E5%AF%B9%E8%B1%A1.png" alt="script对象"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用es5中 &lt;code&gt;var&lt;/code&gt; 命令声明的变量可以在 &lt;code&gt;window&lt;/code&gt; 下找到，比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var myName = &amp;#39;mason&amp;#39;&lt;/code&gt; ，可以使用 &lt;code&gt;window.myName&lt;/code&gt; 访问到。&lt;/p&gt;
&lt;p&gt;但是使用es6的 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明的变量却没有在window下，这是为什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://herotiga.github.io/categories/js/"/>
    
    
  </entry>
  
</feed>
