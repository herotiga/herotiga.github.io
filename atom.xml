<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Typecasting</title>
  
  <subtitle>write some articles about front-end dev,ui design,linux hacking and ai-cv.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://herotiga.github.io/"/>
  <updated>2024-09-04T08:20:32.775Z</updated>
  <id>https://herotiga.github.io/</id>
  
  <author>
    <name>Mason小王子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL中UPDATE和INSERT在加锁上有什么区别</title>
    <link href="https://herotiga.github.io/2024/09/04/mysql-update-insert-lock/"/>
    <id>https://herotiga.github.io/2024/09/04/mysql-update-insert-lock/</id>
    <published>2024-09-04T08:07:37.000Z</published>
    <updated>2024-09-04T08:20:32.775Z</updated>
    
    <content type="html"><![CDATA[<p>在MySQL中，<code>UPDATE</code>和<code>INSERT</code>在加锁上有一些区别。</p><a id="more"></a><h2 id="锁的范围"><a href="#锁的范围" class="headerlink" title="锁的范围"></a>锁的范围</h2><ul><li>UPDATE</li></ul><p>使用UPDATE只会对需要更新的一行或者多行进行加锁，加的是行锁。</p><p>如果还使用了<code>WHERE</code>则还会加上间隙锁，锁住范围内不存在的索引项之间的间隙防止其他事务插入新行。</p><ul><li>INSERT</li></ul><p>INSERT不会加行锁，它会对插入位置加上插入意向锁（Insert Intention Lock）以防止并发插入时死锁。</p><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><ul><li>UPDATE</li></ul><p>UPDATE会使用排他锁锁住需要更新的行。</p><ul><li>INSERT</li></ul><p>INSERT会使用排他锁来保证数据一致性，插入完成后释放锁。</p><h2 id="锁的冲突"><a href="#锁的冲突" class="headerlink" title="锁的冲突"></a>锁的冲突</h2><ul><li>UPDATE</li></ul><p>UPDATE会使用排他锁，故而可能导致锁等待或者死锁。</p><ul><li>INSERT</li></ul><p>并发INSERT时一般不会发生锁冲突。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在MySQL中，&lt;code&gt;UPDATE&lt;/code&gt;和&lt;code&gt;INSERT&lt;/code&gt;在加锁上有一些区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://herotiga.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL中的锁</title>
    <link href="https://herotiga.github.io/2024/09/04/mysql-lock/"/>
    <id>https://herotiga.github.io/2024/09/04/mysql-lock/</id>
    <published>2024-09-04T07:27:08.000Z</published>
    <updated>2024-09-04T08:06:59.509Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL中有那些锁？</p><a id="more"></a><h2 id="全局锁（Global-Lock）"><a href="#全局锁（Global-Lock）" class="headerlink" title="全局锁（Global Lock）"></a>全局锁（Global Lock）</h2><p>全局锁会让数据库变成只可读不可写模式，适用于需要一致性的场景，但是会阻塞写操作。</p><h2 id="表级锁（Table-Lock）"><a href="#表级锁（Table-Lock）" class="headerlink" title="表级锁（Table Lock）"></a>表级锁（Table Lock）</h2><p>表锁锁的是整张表，表所细分为读锁和写锁。</p><p>读锁：多个事务可以同时读表，但是无法写。<br>写锁：一个事务在获取到写锁后其他事务无法读写这张表，等到写锁被释放其他事务才可以继续读写。</p><h2 id="行级锁（Row-Lock）"><a href="#行级锁（Row-Lock）" class="headerlink" title="行级锁（Row Lock）"></a>行级锁（Row Lock）</h2><p>行锁锁定表中的一行或者多行。</p><p>在行锁释放之前，其他事务无法写这些行。</p><p>因为行锁只锁定特定的行，所以不影响整张表，是innoDB主要的锁类型。</p><h2 id="意向锁（Intention-Lock）"><a href="#意向锁（Intention-Lock）" class="headerlink" title="意向锁（Intention Lock）"></a>意向锁（Intention Lock）</h2><p>意向锁不会阻塞其他事务的表锁操作，只是用来表明某个事务打算对某些行加锁。</p><p>意向共享锁（Intention Shared Lock）：当一个事务想要在某些行上加共享锁时，首先需要在表级别加意向共享锁。</p><p>意向排他锁（Intention Exclusive Lock）：当一个事务想要在某些行上加排他锁时，首先需要在表级别加意向排他锁。</p><h2 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h2><p>间隙锁锁定索引项之间的间隙，防止其他事务在间隙中插入新的行。</p><p>间隙锁在范围查询中使用，可以防止幻读。</p><h2 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h2><p>临键锁锁定一个索引记录及前面的间隙，相当于是行锁+间隙锁。临键锁确保其他事务不能对记录进行插入、更新、删除操作。</p><h2 id="自增锁（AUTO-INC-Lock）"><a href="#自增锁（AUTO-INC-Lock）" class="headerlink" title="自增锁（AUTO-INC Lock）"></a>自增锁（AUTO-INC Lock）</h2><p>如果一个表中含有自增字段，MySQL会使用自增锁来确保并发插入操作时自增字段的唯一性和有序性。</p><p>自增锁在事务提交时释放。</p><h2 id="外键锁（Foreign-Key-Lock）"><a href="#外键锁（Foreign-Key-Lock）" class="headerlink" title="外键锁（Foreign Key Lock）"></a>外键锁（Foreign Key Lock）</h2><p>使用外键约束时，innoDB会对相关行加锁确保父表中的行在存在关联的子表行时不会被删除或者更新。</p><h2 id="元数据锁（Metadata-Lock）"><a href="#元数据锁（Metadata-Lock）" class="headerlink" title="元数据锁（Metadata Lock）"></a>元数据锁（Metadata Lock）</h2><p>元数据锁锁定的是表结构（包括表定义、索引定义），当执行改变表结构的操作（ALTER TABLE、DROP TABLE）时MySQL会给表加上元数据锁以防止并发的DDL操作（Data Definition Language，比如CREATE、ALTER、DROP）和DML（Data Manipulation Language，比如INSERT、UPDATE、DELETE）操作发生冲突。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL中有那些锁？&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://herotiga.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js高并发方案</title>
    <link href="https://herotiga.github.io/2024/09/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://herotiga.github.io/2024/09/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2024-09-01T16:15:44.000Z</published>
    <updated>2024-09-02T03:42:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js高并发方案</p><a id="more"></a><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Node.js是单线程的，可以利用Cluster模块创建多个子进程来利用多核CPU，子进程共享相同的端口，平均分发请求，提高并发处理能力。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>常用的反向代理服务器有Nginx和HAProxy。</p><ul><li>Nginx</li></ul><p>使用Nginx作为反向代理服务器，将请求分发给多个Node.js实例。</p><p>还可以用Nginx处理静态文件、SSL卸载以减轻Node.js的压力。</p><ul><li>HAProxy</li></ul><p>HAProxy也可以做负载均衡。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列的作用有：解耦服务，异步任务处理，缓冲突发流量。</p><p>常用RabbitMQ、Kafka。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>将频繁访问的数据写入内存。</p><p>可以使用内存数据库Redis、Memcached，将高频访问的数据写入内存数据库以提高响应速度。</p><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>服务端设置HTTP header的某些字段来减少客户端对服务端的请求，可以降低服务端压力。</p><ul><li>Cache-Control</li><li>ETag</li></ul><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>通过主从复制将数据库读写操作分离，在从库读取，在主库写入。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>确保查询语句有合适的索引，避免全表扫描。</p><h3 id="分库分表（Database-Sharding-amp-Table-Sharding）"><a href="#分库分表（Database-Sharding-amp-Table-Sharding）" class="headerlink" title="分库分表（Database Sharding &amp; Table Sharding）"></a>分库分表（Database Sharding &amp; Table Sharding）</h3><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>分库就是将数据分散到多个数据库中。</p><p>分库又分为垂直分库和水平分库。</p><ul><li>垂直分库</li></ul><p>根据业务模块的不同，将数据按照业务模块的不同拆分到多个数据库中。优点是不同模块的读写操作互不影响。</p><p>比如，在电商系统中，可以将用户模块的数据放在一个数据库中，将订单模块数据放在另一个数据库中。</p><ul><li>水平分库</li></ul><p>将同一个表的数据按照某种规则拆分到多个数据库中。优点是可以均衡数据量和访问压力。</p><p>比如，在电商系统中，将用户表中的数据按照用户ID范围或者哈希值拆分到多个数据库中。</p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>分表就是将一张表的数据分散到多张表中。</p><p>分表又分为垂直分表和水平分表。</p><ul><li>垂直分表</li></ul><p>将表中字段较多的表按照字段拆分为多张表。</p><p>比如，把用户表拆分为基本信息和扩展信息两张表，减少了表的宽度提高了查询效率。</p><ul><li>水平分表</li></ul><p>将同一张表的数据按照行拆分到多张表中。</p><p>比如，按照用户ID将用户表分为user_01和user_02等多张表，解决了单张表数据量过大导致的性能问题。</p><h4 id="如何分库分表"><a href="#如何分库分表" class="headerlink" title="如何分库分表"></a>如何分库分表</h4><ul><li>选择分片键（Shard Key）</li></ul><p>分库分表需要选择一个合理的分片键，这会影响数据的分布和性能。</p><p>一般选择主键、时间戳，或者均匀分布数据的字段（常用UUID）作为分片键。</p><ul><li>路由策略</li></ul><p>分库分表后，路由是需要知道访问的数据在哪个库或者表中。</p><ul><li>事务处理</li></ul><p>分库分表后，事务中可能会出现跨库、跨表的情况。可以使用分布式事务、最终一致性等机制解决。</p><ul><li>数据迁移和扩容</li></ul><p>数据迁移：在单库单表的基础上分库分表，需要进行数据迁移，可以编写脚本或者使用工具将数据迁移到新的分库分表架构中。</p><p>扩容：随着数据量的增长，需要考虑动态扩展数据库或者表的数量。</p><h4 id="分库分表中间件"><a href="#分库分表中间件" class="headerlink" title="分库分表中间件"></a>分库分表中间件</h4><ul><li>Mycat：分库分表中间件。</li><li>ShardingSphere：分库分表中间件，支持分布式事务。</li><li>TDDL：分布式数据库层，可以分库分表。</li></ul><p>如果使用了Sequelize，还可以安装插件支持分库分表：</p><ul><li>Sharding插件</li><li>自定义ORM扩展：在ORM中自定义模型的数据库连接或查询方法，实现对不同数据库或表的访问。</li></ul><h4 id="性能监控和优化"><a href="#性能监控和优化" class="headerlink" title="性能监控和优化"></a>性能监控和优化</h4><p>分库分表架构建立后，需要持续监控新架构的系统性能以及根据监控调整分库分表策略。</p><h4 id="Node-js分库分表简单实现"><a href="#Node-js分库分表简单实现" class="headerlink" title="Node.js分库分表简单实现"></a>Node.js分库分表简单实现</h4><p>下面的实例将用户信息分散到了两个数据库中。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql2/promise'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个数据库的配置信息</span></span><br><span class="line"><span class="keyword">const</span> dbConfigs = [</span><br><span class="line">    &#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">user</span>: <span class="string">'root'</span>, <span class="attr">password</span>: <span class="string">'password'</span>, <span class="attr">database</span>: <span class="string">'db1'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">user</span>: <span class="string">'root'</span>, <span class="attr">password</span>: <span class="string">'password'</span>, <span class="attr">database</span>: <span class="string">'db2'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个数据库创建连接池</span></span><br><span class="line"><span class="keyword">const</span> pools = dbConfigs.map(<span class="function"><span class="params">config</span> =&gt;</span> mysql.createPool(config));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据id将用户请求分散到多个数据库上，计算数据库偏移量</span></span><br><span class="line"><span class="keyword">const</span> getShard = <span class="function">(<span class="params">id</span>) =&gt;</span> id % dbConfigs.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="keyword">async</span> (userId) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 选择id为分片键</span></span><br><span class="line">    <span class="keyword">const</span> shard = getShard(userId);</span><br><span class="line">    <span class="keyword">const</span> pool = pools[shard];</span><br><span class="line">    <span class="keyword">const</span> conn = <span class="keyword">await</span> pool.getConnection();</span><br><span class="line">    <span class="keyword">const</span> [rows] = <span class="keyword">await</span> conn.query(<span class="string">'SELECT * FROM users WHERE id = ?'</span>, [userId]);</span><br><span class="line">    conn.release();</span><br><span class="line">    <span class="keyword">return</span> rows[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">getUser(<span class="number">1234456</span>).then(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(user)).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br></pre></td></tr></table></figure><h2 id="性能监控和调优"><a href="#性能监控和调优" class="headerlink" title="性能监控和调优"></a>性能监控和调优</h2><p>监控工具：PM2，New Relic，Datadog</p><h2 id="服务器扩展"><a href="#服务器扩展" class="headerlink" title="服务器扩展"></a>服务器扩展</h2><ul><li>垂直扩展</li></ul><p>提升服务器硬件配置。</p><ul><li>水平扩展</li></ul><p>增加服务器数量。</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>使用CDN缓存静态资源。</p><h2 id="限流和降级"><a href="#限流和降级" class="headerlink" title="限流和降级"></a>限流和降级</h2><ul><li>限流</li></ul><p>限制流量避免系统宕机。</p><ul><li>降级</li></ul><p>系统压力较大时可以关闭部分非核心服务，有限保证核心服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js高并发方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>在Node.js项目微服务架构中使用Kafka通信</title>
    <link href="https://herotiga.github.io/2024/08/31/nodejs-kafka/"/>
    <id>https://herotiga.github.io/2024/08/31/nodejs-kafka/</id>
    <published>2024-08-31T15:32:21.000Z</published>
    <updated>2024-08-31T16:09:28.411Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka相比于RabbitMQ性能更好。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Kafka客户端库"><a href="#安装Kafka客户端库" class="headerlink" title="安装Kafka客户端库"></a>安装Kafka客户端库</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S kafkajs</span><br></pre></td></tr></table></figure><h3 id="配置Kafka-broker集群"><a href="#配置Kafka-broker集群" class="headerlink" title="配置Kafka broker集群"></a>配置Kafka broker集群</h3><p>通常会使用多个Kafka代理（broker）构成集群。</p><p>Kafka broker集群可以提高系统的可用性和吞吐量。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kafka = <span class="keyword">new</span> Kafka(&#123;</span><br><span class="line">  clientId: <span class="string">'my-app'</span>,</span><br><span class="line">  brokers: [<span class="string">'broker1:9092'</span>, <span class="string">'broker2:9092'</span>],</span><br><span class="line">  <span class="comment">// 重试机制</span></span><br><span class="line">  retry: &#123;</span><br><span class="line">    retries: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h2><p>Kafka生产者向Topic发送消息：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Kafka &#125; = <span class="built_in">require</span>(<span class="string">'kafkajs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Kafka实例并指定Kafka代理（broker）的地址</span></span><br><span class="line"><span class="keyword">const</span> kafka = <span class="keyword">new</span> Kafka(&#123;</span><br><span class="line">  clientId: <span class="string">'my-app'</span>,</span><br><span class="line">  brokers: [<span class="string">'localhost:9092'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个生产者</span></span><br><span class="line"><span class="keyword">const</span> producer = kafka.producer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 连接生产者</span></span><br><span class="line">  <span class="keyword">await</span> producer.connect();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送一条消息到指定的主题</span></span><br><span class="line">  <span class="keyword">await</span> producer.send(&#123;</span><br><span class="line">    topic: <span class="string">'test-topic'</span>,</span><br><span class="line">    messages: [</span><br><span class="line">      &#123; <span class="attr">value</span>: <span class="string">'Hello KafkaJS user!'</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开连接</span></span><br><span class="line">  <span class="keyword">await</span> producer.disconnect();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run().catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><h2 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h2><p>Kafka消费者从Topic中读取消息并消费：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Kafka &#125; = <span class="built_in">require</span>(<span class="string">'kafkajs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Kafka实例并指定Kafka代理（broker）的地址</span></span><br><span class="line"><span class="keyword">const</span> kafka = <span class="keyword">new</span> Kafka(&#123;</span><br><span class="line">  clientId: <span class="string">'my-app'</span>,</span><br><span class="line">  brokers: [<span class="string">'localhost:9092'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个消费者并指定消费的组ID</span></span><br><span class="line"><span class="keyword">const</span> consumer = kafka.consumer(&#123; <span class="attr">groupId</span>: <span class="string">'test-group'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 连接消费者</span></span><br><span class="line">  <span class="keyword">await</span> consumer.connect();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 订阅主题</span></span><br><span class="line">  <span class="keyword">await</span> consumer.subscribe(&#123; <span class="attr">topic</span>: <span class="string">'test-topic'</span>, <span class="attr">fromBeginning</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理消息</span></span><br><span class="line">  <span class="keyword">await</span> consumer.run(&#123;</span><br><span class="line">    eachMessage: <span class="keyword">async</span> (&#123; topic, partition, message &#125;) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(&#123;</span><br><span class="line">        partition,</span><br><span class="line">        offset: message.offset,</span><br><span class="line">        value: message.value.toString(),</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run().catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kafka相比于RabbitMQ性能更好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>在Node.js项目微服务架构中使用RabbitMQ通信</title>
    <link href="https://herotiga.github.io/2024/08/31/nodejs-rabbitmq/"/>
    <id>https://herotiga.github.io/2024/08/31/nodejs-rabbitmq/</id>
    <published>2024-08-31T11:21:47.000Z</published>
    <updated>2024-08-31T15:32:09.738Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列（MQ）可以让系统中不同部分的应用程序或者不同的微服务之间进行异步通信。</p><p>Node.js常用的MQ有RabbitMQ、Kafka、或Redis等。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="搭建RabbitMQ服务器"><a href="#搭建RabbitMQ服务器" class="headerlink" title="搭建RabbitMQ服务器"></a>搭建RabbitMQ服务器</h3><p>构建一个RabbitMQ服务器的Docker容器并暴露服务端口。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure><p>5672端口是RabbitMQ的默认通信端口，15672端口是web管理界面的端口。</p><h3 id="安装amqplib包"><a href="#安装amqplib包" class="headerlink" title="安装amqplib包"></a>安装amqplib包</h3><p>在Node.js项目中安装amqplib：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S amqplib</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="连接RabbitMQ服务器并发送消息到队列"><a href="#连接RabbitMQ服务器并发送消息到队列" class="headerlink" title="连接RabbitMQ服务器并发送消息到队列"></a>连接RabbitMQ服务器并发送消息到队列</h3><p>创建一个消息生产者，连接RabbitMQ并发送消息到队列：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib/callback_api'</span>);</span><br><span class="line"></span><br><span class="line">amqp.connect(<span class="string">'amqp://localhost'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error0, connection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error0) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个通道</span></span><br><span class="line">  connection.createChannel(<span class="function"><span class="keyword">function</span>(<span class="params">error1, channel</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = <span class="string">'task_queue'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个队列</span></span><br><span class="line">    channel.assertQueue(queue, &#123;</span><br><span class="line">      durable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息到队列</span></span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line">    channel.sendToQueue(queue, Buffer.from(msg), &#123;</span><br><span class="line">      persistent: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">" [x] Sent '%s'"</span>, msg);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭连接</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    connection.close();</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="从队列中消费消息"><a href="#从队列中消费消息" class="headerlink" title="从队列中消费消息"></a>从队列中消费消息</h3><p>创建一个消息消费者，从消息队列中取出消息并消费：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib/callback_api'</span>);</span><br><span class="line"></span><br><span class="line">amqp.connect(<span class="string">'amqp://localhost'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error0, connection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error0) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  connection.createChannel(<span class="function"><span class="keyword">function</span>(<span class="params">error1, channel</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = <span class="string">'task_queue'</span>;</span><br><span class="line"></span><br><span class="line">    channel.assertQueue(queue, &#123;</span><br><span class="line">      durable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    channel.prefetch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">" [*] Waiting for messages in %s. To exit press CTRL+C"</span>, queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费消息</span></span><br><span class="line">    channel.consume(queue, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> secs = msg.content.toString().split(<span class="string">'.'</span>).length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">" [x] Received %s"</span>, msg.content.toString());</span><br><span class="line"></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">" [x] Done"</span>);</span><br><span class="line">        channel.ack(msg);</span><br><span class="line">      &#125;, secs * <span class="number">1000</span>);</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      noAck: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ol><li>队列持久化</li></ol><p>消息消费者连接队列时开启<code>durable: true</code>可以实现队列持久化。</p><ol start="2"><li>消息持久化</li></ol><p>消息生产者发送消息时开启<code>persistent: true</code>可以实现消息持久化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列（MQ）可以让系统中不同部分的应用程序或者不同的微服务之间进行异步通信。&lt;/p&gt;
&lt;p&gt;Node.js常用的MQ有RabbitMQ、Kafka、或Redis等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js项目实现微服务架构</title>
    <link href="https://herotiga.github.io/2024/08/31/nodejs-microservices/"/>
    <id>https://herotiga.github.io/2024/08/31/nodejs-microservices/</id>
    <published>2024-08-30T16:28:18.000Z</published>
    <updated>2024-09-02T08:43:52.508Z</updated>
    
    <content type="html"><![CDATA[<p>微服务是一种软件架构风格，在这种架构中，应用程序被构建为一组小的、独立的服务，每个服务负责处理特定的业务功能。这些服务可以独立开发、部署和扩展，并通过轻量级的通信机制（通常是 HTTP API）进行互相通信。</p><a id="more"></a><hr><h2 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h2><ol><li><p>模块化：每个微服务都是一个独立的模块，负责特定的业务功能。不同的团队可以独立地开发和维护不同的微服务。</p></li><li><p>独立部署：微服务可以独立部署和更新，而不必影响其他服务。这使得应用程序更具灵活性，能够快速响应变化。</p></li><li><p>技术多样性：不同的微服务可以使用不同的编程语言、数据库和技术栈，选择最适合其功能的技术。</p></li><li><p>可扩展性：由于微服务是独立的，特定的微服务可以独立扩展，从而优化资源利用。</p></li><li><p>容错性：因为微服务是分布式的，如果一个服务出现故障，通常不会导致整个系统崩溃。</p></li></ol><hr><h2 id="Node-js实现微服务"><a href="#Node-js实现微服务" class="headerlink" title="Node.js实现微服务"></a>Node.js实现微服务</h2><h3 id="将应用拆分为多个服务"><a href="#将应用拆分为多个服务" class="headerlink" title="将应用拆分为多个服务"></a>将应用拆分为多个服务</h3><p>首先，将单体应用拆分为多个独立的微服务。每个微服务应专注于一个特定的业务功能，例如用户管理、订单处理、支付等。</p><p>每个微服务可能会拥有自己的数据库，以实现服务之间的解耦。</p><p>数据库可能需要分片或者复制以提高性能和容错性。</p><p>在微服务之间或微服务与数据库之间使用缓存层（如 Redis、Memcached）来加速数据访问和减少数据库负载。</p><p>使用分布式数据库（如 Cassandra、CockroachDB）来存储和管理海量数据。</p><p>对于文件或大数据对象，可以使用分布式对象存储（如 AWS S3、MinIO）来存储和访问。</p><h3 id="使用独立的代码库和包管理"><a href="#使用独立的代码库和包管理" class="headerlink" title="使用独立的代码库和包管理"></a>使用独立的代码库和包管理</h3><p>每个微服务应当拥有自己的代码库和独立的<code>package.json</code>文件。这使得它们可以独立管理依赖项，并能够使用不同的 Node.js 版本或第三方库。</p><h3 id="选择合适的通信方式"><a href="#选择合适的通信方式" class="headerlink" title="选择合适的通信方式"></a>选择合适的通信方式</h3><p>微服务之间需要通信。</p><p>微服务常见的通信方式：</p><ul><li>HTTP/RESTfull API：每个微服务暴露 RESTfull API 供其他服务调用。</li><li>消息队列（MQ）：可以使用 MQ 来异步传递消息，常用的 MQ 有 RabbitMQ、Apache Kafka、Redis Streams 等。</li><li>gRPC：是一种 RPC（远程过程调用）框架，适合高性能通信场景。</li></ul><h3 id="选择合适的-web-框架构建-RESTfull-微服务"><a href="#选择合适的-web-框架构建-RESTfull-微服务" class="headerlink" title="选择合适的 web 框架构建 RESTfull 微服务"></a>选择合适的 web 框架构建 RESTfull 微服务</h3><p>比如 Express 或者 Koa.js 等。</p><h3 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h3><p>可以使用微服务注册和发现工具来管理与发现这些微服务。</p><p>常用的：Consul、Eureka、etcd</p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>每个微服务拥有自己的配置，可以使用配置管理工具来管理配置。</p><p>常用的：Consul、Vault</p><h3 id="日志记录和监控"><a href="#日志记录和监控" class="headerlink" title="日志记录和监控"></a>日志记录和监控</h3><p>常用的日志聚合工具：ELK（Elasticsearch, Logstash, Kibana）</p><p>常用的监控工具：Prometheus、Grafana</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>可以将每个微服务打包成 Docker 容器，再使用 Docker Compose 或者 K8s 自动化部署、扩展、管理这些容器。</p><p>CI/CD：使用 Jenkins、GitLab CI、CircleCI 等工具实现自动化的构建、测试和部署流程。</p><p>蓝绿部署/金丝雀发布：在发布新版本时，采用蓝绿部署或金丝雀发布策略，减少发布风险。</p><h3 id="负载均衡和代理"><a href="#负载均衡和代理" class="headerlink" title="负载均衡和代理"></a>负载均衡和代理</h3><p>微服务层之间需要使用负载均衡器来实现流量分发，以实现高可用性和容错性。</p><p>常用的负载均衡器：HAProxy、Nginx、AWS ELB</p><p>还需要使用反向代理来分发来自 API 网关的请求到适当的微服务，常用 Nginx 反向代理。</p><h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h3><p>可以使用 API 网关来统一管理和路由所有微服务的请求。</p><p>API 网关可以处理请求路由、认证、限流。</p><p>常用的 API 网关：Nginx、Kong、Express Gateway 等。</p><h3 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h3><p>在分布式系统中可能会出现某个微服务失效。</p><p>可以使用熔断器比如 opossum 来防止级联故障，确保在某个微服务失败时，系统其他部分仍然可用。</p><hr><h2 id="Node-js微服务简单实例"><a href="#Node-js微服务简单实例" class="headerlink" title="Node.js微服务简单实例"></a>Node.js微服务简单实例</h2><ol><li>为微服务创建一个目录，用于存放所有的微服务。</li></ol><p>微服务项目目录结构：</p><pre><code>my-microservices-project/├── api-gateway/│   ├── package.json│   ├── index.js├── user-service/│   ├── package.json│   ├── index.js├── order-service/│   ├── package.json│   ├── index.js├── docker-compose.yml└── README.md</code></pre><ol start="2"><li><p>为每个微服务创建一个目录。</p></li><li><p>每个微服务拥有自己的目录以及<code>package.json</code>文件。</p></li></ol><figure class="highlight json"><figcaption><span>user-service/package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"user-service"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.17.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写微服务，每个微服务都相当于是一个Node.js项目。</li></ol><figure class="highlight js"><figcaption><span>user-service/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json([&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Alice'</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`User service running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>API Gateway</li></ol><p>创建<code>api-gateway/index.js</code>文件，用于路由客户端的请求到对应的微服务。</p><figure class="highlight js"><figcaption><span>api-gateway/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> proxy = httpProxy.createProxyServer();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    proxy.web(req, res, &#123; <span class="attr">target</span>: <span class="string">'http://localhost:3001'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/orders'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    proxy.web(req, res, &#123; <span class="attr">target</span>: <span class="string">'http://localhost:3002'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`API Gateway running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>启动微服务</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动gateway</span></span><br><span class="line"><span class="built_in">cd</span> api-gateway</span><br><span class="line">npm install</span><br><span class="line">node index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动user-service服务</span></span><br><span class="line"><span class="built_in">cd</span> user-service</span><br><span class="line">npm install</span><br><span class="line">node index.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动order-service服务</span></span><br><span class="line"><span class="built_in">cd</span> order-service</span><br><span class="line">npm install</span><br><span class="line">node index.js</span><br></pre></td></tr></table></figure><p>现在api-gateway和微服务已经运行了：</p><ul><li><code>http://localhost:3000</code>：运行了api-gateway，它将客户端请求路由到对应的微服务。</li><li><code>http://localhost:3001</code>：运行了user-service服务。</li><li><code>http://localhost:3002</code>：运行了order-service服务。</li></ul><ol start="7"><li>测试微服务</li></ol><p>使用postman或者cURL测试微服务。</p><ol start="8"><li>微服务容器化</li></ol><p>为每个服务创建<code>Dockerfile</code>文件，然后使用Docker Compose或者K8s来编排这些服务的容器。</p><p>这里使用Docker Compose。</p><p>第一步：为每个服务创建Dockerfile文件</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"index.js"</span>]</span></span><br></pre></td></tr></table></figure><p>第二步：使用Docker Compose，创建docker-compose.yml文件来编排服务容器</p><figure class="highlight yaml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">user-service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3001:3001"</span></span><br><span class="line">  <span class="attr">order-service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3002:3002"</span></span><br><span class="line">  <span class="attr">api-gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./api-gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br></pre></td></tr></table></figure><p>第三步：启动所有服务</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务是一种软件架构风格，在这种架构中，应用程序被构建为一组小的、独立的服务，每个服务负责处理特定的业务功能。这些服务可以独立开发、部署和扩展，并通过轻量级的通信机制（通常是 HTTP API）进行互相通信。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Kubernetes(K8s)学习笔记</title>
    <link href="https://herotiga.github.io/2024/08/30/kubernetes-k8s-notes/"/>
    <id>https://herotiga.github.io/2024/08/30/kubernetes-k8s-notes/</id>
    <published>2024-08-30T07:47:19.000Z</published>
    <updated>2024-08-30T15:02:16.970Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes(K8s)用于自动化部署、扩展和管理容器化应用程序。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>一个独立的、轻量级的可运行的包，包含应用程序和它的所有依赖。</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是K8s中的最小部署单位，他可以包含一个或者多个容器。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node就是K8s集群中的一台机器，可以包含一个或者多个Pod。</p><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>Cluster就是由多个Node组成的集群。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service为一组Pod提供持久的IP地址和负载均衡功能，使得Pod可以稳定的被外部访问。</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace是K8s中的逻辑隔离单元，用于将集群中的资源划分到不同的虚拟子集。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment定义应用程序的部署方式和策略，支持滚动更新和回滚操作。</p><h2 id="安装K8s"><a href="#安装K8s" class="headerlink" title="安装K8s"></a>安装K8s</h2><h3 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h3><p>Minikube是本地的K8s集群，用于开发和测试。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Minikube</span></span><br><span class="line">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Minikube</span></span><br><span class="line">minikube start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Minikube状态</span></span><br><span class="line">minikube status</span><br></pre></td></tr></table></figure><h3 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h3><p>kubectl是用于管理集群的命令行工具。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装kubectl</span></span><br><span class="line">curl -LO <span class="string">"https://dl.k8s.io/release/<span class="variable">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl"</span></span><br><span class="line">chmod +x kubectl</span><br><span class="line">sudo mv kubectl /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line">kubectl version --client</span><br></pre></td></tr></table></figure><h2 id="创建K8s部署（Deployment）"><a href="#创建K8s部署（Deployment）" class="headerlink" title="创建K8s部署（Deployment）"></a>创建K8s部署（Deployment）</h2><p>创建Deployment：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个nginx部署</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建的Deployment和Pod</span></span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>暴露服务：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对外暴露nginx部署</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=NodePort --port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看部署的服务信息</span></span><br><span class="line">kubectl get service nginx</span><br><span class="line">kubectl get services</span><br><span class="line">minikube service nginx --url</span><br></pre></td></tr></table></figure><h2 id="扩展和更新"><a href="#扩展和更新" class="headerlink" title="扩展和更新"></a>扩展和更新</h2><h3 id="扩展Pod副本数"><a href="#扩展Pod副本数" class="headerlink" title="扩展Pod副本数"></a>扩展Pod副本数</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment nginx --replicas=3</span><br></pre></td></tr></table></figure><h3 id="更新容器镜像"><a href="#更新容器镜像" class="headerlink" title="更新容器镜像"></a>更新容器镜像</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment/nginx nginx=nginx:1.19</span><br></pre></td></tr></table></figure><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx</span><br></pre></td></tr></table></figure><h3 id="删除服务和部署"><a href="#删除服务和部署" class="headerlink" title="删除服务和部署"></a>删除服务和部署</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete service nginx</span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes(K8s)用于自动化部署、扩展和管理容器化应用程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://herotiga.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="https://herotiga.github.io/2024/08/30/docker-notes/"/>
    <id>https://herotiga.github.io/2024/08/30/docker-notes/</id>
    <published>2024-08-30T07:00:57.000Z</published>
    <updated>2024-09-02T07:48:34.895Z</updated>
    
    <content type="html"><![CDATA[<p><code>Docker</code>是容器化平台，可以构建、打包、部署和运行应用程序。</p><p>Docker可以将应用程序及依赖打包成一个轻量级的便于移植的容器，然后部署到支持Docker的平台。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参照官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>Docker镜像是一个只读的模板，包含了创建Docker容器的指令。</p><p>还可以基于一个镜像来创建另一个镜像并在此基础上添加一些自定义配置。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>Docker容器是一个独立的环境，它基于Docker镜像创建而来，Docker容器是镜像的实例，容器包含了应用程序及其运行时。</p><p>容器之间是相互隔离的，每个容器都有自己的文件系统。可以将容器看作是轻量的、便于移植的虚拟机。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile是一个文本文件，包含了一系列指令，他告诉Docker如何构建镜像。</p><h3 id="Docker-Volume"><a href="#Docker-Volume" class="headerlink" title="Docker Volume"></a>Docker Volume</h3><p>Docker Volume是Docker提供的持久化存储机制。</p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>Docker Hub是一个存储Docker镜像的公共仓库，可以上传或者下载镜像。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker版本</span></span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull &lt;image_name&gt;</span><br><span class="line"><span class="comment"># 例如：拉取最新的Ubuntu镜像</span></span><br><span class="line">docker pull ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -it --name &lt;container_name&gt; &lt;image_name&gt;</span><br><span class="line"><span class="comment"># 例如：运行一个基于Ubuntu的容器</span></span><br><span class="line">docker run -it --name my_ubuntu ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop &lt;container_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start &lt;container_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入运行中的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container_name&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm &lt;container_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi &lt;image_name&gt;</span><br></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>在项目目录下创建一个Dockerfile来创建镜像。</p><p>Dockerfile：</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的Node.js镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制项目文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用程序的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"app.js"</span>]</span></span><br></pre></td></tr></table></figure><p>带有TypeScript编译阶段的Dockerfile：</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建阶段</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span> AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设项目使用 TypeScript，首先编译</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产阶段</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/package*.json ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/dist ./dist</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/node_modules ./node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"dist/app.js"</span>]</span></span><br></pre></td></tr></table></figure><p>那么，上面的<code>RUN</code>和<code>CMD</code>有什么区别？</p><p>RUN是在image文件的构建阶段执行的，CMD是在容器启动后执行的。<br>一个Dockerfile可以包含多个RUN，但是只能包含一个CMD。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .代表Dockerfile所在目录</span></span><br><span class="line">docker build -t my-node-app .</span><br></pre></td></tr></table></figure><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地的3000端口映射到容器的3000端口</span></span><br><span class="line">docker run -p 3000:3000 my-node-app</span><br></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>比如对于数据库容器，每次部署数据库容器都会删除原来的容器，故而容器内的数据也会被删除。</p><p>可以将数据库的数据目录挂载到主机的一个目录（或者说映射），这样就不会在部署新容器后丢失数据。</p><p><img src="https://gcore.jsdelivr.net/gh/herotiga/cdn@master/img/article/docker-volume.webp" alt="Docker Volume"></p><h3 id="使用Docker-Volume"><a href="#使用Docker-Volume" class="headerlink" title="使用Docker Volume"></a>使用Docker Volume</h3><ol><li>创建Docker Volume</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create mysql_data</span><br></pre></td></tr></table></figure><ol start="2"><li>启动MySQL并挂载Volume到容器内目录</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将mysql_data这个卷挂载到容器内的/var/lib/mysql，这个目录是MySQL数据库默认的存储位置</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=my-secret-pw \</span><br><span class="line">  -v mysql_data:/var/lib/mysql \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure><h3 id="使用主机目录挂载"><a href="#使用主机目录挂载" class="headerlink" title="使用主机目录挂载"></a>使用主机目录挂载</h3><p>还可以直接将主机上的一个目录挂载到容器的MySQL数据存储目录。</p><ol><li>创建主机目录</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /my/mysql_data</span><br></pre></td></tr></table></figure><ol start="2"><li>启动MySQL容器并挂载目录</li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=my-secret-pw \</span><br><span class="line">  -v /my/own/datadir:/var/lib/mysql \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose是一个用于定义和管理多容器Docker应用的工具。也可以使用k8s管理Docker容器。</p><p>可以使用<code>docker-compose.yml</code>文件来定义应用的服务、网络和卷等。</p><figure class="highlight yml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-node-app</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br></pre></td></tr></table></figure><p>构建并启动<code>docker-compose.yml</code>中的所有服务：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line">docker-compose up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止应用</span></span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.docker.com/">https://www.docker.com/</a></li><li><a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;是容器化平台，可以构建、打包、部署和运行应用程序。&lt;/p&gt;
&lt;p&gt;Docker可以将应用程序及依赖打包成一个轻量级的便于移植的容器，然后部署到支持Docker的平台。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://herotiga.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js开发笔记——Mongoose（ODM库）</title>
    <link href="https://herotiga.github.io/2024/08/29/nodejs-odm-mongoose/"/>
    <id>https://herotiga.github.io/2024/08/29/nodejs-odm-mongoose/</id>
    <published>2024-08-29T10:40:32.000Z</published>
    <updated>2024-08-30T06:33:32.757Z</updated>
    
    <content type="html"><![CDATA[<p><code>Mongoose</code>是 Node.js的ODM库。</p><p>和Sequelize类似，Mongoose提供了node.js对于MongoDB进行操作的便利。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S mongoose</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>连接MongoDB</li></ol><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"></span><br><span class="line">mongoose</span><br><span class="line">  .connect(<span class="string">"mongodb://localhost:27017/mydatabase"</span>, &#123;</span><br><span class="line">    useNewUrlParser: <span class="literal">true</span>,</span><br><span class="line">    useUnifiedTopology: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Connected to MongoDB"</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(<span class="string">"Could not connect to MongoDB..."</span>, err));</span><br></pre></td></tr></table></figure><ol start="2"><li>定义Schema</li></ol><p>Mongoose中使用Schema来定义文档结构。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    age: <span class="built_in">Number</span>,</span><br><span class="line">    email: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">unique</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    created_at: &#123; <span class="attr">type</span>: <span class="built_in">Date</span>, <span class="attr">default</span>: <span class="built_in">Date</span>.now &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>创建模型Model</li></ol><p>使用以上创建好的Schema来创建模型Model。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>, userSchema);</span><br></pre></td></tr></table></figure><ol start="4"><li>创建和保存</li></ol><p>使用上面创建好的Model可以对数据进行CRUD。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建user记录</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">    name: <span class="string">'John Doe'</span>,</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">    email: <span class="string">'johndoe@example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存user记录</span></span><br><span class="line">user.save()</span><br><span class="line">    .then(<span class="function"><span class="params">doc</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User saved:'</span>, doc))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error saving user:'</span>, err));</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭连接</li></ol><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connection.close();</span><br></pre></td></tr></table></figure><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><ul><li>Create</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">    name: <span class="string">'John Doe'</span>,</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">    email: <span class="string">'johndoe@example.com'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Read</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.findOne(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User found:'</span>, user))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error finding user:'</span>, err));</span><br><span class="line"></span><br><span class="line">User.find(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Users found:'</span>, users))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error finding users:'</span>, err));</span><br></pre></td></tr></table></figure><ul><li>Update</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User.updateOne(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">31</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User updated:'</span>, result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error updating user:'</span>, err));</span><br><span class="line"></span><br><span class="line">User.updateMany(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">31</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User updated:'</span>, result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error updating user:'</span>, err));</span><br><span class="line"></span><br><span class="line">User.findByIdAndUpdate(userId, &#123; <span class="attr">age</span>: <span class="number">27</span> &#125;, &#123; <span class="attr">new</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Updated user:'</span>, user))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error updating user:'</span>, err));</span><br></pre></td></tr></table></figure><ul><li>Delete</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.deleteOne(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'User deleted:'</span>, result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error deleting user:'</span>, err));</span><br><span class="line"></span><br><span class="line">User.findByIdAndDelete(userId)</span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Deleted user:'</span>, user))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error deleting user:'</span>, err));</span><br></pre></td></tr></table></figure><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Mongoose还支持使用中间件（middleware）来执行一些预处理或后处理操作。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在保存之前执行一些代码</span></span><br><span class="line">userSchema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Before saving a user'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mongoosejs.net/">https://mongoosejs.net/</a></li><li><a href="https://mongoosejs.com/">https://mongoosejs.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Mongoose&lt;/code&gt;是 Node.js的ODM库。&lt;/p&gt;
&lt;p&gt;和Sequelize类似，Mongoose提供了node.js对于MongoDB进行操作的便利。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js开发笔记——Sequelize（ORM库）</title>
    <link href="https://herotiga.github.io/2024/08/29/nodejs-orm-sequelize/"/>
    <id>https://herotiga.github.io/2024/08/29/nodejs-orm-sequelize/</id>
    <published>2024-08-29T02:37:10.000Z</published>
    <updated>2024-08-29T11:07:46.533Z</updated>
    
    <content type="html"><![CDATA[<p>在 Node.js 项目中可以使用<code>Sequelize</code>这个<code>ORM</code>（对象关系映射）库来将项目中的 Model 和数据库表进行映射以及可以让我们可以使用 JavaScript 的对象和方法来操作数据库（CRUD），而不必编写原生 SQL 语句。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-Sequelize"><a href="#安装-Sequelize" class="headerlink" title="安装 Sequelize"></a>安装 Sequelize</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S sequelize</span><br></pre></td></tr></table></figure><h3 id="安装对应数据库驱动"><a href="#安装对应数据库驱动" class="headerlink" title="安装对应数据库驱动"></a>安装对应数据库驱动</h3><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装MySQL驱动</span></span><br><span class="line">npm install -S mysql2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装PostgreSQL驱动</span></span><br><span class="line">npm install -S pg pg-hstore</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装SQLite驱动</span></span><br><span class="line">npm install -S sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装MSSQL驱动</span></span><br><span class="line">npm install -S tedious</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装MariaDB驱动</span></span><br><span class="line">npm install -S mariadb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Oracle数据库驱动</span></span><br><span class="line">npm install -S oracledb</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Sequelize提供的大多数方法都是异步的，会返回<code>Promise</code>，所以可以使用Promise API。</p><h3 id="创建-Sequelize-实例"><a href="#创建-Sequelize-实例" class="headerlink" title="创建 Sequelize 实例"></a>创建 Sequelize 实例</h3><p>创建一个Sequelize实例并连接到数据库：</p><figure class="highlight js"><figcaption><span>models/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Sequelize &#125; = <span class="built_in">require</span>(<span class="string">"sequelize"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Sequelize实例，连接到MySQL数据库</span></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">"database_name"</span>, <span class="string">"username"</span>, <span class="string">"password"</span>, &#123;</span><br><span class="line">  host: <span class="string">"localhost"</span>,</span><br><span class="line">  dialect: <span class="string">"mysql"</span>, <span class="comment">// 选择数据库类型：'mysql' | 'postgres' | 'sqlite' | 'mssql'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试连接是否成功</span></span><br><span class="line">sequelize</span><br><span class="line">  .authenticate()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Connection has been established successfully."</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Unable to connect to the database:"</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出Sequelize实例变量</span></span><br><span class="line"><span class="built_in">module</span>.exports = sequelize;</span><br></pre></td></tr></table></figure><h3 id="定义模型（Model）"><a href="#定义模型（Model）" class="headerlink" title="定义模型（Model）"></a>定义模型（Model）</h3><p>在 Sequelize 中，模型代表数据库中的表。<br>可以通过定义模型来映射数据库表及其字段。</p><figure class="highlight js"><figcaption><span>models/user.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; DataTypes &#125; = <span class="built_in">require</span>(<span class="string">"sequelize"</span>);</span><br><span class="line"><span class="comment">// 引入前面创建的 Sequelize 实例</span></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="built_in">require</span>(<span class="string">"./index"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义User模型</span></span><br><span class="line"><span class="keyword">const</span> User = sequelize.define(</span><br><span class="line">  <span class="string">"User"</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">      unique: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    email: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">      unique: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    tableName: <span class="string">"users"</span>, <span class="comment">// 自定义表名，如果不指定，Sequelize 会自动将模型名转换为复数形式作为表名</span></span><br><span class="line">    timestamps: <span class="literal">true</span>, <span class="comment">// 自动添加 createdAt 和 updatedAt 字段</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = User;</span><br></pre></td></tr></table></figure><h3 id="同步模型与数据库"><a href="#同步模型与数据库" class="headerlink" title="同步模型与数据库"></a>同步模型与数据库</h3><p>在项目启动时同步模型和数据库。</p><p>在项目入口 js 文件中添加：</p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelize = <span class="built_in">require</span>(<span class="string">"./models/index"</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">"./models/user"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步模型</span></span><br><span class="line">sequelize</span><br><span class="line">  .sync(&#123; <span class="attr">force</span>: <span class="literal">false</span> &#125;) <span class="comment">// &#123; force: true &#125; 会先删除表然后重新创建（慎用）</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Database &amp; tables created!"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to sync database:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h3><p>可以调用模型的 CRUD 方法操作数据库。</p><ul><li>Create</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User.create(&#123;</span><br><span class="line">  username: <span class="string">"john_doe"</span>,</span><br><span class="line">  password: <span class="string">"secret123"</span>,</span><br><span class="line">  email: <span class="string">"john@example.com"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"User created:"</span>, user.toJSON());</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to create user:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>Read</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">User.findOne(&#123; <span class="attr">where</span>: &#123; <span class="attr">username</span>: <span class="string">"john_doe"</span> &#125; &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"User found:"</span>, user.toJSON());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"User not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to find user:"</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">User.findAll()</span><br><span class="line">  .then(<span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"All users:"</span>, <span class="built_in">JSON</span>.stringify(users, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to find users:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>Update</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.update(&#123; <span class="attr">password</span>: <span class="string">"newpassword123"</span> &#125;, &#123; <span class="attr">where</span>: &#123; <span class="attr">username</span>: <span class="string">"john_doe"</span> &#125; &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">rowsUpdated</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Number of rows updated:"</span>, rowsUpdated);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to update user:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>Delete</li></ul><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.destroy(&#123; <span class="attr">where</span>: &#123; <span class="attr">username</span>: <span class="string">"john_doe"</span> &#125; &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">rowsDeleted</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Number of rows deleted:"</span>, rowsDeleted);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to delete user:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>默认情况下，Sequelize将记录控制台执行的每个SQL查询。可以使用<code>options.logging</code>参数来自定义每次 Sequelize记录某些内容时将执行的函数。默认值为<code>console.log</code>，使用该值时仅显示日志函数调用的第一个参数。例如，对于查询日志记录，第一个参数是原始查询，第二个参数(默认情况下是隐藏的)是Sequelize对象。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">'sqlite::memory:'</span>, &#123;</span><br><span class="line">  <span class="comment">// 选择一种日志记录参数</span></span><br><span class="line">  logging: <span class="built_in">console</span>.log,                  <span class="comment">// 默认值,显示日志函数调用的第一个参数</span></span><br><span class="line">  logging: <span class="function">(<span class="params">...msg</span>) =&gt;</span> <span class="built_in">console</span>.log(msg), <span class="comment">// 显示所有日志函数调用参数</span></span><br><span class="line">  logging: <span class="literal">false</span>,                        <span class="comment">// 禁用日志记录</span></span><br><span class="line">  logging: <span class="function"><span class="params">msg</span> =&gt;</span> logger.debug(msg),     <span class="comment">// 使用自定义记录器(例如Winston 或 Bunyan),显示第一个参数</span></span><br><span class="line">  logging: logger.debug.bind(logger)     <span class="comment">// 使用自定义记录器的另一种方法,显示所有消息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="关系映射"><a href="#关系映射" class="headerlink" title="关系映射"></a>关系映射</h3><p>Sequelize 支持定义表之间的关系（一对一、一对多、多对多）。</p><p>定义<code>User</code>和<code>Post</code>之间为一对多的关系：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Post = sequelize.define(<span class="string">"Post"</span>, &#123;</span><br><span class="line">  title: DataTypes.STRING,</span><br><span class="line">  content: DataTypes.TEXT,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对多关系：一个用户可以有多个帖子</span></span><br><span class="line">User.hasMany(Post);</span><br><span class="line">Post.belongsTo(User);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在同步时，Sequelize 会自动设置外键</span></span><br><span class="line">sequelize.sync();</span><br></pre></td></tr></table></figure><h3 id="查询生成器"><a href="#查询生成器" class="headerlink" title="查询生成器"></a>查询生成器</h3><p>Sequelize 支持复杂的查询构建与聚合操作，可以轻松实现分页、排序、分组等操作。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User.findAll(&#123;</span><br><span class="line">  where: &#123; <span class="attr">email</span>: &#123; [Op.like]: <span class="string">"%@example.com"</span> &#125; &#125;,</span><br><span class="line">  order: [[<span class="string">"createdAt"</span>, <span class="string">"DESC"</span>]],</span><br><span class="line">  limit: <span class="number">10</span>,</span><br><span class="line">  offset: <span class="number">20</span>,</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Paged users:"</span>, <span class="built_in">JSON</span>.stringify(users, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Failed to retrieve users:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="事务处理（Transactions）"><a href="#事务处理（Transactions）" class="headerlink" title="事务处理（Transactions）"></a>事务处理（Transactions）</h3><p>通过<code>sequelize.transaction()</code>来管理事务，确保操作的原子性。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sequelize</span><br><span class="line">  .transaction(<span class="keyword">async</span> (t) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.create(</span><br><span class="line">      &#123;</span><br><span class="line">        username: <span class="string">"jane_doe"</span>,</span><br><span class="line">        password: <span class="string">"password123"</span>,</span><br><span class="line">        email: <span class="string">"jane@example.com"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">transaction</span>: t &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Post.create(</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">"Jane's first post"</span>,</span><br><span class="line">        content: <span class="string">"This is Jane's first post"</span>,</span><br><span class="line">        userId: user.id,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">transaction</span>: t &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Transaction has been committed"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Transaction has been rolled back:"</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="验证与钩子（Hooks）"><a href="#验证与钩子（Hooks）" class="headerlink" title="验证与钩子（Hooks）"></a>验证与钩子（Hooks）</h3><p>Sequelize 提供内置的验证机制，并允许你定义生命周期钩子，在模型操作前后执行代码。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = sequelize.define(</span><br><span class="line">  <span class="string">"User"</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">      unique: <span class="literal">true</span>,</span><br><span class="line">      validate: &#123;</span><br><span class="line">        len: [<span class="number">4</span>, <span class="number">20</span>], <span class="comment">// 验证用户名长度在 4 到 20 个字符之间</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    hooks: &#123;</span><br><span class="line">      beforeCreate: <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在创建用户前对密码进行哈希处理</span></span><br><span class="line">        user.password = hashPassword(user.password);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="配置与环境变量"><a href="#配置与环境变量" class="headerlink" title="配置与环境变量"></a>配置与环境变量</h3><p>可以通过环境变量或配置文件管理不同环境下的数据库连接配置：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(</span><br><span class="line">  process.env.DB_NAME,</span><br><span class="line">  process.env.DB_USER,</span><br><span class="line">  process.env.DB_PASSWORD,</span><br><span class="line">  &#123;</span><br><span class="line">    host: process.env.DB_HOST,</span><br><span class="line">    dialect: <span class="string">"mysql"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="迁移与种子数据"><a href="#迁移与种子数据" class="headerlink" title="迁移与种子数据"></a>迁移与种子数据</h3><p>Sequelize CLI工具支持数据库迁移和种子数据管理。可以通过命令行生成和应用迁移来管理数据库的演进。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize-cli init</span><br><span class="line">npx sequelize-cli model:generate --name User --attributes username:string,email:string</span><br><span class="line">npx sequelize-cli db:migrate</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.sequelize.cn/">https://www.sequelize.cn/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Node.js 项目中可以使用&lt;code&gt;Sequelize&lt;/code&gt;这个&lt;code&gt;ORM&lt;/code&gt;（对象关系映射）库来将项目中的 Model 和数据库表进行映射以及可以让我们可以使用 JavaScript 的对象和方法来操作数据库（CRUD），而不必编写原生 SQL 语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Tree-Shaking是什么？</title>
    <link href="https://herotiga.github.io/2024/08/26/Tree-Shaking/"/>
    <id>https://herotiga.github.io/2024/08/26/Tree-Shaking/</id>
    <published>2024-08-25T16:39:48.000Z</published>
    <updated>2024-08-27T01:38:43.592Z</updated>
    
    <content type="html"><![CDATA[<p><code>Tree-Shaking</code>是一种代码优化技术，其通过删除未使用的代码来减少最终打包出来的文件的大小，从而提高程序的加载速度和性能。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在webpack5的<code>production</code>环境中默认开启了Tree-Shaking功能，也就是build出来的代码会删除无用的代码。</p><p>无用的代码包括下面几类：</p><ul><li>不可能执行的代码</li><li>定义了但是没有引用的变量</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.webpackjs.com/guides/tree-shaking/#root">https://www.webpackjs.com/guides/tree-shaking/#root</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Tree-Shaking&lt;/code&gt;是一种代码优化技术，其通过删除未使用的代码来减少最终打包出来的文件的大小，从而提高程序的加载速度和性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="https://herotiga.github.io/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>Android开发笔记</title>
    <link href="https://herotiga.github.io/2024/07/08/Android-notes/"/>
    <id>https://herotiga.github.io/2024/07/08/Android-notes/</id>
    <published>2024-07-08T06:38:53.000Z</published>
    <updated>2024-08-25T11:37:51.672Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发笔记</p><a id="more"></a><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>阅读Java文档。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>阅读Kotlin文档。</p><h2 id="Android应用结构和基本组件"><a href="#Android应用结构和基本组件" class="headerlink" title="Android应用结构和基本组件"></a>Android应用结构和基本组件</h2><p>包括四大基本组件Activity、Service、BroadcastReceiver、ContentProvider以及Fragment、Intent、View、Layout、Resources、Manifest等。</p><p>可以查看Android官方文档学习。</p><h2 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h2><p>包括官方文档和Material Design。</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>包括SharedPreferences、读写文件、SQLite本地数据库、Room持久库。</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>包括Retrofit和Volley等库。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>包括内存管理、电池优化、响应速度优化等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android开发笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://herotiga.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Learning MongoDB</title>
    <link href="https://herotiga.github.io/2024/06/28/MongoDB-notes/"/>
    <id>https://herotiga.github.io/2024/06/28/MongoDB-notes/</id>
    <published>2024-06-28T14:17:15.000Z</published>
    <updated>2024-08-25T10:40:15.912Z</updated>
    
    <content type="html"><![CDATA[<p><code>MongoDB</code> is a type of NoSQL database suitable for storing large-scale data.</p><p>MongoDB is a document based database, the data is stored in a JSON-like document format.</p><p>MongoDB uses Collections to organize documents, and each document is composed of key-value pairs.</p><a id="more"></a><h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><ol><li><p>Database: A container for storing data, similar to a database in relational database.</p></li><li><p>Collection: A collection in database, similar to a table in relational database.</p></li><li><p>Document: A data record in a collection, similar to a row in relational database, stored in BSON format.</p></li></ol><article class="message is-info"><div class="message-body"><p>MongoDB stores data as a document, with a data structure consisting of key-value pairs. The document is similar to a JSON object, and field values can contain other documents, arrays, and document arrays.</p></div></article><p>mapping:</p><table><thead><tr><th>SQL Concept</th><th>MongoDB Concept</th><th>Remark</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>database</td></tr><tr><td>table</td><td>collection</td><td>databse table/collection</td></tr><tr><td>row</td><td>document</td><td>data record</td></tr><tr><td>column</td><td>field</td><td>data field</td></tr><tr><td>index</td><td>index</td><td>index</td></tr><tr><td>table joins</td><td></td><td>MongoDB not supported</td></tr><tr><td>primary key</td><td>primary key</td><td>MongoDB will set _id to primary key</td></tr></tbody></table><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install community edition</span></span><br><span class="line">brew install mongodb-community</span><br><span class="line"></span><br><span class="line"><span class="comment"># start on startup</span></span><br><span class="line">brew services start mongodb-community</span><br></pre></td></tr></table></figure><h2 id="MongoDB-Shell"><a href="#MongoDB-Shell" class="headerlink" title="MongoDB Shell"></a>MongoDB Shell</h2><article class="message is-info"><div class="message-body"><p>MongoDB Shell is a interactive interface provided by official, allowing users to interact with the MongoDB database, execute commands, and operate the database.</p><p>The MongoDB Shell is based on JavaScript and allows users to operate the MongoDB database directly from the command line or within scripts using the JavaScript language.</p></div></article><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start mongo shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># in older versions</span></span><br><span class="line">mongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># in the new version</span></span><br><span class="line">mongosh</span><br><span class="line"></span><br><span class="line"><span class="comment"># connect to a remote mongodb server</span></span><br><span class="line">mongosh --host &lt;hostname&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure><h2 id="Basic-Operations"><a href="#Basic-Operations" class="headerlink" title="Basic Operations"></a>Basic Operations</h2><figure class="highlight bash"><figcaption><span>mongosh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show current database</span></span><br><span class="line">db;</span><br><span class="line"></span><br><span class="line"><span class="comment"># show database list</span></span><br><span class="line">show dbs;</span><br><span class="line"></span><br><span class="line"><span class="comment"># switch to the specified database</span></span><br><span class="line">use &lt;db_name&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute query operation</span></span><br><span class="line">db.&lt;collection_name&gt;.find();</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert a document</span></span><br><span class="line">db.&lt;collection_name&gt;.insertOne(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># update a document</span></span><br><span class="line">db.&lt;collection_name&gt;.updateOne(&#123;...&#125;, &#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete a document</span></span><br><span class="line">db.&lt;collection_name&gt;.deleteOne(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit shell</span></span><br><span class="line">quit()</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="MongoDB-Tools"><a href="#MongoDB-Tools" class="headerlink" title="MongoDB Tools"></a>MongoDB Tools</h2><ol><li>MongoDB Compass: A free GUI tool.</li><li>Navicat: A paid GUI tool.</li><li>Studio 3T: A paid GUI tool, with a good CRUD operations experience.</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.mongodb.com/docs/manual/introduction/">https://www.mongodb.com/docs/manual/introduction/</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;MongoDB&lt;/code&gt; is a type of NoSQL database suitable for storing large-scale data.&lt;/p&gt;
&lt;p&gt;MongoDB is a document based database, the data is stored in a JSON-like document format.&lt;/p&gt;
&lt;p&gt;MongoDB uses Collections to organize documents, and each document is composed of key-value pairs.&lt;/p&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="https://herotiga.github.io/categories/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js开发笔记——EventEmitter</title>
    <link href="https://herotiga.github.io/2024/06/03/EventEmitter/"/>
    <id>https://herotiga.github.io/2024/06/03/EventEmitter/</id>
    <published>2024-06-03T05:23:20.000Z</published>
    <updated>2024-08-25T17:09:09.075Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js使用的是事件驱动模型。</p><p>可以通过<code>EventEmitter</code>来实现事件的监听和触发，Node.js中其他的异步API也都是通过继承EventEmitter实现的。</p><a id="more"></a><h2 id="addListener-removeListener"><a href="#addListener-removeListener" class="headerlink" title="addListener/removeListener"></a>addListener/removeListener</h2><p>为指定的事件添加一个监听器，可以为同一个事件添加多个监听器。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> events = <span class="built_in">require</span>(<span class="string">'node:events'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建EventEmitter实例</span></span><br><span class="line"><span class="keyword">const</span> ee = <span class="keyword">new</span> events.EventEmitter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为同一个事件添加多个监听器</span></span><br><span class="line">ee.addListener(<span class="string">'event_name'</span>, handler1)</span><br><span class="line">ee.addListener(<span class="string">'event_name'</span>, handler2)</span><br><span class="line">ee.addListener(<span class="string">'event_name'</span>, handler3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件上指定的监听器</span></span><br><span class="line">ee.removeListener(<span class="string">'event_name'</span>, handler1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件上所有的监听器</span></span><br><span class="line">ee.removeAllListener(<span class="string">'event_name'</span>)</span><br></pre></td></tr></table></figure><h2 id="on-emit"><a href="#on-emit" class="headerlink" title="on/emit"></a>on/emit</h2><p>on方法和addListener是一样的，on是简写。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听事件，可以接受参数</span></span><br><span class="line">ee.on(<span class="string">'event_name'</span>, (arg1, arg2, ...) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，可以携带参数</span></span><br><span class="line">ee.emit(<span class="string">'event_name'</span>, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><p>可以使用once为事件添加单词监听器，监听器最多只会执行一次。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ee.once(<span class="string">'event_name'</span>, handler)</span><br></pre></td></tr></table></figure><h2 id="setMaxListeners-defaultMaxListeners"><a href="#setMaxListeners-defaultMaxListeners" class="headerlink" title="setMaxListeners/defaultMaxListeners"></a>setMaxListeners/defaultMaxListeners</h2><p>EventEmitter默认限制了给同一个事件最大只能添加10个监听器，使用setMaxListeners可以指定限制数量。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ee.setMaxListeners(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>或者可以直接设置默认最大数量：</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为0解除限制</span></span><br><span class="line">ee.defaultMaxListeners = <span class="number">0</span></span><br><span class="line">ee.defaultMaxListeners = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="listeners"><a href="#listeners" class="headerlink" title="listeners"></a>listeners</h2><p>获取指定事件上绑定的所有的监听器。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listeners = ee.listeners(<span class="string">'event_name'</span>)</span><br></pre></td></tr></table></figure><h2 id="newListener事件"><a href="#newListener事件" class="headerlink" title="newListener事件"></a>newListener事件</h2><p>EventEmitter中的特殊事件。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ee.on(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Event name: <span class="subst">$&#123;event&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Listener function: <span class="subst">$&#123;listener&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="removeListener事件"><a href="#removeListener事件" class="headerlink" title="removeListener事件"></a>removeListener事件</h2><p>EventEmitter中的特殊事件。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ee.on(<span class="string">'removeListener'</span>, (event, listener) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Event name: <span class="subst">$&#123;event&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Listener function: <span class="subst">$&#123;listener&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h2><p>EventEmitter中的特殊事件。</p><figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ee.on(<span class="string">'error'</span>, (arg1, arg2, ...) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ee.emit(<span class="string">'error'</span>, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>在实际使用时，我们一般通过自定义类继承EventEmitter来实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js使用的是事件驱动模型。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;EventEmitter&lt;/code&gt;来实现事件的监听和触发，Node.js中其他的异步API也都是通过继承EventEmitter实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://herotiga.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么计算机无法产生真随机数</title>
    <link href="https://herotiga.github.io/2024/06/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%97%A0%E6%B3%95%E4%BA%A7%E7%94%9F%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>https://herotiga.github.io/2024/06/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%97%A0%E6%B3%95%E4%BA%A7%E7%94%9F%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0/</id>
    <published>2024-06-01T15:28:07.000Z</published>
    <updated>2024-08-25T06:12:24.276Z</updated>
    
    <content type="html"><![CDATA[<p>为什么计算机无法产生真随机数？</p><a id="more"></a><hr><h2 id="为什么计算机只能产生伪随机数"><a href="#为什么计算机只能产生伪随机数" class="headerlink" title="为什么计算机只能产生伪随机数"></a>为什么计算机只能产生伪随机数</h2><p>现有计算机编程语言中产生随机数的算法都是<strong>伪随机数生成器</strong>（PRNG）。</p><h3 id="算法是确定的"><a href="#算法是确定的" class="headerlink" title="算法是确定的"></a>算法是确定的</h3><p>计算机的随机数是由特定算法产生的，然而这些算法是确定的，对于这些算法输入相同的参数就会输出相同的结果。</p><p>故而随机数这个结果是由输入值确定的，所以计算机产生的是<strong>伪随机数</strong>（Pseudo-random Number）。</p><p>一般使用的算法有线性<strong>同余生成器</strong>（LCG）或<strong>梅森旋转器</strong>（Mersenne Twister）。</p><h3 id="算法输出的结果是有限的"><a href="#算法输出的结果是有限的" class="headerlink" title="算法输出的结果是有限的"></a>算法输出的结果是有限的</h3><p>由于计算机存在浮点数精度限制以及数字长度限制，所以输入到算法后输入的随机数也一定是精度有限的和长度有限的。</p><h3 id="种子值决定了算法输出的结果"><a href="#种子值决定了算法输出的结果" class="headerlink" title="种子值决定了算法输出的结果"></a>种子值决定了算法输出的结果</h3><p>伪随机数生成器产生的结果只依赖于种子值和算法，所以如果种子值是可以预测的，那么产生的随机数自然也是可以预测的。</p><hr><h2 id="如何产生真随机数"><a href="#如何产生真随机数" class="headerlink" title="如何产生真随机数"></a>如何产生真随机数</h2><p>获得一个<strong>真随机数生成器</strong>（TRNG）的关键在于如何获得一个不可预测的种子值，那么如何获得一个不可预测的种子值呢？</p><p>计算机作为一个由数字电路构成的二进制电路是高度可预测的，故而计算机本身是无法产生随机的种子值的。</p><p><strong>想要获得不可预测的种子值只能通过随机的物理事件。</strong></p><p>在现有的物理学体系中可以产生随机事件的方式有下面几种：</p><h3 id="热噪声"><a href="#热噪声" class="headerlink" title="热噪声"></a>热噪声</h3><p>热噪声是由导体内电子的热运动引起的随机电流或电压波动。通过测量这些波动，可以产生随机数。<br>例如，一个电阻器或半导体器件在工作时会产生热噪声，通过放大和量化这些信号就可以得到随机数。</p><h3 id="光电二极管噪声"><a href="#光电二极管噪声" class="headerlink" title="光电二极管噪声"></a>光电二极管噪声</h3><p>光电二极管在没有光照的情况下内部任然会有热运动和量子效应产生的噪声，通过放大和量化这些信号可以得到随机数。</p><h3 id="量子力学中的不确定性"><a href="#量子力学中的不确定性" class="headerlink" title="量子力学中的不确定性"></a>量子力学中的不确定性</h3><p>根据海森堡不确定性原理，量子的位置和动量不能同时被精确测量，这两个量是随机的。<br>量子的波函数坍塌是随机的。<br>光量子在通过一个半反半透镜时是反射还是透过是随机的。<br>光量子在通过量子分束器时通过的路径是随机的。</p><h3 id="放射性元素衰变"><a href="#放射性元素衰变" class="headerlink" title="放射性元素衰变"></a>放射性元素衰变</h3><p>放射性元素的衰变间隔是随机的。</p><h3 id="激光相位噪声"><a href="#激光相位噪声" class="headerlink" title="激光相位噪声"></a>激光相位噪声</h3><p>激光产生的光具有内在的量子噪声，通过放大和量化光信号可以得到随机数。</p><h3 id="混沌系统"><a href="#混沌系统" class="headerlink" title="混沌系统"></a>混沌系统</h3><p>作为经典物理学中的最后一朵乌云，混沌系统对于初始条件的微小变化可以导致系统一段时间后具有完全不可预测的特性，可以量化后产生随机数。混沌系统比如湍流、混沌震荡器。</p><p>使用以上随机事件进行量化后作为种子值输入算法即可获取到真随机数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么计算机无法产生真随机数？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://herotiga.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>寻找peak元素</title>
    <link href="https://herotiga.github.io/2024/05/29/peak/"/>
    <id>https://herotiga.github.io/2024/05/29/peak/</id>
    <published>2024-05-29T05:25:19.000Z</published>
    <updated>2024-08-25T06:12:24.595Z</updated>
    
    <content type="html"><![CDATA[<p>面试问到的算法题。</p><a id="more"></a><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定一个数组（元素为数字），数组内的值相邻的两个元素值不同，如果一个元素的左右两边的元素值都小于该元素，则该元素为peak元素（对于两个端点元素一边符合即可）。</p><p>要求返回一个peak元素即可。</p><p>算法的时间复杂度越小越好。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>采用暴力解法的时间复杂度为<code>O(n)</code>。</p><p>如果采用二分查找可以将时间复杂度降到<code>O(logn)</code>。</p><p>可以用二分查找，寻找中间点，如果中间点大于右边的点，那么左半边（包含中间点在内）一定有一个点符合peak，反之一样。这样不断地每次缩小1/2的范围最终就可以使用<code>O(logn)</code>的时间复杂度找到peak点。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight ts"><figcaption><span>ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findPeak = (mountains: <span class="built_in">number</span>[]): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right: <span class="built_in">number</span> = mountains.length - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 找到中间点</span></span><br><span class="line">        <span class="keyword">let</span> mid: <span class="built_in">number</span> = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mountains[mid] &gt; mountains[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 左半边一定有peak</span></span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右半边一定有peak</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mountains[left]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findPeak([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(findPeak([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(findPeak([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(findPeak([<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><ol><li>本题难点在于想不到可以使用二分查找来缩小查询范围，因为本题的要求是只要找到任意一个peak即可。</li><li>要想到在使用二分查找时如果中间点大于右边的点，那么左半边（包含中间点）在内的区间一定存在peak，反之亦然，这样就缩小了一半的范围。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试问到的算法题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://herotiga.github.io/categories/Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx基本配置、反向代理、负载均衡以及高可用</title>
    <link href="https://herotiga.github.io/2024/05/18/nginx-conf/"/>
    <id>https://herotiga.github.io/2024/05/18/nginx-conf/</id>
    <published>2024-05-17T16:59:17.000Z</published>
    <updated>2024-08-25T06:10:32.091Z</updated>
    
    <content type="html"><![CDATA[<p>nginx的基本配置。</p><a id="more"></a><p>配置nginx是通过编辑nginx的配置文件实现的。</p><p>nginx配置文件位于<code>/etc/nginx/nginx.conf</code>或者<code>/etc/nginx/conf.d/</code>目录中。</p><h2 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nginx</span></span><br><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure><h2 id="nginx命令"><a href="#nginx命令" class="headerlink" title="nginx命令"></a>nginx命令</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看nginx状态</span></span><br><span class="line">sudo systemctl status nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line">sudo systemctl start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止nginx</span></span><br><span class="line">sudo systemctl stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启nginx</span></span><br><span class="line">sudo systemctl restart nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新载入nginx配置文件</span></span><br><span class="line">sudo systemctl reload nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统启动时启动nginx</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试nginx配置文件是否正确</span></span><br><span class="line">sudo nginx -t</span><br></pre></td></tr></table></figure><h2 id="nginx基本配置"><a href="#nginx基本配置" class="headerlink" title="nginx基本配置"></a>nginx基本配置</h2><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听80端口</span><br><span class="line">    listen 80;</span><br><span class="line">    # 域名</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line"></span><br><span class="line">    # 网站根目录</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;example;</span><br><span class="line">    # 默认首页</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x3D;404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义错误页面</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x3D; &#x2F;404.html &#123;</span><br><span class="line">        internal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        internal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx配置静态资源目录"><a href="#nginx配置静态资源目录" class="headerlink" title="nginx配置静态资源目录"></a>nginx配置静态资源目录</h2><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:3000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 配置静态文件目录，当客户端访问下面的几种格式的静态文件时nginx会定向到&#x2F;static目录下</span><br><span class="line">    location ~ \.jpg|.png|.gif|.css|.js$ &#123;</span><br><span class="line">        root static;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx配置反向代理"><a href="#nginx配置反向代理" class="headerlink" title="nginx配置反向代理"></a>nginx配置反向代理</h2><p>nginx除了可以支持正向代理还可以支持反向代理，反向代理就是对客户端隐藏了真实的服务端。</p><p>下面的配置会将所有传入的请求转发给本地的<code>http://localhost:3000</code>服务器。</p><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:3000;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx配置负载均衡"><a href="#nginx配置负载均衡" class="headerlink" title="nginx配置负载均衡"></a>nginx配置负载均衡</h2><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 服务器集群，serverlist是集群名称</span><br><span class="line">upstream serverlist &#123;</span><br><span class="line">    # 真实服务器</span><br><span class="line">    server 192.168.1.101:8080;</span><br><span class="line">    server 192.168.1.102:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 指定服务器集群</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;serverlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡策略：</p><ul><li>轮询</li></ul><p>nginx默认使用轮询策略。</p><ul><li>权重</li></ul><p>给服务器集群的每台真实服务器添加权重，各个权重表示各个服务器被访问的频率比例。</p><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 服务器集群，serverlist是集群名称</span><br><span class="line">upstream serverlist &#123;</span><br><span class="line">    # 真实服务器，带权重</span><br><span class="line">    server 192.168.1.101:8080 weight&#x3D;1;</span><br><span class="line">    server 192.168.1.102:8080 weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 指定服务器集群</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;serverlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ip_hash</li></ul><p>根据客户端ip分配真实服务器。</p><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 服务器集群，serverlist是集群名称</span><br><span class="line">upstream serverlist &#123;</span><br><span class="line">    # ip_hash</span><br><span class="line">    ip_hash;</span><br><span class="line">    # 真实服务器</span><br><span class="line">    server 192.168.1.101:8080;</span><br><span class="line">    server 192.168.1.102:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 指定服务器集群</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;serverlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三方插件</li></ul><p>使用第三方插件，插件可能使用了其他策略。</p><h2 id="nginx配置https"><a href="#nginx配置https" class="headerlink" title="nginx配置https"></a>nginx配置https</h2><p>下面配置了Let’s Encrypt证书：</p><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;example.com&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;example.com&#x2F;privkey.pem;</span><br><span class="line"></span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;example;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x3D;404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装certbot和获取证书：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install certbot python3-certbot-nginx</span><br><span class="line">sudo certbot --nginx -d example.com -d www.example.com</span><br></pre></td></tr></table></figure><h2 id="nginx高可用"><a href="#nginx高可用" class="headerlink" title="nginx高可用"></a>nginx高可用</h2><p>以上都是基于单个nginx节点进行的配置，如果这个节点挂了那么整个后端服务都挂了。</p><p>为了实现nginx的高可用，一般是在多台服务器上部署nginx节点，在每台服务器上安装keepalived，再配置keepalived。</p><ol><li><p>准备多台服务器并部署nginx</p></li><li><p>在每个服务器上安装keepalived</p></li></ol><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y keepalived</span><br></pre></td></tr></table></figure><ol start="3"><li>配置keepalived</li></ol><p>文件路径：<code>/etc/keepalived/keepalived.conf</code></p><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">notification_email &#123;</span><br><span class="line">  acassen@firewall.loc</span><br><span class="line">  failover@firewall.loc</span><br><span class="line">  sysadmin@firewall.loc</span><br><span class="line">&#125;</span><br><span class="line">notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">    # 节点ip</span><br><span class="line">smtp_ server 192.168.232.166</span><br><span class="line">smtp_connect_timeout 30</span><br><span class="line">    # 节点ip</span><br><span class="line">router_id 192.168.232.166</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># 定义chk_http_port</span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    # nginx检测脚本</span><br><span class="line">script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line">interval 2</span><br><span class="line">    # 如果上面脚本检测成功则降低优先级，反之则相反</span><br><span class="line">weight -20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 节点配置</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    # 将这个节点配置为主节点，BACKUP为从节点</span><br><span class="line">state MASTER</span><br><span class="line">    # 使用的网络接口</span><br><span class="line">interface eth0</span><br><span class="line">    # VRID，必须在主备服务器上保持一致</span><br><span class="line">virtual_router_id 51</span><br><span class="line">    # 节点优先级，数值越大优先级越高</span><br><span class="line">priority 100</span><br><span class="line">    # 通告间隔时间，秒</span><br><span class="line">advert_int 1</span><br><span class="line">    # 认证密码，主从服务器必须保持一致</span><br><span class="line">authentication &#123;</span><br><span class="line">auth type PASS</span><br><span class="line">auth pass 1111</span><br><span class="line">        &#125;</span><br><span class="line">    # 虚拟ip，该ip需要配置和其他节点ip在同一个网段，主备节点共享</span><br><span class="line">virtual_ipaddress &#123; </span><br><span class="line">192.168.0.100</span><br><span class="line">&#125;</span><br><span class="line">#将 track_script 块加入 instance 配置块</span><br><span class="line">track_script &#123;</span><br><span class="line">    chk_http_port #执行 Nginx 监控服务</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在<code>/usr/local/src</code>下添加<code>nginx_check.sh</code>文件</li></ol><figure class="highlight shell"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否开启nginx</span></span><br><span class="line">A=`ps -C nginx --no-header |wc -l`</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">        systemctl stop keepalived</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ol start="5"><li>启动keepalived</li></ol><p>在配置完所有的节点后，在每个节点启动keepalived。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> keepalived</span><br><span class="line">sudo systemctl start keepalived.service</span><br></pre></td></tr></table></figure><ol start="6"><li>验证配置</li></ol><p>6.1 在主节点上查看虚拟ip是否已经绑定到了接口。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>6.2 在备用服务器上，停止主服务器的keepalived服务，检查虚拟IP是否切换到备用服务器。</p><p>6.3 检查日志文件确保keepalived正常工作。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/syslog</span><br><span class="line">cat /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure><ol start="7"><li>访问虚拟ip获取服务</li></ol><p>现在可以访问虚拟ip获取服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx的基本配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://herotiga.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>部署腾讯云轻量应用服务器</title>
    <link href="https://herotiga.github.io/2024/05/17/%E9%83%A8%E7%BD%B2%E8%85%BE%E8%AE%AF%E4%BA%91%E8%BD%BB%E9%87%8F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://herotiga.github.io/2024/05/17/%E9%83%A8%E7%BD%B2%E8%85%BE%E8%AE%AF%E4%BA%91%E8%BD%BB%E9%87%8F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2024-05-17T12:46:08.000Z</published>
    <updated>2024-08-25T06:10:32.112Z</updated>
    
    <content type="html"><![CDATA[<!-- https://blog.csdn.net/2401_83740107/article/details/137733791 --><p>买了新的腾讯云轻量应用服务器，记录一下部署服务器的过程。</p><a id="more"></a><h2 id="部署系统"><a href="#部署系统" class="headerlink" title="部署系统"></a>部署系统</h2><p>我选择了部署OpenCloudOS系统。</p><h2 id="切换shell"><a href="#切换shell" class="headerlink" title="切换shell"></a>切换shell</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前shell</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的shell</span></span><br><span class="line">cat /etc/shells</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看shell安装路径</span></span><br><span class="line"><span class="built_in">which</span> bash</span><br><span class="line"><span class="built_in">which</span> zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换shell</span></span><br><span class="line">chsh -s /usr/bin/zsh</span><br></pre></td></tr></table></figure><p>最后重启终端即可。</p><h2 id="安装tldr"><a href="#安装tldr" class="headerlink" title="安装tldr"></a>安装tldr</h2><p>安装tldr方便查询命令。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y tldr</span><br></pre></td></tr></table></figure><h2 id="安装neofetch"><a href="#安装neofetch" class="headerlink" title="安装neofetch"></a>安装neofetch</h2><p>安装neofetch查看系统信息。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y neofetch</span><br></pre></td></tr></table></figure><h2 id="安装bat"><a href="#安装bat" class="headerlink" title="安装bat"></a>安装bat</h2><p>安装bat替代cat：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -c http://repo.openfusion.net/centos7-x86_64/bat-0.7.0-1.of.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install -y bat-0.7.0-1.of.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y git</span><br></pre></td></tr></table></figure><h2 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h2><p>使用国内源安装nvm：<a href="https://gitee.com/RubyMetric/nvm-cn/">https://gitee.com/RubyMetric/nvm-cn/</a></p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://gitee.com/RubyMetric/nvm-cn/raw/main/install.sh | bash</span><br><span class="line"></span><br><span class="line">chmod +x ~/.nvm/nvm.sh</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>npm换源：<a href="https://gitee.com/RubyMetric/chsrc">https://gitee.com/RubyMetric/chsrc</a></p><h2 id="nvm安装nodejs"><a href="#nvm安装nodejs" class="headerlink" title="nvm安装nodejs"></a>nvm安装nodejs</h2><p>nvm命令：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已安装的nodejs</span></span><br><span class="line">nvm list</span><br><span class="line">nvm ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远端可以安装的nodejs</span></span><br><span class="line">nvm ls-remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装nodejs</span></span><br><span class="line">nvm install [version_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换nodejs版本</span></span><br><span class="line">nvm use system</span><br><span class="line">nvm use [version_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新nvm</span></span><br><span class="line">nvm-update</span><br></pre></td></tr></table></figure><p>这里安装了20的LTS版本：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install v20.13.1 </span><br><span class="line"></span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><p>安装cnpm：<a href="https://npmmirror.com/">https://npmmirror.com/</a></p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line">cnpm install [package]</span><br></pre></td></tr></table></figure><h2 id="安装PM2"><a href="#安装PM2" class="headerlink" title="安装PM2"></a>安装PM2</h2><p>PM2: <a href="https://pm2.keymetrics.io/">https://pm2.keymetrics.io/</a></p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装PM2</span></span><br><span class="line">npm install pm2 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个进程</span></span><br><span class="line">pm2 start app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动多个进程，进程个数应设置为CPU核心数</span></span><br><span class="line">pm2 start app.js -i 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个进程，并命名该进程</span></span><br><span class="line">pm2 start app.js --name app_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控已启动的进程</span></span><br><span class="line">pm2 monit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程的日志</span></span><br><span class="line">pm2 logs app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有进程的日志</span></span><br><span class="line">pm2 logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程的详情</span></span><br><span class="line">pm2 show app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的进程</span></span><br><span class="line">pm2 list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止进程</span></span><br><span class="line">pm2 stop app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止所有进程</span></span><br><span class="line">pm2 stop all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀掉所有进程</span></span><br><span class="line">pm2 <span class="built_in">kill</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启进程</span></span><br><span class="line">pm2 restart app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有进程</span></span><br><span class="line">pm2 restart all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载进程</span></span><br><span class="line">pm2 reload app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载所有进程</span></span><br><span class="line">pm2 reload all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除进程</span></span><br><span class="line">pm2 delete app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有进程</span></span><br><span class="line">pm2 delete all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">pm2 startup</span><br><span class="line">pm2 save</span><br></pre></td></tr></table></figure><h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装3.9</span></span><br><span class="line">sudo yum install -y python39</span><br></pre></td></tr></table></figure><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nginx</span></span><br><span class="line">sudo yum install -y nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看nginx状态</span></span><br><span class="line">sudo systemctl status nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line">sudo systemctl start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止nginx</span></span><br><span class="line">sudo systemctl stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启nginx</span></span><br><span class="line">sudo systemctl restart nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统启动时启动nginx</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure><p>编辑nginx配置文件：<code>/etc/nginx/nginx.conf</code></p><figure class="highlight plain"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;  # 端口</span><br><span class="line">    server_name www.baidu.com;  # 域名或者ip</span><br><span class="line">    root &#x2F;www&#x2F;test;  # 代码路径</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root &#x2F;www&#x2F;test;</span><br><span class="line">        index index.jsp index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完配置文件后需要重新载入配置文件：</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></table></figure><p>然后浏览器打开ip就发现nginx服务启动成功了。</p><p>最后再将前端项目通过SCP、SFTP等工具上传到<code>/www/test</code>下即可通过ip访问到页面。</p><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /path/to/your/<span class="built_in">local</span>/vue-app/dist username@your_server_ip:/path/to/your/server/vue-app/</span><br></pre></td></tr></table></figure><p>实际开发中一般通过CI/CD将代码部署到服务器上。</p><h2 id="安装caddy"><a href="#安装caddy" class="headerlink" title="安装caddy"></a>安装caddy</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo yum install -y caddy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">caddy version</span><br></pre></td></tr></table></figure><h2 id="安装htop"><a href="#安装htop" class="headerlink" title="安装htop"></a>安装htop</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y htop</span><br></pre></td></tr></table></figure><h2 id="配置防火墙规则"><a href="#配置防火墙规则" class="headerlink" title="配置防火墙规则"></a>配置防火墙规则</h2><p>这里配置了常用的规则。</p><p><img src="https://gcore.jsdelivr.net/gh/herotiga/cdn@master/img/article/%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99.png" alt="配置防火墙规则"></p><p>然后设置服务器实例套用规则。</p><h2 id="安装mysql-server"><a href="#安装mysql-server" class="headerlink" title="安装mysql-server"></a>安装mysql-server</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装server</span></span><br><span class="line">sudo yum install -y mysql-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动server</span></span><br><span class="line">sudo systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止server</span></span><br><span class="line">sudo systemctl stop mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启server</span></span><br><span class="line">sudo systemctl restart mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动系统时自动启动mysql-server</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行安全安装向导</span></span><br><span class="line">mysql_secure_installation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录mysql</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>安全安装向导：</p><pre><code>Securing the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD COMPONENT can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD component?Press y|Y for Yes, any other key for No: y  #是否安装密码强度验证组件There are three levels of password validation policy:LOW    Length &gt;= 8MEDIUM Length &gt;= 8, numeric, mixed case, and special charactersSTRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary                  filePlease enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 2 #选择密码强度 ##上面选择不安装密码强度验证组件布显示这个Please set the password for root here.New password:   #设置root密码Re-enter new password:  #确认root密码Estimated strength of the password: 90 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y  #是否确定使用上面的密码By default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : y  #是否删除匿名用户?Success.  Normally, root should only be allowed to connect from&apos;localhost&apos;. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n #是否禁止root远程登录... skipping.By default, MySQL comes with a database named &apos;test&apos; thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y #是否删除test数据库- Dropping test database...Success.- Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y #是否现在重新加载特权表Success.All done! </code></pre><p>mysql基本操作：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有的数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择数据库</span></span><br><span class="line"><span class="keyword">USE</span> database_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出数据库中所有的表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">EXIT;</span><br><span class="line">QUIT;</span><br><span class="line">CTRL+D</span><br></pre></td></tr></table></figure><h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装jdk</span></span><br><span class="line">sudo yum install -y java-11-openjdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">java --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.22.0.7-2.oc8.x86_64'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:$JAVA_HOME/bin'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>购买域名后添加DNS解析记录：</p><p><img src="https://gcore.jsdelivr.net/gh/herotiga/cdn@master/img/article/typecasting.icu%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="typecasting.icu域名解析"></p><p>域名备案要提交的材料越来越多，各种实名认证、签署各种承诺书、还需要录制承诺视频。</p><p>妈的实在是太恶心了。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 
https://blog.csdn.net/2401_83740107/article/details/137733791
 --&gt;

&lt;p&gt;买了新的腾讯云轻量应用服务器，记录一下部署服务器的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://herotiga.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>CSR, SSR, SSG分析</title>
    <link href="https://herotiga.github.io/2024/05/15/CSR-SSR-SSG/"/>
    <id>https://herotiga.github.io/2024/05/15/CSR-SSR-SSG/</id>
    <published>2024-05-15T14:28:34.000Z</published>
    <updated>2024-08-25T06:23:31.125Z</updated>
    
    <content type="html"><![CDATA[<!-- https://mp.weixin.qq.com/s/lYSOYf1Bll0mHJ36jtU7NQ --><p>前端开发中有三种渲染技术，分别是CSR（客户端渲染）、SSR（服务端渲染）、SSG（服务端静态站点生成）。</p><p>我们根据具体需求的不同来使用不同的技术。</p><a id="more"></a><h2 id="CSR（客户端渲染）"><a href="#CSR（客户端渲染）" class="headerlink" title="CSR（客户端渲染）"></a>CSR（客户端渲染）</h2><p>CSR是目前前端开发中最常用的渲染方式。</p><p>CSR渲染方式下，服务端提供给客户端静态html文件、css文件、js文件等，客户端获取到文件后在客户端渲染。</p><h3 id="CSR的优点"><a href="#CSR的优点" class="headerlink" title="CSR的优点"></a>CSR的优点</h3><ol><li>响应速度快：浏览器在html加载好后就可以渲染页面，无需等待各种接口请求的结果。</li><li>交互性好：因为页面的大部分处理逻辑在客户端执行，所以可以提供更加动态和交互性的用户体验。</li><li>服务器压力小：因为渲染是在客户端进行的，而服务端只需要提供数据接口，所以服务端压力小。</li><li>容易跨平台开发：CSR的逻辑主要是在客户端，所以可以更容易开发跨平台的应用。</li><li>部署简单：只需要部署build出来的代码即可。</li></ol><h3 id="CSR的缺点"><a href="#CSR的缺点" class="headerlink" title="CSR的缺点"></a>CSR的缺点</h3><ol><li>首屏加载时间长：因为需要下载很多静态文件，会导致首屏加载时间长，可能会出现白屏。</li><li>不利于SEO：由于数据是在客户端渲染的，所以不利于搜索引擎爬取页面内容。</li></ol><h2 id="SSR（服务端渲染）"><a href="#SSR（服务端渲染）" class="headerlink" title="SSR（服务端渲染）"></a>SSR（服务端渲染）</h2><p>SSR是在服务端渲染页面的技术。</p><p>SSR的渲染方式下，服务端收到客户端的请求后会根据用户请求的页面和数据来渲染完整的页面，然后将渲染好的页面返回给客户端，客户端直接渲染完整的页面。</p><h3 id="SSR的优点"><a href="#SSR的优点" class="headerlink" title="SSR的优点"></a>SSR的优点</h3><ol><li>首屏加载速度快：由于页面由服务端渲染完成了，所以客户端直接拿来渲染即可。</li><li>利于SEO：由于页面以及数据已经在服务端渲染好了，所以搜索引擎爬取时就可以获取到完整的页面，利于SEO。</li><li>降低了客户端负载：由于渲染是在服务端完成的，客户端没有了渲染压力，降低了客户端负载，负载从客户端转移到了服务端。</li><li>更安全：客户端不直接操作数据，所以减少了客户端可能得安全风险。</li><li>更好的可访问性：SSR确保了网页的内容对于无法执行js的用户依然可以访问，提高了站点的可访问性。</li></ol><h3 id="SSR的缺点"><a href="#SSR的缺点" class="headerlink" title="SSR的缺点"></a>SSR的缺点</h3><ol><li>服务端负载大：服务端承担了页面渲染的工作，导致了服务端负载上升。</li><li>开发变得复杂：SSR需要考虑组件在客户端和服务端的运行，导致了开发变得复杂。</li><li>不适用于动态内容页面：对于频繁更新的页面，SSR不适合。</li></ol><h2 id="SSG（服务端静态站点生成）"><a href="#SSG（服务端静态站点生成）" class="headerlink" title="SSG（服务端静态站点生成）"></a>SSG（服务端静态站点生成）</h2><p>SSG是在构建项目时生成静态站点的技术。</p><p>SSG方式下，我们需要编写模板文件以及数据文件，然后在构建时将这些文件转为静态的页面文件，这些页面文件会被部署到服务器上，用户在请求这些页面的时候会直接返给用户这些提前生成的页面文件而无需实时生成。</p><h3 id="SSG的优点"><a href="#SSG的优点" class="headerlink" title="SSG的优点"></a>SSG的优点</h3><ol><li>性能好：此时用户请求页面后，服务端直接返回给客户端提前生成好的页面文件，故而速度很快。</li><li>安全性好：服务端只提供静态文件，故而降低了安全风险。</li><li>容易部署：SSG最终生成的是静态文件，所以很容易部署。</li><li>适合静态网站：SSG适合不经常更新的网站。</li><li>利于SEO：由于页面以及数据已经在服务端渲染好了，所以搜索引擎爬取时就可以获取到完整的页面，利于SEO。</li></ol><h3 id="SSG的缺点"><a href="#SSG的缺点" class="headerlink" title="SSG的缺点"></a>SSG的缺点</h3><ol><li>动态性不好：页面是静态生成的，故而不好实现复杂的动态交互。</li><li>构建时间长：大型站点构建时间可能很长。</li><li>不适合动态内容：频繁更新会消耗服务端大量的资源（构建）。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- 
https://mp.weixin.qq.com/s/lYSOYf1Bll0mHJ36jtU7NQ
 --&gt;

&lt;p&gt;前端开发中有三种渲染技术，分别是CSR（客户端渲染）、SSR（服务端渲染）、SSG（服务端静态站点生成）。&lt;/p&gt;
&lt;p&gt;我们根据具体需求的不同来使用不同的技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://herotiga.github.io/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>Next.js开发笔记</title>
    <link href="https://herotiga.github.io/2024/04/26/Nextjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://herotiga.github.io/2024/04/26/Nextjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-25T17:01:13.000Z</published>
    <updated>2024-08-25T06:23:31.125Z</updated>
    
    <content type="html"><![CDATA[<!-- https://www.bilibili.com/video/BV14t4y187Kk/?spm_id_from=333.337.search-card.all.click&vd_source=8c53c6425ea22c2a5a35c21ddac6a601 --><!-- https://mp.weixin.qq.com/s/J0yF-qynw9fTysrLzkqzQghttps://mp.weixin.qq.com/s/zKLN4tBJc5svYvxB1WkdLghttps://mp.weixin.qq.com/s/HLI4eQpV8IbA2Yt34vUv2Qhttps://blog.csdn.net/woyebuzhidao321/article/details/124133583https://www.jianshu.com/p/8b61ae94ac7fhttps://youmoxiang.blog.csdn.net/article/details/129518797https://zhuanlan.zhihu.com/p/645478020 --><p>Next.js是基于react的一个全栈框架，提供的功能和Nuxt.js基本一样。</p><a id="more"></a><p>Next.js主要是为了解决react的如下问题：</p><ul><li>js环境</li><li>首屏加载慢</li><li>安全问题</li><li>SEO</li></ul><p>Next.js通过将渲染这个过程移动到服务端（将生成DOM放在服务端完成）来解决以上问题，也就是SSR。</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ts</span></span><br><span class="line">npx create-next-app@latest --typescript project-name</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="https://gcore.jsdelivr.net/gh/herotiga/cdn@master/img/article/nextjs-catalogue.png" alt="nextjs目录结构"></p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>静态路由是指在编译时就确定了路由和其对应的页面文件。</p><p>pages下创建文件即可生成对应的路由配置。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>可以在pages目录下创建文件名，文件名是变量的形式<code>[param].ts</code>。</p><p>比如，如果想获取一个article页面的参数id，可以在article下定义名为<code>[id].ts</code>的文件，然后在这个文件内可以使用<code>useRouter</code>来获取id。</p><h3 id="API静态路由"><a href="#API静态路由" class="headerlink" title="API静态路由"></a>API静态路由</h3><p>API路由允许我们再next.js项目章自定义服务端逻辑，可以处理客户端发起的http请求。</p><p>创建方法：</p><ol><li><p>在<code>pages/api</code>下创建一个文件，文件名即为路由，这里创建了<code>user.ts</code>文件。</p></li><li><p>在<code>user.ts</code>中编写处理请求的代码。</p></li></ol><figure class="highlight ts"><figcaption><span>user.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; NextApiRequest, NextApiResponse &#125; <span class="keyword">from</span> <span class="string">'next'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data = &#123;</span><br><span class="line">    code: <span class="built_in">number</span></span><br><span class="line">    users: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">req: NextApiRequest, res: NextApiResponse&lt;Data&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> users: <span class="built_in">string</span>[] = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Charlie'</span>]</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">        code: <span class="number">0</span>,</span><br><span class="line">        users,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后访问地址为<code>/api/user</code>的API即可获取到数据。</li></ol><h3 id="API动态路由"><a href="#API动态路由" class="headerlink" title="API动态路由"></a>API动态路由</h3><p>除了上面的静态路由，next.js还可以实现动态路由（也就是在路由中允许参数）。</p><p>创建方法：</p><ol><li><p>在<code>pages/api</code>下创建一个文件，文件名形如<code>[id].ts</code>，文件名即为路由。</p></li><li><p>在<code>[id].ts</code>中编写处理请求的代码，在代码中可以获取到<code>id</code>。</p></li></ol><figure class="highlight ts"><figcaption><span>[id].ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; NextApiRequest, NextApiResponse &#125; <span class="keyword">from</span> <span class="string">'next'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data = &#123;</span><br><span class="line">    message: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">req: NextApiRequest, res: NextApiResponse&lt;Data&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = req.query</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123; message: Received request <span class="keyword">for</span> ID: $&#123;id&#125; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后访问地址为<code>/api/:id</code>的API即可获取到对应id的数据。</li></ol><h2 id="SSR-amp-SSG"><a href="#SSR-amp-SSG" class="headerlink" title="SSR &amp; SSG"></a>SSR &amp; SSG</h2><p>这里有3个重要的方法。</p><ul><li><p>getServerSideProps：服务端渲染，在请求时运行</p></li><li><p>getStaticProps：服务端生成，生成静态页面时运行</p></li><li><p>getStaticPaths：服务端生成，生成静态页面时运行</p></li></ul><h3 id="声明SSR页面"><a href="#声明SSR页面" class="headerlink" title="声明SSR页面"></a>声明SSR页面</h3><p>在页面组件内添加一个<code>getServerSideProps</code>函数。</p><figure class="highlight plain"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常的页面组件</span><br><span class="line">const Post &#x3D; (&#123;data&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;div&gt;&#123; data &#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将该页面声明为SSR页面，下方函数是在服务端执行的</span><br><span class="line">export async function getServerSideProps(context) &#123;</span><br><span class="line">    &#x2F;&#x2F; 取出id</span><br><span class="line">    const &#123; id &#125; &#x3D; context.query</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据id查询接口</span><br><span class="line">    const res &#x3D; await fetch(&#96;&#x2F;article&#x2F;$&#123;id&#125;&#96;).then(data &#x3D;&gt; data.json())</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的props会被传入到上方组件中</span><br><span class="line">        props: &#123;</span><br><span class="line">            data: res,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明SSG页面"><a href="#声明SSG页面" class="headerlink" title="声明SSG页面"></a>声明SSG页面</h3><p>如果将以上代码的<code>getServerSideProps</code>改为<code>getStaticProps</code>，那么代码会在build的时候运行，此时文件会变为在build时渲染出来。</p><p>但是我们不知道用户会访问哪个id，所以需要搭配<code>getStaticPaths</code>来使用，getStaticPaths就是用来枚举用户可能访问的id。</p><p>下面生成一些用户可能访问的id：</p><figure class="highlight plain"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常的页面组件</span><br><span class="line">const Post &#x3D; (&#123;data&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;div&gt;&#123; data &#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将该页面声明为SSR页面，下方函数是在服务端执行的</span><br><span class="line">export async function getStaticProps(context) &#123;</span><br><span class="line">    &#x2F;&#x2F; 取出id</span><br><span class="line">    const &#123; id &#125; &#x3D; context.query</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据id查询接口</span><br><span class="line">    const res &#x3D; await fetch(&#96;&#x2F;article&#x2F;$&#123;id&#125;&#96;).then(data &#x3D;&gt; data.json())</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的props会被传入到上方组件中</span><br><span class="line">        props: &#123;</span><br><span class="line">            data: res,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面会在build阶段生成id从1到100的页面</span><br><span class="line">export async function getStaticPaths() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        paths: _.range(1, 100).map((id) &#x3D;&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                params: &#123;</span><br><span class="line">                    id: id + &#39;&#39;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; id未命中时退化为SSR</span><br><span class="line">        fallback: &#39;blocking&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallback</code>的取值还有：false（404），true（退化到CSR）。</p><h3 id="增量静态生成（ISR）"><a href="#增量静态生成（ISR）" class="headerlink" title="增量静态生成（ISR）"></a>增量静态生成（ISR）</h3><h4 id="自动重新生成"><a href="#自动重新生成" class="headerlink" title="自动重新生成"></a>自动重新生成</h4><p>添加<code>revalidate</code>参数，表示这个静态页面最多可存活的秒数，如果当用户请求页面时这个页面已经生成了超过10s则会重新生成该页面。可以用来保证静态页面是最新的。</p><figure class="highlight plain"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常的页面组件</span><br><span class="line">const Post &#x3D; (&#123;data&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;div&gt;&#123; data &#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将该页面声明为SSR页面，下方函数是在服务端执行的</span><br><span class="line">export async function getStaticProps(context) &#123;</span><br><span class="line">    &#x2F;&#x2F; 取出id</span><br><span class="line">    const &#123; id &#125; &#x3D; context.query</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据id查询接口</span><br><span class="line">    const res &#x3D; await fetch(&#96;&#x2F;article&#x2F;$&#123;id&#125;&#96;).then(data &#x3D;&gt; data.json())</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的props会被传入到上方组件中</span><br><span class="line">        props: &#123;</span><br><span class="line">            data: res,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 最多存活10s</span><br><span class="line">        revalidate: 10,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面会在build阶段生成id从1到100的页面</span><br><span class="line">export async function getStaticPaths() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        paths: _.range(1, 100).map((id) &#x3D;&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                params: &#123;</span><br><span class="line">                    id: id + &#39;&#39;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; id未命中时退化为SSR</span><br><span class="line">        fallback: &#39;blocking&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手动重新生成"><a href="#手动重新生成" class="headerlink" title="手动重新生成"></a>手动重新生成</h4><p>在<code>pages/api</code>目录下创建一个文件，文件名即路由，在文件中手动调用<code>revalidate</code>方法即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://nextjs.frontendx.cn/">https://nextjs.frontendx.cn/</a></li><li><a href="https://www.nextjs.cn/">https://www.nextjs.cn/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- 
https://www.bilibili.com/video/BV14t4y187Kk/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8c53c6425ea22c2a5a35c21ddac6a601
 --&gt;

&lt;!-- 
https://mp.weixin.qq.com/s/J0yF-qynw9fTysrLzkqzQg
https://mp.weixin.qq.com/s/zKLN4tBJc5svYvxB1WkdLg
https://mp.weixin.qq.com/s/HLI4eQpV8IbA2Yt34vUv2Q
https://blog.csdn.net/woyebuzhidao321/article/details/124133583
https://www.jianshu.com/p/8b61ae94ac7f
https://youmoxiang.blog.csdn.net/article/details/129518797
https://zhuanlan.zhihu.com/p/645478020
 --&gt;


&lt;p&gt;Next.js是基于react的一个全栈框架，提供的功能和Nuxt.js基本一样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://herotiga.github.io/categories/React/"/>
    
    
  </entry>
  
</feed>
