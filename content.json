{"pages":[{"title":"阅读","text":"前端 《head first html &amp; css》 《案例学web前端开发》 《css权威指南第三版》 《css权威指南第四版》 《css世界》 《css选择器世界》 《css揭秘》 《精通CSS 高级Web标准解决方案 第3版》 《JavaScript DOM编程艺术》 《javascript高级程序设计第三版》 《JavaScript语言精粹》 《高性能JavaScript》 《JavaScript DOM高级程序设计》 《JavaScript设计模式》 《你不知道的JavaScript》 《锋利的jQuery》 《深入浅出WebAssembly》 《WebAssembly标准入门》 服务端 《Linux就该这样学》 《Linux命令行大全》 安全 《Metasploit渗透测试指南》 《渗透测试实践指南：必知必会的工具与方法》 《白帽子讲Web安全》 《黑客攻防技术宝典》web版 《破坏之王-DDoS攻击与防范深度剖析》 《Kali渗透测试技术实战》 架构 《大型网站技术架构——核心原理与案例分析》 算法 《算法笔记》 《算法谜题》 人工智能 《人工智能产品经理》 《智能的本质》 计算机基础 《数据结构（c语言版）——严蔚敏》 《计算机组成原理——唐朔飞》 《计算机组成原理——白中英》 《计算机组成与设计：硬件/软件接口》 《计算机操作系统(第三版)——汤子瀛》 《计算机网络(第5版)——谢希仁》 数学 《数学之美》 《计算机科学中的数学–信息与智能时代的必修课》 物理学 《1小时看懂相对论（漫画版）》 《相对论——天津人民出版社》 课程 《极客时间——玩转git三剑客》 《拉钩——程序员的数学课》 商业 《硅谷钢铁侠：埃隆马斯克的冒险人生》 《穷查理宝典》 方法论 《如何高效学习》","link":"/books/index.html"},{"title":"职业规划及成长目标","text":"","link":"/career/index.html"},{"title":"论文","text":"暂无","link":"/paper/index.html"},{"title":"2021","text":"2021年日志","link":"/log/index.html"},{"title":"自媒体计划","text":"概述自媒体这份工作收益巨大，youtube上很多主业程序员的博主都通过youtube得到了比本职工作多得多的收益，比如脑洞乌托邦、老高等等。 油管有个youtuber叫老胡油管研究院可以很好地指导我这种新手。 平台国外：YouTube，没什么可说的，长视频全网上传基本上90%的收益都会来自youtube，通过加入adsense来给视频加入广告得到收益。 国内：长视频平台有bilibili、优爱腾，短视频平台有西瓜快手抖音等等。 内容做自己真正感兴趣的内容以及自己擅长的内容。就我来说我对什么东西都感兴趣，所以比较适合做杂谈类节目或者深耕一个类型的内容创作。就我擅长的东西而言，我可以在抖音快手做唱歌短视频。 变现长视频平台：youtube平台的变现通过adsense插入广告来获益，不过我的视频最多插入三个广告否则会开始影响用户体验，youtube还可以通过接业配来获益。 bilibili由于没有广告，所以只能通过视频恰饭来获取收益。 优爱腾的收益太少了，基本可以忽略不计。 短视频平台：通过打赏、带货获益。 灵感 百万富翁之路利用了所有人都想成为百万富翁的心理，获得subscribe的概率很大。并且可以利用自媒体来监督自己成为百万富翁。 观众从视频中获取了我积极向上努力奋斗的精神感染，我自己也通过自媒体观众的压力为自己创收，两全其美。","link":"/wemedia/index.html"},{"title":"技术栈","text":"Front-end Dev html/html5 canvas css/css3 emmet sass/less/stylus javascript typescript jquery json/xml vue.js/vuex layui element npm/yarn webpack/gulp Java Java SE Linux ssh vi/vim iptables/firewalld apache/nginx mysql/mariadb shell centos/rhel VCS git svn UI/UX Adobe Photoshop Adobe Illustrator Sketch Axure RP draw.io","link":"/stack/index.html"},{"title":"2022","text":"","link":"/log/2022/index.html"},{"title":"2021","text":"2021.1.25微博、视频网站真的是杀时间的利器，想想微博知乎上平台方每天通过推荐算法生成各种人们感兴趣的话题来feed无处发泄情绪的网民就觉得可怕，每天被微博知乎各种feed的人自然就是猪。 远离微博、视频网站等等的奶头乐，专注要做的事情，BE FOCUS！距离过年没几天了，赶紧买买衣服和学学技术。 2021.1.24今天听说IBM中国研究院也关闭了，以前的国企和外企都不再是铁饭碗了。这个大变革的时代真的和三十年前一个单位待一辈子不一样了，还是要注重个人能力、人脉、财富的积累（还要注重个人形象），而不是考个什么公务员或者事业单位就妄想待一辈子。 2021.1.23出差两周，终于回了南京。车上听说春节后回南京要7天内的核酸检测证明，不知道能不能顺利回家过个春节。明天再把《锋利的jQuery》看一遍，毕竟现在的项目需要用到。 .notification p .gallery-item img { border-radius: 3px; padding: 0px 50px; }","link":"/log/2021/index.html"}],"posts":[{"title":"JSON笔记","text":"JSON官网：JSON JSON：JavaScript Object Notation(JavaScript 对象表示法)。 JSON是用于存储和交换文本信息的语法，类似XML但是比XML更小、更快、更易解析。 JSON文件的扩展名为.json JSON文件的MIME类型为application/json 一个JSON实例： 123456789101112{ \"students\": [ { \"name\": \"wang\", \"age\": \"22\" }, { \"name\": \"lee\", \"age\": \"18\" } ]} students这个对象是包含两个记录（对象）的数组。 什么是JSON JSON是javascript对象表示法 JSON是轻量级的文本数据交换格式 JSON独立于语言，JSON解析器和库支持很多语言。 JSON具有自我描述性 转化为JS对象JSON在语法上和javascript对象的代码相同。 故而，javascript可以使用eval()，可以使用JSON数据来生成原生javascript对象。 JSON vs XML同一个实例。 JSON写法： 1234567{ \"sites\": [ { \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" }, { \"name\":\"google\" , \"url\":\"www.google.com\" }, { \"name\":\"微博\" , \"url\":\"www.weibo.com\" } ]} XML写法： 1234567891011&lt;sites&gt; &lt;site&gt; &lt;name&gt;菜鸟教程&lt;/name&gt; &lt;url&gt;www.runoob.com&lt;/url&gt; &lt;/site&gt; &lt;site&gt; &lt;name&gt;google&lt;/name&gt; &lt;url&gt;www.google.com&lt;/url&gt; &lt;/site&gt; &lt;site&gt; &lt;name&gt;微博&lt;/name&gt; &lt;url&gt;www.weibo.com&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; 详细对比（同上图）： 相同点 不同点 JSON也是纯文本 没有结束标签 JSON也具有自我描述性 更简短 JSON也具有层级结构 读写速度更快 JSON也可以通过javascript解析 能使用js内置的eval()解析，而XML需要使用XML解析器 JSON数据也可以使用AJAX传输 能使用数组 JSON也可以被大多数编程语言使用 不使用保留字 JSON.parse()：将一个JSON字符串转化为js对象。 JSON.stringify()：将js值转化为JSON字符串。 应用领域： 使用JSON 使用XML 获取 JSON 字符串 获取 XML 文档 JSON.Parse 解析 JSON 字符串 使用 XML DOM 迭代循环文档 接数据解析出来复制给变量 为什么使用JSON 读取JSON字符串 eval()处理JSON字符串 语法JSON语法是javascript语法的子集。 语法规则 数据为键值对 键值对之间用逗号分隔 用大括号保存对象 用中括号保存数组 键值对1\"key\" : \"value\" 等于以下javascript代码： 1key = \"value\" JSON值 数字，整数和浮点数 字符串，在双引号中 布尔值，true或者false 数组，[1,2,3] 对象，{ key : value } null JSON数字 123{ \"age\": 30} JSON对象 1234{ \"name\": \"wang\", \"age\": 20} JSON数组 数组可以包含多个对象 12345678910111213141516{ \"students\": [ { \"name\": \"wong\", \"url\": \"www.wong.com\" }, { \"name\": \"lee\", \"url\": \"www.lee.com\" }, { \"name\": \"chan\", \"url\": \"www.chan.com\" } ]} 上面的对象students是包含了三个对象的数组，每个对象代表一条记录。 JSON布尔值 123{ \"married\": false} JSON null值 123{ \"name\": null} JSON使用js语法 因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。 通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值： 12345var sites = [ { \"name\":\"runoob\" , \"url\":\"www.runoob.com\" }, { \"name\":\"google\" , \"url\":\"www.google.com\" }, { \"name\":\"微博\" , \"url\":\"www.weibo.com\" }]; 访问对象数组中第一项： 1sites[0].name; 1runoob JSON对象语法1{ \"name\":\"runoob\", \"alexa\":10000, \"site\":null } key必须为字符串，value可以是任意的JSON数据类型。 key和value之间用冒号分隔。 每个键值对之间用逗号分隔。 访问123456789101112var obj,x;obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null}// 使用点访问x = obj.name;// 使用key访问x = obj[\"name\"]; 遍历for…in循环遍历对象属性： 1234var obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null };for (x in obj) { document.getElementById(\"demo\").innerHTML += x + \"&lt;br&gt;\";} 1234var obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null };for (x in obj) { document.getElementById(\"demo\").innerHTML += obj[x] + \"&lt;br&gt;\";} 嵌套JSON对象中可以包含另一个JSON对象： 123456789obj = { \"name\":\"runoob\", \"alexa\":10000, \"sites\": { \"site1\":\"www.runoob.com\", \"site2\":\"m.runoob.com\", \"site3\":\"c.runoob.com\" }} 访问： 123x = obj.sites.site1;// 或者x = obj.sites[\"site1\"]; 修改123obj.sites.site1 = \"www.google.com\";// 或者obj.sites[\"site1\"] = \"www.google.com\"; 删除使用delete关键字删除JSON对象的属性值： 123delete obj.sites.site1;// 或者delete obj.sites[\"site1\"] JSON数组数组作为JSON对象：1[ \"Google\", \"Runoob\", \"Taobao\" ] JSON数组中的值必须是JSON数据类型中的一种。 JSON对象中的数组12345{ \"name\":\"网站\", \"num\":3, \"sites\":[ \"Google\", \"Runoob\", \"Taobao\" ]} 访问： 1x = obj.sites[0]; 遍历 for…in遍历 123for (i in obj.sites) { x += obj.sites[i] + \"&lt;br&gt;\";} for循环遍历 123for (i = 0; i &lt; obj.sites.length; i++) { x += obj.sites[i] + \"&lt;br&gt;\";} 嵌套JSON对象中数组可以包含另一个数组或者另一个JSON对象： 123456789obj = { \"name\":\"网站\", \"num\":3, \"sites\": [ { \"name\":\"Google\", \"info\":[ \"Android\", \"Google 搜索\", \"Google 翻译\" ] }, { \"name\":\"Runoob\", \"info\":[ \"菜鸟教程\", \"菜鸟工具\", \"菜鸟微信\" ] }, { \"name\":\"Taobao\", \"info\":[ \"淘宝\", \"网购\" ] } ]} 使用for-in遍历数组： 123456for (i in obj.sites) { x += \"&lt;h1&gt;\" + obj.sites[i].name + \"&lt;/h1&gt;\"; for (j in obj.sites[i].info) { x += obj.sites[i].info[j] + \"&lt;br&gt;\"; }} 修改数组值1obj.sites[1] = \"Github\"; 删除数组元素使用delete关键字 1delete obj.sites[1]; delete关键字以上使用到了delete关键字，删除数值的元素，数组的大小不变。delete 运算符并不是彻底删除元素，而是删除它的值，但仍会保留空间。 运算符 delete 只是将该值置为undefined，而不会影响数组长度，即将其变为稀疏数组。 JSON.parse()作用JSON通常用于与服务器交换数据。 在接收服务器数据时一般是字符串。 我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。 用法1JSON.parse(text[, reviver]) 参数： text：必需，有效的JSON字符串。 reviver：可选，一个转换结果的函数，将为对象的每个成员调用此函数。 实例假设我们从服务器收到了以下数据： 1{ \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" } 使用JSON.parse()将上面的数据转化为javascript对象： 1var obj = JSON.parse('{ \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" }'); 首先得确保接收到的数据为JSON，否则会出错。 解析完成，使用JSON数据： 123456&lt;p id=\"demo\"&gt;&lt;/p&gt; &lt;script&gt; var obj = JSON.parse('{ \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" }'); document.getElementById(\"demo\").innerHTML = obj.name + \"：\" + obj.site;&lt;/script&gt; 从服务器接受JSON数据使用AJAX从服务器请求JSON，然后解析为js对象： 123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { myObj = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myObj.name; }};xmlhttp.open(\"GET\", \"/try/ajax/json_demo.txt\", true);xmlhttp.send(); 从服务器接受JSON数组如果从服务器收到的是JSON数组，则使用JSON.parse会将其转化为js数组： 123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { myArr = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myArr[1]; }};xmlhttp.open(\"GET\", \"/try/ajax/json_demo_array.txt\", true);xmlhttp.send(); 异常JSON不能存储Date对象。 如果要存储Date对象需要将其转换为字符串，然后再将字符串转化为Date对象。 12345var text = '{ \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"}';var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate); document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期: \" + obj.initDate; 我们可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数。 123456789var text = '{ \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"}';var obj = JSON.parse(text, function (key, value) { if (key == \"initDate\") { return new Date(value); } else { return value;}}); document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期：\" + obj.initDate; 解析函数使用JSON存储函数的方法是将函数转化为字符串然后再转化为函数，不过最好不要再JSON中存储函数。 12345var text = '{ \"name\":\"Runoob\", \"alexa\":\"function () {return 10000;}\", \"site\":\"www.runoob.com\"}';var obj = JSON.parse(text);obj.alexa = eval(\"(\" + obj.alexa + \")\"); document.getElementById(\"demo\").innerHTML = obj.name + \" Alexa 排名：\" + obj.alexa(); JSON.stringify()使用JSON.stringify()将javascript对象转化为字符串： 1JSON.stringify(value[, replacer[, space]]) 参数： value：必需，待转换的js值（通常是数组或者对象）。 replacer：可选，用于转换结果的函数或者数组。 space：可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。 javascript对象转换假设我们向服务器发送以下数据： 1var obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\"}; 使用JSON.stringify()将上面的数据转化为字符串： 1var myJSON = JSON.stringify(obj); myJSON为字符串。 下面发送myJSON到服务器： 1document.getElementById(\"demo\").innerHTML = myJSON; javascript数组转换还可以将js数组转化为JSON字符串： 12var arr = [ \"Google\", \"Runoob\", \"Taobao\", \"Facebook\" ];var myJSON = JSON.stringify(arr); 使用： 1document.getElementById(\"demo\").innerHTML = myJSON; 异常 解析数据 使用JSON存储Date对象的话要将其转化为字符串： 12var obj = { \"name\":\"Runoob\", \"initDate\":new Date(), \"site\":\"www.runoob.com\"};var myJSON = JSON.stringify(obj); 然后再将字符串转化为Date对象。 解析函数 JSON存储函数的话，JSON.stringify()会将js对象的函数删除，包括键和值。 12var obj = { \"name\":\"Runoob\", \"alexa\":function () {return 10000;}, \"site\":\"www.runoob.com\"};var myJSON = JSON.stringify(obj); 可以在执行JSON.stringify()之前将函数转化为字符串： 123var obj = { \"name\":\"Runoob\", \"alexa\":function () {return 10000;}, \"site\":\"www.runoob.com\"};obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); JSON使用将JSON转换为javascript对象用于获取服务器JSON数据的时候，将JSON转换为javascript对象，然后使用在网页中。 实例创建字符串： 1234var txt = '{ \"sites\" : [' +'{ \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" },' +'{ \"name\":\"google\" , \"url\":\"www.google.com\" },' +'{ \"name\":\"微博\" , \"url\":\"www.weibo.com\" } ]}'; eval()可以将JSON文本转换为js对象。 1var obj = eval(\"(\" + txt + \")\"); 在网页中使用js对象： 1234567891011// 创建js字符串var txt = '{ \"sites\" : [' +'{ \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" },' +'{ \"name\":\"google\" , \"url\":\"www.google.com\" },' +'{ \"name\":\"微博\" , \"url\":\"www.weibo.com\" } ]}';// 创建js对象var obj = eval(\"(\" + txt + \")\");document.getElementById(\"name\").innerHTML=obj.sites[0].name document.getElementById(\"url\").innerHTML=obj.sites[0].url JSON解析器由于eval()可以执行任何js代码，故而有安全隐患。 使用JSON解析器将JSON转换为js对象更安全。 JSONP概念JSONP：JSON with Padding，是JSON的一种使用模式，可以跨域读取数据。 浏览器的同源策略出于安全考虑对域有所限制，JSONP就是跨域的一种方式。 应用客户端访问：https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction 客户端期望返回数据：[&quot;customername1&quot;,&quot;customername2&quot;] 客户端真实返回数据：callbackFunction([&quot;customername1&quot;,&quot;customername2&quot;]) 服务器端jsonp.php： 123456789&lt;?phpheader('Content-type: application/json');//获取回调函数名$jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);//json数据$json_data = '[\"customername1\",\"customername2\"]';//输出jsonp格式的数据echo $jsoncallback . \"(\" . $json_data . \")\";?&gt; 客户端callbackFunction()： 123456789101112&lt;script type=\"text/javascript\"&gt;function callbackFunction(result, methodName){ var html = '&lt;ul&gt;'; for(var i = 0; i &lt; result.length; i++) { html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; } html += '&lt;/ul&gt;'; document.getElementById('divCustomers').innerHTML = html;}&lt;/script&gt; 页面： 1&lt;div id=\"divCustomers\"&gt;&lt;/div&gt; 客户端完整代码： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JSONP 实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"divCustomers\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function callbackFunction(result, methodName) { var html = '&lt;ul&gt;'; for (var i = 0; i &lt; result.length; i++) { html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; } html += '&lt;/ul&gt;'; document.getElementById('divCustomers').innerHTML = html; } &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction\"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以上代码由jQuery实现： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JSONP 实例&lt;/title&gt; &lt;script src=\"https://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"divCustomers\"&gt;&lt;/div&gt; &lt;script&gt; $.getJSON(\"https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?\", function (data) { var html = '&lt;ul&gt;'; for (var i = 0; i &lt; data.length; i++) { html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;'; } html += '&lt;/ul&gt;'; $('#divCustomers').html(html); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考 菜鸟教程：JSON教程","link":"/2018/05/10/JSON-notes/"},{"title":"《JavaScript DOM编程艺术》读书笔记","text":"JavaScript简史DOM可以给文档增加交互能力。 ECMAScript对javascript进行了标准化。 JavaScript为了蹭当时红极一时的Java的流量故而叫做javascript。 DOM是文档对象模型，它是一种API，程序和脚本可以通过这个接口动态地访问和修改文档的内容、结构和样式。 JavaScript语法使用js的两种方式 将js代码放入&lt;head&gt;标签中。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // code &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 将js代码放入一个单独的js文件中，在html中用&lt;script&gt;标签引入。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"js/main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 将2中的&lt;script&gt;放入&lt;/body&gt;之前，以快速加载网页。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"js/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;script&gt;标签中没必要写type=&quot;text/javascript&quot;属性 语法注释12345// 单行注释/* 多行注释*/ 变量赋值：mood = 'happy'; 声明：var mood; 声明并赋值：var mood = 'happy'; 一次声明并赋值多个变量：var mood = 'happy', age = 33; 变量名命名：字母、数字、美元符号、下划线，第一个字符不允许为数字，可以适当在变量名中间插入下划线一边阅读或者使用驼峰式。但是通常命名函数名、方法名、对象属性名用驼峰式。 js是弱类型语言 数据类型 字符串 数值 布尔值 数组 对象 条件语句if语句 123if () { } 12345if () { } else { } 1234567if () { } else if () { } else { } 比较操作符123456789&gt;&lt;&gt;=&lt;======!=!== 使用===和!== 逻辑操作符123&amp;&amp;||! 循环while 123while () { } do…while 至少执行一次 123do { } while (); for 123for (var i = 0; i &lt; 10; i++) { } 函数123function f() { } 调用 1f(); 例子1：将两个数相乘并返回结果 1234function multiply(num1,num2) { var total = num1 * num2; return total;} 例子2：华氏摄氏度转换 12345function convertToCelsius(temp) { var result = temp -32; result = result /1.8; return result;} 命名变量名用下划线分割单词，命名函数用驼峰式 1234var crew_name = 'wang';function getCrewsInfo() { } 变量作用域全局变量声明在js脚本中，作用域是整个js文件。 局部变量，也就是声明在函数内部，作用域就是这个函数内部。 12345678function square(num) { total = num * num; return total;}var total = 50;var number = square(20);alert(number);// 400 需要用var声明局部变量： 1234function square(num) { var total = num * num; return total;} 注意，函数内部变量一定要用var声明以避免二义性。 对象对象是键值对 123{ name: value;} 比如Person对象的属性和方法的调用： 12Person.age;Person.eat(); 创建一个Person实例： 123var mason = new Person;mason.age;mason.mood; 内置对象，比如Array对象 12var arr = new Array(5);arr.length; 还有宿主对象，比如浏览器提供的对象。 DOMD：文档 O：对象 M：模型 文档中的每一个节点都是一个对象。 DOM就是将网页文档转化为一棵以&lt;html&gt;为根的树。 DOM由节点构成，有些节点可以包含其他的节点，节点有三种：元素节点，文本节点，属性节点。 元素节点可以包含其他节点。 文本节点总是被元素节点包含。 属性节点总是被元素节点包含。 例子： 1&lt;p title=\"p_title\"&gt;标题&lt;/p&gt; DOM：元素节点p里面包含了一个title属性子节点和一个“标题”文本子节点。 获取元素getElementById getElementsByTagName 取得文档所有元素节点： 1var nodes = getElementsByTagName('*'); 以上的DOM方法还可以在任意一个节点对象上调用： 12var temp1 = document.getElementById('header');var temp2 = temp1.getElementsByTagName('div'); getElementsByClassName 获取带有多个类名的元素： 1document.getElementsByClassName('div p'); 通过以上DOM方法取得节点后赋值给变量再进行其他操作。 获取设置属性获取元素后可以获取其属性和设置其属性。 getAttribute 只能在元素节点上调用 12345var temp = getElementById('header');var t = temp.getAttribute('title');if (t) { alert(t);} setAttribute 12var temp = getElementById('header');temp.setAttribute('title','这里是标题'); 案例：javascript图片库图库demo： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;图片库&lt;/title&gt; &lt;style&gt; body { padding: 0; margin: 0; } &lt;/style&gt; &lt;script&gt; // 参数是一个a元素 function showPic(whichpic) { var placeholder = document.getElementById('placeholder'); var source = whichpic.getAttribute('href'); placeholder.setAttribute('src',source); var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text; } function countBodyChildren() { var body_element = document.getElementsByTagName('body')[0]; console.log(body_element.childNodes.length); } window.onload = countBodyChildren; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;snapshots&lt;/h1&gt; &lt;ol&gt; &lt;li&gt;&lt;a title=\"title1\" href=\"img/1.jpg\" onclick=\"showPic(this);return false;\"&gt;img 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a title=\"title2\" href=\"img/2.jpg\" onclick=\"showPic(this);return false;\"&gt;img 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a title=\"title3\" href=\"img/3.jpg\" onclick=\"showPic(this);return false;\"&gt;img 3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a title=\"title4\" href=\"img/4.jpg\" onclick=\"showPic(this);return false;\"&gt;img 4&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;img id=\"placeholder\" src=\"img/placeholder.jpg\" alt=\"\" height=\"666px\"&gt; &lt;p id=\"description\"&gt;标题&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; nodeType 元素节点的nodeType为1 属性节点的nodeType为2 文本节点的nodeType为3 这里发现了vscode的go live插件不能正确显示改变后的title，垃圾 最佳实践平稳退化1window.open(url,name,features); 1window.open('https://www.baidu.com','baidu','width: 400,height: 150'); 伪协议123function pop(website){ window.open(website,'baidu','width: 400,height: 150');} 1&lt;a href=\"javascript:pop('https://baidu.com');\"&gt;link&lt;/a&gt; 尽量不用伪协议调用js代码。 window.onload = func; 向后兼容对象检测： 123if (document.getElementById) { } 兼容： 1234window.onload = function() { if (!document.getElementById) return false; // ...} 性能考虑 尽量少访问DOM，尽量减少标记 合并脚本，并放在&lt;/body&gt;之前 压缩脚本 案例：图片库改进版123window.onload = function() { } 1234567891011function addloadEvent(func) { var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = func; } else { window.onload = function() { oldonload(); func(); } }} 现在再添加函数只需要：addloadEvent(firstFunc) onkeypress 动态创建标记传统技术：document.write innerHTML DOM方法：createElement createTextNode appendChild insertBefore document.body parentNode firstChild lastChild insertBefore nextSibling 编写insertAfter函数： 12345678function insertAfter(newElement,targetElement) { var parent = targetElement.parentNode; if (parent.lastChild == targetElement) { parent.appendChild(newElement); } else { parent.insertBefore(newElement,targetElement.nextSibling); }} Ajax局部更新页面而不同刷新 XMLHttpRequest对象创建对象： ie： 1var request = new ActiveXObject('Msxml2.XMLHTTP.3.0'); 其他浏览器： 1var request = new XMLHttpRequest(); 编写getHTTPObject.js文件 12345678910111213function getHTTPObject() { if (typeof XMLHttpRequest == 'undefines') XMLHttpRequest = function () { try {return new ActiveXObject(\"Msxml2.XMLHTTP.6.0\");} catch (e) {} try {return new ActiveXObject(\"Msxml2.XMLHTTP.3.0\");} catch (e) {} try {return new ActiveXObject(\"Msxml2.XMLHTTP\");} catch (e) {} return false; } return new XMLHttpRequest();} var request = new getHTTPObject();返回一个XMLHttpRequest对象。 XMLHttpRequest对象的方法： open GET,POST,SEND 是否异步 编写getNewContent.js 123456789101112131415161718function getNewContent() { var request = getHTTPObject(); if (request) { request.open('GET','example.txt',true); request.onreadystatechange = function() { if (request.readyState == 4) { var para = document.createElement('p'); var txt = document.createTextNode(request.responseText); para.appendChild(txt); document.getElementById('new').appendChild(para); } }; request.send(null); } else { alert('sorry,your browser dont support XMLHttpRequest'); }}addLoadEvent(getNewContent); 充实文档的内容CSS-DOMelement.style是一个对象 element.style.property引用节点属性，如果属性名是用连字符的则改写为驼峰式。 但是以上只能返回行内样式，不能用来操作外部样式。 通过用DOM去修改元素的className来达到切换样式的目的。 1element.className = value; addClass函数： 12345678function addClass(element,value) { if (!element.className) { element.className = value; } else { newClassName = element.className + ' ' + value; element.className = newClassName; }} 用js实现动画效果var variable = setTimeout(func,delay); clearTimeout(variable); parseInt() parseFloat() html5canvas &lt;video&gt; controls addEventListener 综合示例js库jQuery prototype etc 常用代码addClassaddClass()用于为节点对象添加新类名。 参数：元素节点，新类名。 12345678910function addClass(element,value) { if (!element.className) { element.className = value; } else { newClassName = element.className; newClassName += ' '; newClassName += value; element.className = newClassName; }} insertAfterinsertAfter()用于将新节点插到目标节点后面。 参数：新节点，目标节点。 12345678function insertAfter(newElement,targetElement) { var parent = targetElement.parentNode; if (parent.lastChild == targetElement) { parent.appendChild(newElement); } else { parent.insertBefore(newElement,targetElement.nextSibling); }} addLoadEvent用于添加页面onload后立刻执行的函数。 参数为需要立刻执行的函数。 1234567891011function addLoadEvent(func) { var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = func; } else { window.onload = function() { oldonload(); func(); } }} 调用： 1addLeadEvent(func);","link":"/2018/03/01/JavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"},{"title":"LaTeX安装和配置（mac平台）","text":"准备写人工智能领域的论文了，安装配置一下LaTeX。 主要是mactex的安装以及vscode的配置。 LaTeX（LATEX，音译“拉泰赫”）是一种基于TEX的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天、甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 下载mactex官网下载（使用迅雷）：https://www.tug.org/mactex/ 清华镜像站：https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/ 安装mactex安装完毕后launchpad会出现两个app，LaTeXiT是配置用的，TeXshop是编辑器。 不过自带的编辑器TeXshop过于简陋，故而使用VScode来配置LaTeX写作环境。 查看文档安装完成后就可以使用以下命令来查看中文的LaTeX简明文档了（一百多页）。 1texdoc lshort-china 然后另存到常用目录下。 使用vscode安装插件 LaTeX workshop LTex 配置settings.jsonvscode在settings.json文件中添加： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115{ \"latex-workshop.latex.tools\": [ { \"name\": \"latexmk\", \"command\": \"latexmk\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-pdf\", \"%DOC%\" ] }, { \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] } ],\"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] }, { \"name\": \"latexmk\", \"tools\": [ \"latexmk\" ] }, { \"name\": \"pdflatex -&gt; bibtex -&gt; pdflatex*2\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] }, { \"name\": \"xelatex-&gt;bibtex-&gt;xelatex-&gt;xelatex\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", ] } ], \"latex-workshop.view.pdf.viewer\": \"tab\", \"latex-workshop.latex.clean.fileTypes\": [ \"*.aux\", \"*.bbl\", \"*.blg\", \"*.idx\", \"*.ind\", \"*.lof\", \"*.lot\", \"*.out\", \"*.toc\", \"*.acn\", \"*.acr\", \"*.alg\", \"*.glg\", \"*.glo\", \"*.gls\", \"*.ist\", \"*.fls\", \"*.log\", \"*.fdb_latexmk\" ], //下面这段是语法检查模块//{\"ltex.enabled\": true, // 启用插件\"ltex.language\": \"en-US\",// 设置语言，这里是德语// 要英语就下载对应 English Support，然后这里填 en, 或者 en-US,en-GB 等*/ \"ltex.de.dictionary\": [\"Niubility\", \"Zhihu\"], //注意根据要对应语言，ltex.&lt;LANGUAGE&gt;.dictionary\"ltex.environments.ignore\": [ \"lstlisting\", \"verbatim\"],\"ltex.commands.ignore\": [ \"\\\\documentclass[]{}\", \"\\\\renewcommand*{}[]{}\"],//}语法检查功能在这里结束} 如果需要配置skim（在skim设置中的sync标签下，PDF-TeX Sync support下的preset选择vscode即可。），则settings.json添加如下配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133{ \"latex-workshop.latex.tools\": [ { \"name\": \"latexmk\", \"command\": \"latexmk\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-pdf\", \"%DOC%\" ] }, { \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] } ],\"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] }, { \"name\": \"latexmk\", \"tools\": [ \"latexmk\" ] }, { \"name\": \"pdflatex -&gt; bibtex -&gt; pdflatex*2\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] }, { \"name\": \"xelatex-&gt;bibtex-&gt;xelatex-&gt;xelatex\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", ] } ], \"latex-workshop.view.pdf.viewer\": \"tab\", \"latex-workshop.latex.clean.fileTypes\": [ \"*.aux\", \"*.bbl\", \"*.blg\", \"*.idx\", \"*.ind\", \"*.lof\", \"*.lot\", \"*.out\", \"*.toc\", \"*.acn\", \"*.acr\", \"*.alg\", \"*.glg\", \"*.glo\", \"*.gls\", \"*.ist\", \"*.fls\", \"*.log\", \"*.fdb_latexmk\" ], //下面这段是语法检查模块//{\"ltex.enabled\": true, // 启用插件\"ltex.language\": \"en-US\",// 设置语言，这里是德语// 要英语就下载对应 English Support，然后这里填 en, 或者 en-US,en-GB 等*/ \"ltex.de.dictionary\": [\"Niubility\", \"Zhihu\"], //注意根据要对应语言，ltex.&lt;LANGUAGE&gt;.dictionary\"ltex.environments.ignore\": [ \"lstlisting\", \"verbatim\"],\"ltex.commands.ignore\": [ \"\\\\documentclass[]{}\", \"\\\\renewcommand*{}[]{}\"],\"editor.fontSize\": 18,//}语法检查功能在这里结束\"latex-workshop.view.pdf.viewer\": \"external\",\"latex-workshop.view.pdf.external.synctex.command\": \"/Applications/Skim.app/Contents/SharedSupport/displayline\",\"latex-workshop.view.pdf.external.synctex.args\": [\"-r\",\"%LINE%\",\"%PDF%\",\"%TEX%\"],\"latex-workshop.view.pdf.external.viewer.command\": \"/Applications/Skim.app/Contents/MacOS/Skim\",\"latex-workshop.view.pdf.external.viewer.args\": [ \"%PDF%\"],} 使用sublime text安装插件安装插件：LaTeX Tools 设置skim支持在skim设置中的sync标签下，PDF-TeX Sync support下的preset选择sublime text即可。 开始写LaTeX新建扩展名为.tex的文档就可以开始写LaTeX了。 1touch article.tex 使用XeLaTeX编译为了解决pdfLaTeX无法支持中文的问题，需要在Tex文档头部加上： 12%!TEX program = xelatex\\usepackage[UTF8]{ctex} 编译的时候也要选择XeLaTeX。 sublime text使用cmd + B即可编译。 随机弹出pdf预览（需要完成设置skim）。 使用shift + cmd并点击skim中的内容可以跳至sublime text对应代码。 使用TexpadTexpad是一款mac平台的LaTeX编辑器，使用起来更为专注和方便。 关键在于不用配置，省心。 测试123456789101112%!TEX program = xelatex\\usepackage[UTF8]{ctex}\\documentclass{article}\\usepackage{fontspec, xunicode, xltxtra}\\setmainfont{Hiragino Sans GB}\\title{标题}\\author{}\\begin{document}\\maketitle{}\\section{段落}内容，内容，内容，内容，内容，内容，内容，内容，内容，内容，内容，内容。\\end{document} 效果： LaTeX辅助工具 LaTeX官方中文文档：https://cdn.jsdelivr.net/gh/herotiga/cdn/pdf/lshort-zh-cn.pdf 妈咪叔LaTeX帮助文档：https://latexlive.com/help mactex官网：https://www.tug.org/mactex/ LaTeX公式编辑器：https://latexlive.com/ xFormula（mac）：https://apps.apple.com/cn/app/id1477136751 LaTeX表格代码生成器：https://www.tablesgenerator.com/ 网页版LaTeX：https://www.overleaf.com/","link":"/2020/06/18/LaTeX-installation/"},{"title":"RSA算法原理","text":"在量子计算机问世之前再复习一下RSA算法。 RSA算法是一种非对称加密算法，所谓非对称加密是相对于对称加密而言的。 下面了解一下对称加密、非对称加密以及RSA算法。 对称加密对称加密算法就是A想要发送一段明文msg给B，但是明文发送会被截获不安全怎么办？A就对明文进行了加密，这个加密算法我将它称之为$f()$，故而明文就被加密为$f(msg)$。B收到密文后使用$f()$的逆算法对$f(msg)$解密出明文。这样的加密算法$f()$就称之为对称加密。 对称加密的缺点是：A必须事先将加密算法$f()$告诉B，这个过程就可能被窃听导致加密算法$f()$泄漏，即使是加密算法没有泄漏，还有可以通过分析密文规律从而破解出明文的。 现在的量子保密通信可以实现密钥分发的保密性，可是量子通信技术还远远没有成熟，目前安全的方法还是非对称加密。 非对称加密B生成一把公钥和一把私钥，公钥可以公布，私钥要保存好。A需要获取B的公钥，A向B发送信息的时候就使用B提供的公钥加密。B收到密文后使用私钥对其进行解密且不能使用公钥而只能使用B所持有的密钥对密文解密，这就是非对称加密。即使别人窃听了密文和公钥也是无法得知明文。 这样只要B的私钥没有泄露，那么信息就是安全的。当然除非使用大算力暴力破解，不过这样做cost是极高的。 RSA算法就是一种典型的非对称加密算法，它的使用范围非常广并且非常安全。 至于为什么叫RSA？因为算法的三个发明者的名字首字母是这个。 RSA算法的密钥长度越长越难破解。 目前普遍使用的是RSA1024和RSA2048。 RSA算法欧拉函数欧拉函数基于一个数学概念“互质”，所谓互质就是两个数如果没有除了1之外的公约数那就称这两个数互质。 对于给定的整数n，有多少个从1到n的数和n互质(包含1)，这就是欧拉函数：$$\\Phi(n)$$比如：$\\Phi(1)=1$,$\\Phi(5)=4$,$\\Phi(8)=4$ 既然用到了欧拉函数，为了防止混淆，再回顾一下欧拉公式和欧拉方程是什么东西。 欧拉公式 欧拉方程 算法 找两个质数p和q n = p * q 构造欧拉函数：$\\Phi(n)=(p-1)(q-1)$ 找一个整数公钥e，满足1 &lt; e &lt; $\\Phi(n)$，并且e要满足与$\\Phi(n)$互质。 找一个私钥d，满足条件ed除以$\\Phi(n)$后余数为1 加密：$m^{e}/n$求出余数c，c就是加密后的密文。（m为明文） 解密：现在有密文c还有私钥d，$c^d/n$求出余数，这个求得的余数就是明文m。 安全性发送信息：公钥e，数字n，密文c 解密信息需要：私钥d，数字n，密文c 通过公钥e算出私钥d是否可行？ 需要知道$\\Phi(n)$,从而又转化为求p和q，n=pq，质因数分解，大数（比如1024位的二进制数或者2048位的二进制数）的质因数分解非常困难。 故而，我们分析出了RSA算法安全的原因，那就是大数的质因数分解非常困难！","link":"/2020/03/27/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"},{"title":"Tex&#x2F;LaTex公式书写","text":"学习一下Tex/LaTex语法 参考1. 简书：markdown中公式编辑教程","link":"/2020/03/21/Tex-LaTex%E5%85%AC%E5%BC%8F%E4%B9%A6%E5%86%99/"},{"title":"Vue.js学习笔记","text":"记录一下学习vue的过程。 vue核心数据驱动传统jquery： 1234567&lt;div&gt; &lt;span class=\"txt\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; $('.txt').text('填充span的内容');&lt;/script&gt; vue数据驱动：一旦改变data里txt变量的内容，则span里面绑定的txt也会跟着改变。 注意：data属性的值不可以被页面修改。 注意：在组件里面使用变量需要这样写： 123456789&lt;script&gt; export default { data: function () { return { msg: '填充span的内容' } } }&lt;/script&gt; 组件里面不能直接这样写，页面里面可以直接这样写： 1234567&lt;script&gt; export default { data: { msg: '填充span的内容' } }&lt;/script&gt; 下面是vue的写法： 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;span&gt;{{ txt }}&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function () { return { msg: '填充span的内容' } } }&lt;/script&gt; 现在用js的setTimeout()来改变span里面txt的内容，这样span里面的txt就会在组件加载完毕后的1000ms后改变msg的值。 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;span&gt;{{ msg }}&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function () { return { msg: '填充span的内容' } }, mounted: function () { var self = this; setTimeout(function() { self.msg = '改变了的数据' },1000) } }&lt;/script&gt; props属性，可以暴露出去让页面异化组件的文案。 指令一般形式v-xxx v-text=&quot;msg&quot;和作用一样 v-html 用于更新元素的innerHTML V-if ：根据表达式真假 渲染元素。 v-show：根据表达式真假切换元素的display。 组件如何在父组件里面引入子组件？ 编辑父组件： 123456789101112131415161718&lt;template&gt; &lt;div id=\"parent\"&gt; &lt;!-- 在父组件中调用子组件 --&gt; &lt;son&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 首先import子组件，这里可以给子组件一个变量，我这里给的变量是son,引入的组件路径名可以不加.vue扩展名 import son from '@/components/son' // 再在components中声明使用子组件 export default { name: 'parent', components: { son } }&lt;/script&gt; 方法vue中定义方法： 123456789&lt;script&gt; export default { methods: { doSth :function () { alert('done'); } } }&lt;/script&gt; 使用方法： v-on:eventName用于绑定事件，这里绑定click事件 12345678910111213&lt;button v-on:click=\"doSth\"&gt;{{ txt }}&lt;/button&gt;//缩写为&lt;button @click=\"doSth\"&gt;{{ txt }}&lt;/button&gt;&lt;script&gt; export default { methods: { doSth: function(){ alert(txt); } } }&lt;/script&gt; 生命周期 beforeCreate：组件创建之前 created：组件创建完毕 beforeMount：组件挂载之前 mounted：组件挂载完毕 beforeDestory：组件销毁之前 destroyed：组件销毁后 vue中还有一些认为出发的回调函数： deactivated：组件未使用状态 activated：组件使用状态（只有在被keep-alive标签包含的时候才会activated和deactivated） beforeUpdate：组件变动之前 updated：组件变动之后（全局监听） watch可以监听data里面的数据。 watch的用法： 12345678910111213&lt;script&gt; export default { watch: { 'info.name': function(newV,oldV) { console.log(newV); console.log(oldV); }, sex: function(newV,oldV) { console.log(newV); } } }&lt;/script&gt; vue里面不能直接监听一个对象，只能监听对象的值或者变量。 下面的例子：watch监听info.name，一旦发生改变就执行后面的函数。 12345678910&lt;script&gt; export default { watch: { 'info.name': function(newV,oldV) { console.log(newV); console.log(oldV); } } }&lt;/script&gt; 上面的函数在info.name发生改变后就执行，紧接着updated()才执行。 如何监听一个对象，下面是监听一个info对象的写法： 12345678910&lt;script&gt; export default { watch: { info: { handler: function(n,o) {}, deep: true } } }&lt;/script&gt; computedv-modellazy懒加载 v-model.lazy=&quot;modelValue&quot; trim去掉空白 v-model可以做到双向绑定，下面是例子： 123456789101112&lt;div id=\"demo\"&gt; &lt;input v-model=\"msg\"&gt; &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; export default { data: { msg: '信息' } }&lt;/script&gt; 安装 方法一：在html中以script标签引入 1&lt;script src=\"https://lib.baomitu.com/vue/2.6.10/vue.js\"&gt;&lt;/script&gt; vue-cli方式引入（通常用这种方式引入） 安装cnpm 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 安装vue-cli 1$ cnpm install -g vue-cli 初始化初始化vue项目webpack参数表示用webpack打包，它可以把.vue打包成css html js文件。 1$ vue init webpack project_name 选项配置如下： 等待安装完毕： 123$ cd test$ cnpm install$ npm run dev 开发1$ npm run dev 开发过程中发现vue的视图有padding: 8px的样式。下面清除vue的默认样式。 清除vue默认样式App.vue文件style标签中添加 1234body { padding: 0; margin: 0;} 或者在main.js文件中引入一个reset.css文件: 1import '@/css/reset.css' reset.css： 1html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,menu,nav,output,ruby,section,summary,time,mark,audio,video,input{margin:0;padding:0;border:0;font-weight:normal;vertical-align:baseline;}article,aside,details,figcaption,figure,footer,header,menu,nav,section{display:block;}body{line-height:1;font-family:\"Microsoft YaHei\";font-size:16px;}blockquote,q{quotes:none;}blockquote:before,blockquote:after,q:before,q:after{content:none;}table{border-collapse:collapse;border-spacing:0;}a{color:#7e8c8d;text-decoration:none;-webkit-backface-visibility:hidden;}li{list-style:none;}::-webkit-scrollbar{width:5px;height:5px;}::-webkit-scrollbar-track-piece{background-color:rgba(0,0,0,0.2);-webkit-border-radius:6px;}::-webkit-scrollbar-thumb:vertical{height:5px;background-color:rgba(125,125,125,0.7);-webkit-border-radius:6px;}::-webkit-scrollbar-thumb:horizontal{width:5px;background-color:rgba(125,125,125,0.7);-webkit-border-radius:6px;}html,body{width:100%;}body{-webkit-text-size-adjust:none;-webkit-tap-highlight-color:rgba(0,0,0,0);} 以上reset.css代码经过了压缩，用的时候在项目目录@/css下新建一个reset.css文件，将上面代码复制进去，再再main.js中import即可。 编译1$ npm run build 最终代码在dist目录中 目录init完毕后项目目录下有这些文件： Package.json保存依赖信息 config保存项目初始化配置 build保存webpack初始化配置 需要写的代码都在src中 src/main.js是入口js文件 dist是最终编译生成的代码 main.js文件123456789101112131415161718192021222324252627// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.// 引入vue，在vue中引入文件直接用importimport Vue from 'vue'// 引入App.vue文件，这个文件是一个视图容器，然后我们在视图中装载各种组件或者页面import App from './App'// 引入路由配置import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */// 新建vue实例。new Vue({ // 绑定#app元素，意思是将视图放在#app元素中 el: '#app', router, // 引入的组件 components: { App }, // 文件内容将以&lt;App/&gt;这样的标签写进#app中 // template里面的内容将被写进页面 template: '&lt;App/&gt;'})// 以上一段代码的意思是将App.vue放到#app中，然后用&lt;App/&gt;代指#app App.vue文件在vue中这种文件叫做组件，单页面的意思是结构、样式、逻辑都写在一个.vue文件中，当我们引入这个文件后就相当于引入了对应的结构、样式和js，这就是前端组件化。 1234567891011121314151617181920212223&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App'}&lt;/script&gt;&lt;style&gt;#app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; 对于.vue文件，webpack在编译的时候将.vue文件中的html、css、js分别抽离出来组成一个单独的文件。 .vue组件文件组成：&lt;template&gt;标签，&lt;script&gt;标签以及&lt;style&gt;标签。这里注意在.vue文件的最后面总是要留一个空行。 &lt;template&gt;标签下仅能有一个根标签， vue依靠锚点达到不需要刷新页面就切换内容的效果。 &lt;router-view&gt;标签的作用是在页面中放入一个路由器视图容器，当我们访问http://localhost:8080/#/about/的时候会将about的内容放进去，访问http://localhost:8080/#/recruit的时候会将recruit的内容放进去 也就是说除了&lt;router-view&gt;中的视图，App.vue文件中的其他部分都是公用的，无所访问什么路由都会有这部分。 路由文件router/index.js12345678910111213141516171819import Vue from 'vue'// 引入路由插件vue-routerimport Router from 'vue-router'// 引入页面组件import HelloWorld from '@/components/HelloWorld'// 声明使用路由Vue.use(Router)// 注册路由器并配置路由，给不同的页面或者组件分配不同的路径export default new Router({ routes: [ { path: '/', name: 'HelloWorld', component: HelloWorld } ]}) 比如配置http://localhost:8080/#/about/me，其实只需要给/about加一个子路由既可。 1234567891011121314151617181920212223export default new Router({ routes: [ { path: '/', name: 'HelloWorld', component: HelloWorld }, { path: '/about', name: 'about', component: About, children: [ { path: '/', component: page1 },{ path: '/me', component: Me } ] } ]}) 然后在about.vue中放路由既可 1234&lt;template&gt; &lt;div&gt;共用部分&lt;/div&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt; 页面一般放在pages或者views目录下，组件放在components目录下，但其实页面和组件都是组件。 如果我想让用户访问我配置之外的路由的时候跳转到根目录该怎么办？使用path: /* 12345678910111213141516171819202122232425262728export default new Router({ routes: [ { path: '/', name: 'HelloWorld', component: HelloWorld }, { path: '/about', name: 'about', component: About, children: [ { path: '/', component: page1 },{ path: '/me', component: Me } ] }, { path: '/*', name: 'HelloWorld', component: HelloWorld } ]}) &lt;router-link&gt;标签是vue提供的用于路由跳转的： 12345&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-link :to=\"{name: HelloWorld}\"&gt;前往helloworld&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 也可以使用传统a标签写： 1&lt;a href=\"#/\"&gt;前往helloworld&lt;/a&gt; 小节 .vue文件中有共用部分也有根据路径选择性装载的部分。这部分的vue文件写完后再在router/index.js中配置好了路由，然后在公共部分后面加上&lt;router-view&gt;&lt;/router-view&gt;既可。 组件将经常用的代码比如按钮、导航等等封装成组件以方便后续使用。调用只需要写&lt;组件名&gt;&lt;/组件名&gt;。 一个页面可以由很多组件组成。 开发组件库我们在日常开发中将一个按钮、导航、列表等元素封装成组件以后以后使用。调用只需要写上&lt;component-name&gt;&lt;/component-name&gt;即可。 现在要开发一个页面： 一个首页，包含三个字页面：按钮页面，列表页面，导航页面。 页面都放在@/pages中，组件都放在@/components中。 @/pages中包含首页和三个子页面，@/components中包含三个组件。 先进行路由配置：先import页面组件，再配置路由。 1234567891011121314151617181920212223242526272829303132333435import Vue from 'vue'import Router from 'vue-router'// 引入首页和三个字页面import index from '@/pages/index.vue'import pageQuiButton from '@/pages/pageQuiButton.vue'import pageQuiList from '@/pages/pageQuiList.vue'import pageQuiNav from '@/pages/pageQuiNav.vue'Vue.use(Router)export default new Router({ routes: [ { path: '/', name: 'index', component: index }, { path: '/btn', name: 'btn', component: pageQuiButton }, { path: '/list', name: 'list', component: pageQuiList }, { path: '/nav', name: 'nav', component: pageQuiNav } ]}) 以上路由配置的意思是： 首页：http://localhost:8080/#/ 按钮页面：http://localhost:8080/#/btn 列表页面：http://localhost:8080/#/list 导航页面：http://localhost:8080/#/nav 注意根页面是：#/，比如： 123&lt;template&gt; &lt;a href=\"#/\"&gt;链接&lt;/a&gt;&lt;/template&gt; 再来看App.vue里面 123456&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1 class=\"page-title\"&gt;&lt;a href=\"#/\"&gt;开发组件库&lt;/a&gt;&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 上面的h1是一个公共元素，无论进入页面都有它。 tips：除了直接在style标签里写样式之外，还可以引入css文件，只要在&lt;style&gt;中添加@import 'url';，比如： 123&lt;style scoped&gt; @import '@/assets/css/common.css';&lt;/style&gt; scoped关键字代表样式是私有的。 下面写首页index.vue：这里用@import引入样式 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=\"mod-module mod-parallel\"&gt; &lt;div class=\"img-list type-full\"&gt; &lt;div class=\"img-box\"&gt; &lt;p class=\"img-item\"&gt; &lt;a class=\"page-link\" href=\"#/btn\"&gt;按钮&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=\"img-box\"&gt; &lt;p class=\"img-item\"&gt; &lt;a class=\"page-link\" href=\"#/list\"&gt;列表&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=\"img-box\"&gt; &lt;p class=\"img-item\"&gt; &lt;a class=\"page-link\" href=\"#/nav\"&gt;导航&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; @import '@/assets/css/index.css'&lt;/style&gt; &lt;template&gt;中的内容和平时写html差不多，不过&lt;template&gt;标签下只能有一个根元素。 特别注意下a标签href属性的书写： 1&lt;a class=&quot;page-link&quot; href=&quot;#/btn&quot;&gt;按钮&lt;/a&gt; vue运行时将&lt;template&gt;中的内容都注入到App.vue页面的router-view中，从而可以实现无刷新路由跳转。 quiButton.vue组件下面编写按钮组件quiButton.vue 1234567891011121314151617181920&lt;template&gt; &lt;button class=\"qui-btn\"&gt; &lt;span&gt;{{ msg }}&lt;/span&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default { data: function() { return { msg: '下载' } } }&lt;/script&gt;&lt;style scoped&gt; @import '@/assets/css/reset.css'; @import '@/assets/css/qui-btn.css'&lt;/style&gt; 如果这不是组件的话，正常data的写法可以直接写一个对象data: { msg: '下载' },但是由于组件会被在多个地方引用，故而这里用function来每次返回一个对象实例。 如果我希望每次调用按钮组件按钮里面的内容都不相同（如下），该怎么办。 1&lt;qui-btn msg=\"确定\" class=\"small\"&gt;&lt;/qui-btn&gt; 只需要将属性写在props里面。 123456789&lt;script&gt; export default { props: { msg: { default: '下载' } } }&lt;/script&gt; 把属性写在props里面就可以暴露给其他页面调用。props是专门用来暴露组件的属性接口的。这里定义了msg的默认值下载，其他页面调用只需要： 1&lt;qui-btn msg=\"确定\"&gt;&lt;/qui-btn&gt; vue如何绑定事件？使用methods属性： 1234567891011121314151617181920&lt;template&gt; &lt;button class=\"qui-btn\" v-on:click=\"btnClickEvent\"&gt; &lt;span&gt;{{msg}}&lt;/span&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default { props: { msg: { default: '下载' } }, methods: { //绑定事件的关键代码 btnClickEvent: function(){ alert(this.msg); } } }&lt;/script&gt; 写完事件函数后，给按钮绑定事件： 12&lt;button v-on:click=\"btnClickEvent\"&gt;&lt;/button&gt; 或者： 12&lt;button @click=\"btnClickEvent\"&gt;&lt;/button&gt; 现在我们已经做好了按钮组件了，来使用pageQuiButton.vue组件。 12345678910111213141516//pageQuiButton.vue&lt;template&gt; &lt;div id=\"pageQuiButton\"&gt; &lt;!--使用--&gt; &lt;qui-btn msg=\"确定\" class=\"small\"&gt;&lt;/qui-btn&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import quiBtn from '../components/quiButton.vue' /*引用*/ export default { name: 'pageQuiButton', components: { 'qui-btn': quiBtn /*注册自定义标签*/ } }&lt;/script&gt; 首先，script里面import了按钮组件复制给变量quiBtn，在components中给他自定义标签名，用msg给组件传值。 那么按钮的点击事件怎样异化呢： 1&lt;qui-btn v-on:btnClickEvent=\"doSth\" msg=\"我可以点击\"&gt;&lt;/qui-btn&gt; 上面的代码引用组件时注册了一个时间，btnClickEvent事件时组按钮组件中定义的，这里给这个btnClickEvent一个新的方法doSth。 同时，在script中声明这个自定义方法： 123456789101112131415//pageQuiButton.vue&lt;script&gt; import quiBtn from '@/components/quiButton.vue' export default { name: 'pageQuiButton', components: { 'qui-btn': quiBtn }, methods: { doSth: function () { alert('你点击了组件的click:btnClickEvent'); } } }&lt;/script&gt; 以上的方法叫做监听，组件引用房监听子组件的内置方法，同时在子组件中需要出发这个事件，一下时在子组件中的关键代码： 1234567891011121314151617//quiButton.vue//子组件中的代码&lt;script&gt;export default { props: { msg: { default: \"下载\" } }, methods: { btnClickEvent: function() { alert(\"先弹出默认的文案\"); this.$emit(\"btnClickEvent\"); //关键代码父组件触发自定义事件 } }};&lt;/script&gt; 父组件监听，子组件触发。 这样引用方（父组件）就可以给不同子组件调用不同的事件处理了。 123456789101112&lt;qui-btn v-on:btnClickEvent=\"doSth1\" msg=\"确定\"&gt;&lt;/qui-btn&gt;&lt;qui-btn v-on:btnClickEvent=\"doSth2\" msg=\"取消\"&gt;&lt;/qui-btn&gt;&lt;script&gt; methods: { doSth1: function () { alert('111'); }, doSth2: function () { alert('222'); } }&lt;/script&gt; 怎样给按钮加上图片：slot插槽 给按钮组件加上一段结构 1234567//quiButton.vue&lt;template&gt; &lt;button class=\"qui-btn\" v-on:click=\"btnClickEvent\"&gt; &lt;slot name=\"icon\"&gt;&lt;/slot&gt;&lt;!--重点在这里--&gt; &lt;span&gt;{{msg}}&lt;/span&gt; &lt;/button&gt;&lt;/template&gt; 引用： 123&lt;qui-btn msg=\"下载\" class=\"with-icon\"&gt; &lt;img slot=\"icon\" class=\"ico\" src=\"xxx.png\" /&gt;&lt;/qui-btn&gt; 渲染的时候，会将img整个替换掉组件中的对应name的slot标签。 quiNav.vue组件如下： 功能需求：点击导航tab可以给当前 tab加上一个active类，同时切换底部的黄色滑条，并且输出当前tab文案，同时支持自定义事件。 还得暴露一个属性支持导航tab个数。 关键代码： 1234567891011121314151617181920212223242526272829303132333435//quiNav.vue&lt;template&gt; &lt;div class=\"qui-nav nav-type-1\"&gt; &lt;a v-for=\"(item, index) in items\" &gt;&lt;!--关键代码v-for--&gt; &lt;span class=\"nav-txt\"&gt;{{item.text}}&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function () { return { items: [ { text: '首页', active: true }, { text: '列表', active: false; }, { text: '关于', active: false }, { text: '招聘', active: false } ] } } }&lt;/script&gt; 以上代码关键在于对a标签的v-for指令的使用，items是data里面定义的对象。 v-for=&quot;(item,index) in items&quot;暴露了item和index两个接口，这是vue提供的，分别代表了items中每一项和该项的下表，接着就可以在标签中使用绑定了。 动态添加class：首先每一个tab都有默认的class，点击tab后，为当前tab添加active类，其他tab删除active类。 动态类名： 1234567891011121314151617181920212223//quiNav.vue&lt;template&gt; &lt;div class=\"qui-nav nav-type-1\"&gt; &lt;a v-for=\"(item,index) in items\" :class=\"[commonClass,item.active ? activeClass : '']\"&gt; &lt;span class=\"nav-txt\"&gt;{{ item.text }}&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function () { return { commonClass:'nav-item', activeClass: 'active', items: [ //数据 ] } } }&lt;/script&gt; 如何修改每一个item的active值？就是给每一个tab绑定一个点击事件，当点击事件触发时修改当前tab对应的item的active： 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=\"qui-nav nav-type-1\"&gt; &lt;a v-for=\"(item, index) in items\" :class=\"[commonClass,item.active ? activeClass : '']\" v-on:click=\"navClickEvent(items,index)\" &gt; &lt;span class=\"nav-txt\"&gt;{{item.text}}&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data:function(){ return { commonClass:'nav-item', activeClass:'active', items:[ { text: '首页', active : true }, ...... ] } }, methods:{ navClickEvent:function(items,index){ /*默认切换类的动作*/ items.forEach(function(el){ el.active = false; }); items[index].active = true; /*开放用户自定义的接口*/ this.$emit('navClickEvent',items,index); } } }&lt;/script&gt; 以上代码，利用v-for为每个a标签绑定了一个click事件，click事件为navClickEvent，事件接受两个参数。 点击的时候，把items中的每一个item.active设置为false，把当前tab的active设置为true，最后再出发一次自定义事件。 这样就完成了导航组件，使用了v-for循环输出每一个tab，为每一个tab绑定动态class类名，同时在点击事件的时候动态的切换类。 小节回顾下我们这一篇章都学了什么内容。 页面路由的配置 按钮组件自定义属性props 按钮组件自定义事件 $on $emit 按钮组件自定义子块slot for循环实现导航组件 动态类名 quiList.vue组件 quiList.vue: 1234567891011121314151617181920212223242526272829//quiList.vue&lt;template&gt; &lt;div class=\"qui-list\"&gt; &lt;span class=\"list-tips\"&gt;{{tipsText}}&lt;/span&gt; &lt;qui-btn v-on:btnClickEvent=\"btnClickEvent\" :msg=msg class=\"small\"&gt;&lt;/qui-btn&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import quiButton from '../components/quiButton.vue' export default{ props:{ msg: { default: '下载' }, tipsText: { default: '默认的文案' } }, components: { 'qui-btn': quiButton }， methods:{ btnClickEvent:function(){ alert('按钮点击事件') } } }&lt;/script&gt;","link":"/2020/03/28/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"YAML笔记","text":"YAML：YAML Ain’t a Markup Language YAML：YAML不是一种标记语言 YAML官网：YAML YAML发音是：/ˈjæməl/，类似于：鸭某。 如上所示，YAML是“YAML Ain’t a Markup Language”的递归缩写（YAML不是标记语言）。 YAML是专门用来写配置文件的语言。 在YAML语言开发的时候，实际上，YAML的意思是“Yet Another Markup Language”（仍然是另一种标记语言）。 YAML可以简单表示清单、散列表、标量等数据，使用空白来缩进和大量依赖外观的特色，适合用来表达或者编辑数据结构、配置文件、倾印调试内容、文件大纲等等。 YAML文件扩展名为.yml。 语法规则 大小写敏感 使用缩进表示层级结构，且不能用tab只能用空格space，缩进的空格数量不重要，只要相同层级左对齐即可 用#进行单行注释 数据类型 对象：键值对的集合，又称为映射、哈希、字典。 键值对写法： 12345678910111213141516171819# 冒号后面有一个空格key: value# 值还可以是对象key: {key1: value1, key2: value2, ...}# 层级，下面用的不是tab，是4个空格key: key1: value1 key2: value2# 较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value# 在复杂对象中的key和value都各为一个数组? - key1 - key2: - value1 - value2 数组：一组有次序的值，又称为序列、列表。 数组以-开头： 123- elem1- elem2- elem3 多维数组： 1key: [value1, value2, value3] 数组结构的子成员是一个数组： 1234- - a - b - c 复杂数组实例： 12345678910111213# microsoft是一个数组，每个元素又有三个属性microsoft: - id: 001 name: wong salary: 15w - id: 002 name: lee salary: 20w# 将以上复杂例子扁平化为flow式表示microsoft: [{id: 001,name: wong,salary: 15w},{id: 002,name: lee,salary: 20w}] 数组和对象的复杂结构 123456789101112# 数组languages: - Ruby - Perl - Python# 对象websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 对应的json： 123456789{ languages: [ 'Ruby', 'Perl', 'Python'], websites: { YAML: 'yaml.org', Ruby: 'ruby-lang.org', Python: 'python.org', Perl: 'use.perl.org' } } 纯量：原子值 字符串 布尔值 整数 浮点数 Null 时间 日期 实例： 123456789101112131415161718192021string: - 'Hello World' # 单引号、双引号均可，用来包裹含有特殊字符的字符串，单引号会转义，双引号不会转义 - HelloWorld # 字符串中不含有特殊字符 - line1 line2 # 多行字符串，从第二行开始要缩进一格，一个换行被转化为一个空格boolean: - true # true,True,TRUE三种均可 - false # false,False,FALSE三种均可int: - 4869 # 十进制表示 - 0b1001_1001_1110_1011 # 二进制表示float: - 3.1415 - 1.23e+2 # 科学计数法null: name: 'node' parent: ~ # ~表示null，注意是null不是Nulldatetime: - 2020-5-12T14:55:02+08:00 # ISO8601格式，时间和日期用T连接，最后+时区date: - 2020-5-12 # ISO8601格式 引用 锚点：&amp;用来建立锚点。 别名：*用来引用锚点。 合并：&lt;&lt;用来合并引用的锚点数据到当前数据。 实例1： 123456classA: &amp;classA student1: wong student2: leeclassB: student3: queen &lt;&lt;: *classA 以上代码相当于： 1234567classA: student1: wong student2: leeclassB: student3: queen student1: wong student2: lee 实例2： 12345names: - &amp;bruce bruce - lee - wong - *bruce 以上代码相当于： 12345names: - bruce - lee - wong - bruce 参考 阮一峰YAML语言教程","link":"/2020/05/10/YAML-notes/"},{"title":"用animation写轮播图","text":"代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;style&gt; * { padding: 0; margin: 0; } a { text-decoration: none; } body { min-width: 1080px; background-color: #f4f4f4; } .banner { width: 1000px; overflow: hidden; margin: 0 auto; } .box&gt;img { float: left; width: 1000px; } .box { width: 5000px; animation: banner 25s infinite 3s; } @keyframes banner { 20% { margin-left: -1000px; } 40% { margin-left: -2000px; } 60% { margin-left: -3000px; } 80% { margin-left: -4000px; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"banner\"&gt; &lt;div class=\"box\"&gt; &lt;img src=\"image/4.png\" alt=\"\"&gt; &lt;img src=\"image/5.png\" alt=\"\"&gt; &lt;img src=\"image/2.png\" alt=\"\"&gt; &lt;img src=\"image/3.png\" alt=\"\"&gt; &lt;img src=\"image/1.png\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 改进123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"banner\"&gt; &lt;div class=\"box\"&gt; &lt;img src=\"image/5e52a48c00012a6418720764.jpg\" alt=\"\"&gt; &lt;img src=\"image/5e52a74200016f6218720764.jpg\" alt=\"\"&gt; &lt;img src=\"image/5e59d4c600017cc318720764.jpg\" alt=\"\"&gt; &lt;img src=\"image/5e5f7aea0001a36618720764.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243* { padding: 0; margin: 0;}a { text-decoration: none;}body { min-width: 1080px; background-color: #f4f4f4;}.banner { width: 1000px; height: 408px; /* border: 1px red solid; */ overflow: hidden; margin: 0 auto;}.banner&gt;div&gt;img { width: 1000px; height: 408px; float: left;}.box { width: 4000px; animation: banner 16s 2s infinite;}@keyframes banner { 25% { margin-left: -1000px; } 50% { margin-left: -2000px; } 75% { margin-left: -3000px; }}","link":"/2018/06/07/animation-slideshow/"},{"title":"汇编语言基础备忘","text":"陆陆续续记录一下常用的汇编指令，真的是非常基础。 寄存器分类通用寄存器主要有AX,BX,CX,DX等等 指令寄存器IR存储着现在正在执行的指令地址 指针寄存器有栈指针寄存器SP和栈基址指针寄存器BP 段寄存器标志端的开始，有CS,DS,SS,ES 特殊用途有些寄存器有特定用途，如： AX用于累加和终端 CX用于计数、循环 内存分段一个程序可以有数据段、代码段、堆栈段。 数据段：存放全局变量，段寄存器为DS 代码段：存放汇编指令，段寄存器为CS 堆栈段：存放程序运行期间产生的变量，分为堆和栈，栈用于存放函数局部变量，堆用于存放动态分配的变量。堆栈段寄存器为SS，SP寄存器指向栈顶。 扩展段用于保存其他信息，段寄存器为ES 常用汇编指令(8086为例)mov传送指令 mov a,b将b的值赋值给a add加法指令 add a,b等同于 a=a+b sub减法指令 sub a,b等同于a=a-b cmp比较指令 cmp a,b比较a和b的大小，结果存在编制寄存器中 jmp无条件跳转指令 修改IP和CS是程序跳转到特定地址运行 jcc条件转移指令 通过判断标志寄存器的状态决定是否跳转 call调用函数指令 程序会调用函数入口执行 ret函数返回指令","link":"/2018/12/28/assembly-basic/"},{"title":"我的博客vi已经上线","text":"今天开始陆陆续续给我的博客设计在hexo-icarus中的vi，主要包括： 不同类型文章的固定用的banner 站点favicon、logo、以及头像。 装饰性gif sketch源文件下载（实时更新）：blog-vi.sketch post-thumbnail2020/3/22 用于不同分类文章front-matter中的thumbnail。 由于电脑上没装photoshop和illustrator，所以暂时使用sketch设计了一个初版thumbnail。 规格：566*242 总览","link":"/2020/03/22/blog-vi/"},{"title":"bootstrap grid布局","text":"grid布局概念 grid原生布局写法1234567891011&lt;div class=\"container\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt;&lt;/div&gt; 12345678910.container { height: 500px; border: 1px red solid; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;}.container&gt;div { border: 1px green solid;} 简写112345.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;} 也可以写为： 1234567.container { height: 500px; border: 1px red solid; display: grid; grid-template-columns: repeat(3,100px); grid-template-rows: repeat(3,100px);} 简写21234.container { display: grid; grid-template-columns: 100px 200px 300px 100px 200px 300px;} 也可以写为： 1234.container { display: grid; grid-template-columns: repeat(2,100px 200px 300px);} auto-fill关键字auto-fill关键字可以使得.container容器内部columns以一定的宽度自动填充满。 1234.container { display: grid; grid-template-columns: repeat(auto-fill,100px);} fr关键字(fr:fraction片段)1234.container { display: grid; grid-template-columns: 1fr 2fr;} 如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。 fr可以与绝对长度的单位结合使用，这时会非常方便。 例如： 12345.container { display: grid; grid-template-columns: 100px 1fr 2fr; /*第一列的宽度为150像素，第二列的宽度是第三列的一半。*/} minmax()函数minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1234.container { display: grid; grid-template-columns: 1fr 2fr minmax(100px,1fr);} auto关键字1234.container { display: grid; grid-template-columns: 1fr 2fr auto;} 指定网格线名字12345.container { display: grid; grid-template-columns: [c1] 100px [c2] 200px [c3] 300px [c4] 400px [c5]; grid-template-rows: [r1] 100px [r2] 100px [r3] 100px [r4];} 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 布局实例两栏布局：1234.container { display: grid; grid-template-columns: 70% 30%;} 十二网格布局：1234.container { display: grid; grid-template-columns: repeat(12,1fr);} gap间隔旧属性名： grid-column-gap grid-row-gap grid-gap 新属性名： column-gap row-gap gap 行列单独设置： 12345.container { display: grid; grid-column-gap: 20px; grid-row-gap: 30px;} 一起设置： 1234.container { display: grid; grid-gap: 20px 30px;} 如果grid-gap只有一个值，则行列都为这个值。 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 grid-template-areas属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。 12345678.container { display: grid; grid-template-columns: repeat(3,100px); grid-template-rows: repeat(3,100px); grid-template-areas: 'a b c' 'd e f' 'g h i';} 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下。 12345.container { grid-template-areas: 'a a a' 'b b b' 'c c c';} 上面代码将9个单元格分成a、b、c三个区域。 布局实例： 12345.container { grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\";} 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用”点”（.）表示。 12345.container { grid-template-areas: 'a a a' 'b . b' 'c c c';} 上面代码中，中间为点，表示没有用到该单元格，或者该单元格不属于任何区域 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 grid-auto-flow属性默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。 grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。 使用bootstrap进行grid布局使用bootstrap基本模版： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; bootstrap布局（记忆） 容器需要将class设置为container（带宽度），或者container-fluid（100%宽度），bootstrap中一行最多12列。 参考文章1.阮一峰grid教程","link":"/2020/05/18/bootstrap-layout-grid/"},{"title":"centos下删除以及重新安装ruby","text":"由于jekyll从要求ruby2.0提升到&gt;=2.1故有了这次ruby的删除与重新安装。 卸载旧版本centos或者RHEL安装了老版本ruby的可以直接 1$ yum remove ruby -y 来卸载ruby及其依赖包 安装新版本这里安装ruby2.3.7 下载： 1234$ yum install -y wget$ wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.7.tar.gz$ tar -zxvf https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.7.tar.gz$ cd ruby-2.3.7 编译安装： 123$ ./configure$ make$ make install 查看是否安装成功： 12$ ruby -vruby 2.3.7 安装成功！","link":"/2018/05/07/centos-remove-ruby/"},{"title":"使用commitizen规范化commit信息","text":"commitizen 可以规范化 git commit 信息以便回溯。 安装1cnpm install -g commitizen 使用12345# 先add文件git add &lt;filename&gt;# 使用j和k上下选择类型，输入影响范围，输入短描述和长描述git cz 查看1git log 阅读 http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html https://www.jianshu.com/p/36d970a2b4da","link":"/2020/11/23/commitizen/"},{"title":"什么是CR,LF,CRLF","text":"使用编辑器和IDE的时候经常看到CR、LF和CRLF。其实这三个是不同操作系统的不同换行符。 CR：表示回车，对应ASCII码中的\\r。 LF：表示换行，对应ASCII码中的\\n。 CRLF：表示回车并换行，对应的ASCII码为\\r\\n。 那么三个分别适用于哪些系统呢？ CR：用于远古mac系统。 LF：unix,linux和现在的macos。 CRLF：用于windows。 一般安装完编辑器或者IDE都会根据你的系统预置换行配置。","link":"/2020/06/29/cr-lf-crlf/"},{"title":"跨域（cross domain）","text":"概念广义上的跨域是指一个域下的文档或者脚本请求另一个域下的资源。狭义上的跨域是指由于浏览器的同源策略限制，从一个域名请求另一个域名的资源。我们通常所说的跨域是指狭义上的跨域。 同源：域名、端口和协议三者一致即为同源。以上三者只要有一个不同即为跨域。 解决方案 jsonp document.domain + iframe location.hash + iframe window.name + iframe postMessage CORS nginx代理 nodejs中间件代理 websocket","link":"/2018/09/20/cross-domain/"},{"title":"CSS权威指南（第三版）读书笔记","text":"《CSS权威指南（第三版）》覆盖了CSS2 + CSS2.1的内容。《CSS权威指南（第四版）》加入了CSS3的内容。 CSS和文档 CSS：层叠样式表 替换元素：img、input等等。 非替换元素：大多数都是非替换元素。 块元素、行内元素，html和xhtml中块元素不能继承行内元素，但是CSS没有限制块元素和行内元素的嵌套。行内元素可以继承块元素，块元素不能继承行内元素。可以自定义元素并赋予样式。 引入外部样式表： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"basic.css\" media=\"screen, print\" /&gt; 候选样式表：需要用户手动选择，下面是如何定义候选样式表。候选样式表的title属性定义了候选样式表的名称。 123&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"default.css\" title=\"default\" /&gt;&lt;link rel=\"alternate stylesheet\" type=\"text/css\" href=\"alt01.css\" title=\"alt01\" /&gt;&lt;link rel=\"alternate stylesheet\" type=\"text/css\" href=\"alt02.css\" title=\"alt02\" /&gt; style标签：type一定要设置为 text/css ，还可以给style指定media属性。 123&lt;style type=\"text/css\"&gt; /* css code */&lt;/style&gt; @import规则 必须要放在样式表中，而且在最前面。 123&lt;style type=\"text/css\"&gt; @import url(style.css);&lt;/style&gt; 指定应用的媒体： 12345&lt;style type=\"text/css\"&gt; @import url(style.css) all; @import url(screen.css) screen; @import url(printandprojection.css) print, projection;&lt;/style&gt; 向后可访问性，使不能识别style标签的浏览器忽略标签中的声明（几乎用不到了） 写法： 123456789&lt;style type=\"text/css\"&gt; &lt;!-- @import url(style.css) all; h1 { background: yellow; } --&gt;&lt;/style&gt; 注释，不能嵌套 12345/* 注释1 *//* 注释2*/ 内联样式，可用于body以及body中的任何标签，现在几乎不用这种写法。 123&lt;p style=\"color: red; font-size: 14px;\"&gt; this is a paragraph.&lt;/p&gt; 选择器规则结构 每条规则都由选择器和声明块组成。 选择器定义了声明块影响文档中内容的范围。 声明块由一个或者多个声明组成，每条声明是一个属性-值对。 如下： 1234h1 { color: red; background: yellow;} 一个属性的属性值可以有多个： 123p { font: red 14px bold;} 选择器 元素选择器 123p { color: red;} 选择器分组 1234567891011121314151617181920212223h1 { color: red;}h2 { color: red;}h3 { color: red;}h4 { color: red;}h5 { color: red;}h6 { color: red;} 可以用分组来压缩代码： 12345678h1,h2,h3,h4,h5,h6 { color: red;} 通配选择器 12345* { color: red;} 声明分组 1234567891011p { color: red;}p { font-size: 14px;}p { background: yellow;} 12345p { color: red; font-size: 14px; background: yellow;} 每条声明后面的分号不能少。 结合选择器和声明的分组 为h1-h6设置字体颜色、背景颜色和border 12345678910h1,h2,h3,h4,h5,h6 { color: red; background: yellow; border: 1px solid gray;} 类选择器，可以给多个元素设置同一个类名 123456789&lt;p class=\"warning\"&gt; WARNING!&lt;/p&gt;&lt;style&gt; .warning { font-weight: bold; }&lt;/style&gt; 也可以只让包含warning类的所有p元素字体变粗： 123456789&lt;p class=\"warning\"&gt; WARNING!&lt;/p&gt;&lt;style&gt; p.warning { font-weight: bold; }&lt;/style&gt; 这里的 p.warning 比 .warning 更特殊，故而前者的声明会覆盖后者。 多类选择器 比如要选中既有urgent类又含有warning类的元素： 1.urgent.warning {} id选择器，只能给一个元素设置id名，id选择器一般用于js而不是css 1234567&lt;p id=\"para\"&gt; this is a paragraph.&lt;/p&gt;&lt;style&gt; #para {}&lt;/style&gt; 使用类选择器还是ID选择器？ 属性选择器 简单属性选择器 选择含有class属性的所有h1元素： 1h1[class] {} 选择同时有href和title属性的a元素： 1a[href][title] {} 根据具体属性值选择（属性值必需完全匹配）： 12345/* 根据一个特定属性选择a元素 */a[href=\"https://www.google.com\"] {}/* 根据多个属性值选择a元素 */a[href=\"https://www.google.com\"][title=\"google\"] {} 根据部分属性值选择： 123&lt;p class=\"urgent warning\"&gt; qwertyuiop&lt;/p&gt; 1p[class~=\"warning\"] {} 以上选择器选择了class属性包含warning的元素。（以空格做隔断） 子串匹配属性选择器： 类型 描述 [foo^=”bar”] 选择foo属性值以“bar”开头的所有元素 [foo$=”bar”] 选择foo属性值以“bar”结尾的所有元素 [foo*=”bar”] 选择foo属性值包含子串“bar”的所有元素 [foo~=”bar”] 选择foo属性值包含以空格隔断的“bar”子串的所有元素 这里注意最后两条的区别。 特定属性选择器 1*[lang|=\"en\"] {} 这个规则会选择lang属性为en或者以en开头的所有元素，这种选择器最常用的用途是匹配语言。 也就是： 类型 描述 [foo|=”bar”] 选择foo属性值等于“bar”或者以其为开头的所有元素 后代选择器：也叫上下文选择器， 12/* 这个选择器会选择作为h1后代的所有em元素 */h1 em {} 上面选择器中的空格表示后代。 子元素选择器：选择元素的直接后代，也就是子元素。 1p&gt;a {} 相邻兄弟选择器 12&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt; 1p+h1 {} 以上选择器读作：选择作为p元素同级别的紧邻的下一个h1元素。 伪类选择器 静态伪类选择器 12345/* 未访问的链接 */a:link {}/* 访问过的链接 */a:visited {} 动态伪类选择器 12345678/* 获取了焦点的元素 */a:focus {}/* 鼠标悬停的元素 */a:hover {}/* 激活的元素 */a:active {} 以上伪类的书写顺序应该为：LVHA或者LVFHA。 比如： 12345678910111213141516171819a:link { color: navy;}a:visited { color: gray;}a:focus { color: red;}a:hover { color: blue;}a:active { color: yellow;} 伪类结合使用，不能把互斥的伪类一起使用 1234567a:link:hover { color: red;}a:visited:hover { color: maroon;} 选择第一个子元素： 12345678910&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;&lt;style&gt; p:first-child { color: red; }&lt;/style&gt; 以上选择器选择作为第一个子元素的p元素。 根据语言选择： 使用:lang()伪类 例子：选择所有语言为法语的元素 1*:lang(fr) {} 伪元素选择器 123p:first-letter {}p:first-line {} 伪元素 :before 和 :after 用于在元素前后插入内容并赋予其样式。 before实例： 1234p:before { content: 'new'; color: red;} 结构和层叠特殊性重要声明： !important例子： 123p { color: red !important;} 继承一个例外：body元素的属性会传递到html标签。 层叠LVHA或者VLHA 值和单位值值分为数字（整数和小数）和百分数。 颜色css2.1中的17个颜色：aquafuchsialimeoliveredwhiteblackgraymaroonorangesilveryellowbluegreennavypurpleteal 字体字体系列CSS定义的5种通用字体系列。 Serif：衬线体，Times、Georgia、New Century Schoolbook。 Sans-serif：非衬线体，Helvetica、Geneva、Verdana、Arial、Univers。 Monospace：等宽字体，Courier、Courier New、Andale Mono。 Cursive：手写体，Zapf Chancery、Author、Comic Sans。 Fantasy：Western、Woodblock、Klingon。 使用字体123p { font-family: Georgia, serif;} 有空格或者有特殊字符的字体需要用引号括起来。 正确地font属性书写方式： 1234h1 { /* 前三个font-style,font-weight,font-variant顺序随意，后面两个顺序一定要先写font-size再写font-family且必须要写不能省略 */ font: italic normal small-caps 16px Arial, sans-serif;} font-size和line-height的写法： 16px/1.2 。 font-face规则已经从css2.1删除。 12345/* 下载字体 */@font-face { font-family: 'new font name'; src: url(...);} 文本属性 text-indent 只能用于块元素缩进，如果行内元素想要缩进则可以设置padding-left或者margin-left。 text-align vertical-align 只能用于行内元素和替换元素，不影响块元素中内容的对齐。 line-height word-spacing letter-spacing text-transform text-decoration text-shadow white-space direction 基本视觉格式化水平格式化垂直格式化","link":"/2018/05/04/css-definitive-guide/"},{"title":"用纯css判断鼠标进入元素的方向","text":"如何用纯css来判断鼠标进入元素的方向呢？ 这是一个面试问题。 给定结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { padding: 2em; text-align: center; } .block { position: relative; display: inline-block; width: 10em; height: 10em; vertical-align: middle; } .block_content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; text-align: center; line-height: 10em; background: #333; color: #FFF; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"text\"&gt;从不同方向使鼠标指针移过下面的内容&lt;/p&gt; &lt;p&gt;↓&lt;/p&gt; &lt;span&gt;→ &lt;/span&gt; &lt;div class=\"block\"&gt; &lt;div class=\"block_content\"&gt; Hover me! &lt;/div&gt; &lt;/div&gt; &lt;span&gt; ←&lt;/span&gt; &lt;p&gt;↑&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果： 思路： 我们在css中判断鼠标移入用的是:hover，关键是如何判断鼠标移入的方向。 我们用:hover只能知道鼠标移入了，而却无法得知鼠标移入方向的。 那么如何通过css来判断出鼠标移入的方向呢？ 一开始我想用border来实现，可是一想border不能各自被hover。于是只能制造能被hover的块来实现。 实现： 在四个方向上都加上可以被hover的块。 123456789&lt;div class=\"block\"&gt; &lt;div class=\"block_hoverer\"&gt;上&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;下&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;左&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;右&lt;/div&gt; &lt;div class=\"block_content\"&gt; Hover me! &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.block_hoverer { position: absolute; width: 100%; height: 100%; z-index: 1;}.block_hoverer:nth-child(1) { background: red;}.block_hoverer:nth-child(2) { background: lime;}.block_hoverer:nth-child(3) { background: orange;}.block_hoverer:nth-child(4) { background: blue;} 结果只有最后一块露了出来。 接下来让四个快在其容器中仅仅有一点点宽度。 1234567891011121314151617181920212223242526.block_hoverer { position: absolute; z-index: 1; width: 100%; height: 100%; transition: all 0.3s ease;}.block_hoverer:nth-child(1) { background: red; top: -90%;}.block_hoverer:nth-child(2) { background: lime; top: 90%;}.block_hoverer:nth-child(3) { background: orange; left: -90%;}.block_hoverer:nth-child(4) { background: blue; left: 90%;} 给每个块加上过渡 12345678.block_hoverer { transition: all 0.3s ease;}.block_hoverer:hover { opacity: 1; top: 0; left: 0;} 隐藏 1234567891011121314.block { position: relative; display: inline-block; overflow: hidden; width: 10em; height: 10em; vertical-align: middle;}.block_hoverer { opacity: 0;}.block_hoverer:hover { opacity: 1;} 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { padding: 2em; text-align: center; } .block { position: relative; display: inline-block; overflow: hidden; width: 10em; height: 10em; vertical-align: middle; transform: translateZ(0); } .block_hoverer { position: absolute; z-index: 1; width: 100%; height: 100%; opacity: 0; transition: all .3s ease; } .block_hoverer:nth-child(1) { background: red; top: -90%; } .block_hoverer:nth-child(2) { background: lime; top: 90%; } .block_hoverer:nth-child(3) { background: orange; left: -90%; } .block_hoverer:nth-child(4) { background: blue; left: 90%; } .block_hoverer:hover { opacity: 1; top: 0; left: 0; } .block_content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; text-align: center; line-height: 10em; background: #333; color: #FFF; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"text\"&gt;从不同方向使鼠标指针移过下面的内容&lt;/p&gt; &lt;p&gt;↓&lt;/p&gt; &lt;span&gt;→ &lt;/span&gt; &lt;div class=\"block\"&gt; &lt;div class=\"block_hoverer\"&gt;1&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;2&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;3&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;4&lt;/div&gt; &lt;div class=\"block_content\"&gt; Hover me! &lt;/div&gt; &lt;/div&gt; &lt;span&gt; ←&lt;/span&gt; &lt;p&gt;↑&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 最终效果： Gif由gifox制作而成","link":"/2020/05/09/css-judge-directions/"},{"title":"CSS布局（长期更新）","text":"长期总结css布局相关内容。 居中布局水平居中布局 inline-block + text-align 通过设置内容元素为inline-block，并且给父元素设置text-align: center;使内容元素具有文本对齐居中的属性。 123456789101112131415161718192021&lt;style&gt; .container { width: 100%; height: 200px; background-color: blue; text-align: center; } .content { width: 200px; height: 200px; background-color: red; display: inline-block; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; absolute + transform 父元素设置relative，子元素设置absolute并left: 50%。这个时候再将自身transform: translateX(-50%);完成居中。 这里使用到transform属性，这个属性为CSS3属性。 1234567891011121314151617181920212223&lt;style&gt; .container { position: relative; width: 100%; height: 200px; background-color: blue; } .content { position: absolute; left: 50%; transform: translateX(-50%); width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; block + margin 对子元素设置display: block,margin: 0 auto;就可以水平居中。 table也可以。 123456789101112131415161718192021&lt;style&gt; .container { width: 100%; height: 200px; background-color: blue; } .content { width: 200px; height: 200px; background-color: red; display: table; margin: 0 auto; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 垂直居中布局 定位 + transform 容器设置position: relative;，内容设置position: absolute;并且top: 50%;再transform: translateY(-50%);完成垂直居中。 1234567891011121314151617181920212223&lt;style&gt; .container { position: relative; width: 200px; height: 600px; background-color: blue; } .content { position: absolute; top: 50%; transform: translateY(-50%); width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; display: table-cell + vertical-align table-cell的元素有td元素的行为，其子元素布局类似文本元素。 故而父元素display: table-cell;+vertical-align: middle;即可让其子元素垂直居中。 注意父元素的所有子元素都会继承居中显示。 12345678910111213141516171819&lt;style&gt; .container { display: table-cell; vertical-align: middle; width: 200px; height: 600px; background-color: blue; } .content { width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 水平垂直居中布局 定位 + transform 也就是上面两个的集合。 123456789101112131415161718192021222324&lt;style&gt; .container { position: relative; width: 1200px; height: 800px; background-color: blue; } .content { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 水平block + margin，垂直display: table-cell + vertical-align 1234567891011121314151617181920&lt;style&gt; .container { display: table-cell; vertical-align: middle; width: 1200px; height: 800px; background-color: blue; } .content { margin: 0 auto; width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 使用flex居中布局水平居中：justify-content: center; 垂直居中：align-items: center; 需要考虑浏览器兼容。 12345678910111213141516171819202122&lt;style&gt; .container { display: flex; align-items: center; justify-content: center; width: 1200px; height: 800px; background-color: blue; } .content { width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 多列布局两列布局这里是一列定宽，一列自适应。 左列左浮动，右列设置margin-left 12345678910111213141516171819202122&lt;style&gt; .left, .right { height: 600px; } .left { width: 400px; background-color: blue; float: left; } .right { background-color: red; margin-left: 400px; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;定宽元素&lt;/div&gt; &lt;div class=\"right\"&gt;自适应元素&lt;/div&gt;&lt;/body&gt; 左列左浮动，右列overflow: hidden 右列设置overflow: hidden;开启BFC，与外界隔离，所以能实现效果。 12345678910111213141516171819202122&lt;style&gt; .left, .right { height: 600px; } .left { width: 400px; background-color: blue; float: left; } .right { background-color: red; overflow: hidden; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;定宽元素&lt;/div&gt; &lt;div class=\"right\"&gt;自适应元素&lt;/div&gt;&lt;/body&gt; 父元素display: table，左右列display: table-cell 1234567891011121314151617181920212223242526272829&lt;style&gt; .container { display: table; table-layout: fixed; width: 100%; } .left, .right { display: table-cell; height: 600px; } .left { width: 400px; background-color: blue; } .right { background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;定宽元素&lt;/div&gt; &lt;div class=\"right\"&gt;自适应元素&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; flex两列布局 父元素设置为flex，左列定宽，右列flex: 1;。 1234567891011121314151617181920212223&lt;style&gt; .container { display: flex; height: 600px; } .left { background-color: blue; width: 400px; } .right { flex: 1; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;自适应&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 三列布局普通三列布局左中定宽，右边自适应。 定宽 + overflow: hidden 123456789101112131415161718192021222324252627282930&lt;style&gt; .left, .center, .right { height: 600px; } .left { width: 400px; background-color: blue; float: left; } .center { width: 400px; background-color: yellow; float: left; } .right { background-color: red; overflow: hidden; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"center\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;自适应&lt;/div&gt;&lt;/body&gt; flex三列布局 与两列flex相同。 1234567891011121314151617181920212223242526272829&lt;style&gt; .container { display: flex; height: 600px; } .left { width: 400px; background-color: blue; } .center { width: 400px; background-color: yellow; } .right { flex: 1; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"center\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;自适应&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 圣杯布局两侧定宽，中间自适应的三列布局。 左边定宽左浮动，右边定宽右浮动，中间设置margin 需要将右边元素放在中间元素的前面，否则右边元素会下沉。但是不利于中间元素的SEO。 12345678910111213141516171819202122232425262728293031&lt;style&gt; .left, .center, .right { height: 600px; } .left { width: 400px; background-color: blue; float: left; } .center { background-color: yellow; margin-left: 400px; margin-right: 400px; } .right { width: 400px; background-color: red; float: right; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;定宽&lt;/div&gt; &lt;div class=\"center\"&gt;自适应&lt;/div&gt;&lt;/body&gt; 父元素设置margin，左中右都浮动，利用定位和margin布局 center在最前面，有利于SEO。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; .container { /* margin-left对应左边元素left的宽度，margin-right对应右边元素right的宽度 */ margin-left: 400px; margin-right: 400px; } .left, .center, .right { height: 600px; float: left; } .left { width: 400px; background-color: blue; position: relative; /* 为了让left元素从当前行移动到第一行同一位置*/ margin-left: -100%; /* 移动到中间元素左侧正确位置 */ left: -400px; } .center { width: 100%; background-color: yellow; } .right { width: 400px; background-color: red; position: relative; /* 为了让left元素从当前行移动到上一行*/ margin-left: -400px; right: -400px; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"center\"&gt;自适应&lt;/div&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;定宽&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 双飞翼布局左右定宽，中间自适应。 中间元素增加子元素用来放置内容。 中间元素设置margin，左中右设置浮动，左右margin 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .left, .center, .right { height: 600px; float: left; } .left { width: 400px; background-color: aqua; /* 为了让l元素从当前行移动到第一行同一位置*/ margin-left: -100%; } .center { width: 100%; background-color: blue; } .i { height: 600px; background-color: blueviolet; margin-left: 400px; margin-right: 400px; } .right { width: 400px; background-color: brown; /* 为了让r元素移动到第一行*/ margin-left: -400px; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"center\"&gt; &lt;div class=\"i\"&gt;自适应&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;定宽&lt;/div&gt;&lt;/body&gt; flex三列布局 1234567891011121314151617181920212223242526272829&lt;style&gt; .container { display: flex; height: 600px; } .left { width: 400px; background-color: blue; } .center { flex: 1; background-color: red; } .right { width: 400px; background-color: yellow; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"center\"&gt;自适应&lt;/div&gt; &lt;div class=\"right\"&gt;定宽&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 多列等分布局 浮动 + 百分数进行多列等分布局 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .col { float: left; width: 20%; height: 300px; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;&lt;/div&gt; &lt;div class=\"col col2\"&gt;&lt;/div&gt; &lt;div class=\"col col3\"&gt;&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; table多列等分布局 父元素display: table;，设置布局行为table-layout: fixed，指定每个表格等宽。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .container { display: table; /* 列宽由表格宽度和列宽度设定 */ table-layout: fixed; width: 100%; } .col { display: table-cell; height: 300px; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;&lt;/div&gt; &lt;div class=\"col col2\"&gt;&lt;/div&gt; &lt;div class=\"col col3\"&gt;&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; column多列等分布局 指定内容区域为5列。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .container { /* 指定列数 */ column-count: 5; /* 指定列与列之间的间隙，默认1em */ column-gap: 0; } .col { height: 300px; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;&lt;/div&gt; &lt;div class=\"col col2\"&gt;&lt;/div&gt; &lt;div class=\"col col3\"&gt;&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; flex多列等分布局 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .container { display: flex; } .col { height: 300px; flex: 1; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;&lt;/div&gt; &lt;div class=\"col col2\"&gt;&lt;/div&gt; &lt;div class=\"col col3\"&gt;&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 多列等高布局意思是每一列高度相等。 table多列等高布局 父元素设置为table，子元素table-cell，这样就使得子元素等高。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .container { display: table; } .col { display: table-cell; width: 20%; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col2\"&gt;啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col3\"&gt; 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt; 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; flex多列等高布局 align-items设置为auto或者不设置。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .container { display: flex; } .col { flex: 1; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col2\"&gt;啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col3\"&gt; 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt; 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 全屏布局全屏布局就是头部、内容区域、底部组成的。 这里采用头部底部fixed，中间内容区域两列布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;style&gt; html, body { margin: 0; overflow: hidden; } header { position: fixed; left: 0; top: 0; right: 0; height: 100px; background-color: salmon; } .container { position: fixed; left: 0; right: 0; top: 100px; bottom: 100px; overflow: auto; background-color: palevioletred; } .container .left { width: 400px; /* height: 100%; */ position: fixed; left: 0; top: 100px; bottom: 100px; background-color: greenyellow; } .container .right { position: fixed; left: 400px; right: 0; top: 100px; bottom: 100px; background-color: blueviolet; } footer { position: fixed; left: 0; right: 0; bottom: 0; height: 100px; background-color: goldenrod; }&lt;/style&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt; 持续挖掘中…","link":"/2020/05/12/css-layout/"},{"title":"position属性值详解","text":"position属性值有5个：static,relative,absolute,fixed,sticky static默认值 relative相对定位，不会对其他元素的位置产生影响，因此元素之间可能产生重叠，相对于元素的默认位置进行偏移，搭配top,right,bottom,left，left和top搭配，right和bottom搭配 fixed相对定位，不会对其他元素的位置产生影响，因此元素之间可能产生重叠，相对与浏览器进行偏移，定位基点为浏览器窗口。搭配left,right,bottom,top使用。 absolute相对定位，不会对其他元素的位置产生影响，因此元素之间可能产生重叠，相对于上级元素进行偏移，条件是上级元素不能为static，否则定位基点变成html这个dom，搭配top,right,bottom,left使用。 使用： 1234&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt; &lt;/div&gt;&lt;/div&gt; 12345678.father { position: relative;}.son { position: absolute; left: 66px; top: 66px;} 以上代码.son元素相对于father元素进行往右66px往下66px的偏移 重点：.son元素会被正常文档流忽略，不会占用空间。 sticky一般用于导航条，脑补京东详情页，搭配left等使用。它的具体规则是，当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛，relative定位自动切换为fixed定位；等到父元素完全脱离视口时（即完全不可见），fixed定位自动切换回relative定位。 使用：对于safari要添加-webkit-sticky- 12345.toolbar { position: -webkit-sticky; /* safari 浏览器 */ position: sticky; /* 其他浏览器 */ top: 20px;} 上面代码中，页面向下滚动时，.toolbar的父元素开始脱离视口，一旦视口的顶部与.toolbar的距离小于20px（门槛值），.toolbar就自动变为fixed定位，保持与视口顶部20px的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），.toolbar恢复成relative定位。 例子：动态堆叠照片 代码： 123&lt;div&gt;&lt;img src=\"pic1.jpg\"&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=\"pic2.jpg\"&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=\"pic3.jpg\"&gt;&lt;/div&gt; 1234div { position: sticky; top: 0;} 它的原理是页面向下滚动时，每张图片都会变成fixed定位，导致后一张图片重叠在前一张图片上面 例子：表格th固定，数据滚动 代码： 12345678910&lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;小明&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;小洪&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;小黑&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 1234th { position: sticky; top: 0;} 注意：sticky必须设置在th上 复习下table的结构： 12345678&lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;标题1&lt;/th&gt;&lt;th&gt;标题2&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;数据1&lt;/td&gt;&lt;td&gt;数据2&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; or： 12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;标题1&lt;/th&gt; &lt;th&gt;标题2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数据1&lt;/td&gt; &lt;td&gt;数据2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","link":"/2018/05/18/css-position-attributes/"},{"title":"css三角形","text":"虽然现在的带宽速度已经足够加载图片，但是使用css来生成三角形仍然可以压缩页面资源大小以及获得比粗暴插入图片更好的样式。 利用css盒模型的border创建三角形1234567891011&lt;div&gt;&lt;/div&gt;&lt;style&gt; /*div长宽设置为0，四周border设为同样的值，三个border颜色设置为transparent另一个border设置为想要的三角形的颜色便可得到一个直角三角形*/ div { width: 0; height: 0; border: 20px solid; border-color: transparent transparent red; } /*可以得到一个下边的红色三角形*/&lt;/style&gt; 不过这样得到的三角形其他三个部分仍然占用空间，只是我们把它设置为了透明。 再将border-top的width设置为0即可： 12345678910&lt;div&gt;&lt;/div&gt;&lt;style&gt; div { width: 0; height: 0; border-width: 0 20px 20px; border-style: solid; border-color: transparent transparent red; }&lt;/style&gt; 利用两个三角形重叠形成三角形环1234567891011121314151617181920212223&lt;div class=\"tri_big\"&gt;&lt;/div&gt;&lt;style&gt; div.tri_big { position: relative; width: 0; height: 0; border-width: 0 20px 20px; border-style: solid; border-color: transparent transparent red; } div.tri_big:after { content: ''; position: absolute; left: -16px; top: 3px; width: 0; height: 0; border-width: 0 16px 16px; border-style: solid; border-color: transparent transparent yellow; }&lt;/style&gt; 绘制左/右直角三角形右直角三角形将border-left设置为0 1234567891011&lt;div class=\"tri\"&gt;&lt;/div&gt;&lt;style&gt; div.tri { width: 0; height: 0; border-width: 0 20px 20px 0; border-style: solid; border-color: transparent transparent red; }&lt;/style&gt; 左直角三角形将border-right设置为0 1234567891011&lt;div class=\"tri\"&gt;&lt;/div&gt;&lt;style&gt; div.tri { width: 0; height: 0; border-width: 0 0 20px 20px; border-style: solid; border-color: transparent transparent red; }&lt;/style&gt;","link":"/2019/09/02/css-triangle/"},{"title":"css变量","text":"2017年三月，微软宣布edge正式支持了css变量，至此市面上所有主流的浏览器都支持了css变量。 变量声明在变量名前面加上--即可 这里在body里面声明了color1 color2两个变量。它们实质上就是属性，但是没有默认含义。故而css变量又称之为css自定义属性。 1234body { --color1: #111; --color2: #222;} 注意：变量名大小写敏感。 1234:root { --font-color: #3a3a3a; --block-color: #333333;} 这里:root匹配DOM根元素，对于html而言就是匹配&lt;html&gt;元素 var()函数用于读取变量： 1234a { color: var(--font-color); background-color: var(--block-color);} 第二参数： 123a { color: var(--font-color,#333);} 如果第一个变量不存在则使用第二个参数。 注意：第一个参数逗号之后的部分都属于第二个参数整体。 var()还可以用在变量的声明： 1234a { --first-color: #333; --second-color: var(--first-color);} 注意：var()是一个属性值。 变量值类型字符串1234a { --foo: 'hello'; --bar: var(--foo)' world';} 结果： --bar = 'hello world'。 数值 变量值没有单位 需要使用到calc()函数，这里注意calc()函数内符号两边要留空格。 1234p { --gap: 20; margin-top: calc(var(--gap) * 1px);} 变量值有单位 1234p { --gap: 20px; margin-top: var(--gap);} 作用域同一个css变量可以在多个选择器中被声明，按照css层叠来选择优先级最高的声明。 总结：css变量的作用域就是声明其的选择器的范围，并且按照层叠，优先级越高的作用越优先。 一般将css全局变量放在:root中，以使得所有选择器都可读取。 12345:root { --font-color: #000; --block-color: blue; --border-color: red;} 响应式布局12345678910111213141516body { --primary: #7F583F; --secondary: #F7EFD2;}a { color: var(--primary); text-decoration-color: var(--secondary);}@media screen and (min-width: 768px) { body { --primary: #F7EFD2; --secondary: #7F583F; }} 这样，窗口宽度在大于等于768px的时候采用: 1234body { --primary: #F7EFD2; --secondary: #7F583F; } 其他情况采用： 1234body { --primary: #7F583F; --secondary: #F7EFD2;} 而a标签是公共样式： 1234a { color: var(--primary); text-decoration-color: var(--secondary);} 兼容如果浏览器不支持css变量，则： 12345a { --main-color: #333; color: #333; color: var(--main-color);} 或者使用@supports检测： 1234567@supports ( (--a: 0) ) { /*supported*/}@supports ( not (--a: 0) ) { /*not supported*/} js检测浏览器是否支持css变量1234567const isSupported = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports('--a', 0);if (isSupported) { /*支持，继续使用css变量*/} else { /*不支持，使用兼容写法*/} JavaScript 操作 CSS 变量的写法如下。 123456789// 设置变量document.body.style.setProperty('--primary', '#7F583F');// 读取变量document.body.style.getPropertyValue('--primary').trim();// '#7F583F'// 删除变量document.body.style.removeProperty('--primary'); css变量提供了一种css与js通信的方式： 123div { --msg: if (x === 1) { this.width = 10};} 这个--msg变量的值在css中是无效的，但是我们通过js可以读取到它，变相让css传值给了js。","link":"/2019/10/26/css-var/"},{"title":"一条属性让网站变成灰色","text":"昨天是国家哀悼日，我发现所有主流网站都变成了灰色，那么这是怎么做到的呢。 其实这里用到了css3的滤镜filter属性，以及属性值grayscale()。 只需要给html标签加个class即可。 123456html.gray { -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%);} IE不支持filter 就拿youtube来试试看。 原来： 现在：","link":"/2020/04/05/css3-filter-grayscale/"},{"title":"css技巧（长期更新）","text":"总结一下css 的一些技巧。 文本水平居中 123p { text-align: center;} 容器水平居中 先给容器定宽，再margin: 0 auto 1234div { width: 100px; margin: 0 auto;} 文本垂直居中 直接将line-height设置为容器高度即可。 1234567&lt;div&gt;文本&lt;/div&gt;&lt;style&gt; div { height: 18px; line-height: 18px; }&lt;/style&gt; 如果容器内有n行文本，则设置line-height为height/n即可。 容器垂直居中 一个大容器包含一个小容器，让小容器垂直居中。 首先设置大容器高度以及将大容器position: relative，然后小容器定高度以及position: absolute，top设置为50%，margin-top设置为负值的小容器高度的一半。 下面使用calc()简化代码。 calc()函数写法如下，符号两边各空一个空格。 1234567891011121314151617181920212223&lt;div class=\"big\"&gt; &lt;div class=\"small\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .big { height: 100px; position: relative; } .small { height: 20px; position: absolute; top: calc(50% - 10px); } /*或者*/ .small { height: 20px; position: absolute; top: 50%; margin-top: -10px; }&lt;/style&gt; 图片自适应容器 12345678img { max-width: 100%;}/*ie-6写法*/img { width: 100%;} 3D按钮 设置左上为浅色，右下为深色。 1234button { border: 1px solid; border-color: #999 #777 #777 #999;} font简写,注意font-family属性值引号 分开写： 12345678p { font-family: Arial, Helvetica, sans-serif; font-size: 12px; font-weight: bold; font-variant: small-caps; font-style: italic; line-height: 150%;} 写一起： 123p { font: 12px/150% bold small-caps italic Arial, Helvetica, sans-serif;} a标签的伪类 1234a:link {}a:visited {}a:hover {}a:active {} IE条件注释 使用条件注释，引入只对IE生效的语句，比如这里引入只对IE生效的ie.css样式 123&lt;!--[if IE] &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"ie.css\"&gt;&lt; ![endif]--&gt; 区分IE版本： 12345 &lt;!--[if IE 6]&gt; - targets IE6 only --&gt; &lt;!--[if gt IE 6]&gt; - targets IE7 and above --&gt; &lt;!--[if lt IE 6]&gt; - targets IE5.5 and below --&gt; &lt;!--[if gte IE 6]&gt; - targets IE6 and above --&gt; &lt;!--[if lte IE 6]&gt; - targets IE6 and below --&gt; IE6专用语法 ie6视html为根元素，故而以下代码仅对ie6生效。 123* html {}* html body {}* html .class{} IE专用语法 只有ie6可以识别属性前面的下划线 只有ie7可以识别属性前面的通配符 12345.class { background: red; *background: green; _background: blue;} 然而并没有什么卵用。 选择器优先级 1行内样式 &gt; ID &gt; class &gt; 标签 IE6的min-height IE6不支持min-height 解决方法一： 顺序不能乱！ 12345.class { min-height: 100px; height: auto !important; height: 100px;} 解决方法二： 使用了IE6才能识别的_height属性 1234.class { min-height: 100px; _height: 100px;} font-size统一 浏览器默认16px。 可以先设置基准文字大小为10px： 1234body { font-size: 62.5%; /*基准字体大小设置为了10px*/} 后面一律使用em来设置字体： 2.4em就是24px 123h1 { font-size: 2.4em;} 改变字母大小写 123456789101112/*字母设置为大写*/p { text-transform: uppercase;}/*字母设置为小写*/p { text-transform: lowercase;}/*字母设置为首字母大写*/p { text-transform: capitalize;} 1234/*字母设置与小写字母等高的大写形式*/p { font-variant: small-caps;} reset.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;}/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block;}body { line-height: 1;}ol, ul { list-style: none;}blockquote, q { quotes: none;}blockquote:before, blockquote:after,q:before, q:after { content: ''; content: none;}table { border-collapse: collapse; border-spacing: 0;} 修改list图标样式 默认： 123ul { list-style-type: disc;} 自定义图标： 123ul { list-style: url('triangle.png');} 或者： 123456ul { list-style: none;}ul li { background: url('pic.png') no-repeat 0 0.5em;} css中的透明 123div { opacity: 0.5;} css三角形 原理：容器长宽设为0，设置border-width后，对四个border分别着色，可以看到四个不同颜色的等腰直角三角形组成了一个正方形（由border构成）。 容器长宽设置为0，设置border-width border-style: solid,将需要的三角形着色，其他三角形设为透明border-color: transparent。 1234567891011&lt;div class=\"triangle\"&gt;&lt;/div&gt;&lt;style&gt; .triangle { width: 0; height: 0; border-style: solid; border-width: 4px; border-color: transparent transparent red transparent; }&lt;/style&gt; 以上就得到了一个底边长8px红色的相左的等腰直角三角形。 详细css三角形见博客单独文章。 禁止文本自动换行 让文本在一行显示 123p { white-space: nowrap;} 给标题设置图标 不想使用文本，想使用图标替换h1达到更好的视觉效果。但是又不能丧失SEO。 方法： 为容器设置宽高。 设置一个负的大的文本缩进将h1移出视野。 background设置替换的图片。 123456h1 { width: 200px; height: 50px; text-indent: -9999px; background: url('icon.jpg') no-repeat;} :focus 为可以获取焦点的元素设置获取焦点后的样式。 123input:focus { border: 1px yellow solid;} !important 1234p { color: red !important; color: green;} 规则color: red胜出。 值得一提的是IE不支持!important规则，故而可以用来区分IE和非IE浏览器。 提示框 1&lt;a class=\"tips\" href=\"#\"&gt;https://google.com/&lt;span&gt;提示文本&lt;/span&gt;&lt;/a&gt; 123456789101112131415a.tips { position: relative;}a.tips span { display: none; padding: 5px; width: 200px;}a:hover { background: #fff;}a.tips:hover span { display: inline; position: absolute;} 固定header位置 将header标签固定在页面顶部 1234567891011121314151617body{ margin:0;padding:100px 0 0 0;}div#header{ position:absolute; top:0; left:0; width:100%; height:&lt;length&gt;;}@media screen{ body&gt;div#header{position: fixed;}}* html body{overflow:hidden;}* html div#content{height:100%;overflow:auto;} 浏览器兼容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* IE6 and below */ * html #uno { color: red } /* IE7 */ *:first-child+html #dos { color: red } /* IE7, FF, Saf, Opera */ html&gt;body #tres { color: red } /* IE8, FF, Saf, Opera (Everything but IE 6,7) */ html&gt;/**/body #cuatro { color: red } /* Opera 9.27 and below, safari 2 */ html:first-child #cinco { color: red } /* Safari 2-3 */ html[xmlns*=\"\"] body:last-child #seis { color: red } /* safari 3+, chrome 1+, opera9+, ff 3.5+ */ body:nth-of-type(1) #siete { color: red } /* safari 3+, chrome 1+, opera9+, ff 3.5+ */ body:first-of-type #ocho { color: red } /* saf3+, chrome1+ */ @media screen and (-webkit-min-device-pixel-ratio:0) { #diez { color: red } } /* iPhone / mobile webkit */ @media screen and (max-device-width: 480px) { #veintiseis { color: red } } /* Safari 2 - 3.1 */ html[xmlns*=\"\"]:root #trece { color: red } /* Safari 2 - 3.1, Opera 9.25 */ *|html[xmlns*=\"\"] #catorce { color: red } /* Everything but IE6-8 */ :root *&gt; #quince { color: red } /* IE7 */ *+html #dieciocho { color: red } /* Firefox only. 1+ */ #veinticuatro, x:-moz-any-link { color: red } /* Firefox 3.0+ */ #veinticinco, x:-moz-any-link, x:default { color: red } /***** Attribute Hacks ******/ /* IE6 */ #once { _color: blue } /* IE6, IE7 */ #doce { *color: blue; /* or #color: blue */ } /* Everything but IE6 */ #diecisiete { color/**/: blue } /* IE6, IE7, IE8 */ #diecinueve { color: blue\\9; } /* IE7, IE8 */ #veinte { color/*\\**/: blue\\9; } /* IE6, IE7 -- acts as an !important */ #veintesiete { color: blue !ie; } /* string after ! can be anything */ 容器水平和垂直居中 1234&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;img&gt;&lt;/div&gt; 123456789101112131415161718div { width: 100px; height: 200px; display: block; text-align: center; vertical-align: middle;}div * { display: inline-block; height: 100%; vertical-align: middle;}div img { width: auto; height: auto; max-width: 100%; max-height: 100%;} 阴影 text-shadow box-shadow 外阴影： 123456div { -moz-box-shadow: 5px 5px 5px #ccc; -webkit-box-shadow: 5px 5px 5px #ccc; box-shadow: 5px 5px 5px #ccc; /*不带厂商前缀的放在最后*/} 内阴影： 12345div { -moz-box-shadow: inset 0 0 10px #000; -webkit-box-shadow: inset 0 0 10px #000; box-shadow: inset 0 0 10px #000;} 取消IE文本框滚动条 1textarea { overflow: auto; } 图片预加载 纯css预加载： 12345678body:after { content: \"\"; display: block; position: absolute; background: url(\"../image/manage/help/help_item2_01.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_02.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_03.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_04.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_05.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_06.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_07.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_01.png?v=201707241359\") no-repeat -10000px -1000px; width: 0; height: 0}","link":"/2020/03/24/css%E6%8A%80%E5%B7%A7/"},{"title":"使用curl代替postman","text":"curl是一个命令行工具，功能是发出请求并得到应答，最后输出到终端。 使用 查看源码 12345678# 打印在终端中curl www.baidu.com# 将输出保存为文件curl -o &lt;filename&gt; www.baidu.com# 自动跳转curl -L www.baidu.com 显示头信息 12345# 显示代码和头信息curl -i www.baidu.com# 只显示头信息curl -I www.baidu.com 显示通信过程 12345curl -v www.baidu.com# 查看详细信息curl --trace &lt;filename&gt; www.baidu.comcurl --trace-ascii &lt;filename&gt; www.baidu.com GET/POST GET: 1curl baidu.com/form.cgi?data=xxx POST: 1curl -X POST --data \"data=xxx\" baidu.com/form.cgi 表单编码： 1curl -X POST--data-urlencode \"date=April 1\" baidu.com/form.cgi http动词 默认GET -X参数用来指定动词。 12curl -X POST www.baidu.comcurl -X DELETE www.baidu.com 上传文件 1curl --form upload=@filename --form press=OK [URL] referer 该字段用于指示从哪个url跳转而来 1curl --referer http://www.baidu.com http://www.baidu.com User Agent 该字段表示客户端的代理信息。 模拟用户代理： 1curl --user-agent \"[User Agent]\" [URL] cookie 发送cookie： 1curl --cookie \"name=xxx\" www.baidu.com 增加头信息 1curl --header \"Content-Type:application/json\" http://example.com HTTP认证 1curl --user name:password baidu.com 参考 http://www.ruanyifeng.com/blog/2011/09/curl.html http://www.ruanyifeng.com/blog/2019/09/curl-reference.html","link":"/2020/07/26/curl-postman/"},{"title":"deno试水","text":"Deno: A secure runtime for JavaScript and TypeScript. 安装12345# curlcurl -fsSL https://deno.land/x/install/install.sh | sh# brewbrew install deno 开始12# exampledeno run https://deno.land/std/examples/welcome.ts","link":"/2020/07/01/deno-install/"},{"title":"DNS详解","text":"DNS（Domain Name System）：域名解析系统。 DNS的作用是根据域名查找ip，也就是输入一个域名输出一个ip。 域名的层级根域名：.root或者.。 顶级域名：.com、.cn、还有我的.icu都是顶级域名。 次级域名：比如我的域名ownpress.icu。 主机域名：比如proxy.ownpress.icu，主机域名由域名持有者自行分配。 proxy.ownpress.icu.root主机域名.次级域名.顶级域名.根域名 DNS解析过程比如在浏览器中输入了www.ownpress.icu，会发生什么？ 浏览器会查找本地dns缓存，有则返回结果，没有则继续下一步。 查看本地hosts文件有没有记录，有则返回，没有则继续下一步。 Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 需要注意的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。 浏览器向本地dns服务器（运营商提供的）发送查询请求，本地dns服务器收到请求后会查询本地缓存，有则返回，没有则向dns根域名服务器发出查询请求。 根域名服务器收到请求后就返回.icu这个顶级域名的服务器。 本地dns服务器收到返回的.icu顶级域名服务器地址后就给.icu顶级域名服务器发出查询请求。 .icu顶级域名服务器收到查询请求后返回ownopress.icu的地址。 本地dns服务器收到后，向.ownpress.icu这个域名服务器请求查询www.ownpress.icu。 .ownpress.icu域名服务器收到请求后，查询www.ownpress.icu的ip并返回给本地dns服务器。 本地dns收到最终查询结果后将其返回给了用户，不过本地dns服务器不会每次都傻傻的去一层层查询，它会缓存一部分在本地dns服务器中。 DNS缓存时间dns服务器会配置有一个参数TTL(time to live)，也就是dns记录的存活时间。 设置TTL的原因是一个域名对应的ip可能会发生变动导致dns服务器缓存记录失效，另外就是让访问量不是那么大的域名的解析不要一直占用dns服务器的缓存。 超过TTL的记录都会被删除，下次再有用户查询则重新获取。 DNS记录类型 A：地址记录（address），返回域名指向的ip。 NS：域名服务器记录（name server），返回保存下一级域名信息的服务器地址，要设置为域名。 MX：邮件记录（mail exchange），返回接受电子邮件的服务器地址。 CNAME：规范名称记录（canonical name），返回另一个域名，也就是跳转到另一个域名。 PTR：逆向查询记录（pointer record），只用于从ip地址查询域名。 DNS报文结构DNS报文： 同一个dns解析的请求报文和应答报文具有相同的事务ID。 DNS劫持和http劫持dns劫持：中国互联网早期经常出现dns劫持，dns劫持就是dns返回的ip与你要访问的域名的真实ip不符。dns劫持的方法有好几种，第一种是流氓软件或者恶意程序修改了用户本地的hosts文件，第二种是路由劫持，第三种是dns服务器查询并返回了错误的ip，这可能是dns服务器被攻陷了亦或者是dns服务器故意如此。 http劫持： 在用户的客户端与其要访问的服务器经过网络协议协调后，二者之间建立了一条专用的数据通道，用户端程序在系统中开放指定网络端口用于接收数据报文，服务器端将全部数据按指定网络协议规则进行分解打包，形成连续数据报文。 用户端接收到全部报文后，按照协议标准来解包组合获得完整的网络数据。其中传输过程中的每一个数据包都有特定的标签，表示其来源、携带的数据属性以及要到何处，所有的数据包经过网络路径中ISP的路由器传输接力后，最终到达目的地，也就是客户端。 HTTP劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文，目的是让用户端程序解释“错误”的数据，并以弹出新窗口的形式在使用者界面展示宣传性广告或者直接显示某网站的内容。 使用工具管理DNS dig dig可以查询dns记录以及dns解析的过程。 使用：dig +trace www.ownpress.icu查询详细信息。 使用：dig +short www.ownpress.icu查询结果。 使用：dig @8.8.8.8 www.ownpress.icu指定dns服务器。 使用：dig cname www.ownpress.icu查询指定类型的记录。 host host是dig的简化版，返回当前请求域名的各种记录。 用法：host www.ownpress.icu whois 查看域名的注册信息。 用法：whois ownpress.icu nslookup 1nslookup [待查询域名] [指定DNS服务器] 清理本地dns缓存 macos 12sudo dscacheutil -flushcachesudo killall -HUP mDNSResponder linux 使用NSCD的dns缓存： 1sudo /etc/init.d/nscd restart 使用DNSMASQ： 1sudo dnsmasq restart windows 1ipconfig /flushdns 根域名请参考：http://www.ruanyifeng.com/blog/2018/05/root-domain.html","link":"/2020/06/02/dns/"},{"title":"Emmet常用写法","text":"整理一下Emmet常用写法。 Emmet一般IDE都支持，tab即可生成dom树，非常快捷，再tab既可依次输入内容。 编辑器需要安装插件。 选择器生成 p p{content} p.class p#id a[href=&quot;https://baidu.com&quot;] div&gt;span h1+p div&gt;ul&gt;li^span 123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 这里 ^ 是代表上级节点，这里就是让 span 成为 li 的上级节点，也就是成为 ul 的兄弟节点。 然后tab生成结构。 连写 li*3&gt;a 效果： 123&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; 自动编号 div#id_name$.class_name$$*3 其中 $ 表示位数为一的序号， $$ 表示拥有两位的序号。 效果： 123&lt;div id=\"id_name1\" class=\"class_name01\"&gt;&lt;/div&gt;&lt;div id=\"id_name2\" class=\"class_name02\"&gt;&lt;/div&gt;&lt;div id=\"id_name3\" class=\"class_name03\"&gt;&lt;/div&gt; 从指定序号开始生成： div#id_name$@3*5 倒序生成： div#id_name$@-*5 倒序并指定序号： div#id_name$@-10*5 综合方式 header+nav+article 效果： 123&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;article&gt;&lt;/article&gt; nav&gt;ul&gt;(li&gt;a[href=#]{Link})*5 效果： 123456789&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; table&gt;(thead&gt;tr&gt;th*5)(tbody&gt;tr&gt;td*5) 这里 () 里为一个代码块。 {} 里面写内容 效果： 1234567891011121314151617181920&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 生成html基本结构 ! 效果： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 隐式标签:未指定标签 .class_name 效果： 1&lt;div class=\"class_name\"&gt;&lt;/div&gt; ul&gt;.item$*3 效果： 12345&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt;&lt;/ul&gt; 生成属性 标签:属性 form form: form:get form:post input:input:b or input:button input select: select&gt;option*3 select&gt;[value=&quot;item$&quot;]*3 XML的生成 root&gt;player*3 root&gt;player#$*3 root[match=&quot;nba&quot; title=&quot;1nba&quot;]&gt;player#$$*4 name+age+sex+address root&gt;player#$*3&gt;name+age+sex+address css的生成 margin: m m10 m10p m10r m10-20-10-20 m10p20p mt10 mr10 mb10 ml10 m-10 m-10--20 padding: p color: c c#f c#f0 color:rgb color:rgba 常用生成写法：pore : position: relative; posa : position: absolute; d:n : display: none; d:b : display: block d:i : display: inline ov:h : overflow: hidden; cur:p : cursor: pointer; ta:c : text-align: center; 以此类推。 cheatsheet 发掘更多：https://docs.emmet.io/cheat-sheet/","link":"/2020/03/25/emmet/"},{"title":"docsify使用方式","text":"docsify是什么？看官网怎么说： A magical documentation site generator. 一个神奇的文档站点生成器。 docsify官网 安装npm全局安装 1npm i docsify-cli -g Mac使用npm安装docsify的时候遇到了错误： 1gyp: No Xcode or CLT version detected! 解决办法： 12sudo rm -rf $(xcode-select -print-path)xcode-select --install 初始化创建目录并初始化： 1docsify init docsify_folder 在已有的目录中初始化： 1docsify init index.html：入口文件 README.md：主页内容 .nojekyll：用于阻止 GitHub Pages忽略掉下划线开头的文件 预览1docsify serve docsify_folder 路由页面路由和文件夹的对应关系如下： 1234docsify_folder/README.md =&gt; http://domain.comdocsify_folder/guide.md =&gt; http://domain.com/guidedocsify_folder/zh-cn/README.md =&gt; http://domain.com/zh-cn/docsify_folder/zh-cn/guide.md =&gt; http://domain.com/zh-cn/guide 导航栏与侧边栏导航栏简单导航条 在index.html中： 1234567&lt;body&gt; &lt;nav&gt; &lt;a href=\"#/\"&gt;LeetCode题解&lt;/a&gt; &lt;a href=\"https://herotiga.github.io\" target=\"_blank\"&gt;我的博客&lt;/a&gt; &lt;/nav&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt; 复杂导航条 通过md文件配置 配置 loadNavbar 为 true： 123456&lt;script&gt; window.$docsify = { loadNavbar: true }&lt;/script&gt;&lt;script src=\"//unpkg.com/docsify\"&gt;&lt;/script&gt; 在 ./docs 下创建一个 _navbar.md 文件，在该文件中使用 Markdown 格式书写导航： 123* 导航1 * [子导航](nav1/child/)* [导航2](nav2/) 侧边栏默认情况下，侧边栏会根据当前文章的标题生成目录。但也可以通过 Markdown 文档生成。 首先配置 loadSidebar 选项为 true： 123456&lt;script&gt; window.$docsify = { loadSidebar: true }&lt;/script&gt;&lt;script src=\"//unpkg.com/docsify\"&gt;&lt;/script&gt; 然后在 ./docs 下创建 _sidebar.md 文件： 12345678910111213141516171819202122232425262728293031323334353637383940* [简介](/)* 数据结构 * [数组](data-structure/array/) * [字符串](data-structure/string/) * [链表](data-structure/linked_list/) * 树 * [递归](data-structure/tree/recursion/) * [层次遍历（BFS）](data-structure/tree/bfs/) * [前中后序遍历（DFS）](data-structure/tree/dfs/) * [其他](data-structure/tree/other/) * [堆](data-structure/heap/) * [栈](data-structure/stack/) * [哈希表](data-structure/hash/)* 算法思想 * 排序 * [堆排序](algorithm/sort/heap/) * [快速排序](algorithm/sort/quick/) * [冒泡排序](algorithm/sort/bubble/) * [其他](algorithm/sort/other/) * 搜索 * [深度优先](algorithm/research/dfs/) * [广度优先](algorithm/research/bfs/) * [二分查找](algorithm/research/binary-search/) * [动态规划](algorithm/dynamic/) * [贪心](algorithm/greedy/) * [位运算](algorithm/bit/) * [数学题](algorithm/math/) * [其他](algorithm/other/)* 周赛 * [第 121 场周赛](weekly/121/) * [第 122 场周赛](weekly/122/) * [第 124 场周赛](weekly/124/) * [第 129 场周赛](weekly/129/) * [第 130 场周赛](weekly/130/) * [第 131 场周赛](weekly/131/) * [第 133 场周赛](weekly/133/) * [第 134 场周赛](weekly/134/) * [第 136 场周赛](weekly/136/) * [第 137 场周赛](weekly/137/) * [第 138 场周赛](weekly/138/) 插件代码高亮使用 Prism 作为代码高亮插件，可以在 index.html 中这样配置： 123&lt;script src=\"//unpkg.com/docsify\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/prismjs/components/prism-bash.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/prismjs/components/prism-php.js\"&gt;&lt;/script&gt; 注意这里引入的文件，如果你要高亮 Python 代码，那么就要引入： 1&lt;script src=\"//unpkg.com/prismjs/components/prism-python.js\"&gt;&lt;/script&gt; 对不同语言的高亮支持可见 Prism 仓库。 部署我的 Github Pages 读取的是 gh-pages 分支下的代码，因此我要把 ./docs 下的文件上传到 gh-pages 分支上，完整的代码则上传的到 master 分支。 为了方便更新，我在项目根目录下放置了一个用于推送代码的脚本 push.sh： 12345678910111213141516message=$1# 复制 README.mdcp README.md docs/README.md# 更新 mastergit add .git commit -m \"$message\"git push -f git@github.com:JalanJiang/leetcode-notebook.git master# 更新 gh-pagescd docs/git initgit add -Agit commit -m \"$message\"git push -f git@github.com:JalanJiang/leetcode-notebook.git master:gh-pages","link":"/2019/05/14/docsify-usage/"},{"title":"前端面试系列（一）","text":"var和let的区别var声明在函数中则作用域就是该函数，声明在函数外则作用于为全局，js引擎执行代码时会提升变量到顶部。 let作用域为当前所处的代码块，没有变量提升故而要先声明后使用，且不允许在相同作用域中重复声明同一个变量。 实例1：作用域对比 123456{ let a = 123; var b = 321;}a // 引用错误b // 321 实例2：let在for循环中的使用 12345for (let i = 0; i &lt; 5; i++) { console.log(i); // 0 1 2 3 4}console.log(i); // 引用错误 实例3：常见面试题 12345for (var i = 0; i &lt; 10; i++) { setTimeout(function() { console.log(i); // 执行的时候同步代码for已经执行完毕 },0);} 1234567891010101010101010101010 12345for (let i = 0; i &lt; 10; i++) { setTimeout(function() { console.log(i); // 这里的i的作用域是循环体内，不受外界影响 },0);} 123456789100123456789 实例4：for循环特点，()中的是父作用域，{}中是子作用域。 1234for (let i = 0; i &lt; 3; i++) { let i = 'love'; console.log(i);} 123lovelovelove == 和 === 有什么区别==允许自动类型转换 ===不允许自动类型转换 this 在对象方法中，this指向调用它所在方法的对象。 在全局环境中，this指向全局对象。 在函数中，this指向函数的所有者。 在函数中，严格模式，this指向undefined。 在事件中，this指向接收事件的元素。 call()和apply()可以指定函数执行的上下文环境，即this绑定的对象，可以将this引用到任何对象。 以下实例均在浏览器环境中运行。 实例1：方法中的this指向调用该方法的对象。 123456789var person = { firstName: \"mason\", lastName: \"wong\", fullName: function() { return this.firstName + ' ' + this.lastName; }};person.fullName();// 'mason wong' 实例2：单独使用this，指向全局对象（严格模式也是）。 12console.log(this);// window 实例3：函数中使用this，指向函数所有者，也就是全局对象。 12345function func() { return this;}func();// window 实例4：严格模式下，函数中使用this，指向undefined。 123456\"use strict\";function func() { return this;}func();// undefined 实例5：事件中的this，指向接收事件的html元素。 1&lt;button onclick=\"this.style.display='none'\"&gt;点击我消失&lt;/button&gt; 实例6：对象方法中绑定，这里对象是函数的所有者。 12345678var person = { firstName : \"John\", lastName : \"Doe\", id : 5566, myFunction : function() { return this; }}; 实例7：显式函数绑定 使用call和apply切换函数执行上下文环境（context），也就是指定this指向的对象。 1234567891011var person1 = { fullName: function() { return this.firstName + \" \" + this.lastName; }}var person2 = { firstName:\"John\", lastName: \"Doe\",}person1.fullName.call(person2); // \"John Doe\" 上面这个例子中调用person1.fullName()方法，使用call()指定了this指向的对象为person2，故而取得了person2中的firstName和lastName。 什么是构造函数使用new关键字调用的函数为构造函数，通常构造函数的函数名首字母大写。 构造函数的样子如下： 12345function Person(name, gender, hobby) { this.name = name; this.gender = gender; this.hobby = hobby;} 这样就可以通过new来调用，也就是通过new构造函数传入参数并快速创建对象： 1var p1 = new Person('小明', '男', '足球'); 这样就达到了代码复用。 确定一个函数是构造函数的方法是看是否使用new调用了它。 构造函数执行过程 使用new调用后会创建一个新的内存空间分配给实例。 函数题内部的this指向该内存空间。 执行函数题内代码 默认返回this。 如何将基于回调的函数转换为基于Promise的函数实例：将getData回调函数转换为Promise 12345678910111213141516171819202122232425262728293031// the function itselffunction getData(callback, errorCallback) { try { // Do some network/api stuff... callback(result) } catch (e) { errorCallback(e); }}// Here is how you would use it:getData(result =&gt; console.log(result), error =&gt; console.error(error));// Here is how to create a Promise-based function from it:function getDataAsync() { return new Promise((resolve, reject) =&gt; { getData(resolve, reject); });}getDataAsync() .then(result =&gt; console.log(result)) .catch(error =&gt; console.error(error));// ORasync functoin main() { const result = await getDataAsync(); console.log(result);} Promise构造函数接受一个回调，该回调接收两个函数：resolve和reject。在回调内部，你可以执行耗时的任务，并根据结果调用resolve或reject。 NaN === NaN ?结果：false NaN不===于任何值 0.1 + 0.2 === 0.3 ?结果：false 事实上：0.1 + 0.2 = 0.30000000000000004 原因：js中的数字以IEEE 754的双精度标准存储。无法精确表示0.1和0.2，故而结果对不对就看运气。 解决方法：将浮点数转化为整数运算。 10.1 + 0.2 1(1 + 2) / 1e1 输出： 10.3 js中的原始数据类型是什么Boolean Number String 什么是严格模式1'use strict'; 以下省略一千字。 以下代码的输出是什么12345678function func() { return { a: 'b'; }}console.log(func()); 输出： 1undefined 原因： js会在第二行的return后面自动添加分号;，将后面的{}代码块视为作用域而不是对象定义。","link":"/2020/04/15/fed-interview-01/"},{"title":"前端面试系列（二）","text":"如何理解执行上下文 每一段js代码的执行之前都会创建一个上下文环境 JavaScript执行上下文是指代码运行环境。 执行上下文有三种： 全局执行上下文 函数执行上下文 eval执行上下文 如何理解作用域链 JavaScript代码执行前会创建上下文环境（包含变量、作用域链、this） 也就是从当前环境向父级一层层的查找变量的过程，这个链就是作用域链。 实例： 1234var name = 'wang'function hello() { console.log(name);} 以上代码：执行hello()的时候，会先在hello()的作用域内查找变量name，如果没有找到则去hello()的父级作用域查找。 如何理解原型链每个函数都有一个prototype属性，每个函数实例对象都有一个__proto__属性，这个属性指向函数的prototype。 当我们访问实例对象的属性或者方法的时候，会先从自身构造函数中查找，如果找不到就通过__proto__去原型中查找，这个查找过程所访问的链就是原型链。 实例： 123456789101112131415161718192021222324// parent classfunction Human() { this.age = 30; this.say = function() { return 'hello'; }}// son classfunction Man() { this.name = 'Adam';}// son class inherits parent class via prototype chainMan.prototype = new Human();// create a Man() examplevar lee = new Man();// compare,return truelee.__proto__ === Man.prototype;// print \"age\",return 30console.log(lee.age); 上面会先查找lee再查找Human，找不到再往上找。 闭包闭包就是定义在一个函数内部的函数，这样就可以使用内部函数访问到外部函数中的局部变量。 实例： 正常情况下无法访问到函数内部的局部变量： 1234function f1() { var name = 'mason';}console.log(name); 输出： 1undefined 使用闭包： 12345678function f1() { var name = 'mason'; return function f2() { console.log(name); }}var f = f1();f(); 输出： 1mason 总结： 由于在 JavaScript 中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 继承有哪些方法 原型继承 构造继承 实例继承 call(),apply() ES6的class extends 深拷贝、浅拷贝javascript的数据类型总体分为基本类型和引用类型。 基本类型保存值，引用类型保存指针。 浅拷贝：共用一个引用地址，方法有直接对象复制、Object.assign。 深拷贝：创建新的内存地址，方法有：先JSON.stringify转化为字符串再JSON.parse，还有深度递归遍历。 如何判断一个对象是数组方法： 1Object.prototype.toString.call([]) 输出： 1\"[object Array]\" 数组有哪些方法 push() pop() shift() unshift() concat() join() reverse() sort() map() forEach() filter() indexOf() includes() slice() splice() slice()和splice()的区别： slice()：截取数组，参数有起始点和结束点，不改变原数组，返回新数组。 splice()：删除，参数有起始点、长度、待插入的元素。 DOM常用操作创建节点： createElement createTextNode createDocumentFragment 修改节点： appendChild insertBefore replaceChild CSS清除浮动的方法有哪些 父元素设置高度，手动撑开 浮动元素结尾添加空标签，设置空标签clear: both 父元素设置overflow: hidden 父元素添加伪类:after和zoom CSS选择器优先级!important &gt; 内联样式 &gt; id选择器 &gt; 类选择器/属性选择器/伪类 &gt; 元素选择器 CSS三列布局 浮动布局 左边区域float: left;，右边区域float: right;，中间区域设置margin-left和margin-right。 12345&lt;div class=\"layout\"&gt; &lt;div class=\"layout_left\"&gt;&lt;/div&gt; &lt;div class=\"layout_center\"&gt;&lt;/div&gt; &lt;div class=\"layout_right\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.layout { width: 1200px; overflow: hidden;}.layout_left { width: 20%; float: left;}.layout_right { width: 20%; float: right;}.layout_center { margin-left: 5%; margin-right: 5%;} 定位布局 三列布局的父元素设置position: relative;，左边区域position: absolute;并同时设置left，右边区域position: absolute;并同时设置right。 中间部分设置position: absolute;并设置margin-left和margin-right。 flex布局 123456789.layout_left { flex: 0 0 200px;}.layout_right { flex: 0 0 200px;}.layout_center { flex: 1;} 谈一下flex布局flex是弹性布局。 包含flex-container和flex-item。 常用属性：flex-direction、flex-wrap、justify-content、align-items。 水平居中 justify-content:center 水平两头居中 justify-content:space-between 垂直居中 align-items:center。 什么是盒模型内容区、padding、border、margin 分为IE盒模型和w3c盒模型 box-sizing: border-box; box-sizing: content-box IE盒模型的width包含了content、border、padding。 transition动画和animation的区别transition用于做简单的过渡效果。 animation可以做复杂的效果。 h5自适应方案使用rem，rem是根据html的font-size来设置的。 call(),apply(),bind()作用都是改变函数的作用域。 call(),apple()可以直接执行，bind()不会立刻执行。 call()单个传参，apply()用数组传参。 观察者和发布订阅的区别发布订阅有调度中心， 浏览器解析渲染页面的过程 浏览器解析html文档并生成DOM树。 浏览器解析CSS生成CSSOM树。 DOM和CSSOM关联，生成渲染树。 根据渲染树进行布局。 根据渲染树进行绘制。 将图像信息发送给GPU，最终显示在显示器上。 谈一谈EventLoop事件循环 JavaScript本身是单线程，也就是同一时刻只能干一件事，JS任务包含了同步任务和异步任务，遇到执行函数会将其放入调用栈(先进后出)中，遇到setTimeout/setInterval等异步任务时，会把它放入到消息队列中，等主线程的任务执行完成以后，再回过头执行消息队列中的异步任务，如果异步任务中仍然有异步任务，会继续放入消息队列，以此类推，便形成了一个事件循环。 GET和POST的区别 GET传输大小2K-8K，POST无限制 都不安全，GET通过url明文传输，POST通过body传输 浏览器会记录GET请求，不会记录POST GET对浏览器后退无影响，POST会再次提交 浏览器收藏：GET可以，POST不可以 GET可缓存，POST不会 GET用的url编码，POST支持多种编码 GET产生一个TCP数据包，POST产生2个TCP数据包 GET主要是拉取数据，POST主要是提交数据 防抖和节流两者目的都是希望一段时间内不要重复请求。 应用场景：搜索，滚动。 区别：防抖是规定时间内只触发一次，再次调用时间重新计算。节流是在固定时间内只触发一次。 数组去重 ES6 set去重 Object key去重 两层循环遍历生成新的不重的数组 indexOf() sort()排序后依次对比 数组排序 sort()排序 冒泡排序 选择排序 插入排序 常用设计模式 单例模式 工厂模式 观察者模式 适配器模式 for…ofes2015的语法 可以用来遍历数组、类数组、map/set/字符串等等。 数组遍历 1for (const number of [1,2,3]) {} 类数组遍历 1for (const number of arguments) {} 字符串遍历 12const msg = 'hello';for (const character of msg) {} Map遍历 123456const map = new Map();map.set(\"name\", '前端未来');map.set(\"author\", '河畔一角');for(const item of map){ }// 或者for(const [key,val] of map){ } Set遍历 12const names = new Set(['Tom', 'Jack', 'Lily']);for (let name of names) { } 前端常见攻击方式 XSS CSRF sql注入 html脚本注入 常见跨域方案跨域源于浏览器的同源政策：必须同协议、同域名、同端口。 JSONP（js调用） CORS（后台设置） Nginx反向代理（运维） 网站常用优化方案思路： 减少请求次数 压缩资源大小 提高响应速度和加载速度 优化资源加载时机 优化加载方式 方法： 合并、压缩、混淆前端代码 服务器nginx开启gzip压缩 静态资源使用CDN 图标做base64处理以减小大小 css放head，js放body中的最后面 设置缓存 css和js的rel属性设置prefetch或preload可预加载资源 按需加载组件库 按需import和require 服务端渲染SSR，加快首屏渲染，利于SEO 页面使用骨架屏提高首页加载速度 尽量少使用jpeg和png，转而使用JPEG 2000, JPEG XR, WebP 图片懒加载","link":"/2020/05/12/fed-interview-02/"},{"title":"转载：前端高频面试题整理","text":"作者：Big shark@LX原文链接：https://juejin.im/post/5eb250f3f265da7bf6742594备用链接：https://mp.weixin.qq.com/s/Jyc_OHmHiTyuIjaVf02F9w","link":"/2020/05/23/fed-interview-reship-01/"},{"title":"备案小记","text":"昨天下午给这个网站提交了备案，今天早上就完全备案完了，也在footer悬挂了ICP备案信息，就来记录一下备案的过程以及备案的痛点。 首先，备案有两种：ICP备案和公安备案。ICP备案是在中国大陆运行的所有网站都需要备案的，当然，我的网站由github page托管，服务器不在国内所以其实不用备案。 但是迫于前几天收件撸了一个阿里云的dcdn（全站加速）。dcdn和cdn的区别？dcdn就是对网站的所有资源进行加速而不是cdn仅对静态资源进行加速。但是你懂的，像大陆IDC提供的其他服务一样，使用dcdn也是需要以网站备案为前提的，故而没办法只能进行备案。 公安备案是你的网站在大陆境内进行业务的话会需要这个备案，我作为一个个人博客是不需要备案的。当然还有很多其他各种专项备案，大家看大型网站底部总是能发现一堆的备案信息，其实都是各种专项的东西，个人使用的博客站只需要ICP备案即可。 软硬环境服务器使用了github提供的github page服务，这个服务提供了免费的静态页面的托管服务以及一个github.io的次级域名。 网站使用了hexo这个静态博客生成器，hexo可以再本地编辑修改配置文件来给网站一定的信息以及本地编写文章，再编译为静态文件后部署到github page上面。就我以前用wordpress的经验来看，越接近服务器的博客方案维护成本越高，我使用服务器搭建wordpress的时候需要自己购买服务器域名，自己维护服务器的web服务器环境比如LAMP或者LNMP，自己搞SSL证书，自己搞重定向以及配置端口。这还不是全部，wordpress一周一个小版本一个月一次大版本的更新实在受不了，还有各种插件的更新以及兼容的问题。所以自建服务器以及自建站点实在是太费心费力了。 域名ownpress.icu是在阿里云购买的，dns解析也没改也是阿里云的dns。 开始备案我的域名是购于阿里云但是我的服务器实际是位于海外的，点进阿里云的备案系统后到了第二步发现需要填写服务器的一个id，但是我并没有在阿里云购买。这个时候其实上只要去淘宝购买一个备案服务号就可以填写进去从而不用提供主机信息了。 填写信息接下来就是在阿里云填写各种个人信息以及身份证和摄像头人脸识别等等。这个过程真的让我感觉我就是一颗韭菜，嗯，这里省略一万字。最后提交 提交审核写完了就可以提交了，提交了以后会先送到阿里云进行初审，阿里云初审通过后会提交到管局（管局就是工信部下面管理网站的一个部门）进行审核。 备案完成没什么问题的话管局就会给你发一个短信和一封邮件告诉你成功了，并提醒你悬挂ICP备案信息在网站footer，不然可能会罚款5000-10000元。 悬挂ICP在主题layout目录下找到footer.*文件，我的主题是footer.ejs模板文件，在对应位置添加a链接即可。","link":"/2020/06/08/filing/"},{"title":"从删库到恢复","text":"讨论一下程序员从删库到跑路恢复的问题。 误删库后该怎么办如果真的不幸在生产环境服务器直接或者间接地执行了rm -rf /*那么该怎么办呢？ 首先，当你错误执行了rm -rf /*那么当终端开始滚动删除文件信息的时候你应该知道大事不妙了。这时你应该眼疾手快地赶紧ctrl+ c来中断命令，这非常重要，这可以极大减少数据损失。 到这个时候千万不要重启服务器或者断开ssh连接，然后就是对比查看到底是哪些文件和目录被删除了，使用ls来确定被删除的文件和目录。如果不幸ls已经被删除了（linux中一切皆文件），那么可以使用cd和 tab来查看当前目录的文件和目录（如下）。 回顾一下linux系统目录有哪些以及其功能（参考自：http://www.92csz.com/study/linux/）： /binbin是Binary的缩写。这个目录存放着最经常使用的命令。 /boot这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /devdev是Device(设备)的缩写。该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /medialinux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root该目录为系统管理员，也称作超级权限者的用户主目录。 /sbins就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv该目录存放一些服务启动之后需要提取的数据。 /sys这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs ，sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统种被创建。 /tmp这个目录是用来存放一些临时文件的。 /usr这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /usr/bin系统用户使用的应用程序。 /usr/sbin超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src内核源代码默认的放置目录。 /var这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 恢复/bin目录，找一台拥有正常/bin目录的服务器，通过wget先下载tar命令并赋予执行权限，再用tar打包/bin为一个文件后wget下载至本机。并给予/bin下的命令以执行权限。如果chmod也被删除了，可以用perl给予权限。 1perl -e \"chmod 777, 'ls'\" 预防再一次误删 首先要多加小心，在执行rm之前要停顿对目标文件或目录确定确定再确定。如果在脚本中执行rm命令，则需要判断目标文件或目录是否可能为空，判断如果不为空再执行rm。 针对遇到目标变量不存在导致rm删库的情况，使用set -u使得脚本遇到不存在的变量报错并停止执行。 比如： 12345#!/bin/bashset -urm -rf $a/*echo finished 结果： 1test.sh: line 4: a: unbound variable 使用safe-rm代替rm，safe-rm是一个开源项目，用来安全删除文件。通过配置/etc/safe-rm.conf文件来排除一些目录来防止这些目录被删除。 创建回收站机制。大家都知道命令行下的linux是没有回收站机制的，通过在命令行下创建回收机制就可以有后悔的机会。 那么我们先回忆一下windows下的回收站是如何工作的：我们在windows下删除一个文件或目录的时候，这个文件或目录被移除了本来所属的目录并且被移动到了回收站，等待用户手动清空回收站这些文件才会被真正删除。 具体方法：https://www.cnblogs.com/xiaoyuxixi/p/11608198.html 根目录挂载为只读。 在/etc/fstab中将/挂载为只读： 12# &lt;file system&gt; &lt;mount pt&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;/dev/root / ext4 remount,ro,noatime 0 1 ​","link":"/2020/06/04/from-delete-to-restore/"},{"title":"git知识点和常用操作总结","text":"工作原理 工作目录（workspace）：持有实际文件。 暂存区（index/stage）：缓存区，临时保存你改动了的文件索引。 本地仓库（repository）：保存本地仓库commit。 远程仓库（remote）：用于团队协作或者作为个人备份。 我们写代码就是修改工作区文件，add之后会暂存到index/stage暂存区（修改了的文件的索引）中，多次add到index后，commit提交到本地仓库完成一次提交，或者说是一次快照。 HEAD^ 指 HEAD 的父节点，或者 HEAD~1 。同理： HEAD^^ == HEAD~2 配置查看配置使用 git config --list 。 或者直接查看 .gitconfig 文件： 1bat ~/.gitconfig 下面是我的配置： 123456789101112131415161718192021222324252627282930[user] email = herotiga@vip.qq.com name = wangwei[http] proxy = socks5://127.0.0.1:1086[https] proxy = socks5://127.0.0.1:1086[core] excludesfile = /Users/wangwei/.gitignore_global[difftool &quot;sourcetree&quot;] cmd = opendiff \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; path =[mergetool &quot;sourcetree&quot;] cmd = /Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; -ancestor \\&quot;$BASE\\&quot; -merge \\&quot;$MERGED\\&quot; trustExitCode = true[commit] template = /Users/wangwei/.stCommitMsg[filter &quot;lfs&quot;] clean = git-lfs clean -- %f smudge = git-lfs smudge -- %f process = git-lfs filter-process required = true[alias] dog = log --all --decorate --oneline --graph st = status co = checkout ci = commit br = branch unstage = reset HEAD -- last = log -1 HEAD 查看某个仓库的配置： 1bat .git/config 配置全局用户名和邮件git用户名和邮箱的用途是标识git操作的用户。 12git config --global user.name \"user name\"git config --global user.email \"email@example.com\" 配置命令别名（git alias）配置： 12345678# 常用的aliasgit config --global alias.co checkoutgit config --global alias.st statusgit config --global alias.ci commitgit config --global alias.br branch# 美化git log输出，实际使用时可以在 git lg 后面加命令参数，如： git lg -10 显示最近10条提交git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\" 取消配置： 12git config --global --unset alias.cogit config --global --unset user.name 除了使用命令配置之外，还可以直接编辑 ~/.gitconfig 的 [alias] 字段来给git命令起别名。 123456789101112[alias] st = status ci = commit co = checkout br = branch cf = config fc = fetch pl = pull ps = push unstage = reset HEAD -- last = log -1 HEAD visual = !gitk 除了git alias之外，像oh my zsh的 ~/.zshrc 文件还从linux alias层面提供了一堆git的别名。 配置代理迫于 git clone 实在是太慢了，学习了一下怎样配置使其走代理。 [http] 和 [https] 字段用来配置本地代理，1081端口。 方法一：使用命令配置 1234567# 配置socks5代理git config --global http.proxy socks5://127.0.0.1:1081git config --global https.proxy socks5://127.0.0.1:1081# 配置http/https代理git config --global https.proxy http://127.0.0.1:1081git config --global https.proxy https://127.0.0.1:1081 方法二：编辑 ~/.gitconfig 文件 1234567891011# 配置socks5代理[http] socks5://127.0.0.1:1081[https] socks5://127.0.0.1:1081 # 配置http/https代理[http] proxy = http://127.0.0.1:1081[https] proxy = https://127.0.0.1:1081 查看代理 12git config --global --get http.proxygit config --global --get https.proxy 取消代理 12git config --global --unset http.proxygit config --global --unset https.proxy 速度飞起～ 初始化仓库123456# 初始化已存在的目录为git仓库cd &lt;repository&gt;git init# 创建目录并初始化为git仓库git init &lt;repository&gt; 查看仓库状态1git status 克隆仓库12345678# 克隆本地仓库git clone /path/to/repository# 克隆远程仓库git clone username@host:/path/to/repository# 克隆到指定目录git clone /path/to/repository path/to/newFolder 添加和提交从工作区添加文件到暂存区： 1234567891011121314# 添加单个文件git add &lt;filename&gt;# 添加所有文件git add *# 添加本目录，监控工作区，会add所有改动，包括修改和新文件，不包括被删除的文件git add .# 是git add --all的缩写，提交所有变化git add -A# 仅监控已经被add的文件的改动，不提交新文件git add -u 撤回git add： 1git rm --cached &lt;file name&gt; 提交到 HEAD 并附上提交信息： 1234567891011121314# 不附加提交信息git commit# 附加提交信息git commit -m 'commit infomation'# add并commit，不推荐使用git commit -am 'commit infomation'# 修改最近一次的commit附加信息git commit --amend# 修改commit附加信息git rebase -i &lt;需要修改附加信息的commit的父节点的commit-id&gt; 推送到远程仓库12345# 指定远程仓库名origin和分支名master，参数-u的作用是，以后直接git push即可，不用加origin &lt;branch&gt;git push -u origin master# 不指定远程仓库名和分支名，只关联了一个远程仓库且只有一个分支则可以使用该命令git push 添加远程服务器 12345# 下面的origin为远程仓库的默认别名，用以区分不同的远程仓库（一个本地仓库关联多个远程仓库）。git remote add origin &lt;remote-repository&gt;# 查看remotegit remote -v 如果没有克隆远程仓库，将仓库连接到远程服务器。 这里需要做ssh免密校验。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候， master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个“feature_x”的分支，并切换过去 123456# 创建分支dev并切换到dev分支，-b表示创建完了切换上去git checkout -b feature_x# 上面的代码相当于git branch feature_xgit checkout feature_x 基于某个分支产生新的分支： 1git checkout -b new_branch base_branch 切换回主分支 1git checkout master 再把新分支删除 12345# 删除分支git branch -d feature_x# 强制删除分支git branch -D feature_x 除非将新分支推送到远程仓库，否则该分支就不对他人所见 1234git push origin &lt;branch&gt;# 推送到remote并重命名远端分支名git push origin local_branch_name:remote_branch_name 删除远程仓库分支： 1git push origin :&lt;branch_name&gt; 将工作区恢复为暂存区内容： 1git checkout -- &lt;filename&gt; 将master回退到上一次commit： 12git reset master^git reset master~5 将master回退到指定commit id： 1git reset &lt;commit_id&gt; 将暂存区内容恢复为HEAD内容： 1git reset HEAD -- &lt;filename&gt; 查看所有分支信息 12345# 查看本地分支git branch# 查看本地和远程所有分支git branch -av 更新与合并更新你的本地仓库至最新改动 1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行： 12345# 默认ffgit merge &lt;branch&gt;# 推荐使用这种merge方式，保留了合并时的commitgit merge &lt;branch&gt; --no-ff 在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功： 1git add &lt;filename&gt; 在合并改动之前，你可以使用如下命令预览差异： 1git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签： 1git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID： 1git log 你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。 替换本地改动假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动： 1git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它： 12git fetch origingit reset --hard origin/master 重命名和删除文件123git mv old_name new_namegit rm filename 更新本地仓库到最新改动（拉取最新）12git pullgit pull origin master 合并多个连续的分支 1git rebase -i 然后再pick多个分支中的一个分支作为base，其他的分支squash(s)既可。 合并分支到当前分支 1git merge &lt;branch&gt; 如若合并失败，则手动修改文件解决冲突，改完之后，你需要执行如下命令以将它们标记为合并成功： 1git add &lt;filename&gt; 预览分支差异： 1git diff source_branch target_branch 对比暂存区和HEAD的差异： 1git diff --cached 对比工作区和暂存区的差异： 12345# 对比所有文件git diff# 对于指定文件git diff -- readme.md css/style.css git标签id通过 git log 查看，只需要写前几位并具有唯一指向性即可。 1git tag 1.0.0 &lt;commit_id&gt; 查看日志1234567891011121314151617181920# 查看当前分支的历史git log# 查看所有分支历史git log --all# 查看所有分支历史（图形化）git log --all --graph# 简明显示git log --oneline# 输出最近3次的commitgit log -n3# 查看某个commit的详细信息git show &lt;commit_id&gt;# 查看引用日志git reflog 我最常用的git log是这条： 1git log --all --decorate --oneline --graph 替换本地改动假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动： 1git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它： 1git fetch origin 1git reset --hard origin/master 12# 将工作区和暂存区恢复到指定commit，丢弃这个commit之后所有的commitgit reset --hard &lt;commit-id&gt; git垃圾回收机制随着cdn仓库commit次数的变多，本地的cdn仓库会越来越占空间。可是我本地cdn仓库的目的只是用来push静态文件到github的cdn仓库，目的不是用来做版本管理，那么怎么释放这些成倍于静态文件大小的本地仓库占用空间呢？ git有gc机制（garbage collection），git会不定时的自动auto gc，它可以将松散的文件压缩。 下面是命令： 1git gc 搭配参数使用： 12345# 对git仓库进行彻底的清理和优化git gc --aggressive# 如果有7000个松散的对象或者50个以上的packfile，git才会进行gcgit gc --auto 还有另一个简单粗暴的方法：删除.git目录，重新 git init 仓库，然后重新 commit 1234rm -rf .gitgit initgit add .git commit -m 'info' 上面的方法都试过了发现 git gc --aggressive 比较靠谱。 暂存工作区变动到临时空间有一种场景是：我们已经add了一些文件到暂存区，而我们的工作区又修改了，这个时候测试提交了一个代码错误需要我们在原来的环境下fix，那么该怎么办呢？ 1git stash 这个时候工作区就被清空了，开始做bug fix。 完成修复后再pop就可以恢复之前的工作区： 12# apply会保留stash list，而pop不会保留git stash apply 查看stash： 1git stash list .gitignore文件编写便携 .gitignore 文件用于使得git仓库忽略某些文件。 在git仓库目录下touch一个 .gitignore 既可，然后编写规则。 .gitignore 文件生成：https://www.toptal.com/developers/gitignore tips内建的图形化 git： 1gitk 彩色的 git 输出： 1git config color.ui true 显示历史记录时，每个提交的信息只显示一行： 1git config format.pretty oneline 交互式添加文件到暂存区： 1git add -i rebaserebase用于将当前分支移动到目标分支的最后一次commit。 rebase黄金法则：不要在公共分支上面使用rebase，比如master。 使用merge还是rebase看团队而定。 revert在公共分支使用git revert以保留commit以便回溯，在特性分支使用git reset既可。 将fork的仓库与上游仓库保持一致 先clone已经fork的仓库到本地。 git remote -av查看分支。 添加上游仓库git remote add upstream git fetch upstream git rebase upstream/，这里如果是做contribution那就用merge。 pull（拉取并合并） = fetch（拉取） + merge（合并） 工作流https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md GUI工具 sourcetree：支持git和svn。 vscode jetbrains 扩展阅读 https://juejin.im/post/6844904191203213326","link":"/2019/08/02/git-all-in-one/"},{"title":"git学习笔记","text":"系统的学习了一下廖雪峰老师的git教程。 参考 廖雪峰git教程 简介git是世界上最先进的分布式版本控制系统。 git是linux之父linus大神花了两个星期用c写的。。。 安装1git --version #查看机器上是否有git以及版本号 windows: 直接下载gitbash：https://git-scm.com/downloads linux/macos 1234sudo apt-get install git #debian/ubuntu安装sudo apt-get install git-core #老版本debian/ubuntu安装yum install git #centos/RHEL安装brew install git #macos安装，需要先安装homebrew包管理工具 使用配置名称和邮件12git config --global user.name \"Your Name\"git config --global user.email \"email@example.com\" 创建版本库1234#linux和macos没问题，提醒一下windows不要使用cmd/powershell，使用gitbashmkdir gitDircd gitDirgit init #在gitDir目录下初始化git仓库 仓库中.git目录用来跟踪管理版本库，不要修改！ 1ls -lha #查看.git目录，-lha三个参数分别为列表显示、人性化显示、全部显示(显示以.开头的文件) 在非空目录下 git init 也可 把文件添加到版本库git仅可以跟踪文本文件的变动，对于二进制文件仅可以知道其改动了。 ps：二进制文件非常多，包括office三兄弟 文本文件使用utf-8编码 切勿使用新建记事本文件，记事本为utf-8 with BOM编码，若使用notepad++则改为utf-8 without BOM编码 命令 git仓库中新建一个readme.txt文件： 12Git is a version control system.Git is free software. git add 命令把文件添加到仓库 12345git add readme.txt#执行完无显示则表示成功git add .git add *git add -u # 自动追踪更新的文件 git commit 把文件提交到仓库 1git commit -m 'wrote a readme.txt file' # -m后面为本次commit的说明 为什么Git添加文件需要 add ， commit 一共两步呢？因为 commit 可以一次提交很多文件，所以你可以多次 add 不同的文件，比如： 123git add file1.txtgit add file2.txt file3.txtgit commit -m 'add 3 files' 即add一次可以add一个或者多个文件，而commit则一次性把add的文件提交 重命名文件名 1git mv file_old_name file_new_name 小结初始化一个Git仓库，使用 git init 命令。 添加文件到Git仓库，分两步： 使用命令 git add ，注意，可反复多次使用，添加多个文件； 使用命令 git commit -m ，完成。 回滚修改readme.txt文件为： 12Git is a distributed version control system.Git is free software. 运行 git status 可以看到仓库状态和哪些文件被修改了。 1git status 运行 git diff 查看修改了什么内容 1git diff readme.txt 再提交 12git add readme.txtgit commit -m 'readme.txt has been modified' 看状态 12git status# 提示没有需要提交的修改，工作目录干净 版本回退git log 查看历史记录 1git log # 从上到下是从近期到以前的commit 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 --pretty=oneline 参数： 1git log --pretty=online 或者 1git log --oneline 最近4次的记录 1git log -n4 --oneline 图形化显示 1git log --oneline --graph commit id是SHA1计算出来的16进制大数（为防止冲突） 版本回退： 当前版本为 HEAD ，上一个版本为 HEAD^ , 上100个版本为 HEAD~100回退上一个版本： 1git reset --hard HEAD^ 退回特定版本： 1git reset --hard commit-id #版本号可以只写前几位 版本回退仅仅是吧HEAD指针指向当前版本 git reflog 用来记录每一条git命令，可以用来找以前的commit id 1git reflog 小结： HEAD 指向当前版本 版本回退命令： git reset --hard commit-id git log 查看提交历史，以便决定回退到哪个版本 git reflog 查看历史命令，以便决定回退到哪个版本 工作区和暂存区123mkdir gitDircd gitDir #gitDir就是工作区ls -lha #可以看到.git目录，.git就是版本库 版本库中有一个叫stage的暂存区、master分支和HEAD指针 git add 就是把文件添加进暂存区 git add 是把暂存区文件提交到当前分支 若之后未对工作区做任何修改，则工作区clean 123git status#On branch master#nothing to commit, working tree clean 此时版本库变为： 总结： Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库) 工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库 git add 把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库， git diff 查看工作区和暂存区差异， git diff --cached 查看暂存区和仓库差异， git diff HEAD 查看工作区和仓库的差异， git add 的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区， git commit 的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。 修改管理git跟踪的是修改而不是文件。 第一次修改完一个文件后 git add ，再第二次修改这个文件，然后再 git commit ，只会提交第一次修改，故而git跟踪的是修改而不是文件。现在要提交第二次修改只需要： git add 这个文件，再 git commit 就行了，或者第一次修改完了不要急着 git add ，等着两次修改完了一起 git add git commit 。 撤销修改git checkout -- filename ：将文件咋工作区的修改完全撤销 作用是让这个文件回到最近一次 git commit 或者 git add 时候的状态： 一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git reset HEAD filename 可以把暂存区修改撤销 git reset 既可以回退版本也可以吧暂存区修改回退到工作区 小结情况一：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- file 。 情况二：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 git reset HEAD ，就回到了场景1，第二步按场景1操作。 情况三：已经提交了不合适的修改到版本库时，想要撤销本次提交，使用版本回退。 情况四：如果已经push到了远程仓库，完蛋。 简而言之： 没有 git add 时，用 git checkout -- file 回退到与版本库最新版一致 已经 git add 时，先 git reset HEAD 回退到1.，再按1. 操作 已经 git commit 时，用 git reset 回退版本 推送到远程库，GG 删除文件 先直接删除文件 使用 git rm 从版本库中删除该文件 git commit 提交更改 若误删文件，则用 git checkout -- filename 从版本库中恢复到工作区 远程仓库我一般使用github 本地git仓库和github仓库的传输通过ssh加密，故而本地要创建ssh key： 1ssh-keygen -t -C \"youremail@example.com\" 一路回车既可，无需设置密码 ~/.ssh/ 下面有有 id_rsa 和 id_rsa.pub 两个文件 登录github-setting-add ssh key，填写title，粘贴pub里的内容到上面，点击add key。 GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 github仓库为公开，不要提交敏感信息 可以搭建git服务器保护代码 搭建git服务器以ubuntu/debian为例： 1234567891011121314sudo apt-get install git # 服务器安装gitsudo adduser git # 创建一个用户git，用来运行git服务 sudo git init --bare sample.git # 创建证书登录，收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。sudo git init --bare sample.git # 初始化git仓库，选择一个目录用作git仓库，--bare创建了一个裸仓库，没有工作区sudo chown -R git:git sample.git # 将owner改为git# 禁用ssh登录：# 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash# 改为git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell# 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。git clone git@server:/srv/sample.git # 克隆远程仓库 管理公钥： 小团队管理：把团队中每个人的公钥收集起来放到服务器的 /home/git/.ssh/authorized_keys 文件里就可以。 大团队管理：使用gittosis。 git不支持权限管理！！！ 添加远程仓库 先在github上创建一个新的仓库 本地仓库 git remote add origin git@github.com:herotiga/Python-100-Days.git 第一次推送本地文件到远程仓库： git push -u origin master 以后只需要 git push origin master ssh警告第一次使用git clone or git push连接github会有警告 小结 关联远程仓库： git remote add origin git@github.com:herotiga/learngit.git 关联后，使用 git push -u origin master 第一次推送master分支 之后每次只需要 git push origin master 从远程仓库克隆1git clone git@github.com:herotiga/asd.git 注意：克隆下来的是一个目录 一般使用ssh，添加了ssh key之后无需输入密码。而https需要输入密码。 小结git clone 将项目克隆下来，一般使用ssh（除非公司内部只能使用https）。 分支管理创建分支1git checkout -b dev # 创建分支dev并切换到dev分支，-b表示创建完了切换上去 以上命令等同于： 12git branch devgit checkout dev 查看当前分支 1git branch 当前分支前面会有* 或者 1git status 合并分支1git merge dev # 将dev分支合并到当前分支上 删除分支1git branch -d dev 切换分支123git switch -c dev # 创建并切换到新的dev分支git switch master # 切换到已经有的分支，比如master分支 小结12345git branch # 查看分支git branch branchName # 创建分支git checkout branchName / git switch branchName #切换分支git merge branchName # 合并分支到当前分支git branch -d branchName # 删除分支 不完整，仍需补充","link":"/2018/01/30/git-notes/"},{"title":"gitbook使用方式","text":"gitbook可以用来管理知识。 搭建gitbook并托管到github pages 安装需要node.js 1cnpm install gitbook-cli -g 命令1234567891011# 初始化gitbookgitbook init# 预览gitbook serve# 生成静态页面gitbook build# 初始化安装插件gitbook install 目录结构12345678910.├── book.json├── README.md├── SUMMARY.md├── chapter-1/| ├── README.md| └── something.md└── chapter-2/ ├── README.md └── something.md book.json:配置文件数据 README.md:简介-书籍的简单介绍 SUMMARY.md:目录 以子目录的方式与项目集成 对于软件项目，可以使用子目录(如docs/)来存储项目的文档。您可以在book.json中通过配置选项告诉GitBook在那里找到根目录： 12345.├── book.json└── docs/ ├── README.md └── SUMMARY.md book.json配置如下： 123{ \"root\": \"./docs\"} 菜单与页面GitBook使用一个SUMMARY.md文件来定义文档的菜单。 SUMMARY.md中[]内的内容是标题，()内是文档的路径，章节和子章节用四个空格或者tab键来分级。 菜单示例： 123456789101112# 概述### 服务介绍* [服务介绍](README.md)### 服务接入流程* [服务开通](serviceOpen.md)* [应用配置](appConfig.md)### 企业实名认证服务端API* [API服务规范](apiStandard.md)* [营业执照OCR接口](apiOCR.md) 配置GitBook允许您使用灵活的配置自定义书籍和文档。这些选项在book.json文件中指定。 常用的配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041{ \"root\": \"./docs\", \"language\" : \"zh-hans\", \"styles\": { \"website\": \"./styles/website.css\" }, \"plugins\": [ \"hide-element\", \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"custom-favicon\", \"insert-logo\", \"tbfed-pagefooter\", \"-sharing\", \"sharing-plus\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [ \".gitbook-link\" ] }, \"insert-logo\": { \"url\": \"./images/logo.png\", \"style\": \"background: none; max-height: 60px; min-height: 50px\" }, \"favicon\": \"./images/favicon.ico\", \"sharing\": { \"twitter\": false, \"facebook\": false, \"google\": false }, \"tbfed-pagefooter\": { \"copyright\":\"北京科技XXX公司版权所有\", \"modify_label\":\"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } }} 也可以使用gitbook editor编辑markdown文件。 待阅读 简书GitBook 使用教程 简书gitbook入门 csdn GitBook 从懵逼到入门","link":"/2019/05/01/gitbook-usage/"},{"title":"解决github.io子域名dns污染","text":"上个月月末开始就发现本博客的herotiga.github.io域名无法访问了，于是我试着打开了各个大佬的github.io的博客果然都一样，当时就发觉这是一场有组织有纪律的dns污染行为。 解决方法从v2ex反应的情况来看，默认自动从ISP获取的dns都被污染了，所以手动更换一个公共dns服务器即可。 我选择了 114.114.114.114 。","link":"/2020/08/07/github-dns%E6%B1%A1%E6%9F%93/"},{"title":"哈希碰撞","text":"哈希函数（hash function）就是将不同的输入映射为独一无二的固定长度的哈希值。 哈希是对输入信息的一种summarize，故而存在输出相同的情况，这种情况就称之为哈希碰撞。 由于hash是压缩映射，故而必然会导致哈希碰撞。 那么如何降低哈希碰撞的概率呢？ 最简单粗暴的方法就是增加哈希值的取值范围，或者说增加哈希值的长度。但是更长的哈希值也意味着占用的存储空间和消耗的cpu时间也会随之增长。 我们在实际开发中要做的就是在消耗资源的量和安全性之间找到balance使得我们能在有很高安全性的同时尽可能使用较少的资源消耗。 生日攻击假设哈希值是均匀分布的，那么影响哈希碰撞的因素有以下两点： 哈希值取值范围 哈希值生命周期中的计算次数 在数学中有一个生日问题，就是说假设全班有n个同学，一年365天（简化模型），那么班上有同学生日为同一天的概率有多大。 答案很出人意料。如果至少两个同学生日相同的概率不超过5%，那么这个班只能有7个人。事实上，一个23人的班级有50%的概率，至少两个同学生日相同；50人班级有97%的概率，70人的班级则是99.9%的概率。 这意味着，如果哈希值的取值空间是365，只要计算23个哈希值，就有50%的可能产生碰撞。也就是说，哈希碰撞的可能性，远比想象的高。实际上，有一个近似的公式。 $$\\sqrt{\\frac{\\pi}{2} N}$$ 50%的哈希碰撞概率所需要的计算次数，N表示哈希的取值空间。生日问题的 N 就是365，算出来是 23.9。 这个公式告诉我们，哈希碰撞所需耗费的计算次数，跟取值空间的平方根是一个数量级。 这种利用哈希空间不足够大，而制造碰撞的攻击方法，就被称为生日攻击（birthday attack）。 哈希碰撞概率公式这里省略了计算过程。 $$p(n, d) \\approx 1-e^{\\frac{-n(n-1)}{2 d}}$$ 封装为函数1234const calculate = (d, n) =&gt; { const exponent = (-n * (n - 1)) / (2 * d) return 1 - Math.E ** exponent;} 参考 https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8 http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html","link":"/2020/07/20/hash-collision/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/01/30/hello-world/"},{"title":"hexo在控制台打印自定义信息","text":"在控制台输出一些信息。 修改布局文件我使用的是icarus主题。 修改/themes/icarus/layout/layout.ejs文件，在&lt;/body&gt;上面添加console.log()即可： 12345&lt;script type=\"text/javascript\"&gt; console.log('[]~(￣▽￣)~*没啥可看的'); console.log('[]~(￣▽￣)~*没啥可看的'); console.log('[]~(￣▽￣)~*没啥可看的');&lt;/script&gt; 图片转字符画https://www.jianshu.com/p/fca56d635091 其他参考 https://www.cnblogs.com/Wayou/p/chrome_dev_tool_style_console.html","link":"/2020/05/30/hexo-console-log/"},{"title":"icarus主题魔改","text":"https://www.imaegoo.com/2020/icarus-with-bulma/ https://www.imaegoo.com/2020/icarus-3-guide/ https://removeif.github.io/theme/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html https://www.v2ex.com/t/504000 https://blog.zhangruipeng.me/hexo-theme-icarus/tags/Icarus用户指南/ https://blog.zhangruipeng.me/hexo-theme-icarus/","link":"/2020/03/28/hexo-icarus-modify/"},{"title":"hexo插入图片","text":"总结一下hexo中插入图片的几种方法。 图床插入图片使用sm.ms或者新浪图床之类的图床，也可以是七牛云oss等。 插入语法： 1![pic_title](url) 优点是在任何联网的场景都可以查看，而且可以缓解服务器的带宽压力，明显提高网站性能。 缺点是图床毕竟不是自己的服务器，之前一直用的微博图床就出现了防盗链导致我的原博客所有图片失效，第二个缺点就是使用图床的话只能在联网的环境下才能查看到图片。 本地插入图片就是将图片防止在markdown文件所在的目录中。 优点是图片永远不会丢失。 缺点是图片会占用服务器存储空间、带宽。以及在hexo中本地插入图片有些不方便。 流行的方式： 首先在hexo根目录下打开_config文件，查找到post_asset_folder，修改为post_asset_folder: true。 该配置会使得hexo new 'post_title'的时候在_posts目录中自动生成一个与文章同名的文件夹用来存放资源。 安装hexo-asset-image插件 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 将文章图片拷贝至同名文件夹下，记住图片文件名，现在只需要插入到markdown中，直接![pic_title](pic_name.jpg)即可。如下： 1![pic_title](pic.jpg) 完成 网上流行这种方式，hexo的确可以正常显示图片。不过在markdown中就无法显示图片了，因为这种路径是相对于public目录中图片的目录的，在markdown编辑的时候路径错误故而无法正确显示图片。 我的方法：最后还是上传到了图床sm.ms。","link":"/2020/03/22/hexo-insert-picture/"},{"title":"hexo不渲染指定文件或目录","text":"给hexo添加gitbook以及自己写的前端代码的时候hexo都会自动渲染这些代码从而达不到我们需要的效果。 如果不需要hexo渲染自己的文件但又想要文件出现在hexo中，那么怎么办呢。 单个文件对于单个文件（md）的不渲染需求，只要在文件中添加如下配置： 123---layout: false--- 多个文件对于多个文件的不渲染需求，需要配置博客根目录下的_config.yml文件： 12345678910111213141516171819# 跳过单个文件skip_render: test.html# 跳过所有的html的文件skip_render: '*.html'# 跳过目录下的所有文件skip_render: test/*# 跳过某一目录下的所有文件和子目录的渲染skip_render: test/**# 跳过多个目录，或者多个文件的渲染skip_render: ['*.html', demos/**, test/*]skip_render: - test.html - '*.html' - test/** - test/* 上面的路径只能为相对路径。 编写html代码在hexo的post或者page中插入html代码需要用以下代码包裹 123{% raw %}&lt;!-- html code --&gt;{% endraw %} 测试 测试 * { margin: 0; padding: 0; border-radius: 0; } div.box { background: green; font-size: 2em; color: #fff; } 成功 测试外链文件点我测试 参考 https://github.com/hexojs/hexo/issues/1146","link":"/2020/06/18/hexo-skip-render/"},{"title":"hexo常用命令以及配置","text":"整理以下hexo常用的命令和配置 hexo初始化12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server hexo常用命令1234567891011121314151617181920212223242526272829# 新建文章hexo n &lt;title&gt;# 新建草稿hexo n draft &lt;title&gt;# 新建页面hexo n page &lt;title&gt;# 新建指定layouthexo n [layout] &lt;title&gt;# 将一个草稿发布，hexo会将其从_drafts目录中移动到_posts目录hexo publish &lt;draft_title&gt;# 清除静态文件hexo clean# 生成静态文件hexo g# 运行本地服务器hexo s# 部署代码到远程服务器hexo d# 清除静态文件、生成静态文件并部署hexo clean &amp;&amp; hexo d -g tips折叠文章在文章的summary和article之间插入如下代码 1&lt;!-- more --&gt; 开启RSS安装插件 1npm install hexo-generator-feed --save 配置hexo根目录下的_config.yml文件，添加 1rss: /atom.xml #rss地址 默认即可","link":"/2018/03/10/hexo-using/"},{"title":"hexo待解决问题","text":"Back-to-top,code-copy,code-line-number","link":"/2020/03/23/hexo%E5%BE%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"},{"title":"如何编写shell脚本（未完）","text":"学习shell脚本的目的是更好的管理github博客以及服务器。 为了给博客写一些自动化运维的脚本，比如定期创建hexo生成器的备份，定期生成和部署等等，shell脚本配合crontab，这样使用hexo博客的时候就只需要一篇一篇的书写博客就行了，生成部署备份的工作都可以交由crontab定期运行shell脚本来完成，定期创建新备份的同时还可以同时删除老备份，这样即使是失误破坏了hexo生成器也可以迅速找到之前的备份用于恢复。 shellshell使用c语言编写的程序。 shell既是命令语言又是编程语言。 shell是一层给linux内核与用户之间建立桥梁的中间层。用户通过shell访问linux内核功能。 windows中的explorer就是GUI的shell。 shell脚本shell脚本是为shell编写的脚本程序。我们通常说的shell是指shell脚本，但我们要知道shell和shell脚本是两个不同的概念。故而，我们所说的shell编程指的是shell脚本编写，而不是shell自身。 shell环境只需要一个文本编辑器和一个脚本解释器。 文本编辑器不用多说，脚本解释器就是bash zsh等等。 常见的有： Bourne Shell: /usr/bin/sh /bin/sh Bounrne Again Shell: bin/bash C Shell: /usr/bin/csh K Shell: /usr/bin/ksh Shell for Root: /sbin/sh 最常见的就是bash，也就是Bounrne Again Shell，bash也是绝大多数linux系统的默认shell解释器。 一般情况下，不区分Bourne Shell和Bounrne Again Shell，也就是#!/bin/sh可以改为#!/bin/bash。 编写shell脚本 新建file.sh文件，扩展名不影响脚本，.sh只是用来让用户知道这是个shell脚本而已。 12#!/bin/bashecho 'hello world!' 以上的#!后面带shell解释器路径，用于告诉shell这个脚本用什么解释器执行。 运行脚本 123456$ chmod +x file.sh# 给脚本添加执行权限，此时ls后发现.sh文件已经变色了，因为它已经获取了执行权限。$ ./file.sh$ /local/shellScript/file.sh# 输入脚本路径执行，绝对路径和相对路径均可 还有/bin/bash file.sh,/bin/sh file.sh这几种方法，意思是直接使用特定解释器解释脚本文件，无需在脚本文件里第一行添加#!声明。 shell变量定义变量变量命名规范： 变量名不能加美元符号。 变量名和等于号之间不能有空格。 命名只能用字母、数字、下划线，且不能以数字开头。 不能有空格。 不能使用bash里面的关键字。 正确变量命名： 12#!/bin/bashweb_site0=\"herotiga.github.io\" 还可以使用语句给变量赋值： 1234#!/bin/bashfor file in 'ls /etc'# orfor file in $(ls /etc) 使用变量在定义过的变量名之前加上$即可： 1234#!/bin/bashwebsite=\"herotiga.github.io\"echo $websiteecho ${website} 加不加花括号都行，花括号用于识别变量边界，最好加上花括号。 可以重复定义之前定义过的变量： 12345#!/bin/bashwebsite=\"herotiga.github.io\"echo $websitewebsite=\"baidu.com\"echo $website 只读变量： 使用readonly命令可以将变量设置为只读： 12345#!/bin/bashwebsite=\"herotiga.github.io\"readonly websitewebsite=\"baidu.com\" 以上先定义变量后设置为只读，再重新定义变量，现在运行看看： 1/bin/bash: NAME: This variable is read only. 删除变量使用unset命令删除变量： 12#!/bin/bashunset website unset命令不能删除只读变量。 变量类型 局部变量：定义在脚本或命令中，仅仅在当前shell实例中生效，其他shell无法访问局部变量。 环境变量：所有程序都能访问。 shell变量：是特殊变量，其中一部分是环境变量一部分是局部变量。这些变量保证了shell正常运行。 shell字符串字符串可以用单引号双引号或者不用引号。 12#!/bin/bashstr='this is a string' 单引号 单引号中的所有字符都会原样输出，故而不能有变量。 单引号包裹中间不能出现单独的一个单引号。 双引号 双引号中可以有变量。 双引号中可以出现转义字符。 故而尽量使用双引号 拼接字符123456my_name=\"mason\"greeting=\"hello, \"$my_name\" !\" # hello, mason !greeting=\"hello, {$my_name} !\" # hello, mason !greeting='hello, '$my_name' !' # hello, mason !greeting='hello, ${my_name} !' # hello, ${my_name} ! 获取字符串长度12str=\"my name is barry allen.\"echo ${#str} # 23 提取子串下标从0开始 12str=\"my name is barry allen.\"echo ${str:0:2} # my 查找子串查找字符i首次出现的位置： 12str=\"my name is barry allen.\"echo `expr index \"$string\" i` shell数组bash支持一维数组，数组长度不限。 参考 菜鸟教程","link":"/2019/04/13/how-to-write-shellscript/"},{"title":"hexo详细使用方式","text":"前提是已经安装了nodejs和git 安装并初始化安装hexo123456789101112# 本地全局安装hexo$ npm install hexo-cli -g# 初始化博客目录$ hexo init blog_dir# 进入初始化好的博客目录并安装依赖包$ cd blog_dir$ npm install# 本地启动server查看效果$ hexo server cnpm若npm速度慢，可以使用cnpm代替。 cnpm安装： 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 使用cnpm： 1$ cnpm install [package_name] 目录结构12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的配置信息 package.json安装了的应用 scaffolds模板文件夹（hexo new的时候，hexo根据scaffolds文件夹中的模板来建立文件） Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 配置在_config.yml文件中 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 keywords 网站的关键词。使用半角逗号 , 分隔多个关键词。 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。 url 网址 默认值 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 pretty_urls 改写 permalink 的值来美化 URL pretty_urls.trailing_index 是否在永久链接中保留尾部的 index.html，设置为 false 时去除 true pretty_urls.trailing_html 是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效) true 其他配置一般不需要改动 命令123456789# init$ hexo init [folder]# new post#若没有指定layout，则默认使用_config.yml中的default_layout参数代替$ hexo new [layout] &lt;title&gt;# 如果标题包含空格，则使用引号包裹$ hexo new \"new post\" 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 自定义文章路径： 1$ hexo new page -p about/me \"About me\" 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot; 1234# 生成静态文件$ hexo generate# or$ hexo n 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 简写为： 1$ hexo g 12# publish发表草稿$ hexo publish [layout] &lt;filename&gt; 很少使用 12# server$ hexo server 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 简写为： 1$ hexo s 12# deploy部署$ hexo deploy 参数 描述 -g, --generate 部署之前预先生成静态文件 简写为： 1$ hexo d 1# clean清除缓存文件db.json和已经生成的静态文件public 12# 列出网站资料$ hexo list &lt;type&gt; 12# 显示hexo版本$ hexo version 12# 安全模式$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 12# 调试模式$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 12# 显示草稿$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 迁移从wordpress迁移到hexo先安装hexo-migrator-wordpress插件 1$ npm install hexo-migrator-wordpress --save 在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考WP支持页面）。 插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。 1$ hexo migrate wordpress &lt;source&gt; 插件不完美，迁移完毕后手动审核文件。 开始写作12# 创建新文章或者新页面$ hexo new [layout] &lt;title&gt; layout默认为post 布局layoutpost路径：source/_posts page路径：source draft路径：source/_drafts 将Front-Matter中的layout: false，可以使得文章不被处理 draft草稿(一般用不到)draft布局被创建的时候在source/_drafts中 使用publish命令后，草稿将被移动到source/_posts 文件夹 1$ hexo publish [layout] &lt;title&gt; 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo \"my photo\" 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matterFront-matter格式： 1234---title: Hello Worlddate: 2012/4/5 12:32:54--- 参数： 参数 描述 默认值 layout 布局 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） categories/tags只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 12345categories:- csstags:- float- position 将一个文章加入一个多层级分类（前端 - css）： 12345---categories:- 前端- css--- 将一个文章加入多个分类（前端,css,布局）： 123456---categories:- [前端]- [css]- [布局]--- 将一个文章加入多个深层分类（前端 - css,前端 - 布局,技术）： 123456---categories:- [前端,css]- [前端,布局]- [技术]--- 组合自己所需的front-matter参数,形成post模版123456789101112131415161718---title: article_titledate: 2018-07-08 16:11:13updated:toc: truecategories: - [前端,html] - [前端,css]tags: - css - 前端thumbnail:permalink:comments:---summary paragraph.&lt;!-- more --&gt;main paragraph.(this paragraph cannot be seen) 写完front-matter后，写一段summary，紧接着加一行&lt;!-- more --&gt;用来隐藏正文。 标签插件标签插件是用于在文章中快速插入特定内容的插件。 引用块（在文章中插入引言，可以包含作者，来源，标题）：123{% blockquote [author[,source]] [link] [source_link_title] %}content{% endblockquote %} 示例1：纯粹引用内容，没有作者信息 123{% blockquote %}content{&amp; endblockquote &amp;} 示例2: 引用内容并给出作者和书名 123{% blockquote David Levithan,Wide Awake %}nothing but just example.{% endblockquote %} 示例3:引用twitter 123{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}content{% endblockquote %} 示例4: 引用网络内容 123{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}content{% endblockquote %} 代码块hexo提供的插入代码块的语法： 123{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %} Specify additional options in option:value format, e.g. line_number:false first_line:5. Extra Options Description Default line_number Show line number true highlight Enable code highlighting true first_line Specify the first line number 1 mark Line highlight specific line(s), each value separated by a comma. Specify number range using a dash Example: mark:1,4-7,10 will mark line 1, 4 to 7 and 10. wrap Wrap the code block in `` true 示例（codeblock仅能在hexo渲染器中看到效果，markdown没效果） codeblock代码段： [grid布局] [lang: css]1234567.container {​ display: grid;} 渲染结果，貌似hexo不能高亮代码 markdown代码段： 123.container { display: grid;} 可以高亮代码 示例：普通代码块 代码： 123{% codeblock %}alert('done!');{% endcodeblock %} 效果（仅可在hexo渲染器中查看效果）： 123alert('done!'); 示例：指定语言 代码： 123{% codeblock lang:objc %}[rectangle setX: 10 y: 10 width: 20 height: 20];{% endcodeblock %} 效果： 1[rectangle setX: 10 y: 10 width: 20 height: 20]; 示例：附加说明 代码： 123{% codeblock Array.map %}array.map(callback[, thisArg]){% endcodeblock %} 效果： Array.map123array.map(callback[, thisArg]) 反引号代码块代码： 1​```[language] [title] [url] [link text] this is code snippet 1234效果：```[language] [title] [url] [link text] this is code snippet markdown代码块代码： 123​```csscode snippet​ 1234567效果：```css.div { background-color: blue;} markdown小段代码代码； 1`code snippet` 效果： code snippet 插入pull quote代码： 123{% pullquote [class] %}content{% endpullquote %} 效果： content 插入jsFiddle代码： 1{% jsfiddle shorttag [tabs] [skin] [width] [height] %} 效果： 插入gist代码： 1{% gist gist_id [filename] %} 效果： 插入iframe代码： 1{% iframe url [width] [height] %} 效果： 插入图片代码： 1{% img [class names] /path [width] [height] '\"title text\" \"alt text\"' %} 效果： 插入链接代码： 1{% link text url [external] [title] %} 效果： 百度 插入include code插入 source/downloads/code 文件夹内的代码文件。source/downloads/code 不是固定的，取决于你在配置文件中 code_dir 的配置。 代码： 1{% include_code [title] [lang:language] [from:line] [to:line] path/file %} 示例： 嵌入 test.js 文件全文 1{% include_code lang:javascript test.js %} 只嵌入第 3 行 1{% include_code lang:javascript from:3 to:3 test.js %} 嵌入第 5 行至第 8 行 1{% include_code lang:javascript from:5 to:8 test.js %} 嵌入第 5 行至文件结束 1{% include_code lang:javascript from:5 test.js %} 嵌入第 1 行至第 8 行 1{% include_code lang:javascript to:8 test.js %} 插入youtube视频代码： 1{% youtube video_id %} 效果（需科学上网环境）： 插入vimeo视频代码： 1{% vimeo video_id %} 引用文章链接12{% post_path filename %}{% post_link filename [title] [escape] %} 详细使用方法查看hexo文档 引用资源123{% asset_path filename %}{% asset_img filename [title] %}{% asset_link filename [title] [escape] %} raw如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。 123{% raw %}content{% endraw %} 文章摘要代码： 1&lt;!-- more --&gt; 摘要可能会被 Front Matter 中的 excerpt 覆盖。 资源文件夹asset代表source文件夹中除了文章之外的所有文件：图片,css,js文件etc 简单引用图片的方法：如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 代码： 绝对路径： 1234![test image size](/images/1.jpg)![test image size](/images/1.jpg){:class=\"img-responsive\"}![test image size](/images/1.jpg){:height=\"50%\" width=\"50%\"}![test image size](/images/1.jpg){:height=\"100px\" width=\"400px\"} 效果：在编辑时没有效果，hexo中有效果 相对路径： 1![test image size](../images/1.jpg) 效果：在编辑时有效果，hexo中有效果 assets文件夹config.yml文件中的post_asset_folder选项设置为true，则每次new新文章会自动生成一个同名文件夹用来存储资源文件。再通过相对路径引用。 ###相对路径引用的标签插件 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。 hexo中引用方式： 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} 示例 代码： 1{% asset_img example.jpg this is an example image %} 效果： 数据文件(一般用不到)在主题中使用一些不在文章内部的资料，并且要复用这些资料，使用数据文件功能。 此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。 举例来说，在 source/_data 文件夹中新建 menu.yml 文件： 123Home: /Gallery: /gallery/Archives: /archives/ 您就能在模板中使用这些资料： 123&lt;% for (var link in site.data.menu) { %&gt; &lt;a href=&quot;&lt;%= site.data.menu[link] %&gt;&quot;&gt; &lt;%= link %&gt; &lt;/a&gt;&lt;% } %&gt; 渲染结果如下 : 123&lt;a href=\"/\"&gt; Home &lt;/a&gt;&lt;a href=\"/gallery/\"&gt; Gallery &lt;/a&gt;&lt;a href=\"/archives/\"&gt; Archives &lt;/a&gt; 服务器hexo将server独立成一个单独的模块 安装1$ npm install hexo-server --save 启动服务器运行期间会见空文件变动，自动更新 123$ hexo server# or$ hexo s 修改端口端口默认4000，若被占用，可以修改端口号 1$ hexo server -p 5000 静默模式服务器之处理public文件夹内文件，不处理文件变动。 此时需要hexo g更新文件变动。 静默模式通常用于生产环境下。 1$ hexo server -s 自定义ip服务器默认运行在0.0.0.0。 自定义ip： 1$ hexo server -i 192.168.1.1 pow(用不到)pow时macos上面的rack服务器，可以作为建议静态文件服务器使用。 安装1$ curl get.pow.cx | sh 设置在~/.pow文件夹建立链接(symlink) 12$ cd ~/.pow$ ln -s /path/to/myapp 网站就将在http://myapp.dev下运行。 生成器一次生成123$ hexo generate# or$ hexo g 持续监控监控文件SHA1 checksum变动并生成新静态文件 123$ hexo generate --watch# or$ hexo g -w 部署12345$ hexo generate --deploy$hexo g -d# or$ hexo deploy --generate$ hexo d -g 以上两条命令可以分别简写为： 123$ hexo g -d# or$ hexo d -g 我的简写方法： 1$ hexo g &amp;&amp; hexo d 模版 模板 用途 回退 index 首页 post 文章 index page 分页 index archive 归档 index category 分类归档 archive tag 标签归档 archive icarus主题参数banner大小：566px*242px 参考1.hexo中文文档 2.淘宝cnpm","link":"/2018/03/08/hexo%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"title":"常用meta总结","text":"summary 常用meta整理&lt;meta&gt;标签定义了文档的元数据，对于浏览器可读。 SEO相关12345678910111213141516&lt;!-- 页面关键字 --&gt;&lt;meta name=\"keywords\" content=\"html,css,js,node,java,python\" /&gt;&lt;!-- 页面描述，不超过150个字符 --&gt;&lt;meta name=\"description\" content=\"about computer science.\" /&gt;&lt;!-- 搜索引擎索引方式，常用值none，noindex，nofollow，all，index和follow --&gt;&lt;!-- all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。 --&gt;&lt;meta name=\"robots\" content=\"index,follow\"&gt;","link":"/2018/06/22/html-meta/"},{"title":"html5小技巧","text":"声明文档类型 1&lt;!DOCTYPE html&gt; 善用figure标签 123456&lt;figure&gt; &lt;img src=”” alt=\"\" /&gt; &lt;figcaption&gt; &lt;p&gt;img title&lt;/p&gt; &lt;/figcaption&gt;&lt;/figure&gt; 引入css和js无需写类型 如下： 12&lt;link rel=”stylesheet” href=”” /&gt;&lt;script src=””&gt;&lt;/script&gt; contenteditable属性 contenteditable属性允许用户编辑元素内容 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=”en”&gt;&lt;head&gt; &lt;meta charset=”utf-8″&gt; &lt;title&gt;untitled&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;ul contenteditable=”true”&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; placeholder 1&lt;input name=”email” type=”email” placeholder=”example@email.host” /&gt; local storage html5的local storage可以让浏览器记住输入的内容，就算后来浏览器关闭或者重新刷新也不受影响。 语义标签 有header和footer等等 123456&lt;header&gt; &lt;!-- header --&gt;&lt;/header&gt;&lt;footer&gt; &lt;!-- footer --&gt;&lt;/footer&gt; 群组标题标签 1234&lt;hgroup&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;h2&gt;h2&lt;/h2&gt;&lt;/hgroup&gt; 低版本IE兼容html5 123header, footer, article, section, nav, menu, hgroup { display: block;} 123456document.createElement(“article”);document.createElement(“footer”);document.createElement(“header”);document.createElement(“hgroup”);document.createElement(“nav”);document.createElement(“menu”); required属性 某个表单必须要输入，则使用required属性 1&lt;input type=”text” name=”someInput” required&gt; 例子： 12345&lt;form method=”post” action=\"\"&gt; &lt;label for=”someInput”&gt; Your Name: &lt;/label&gt; &lt;input type=”text” id=”someInput” name=”someInput” placeholder=”Douglas Quaid” required&gt; &lt;button type=”submit”&gt;Go&lt;/button&gt;&lt;/form&gt; autofocus属性 1&lt;input type=”text” name=”someInput” placeholder=”Douglas Quaid” required autofocus&gt; audio标签 12345&lt;audio autoplay=”autoplay” controls=”controls”&gt; &lt;source src=”file.ogg” /&gt; &lt;source src=”file.mp3″ /&gt; &lt;a href=”file.mp3″&gt;Download&lt;/a&gt;&lt;/audio&gt; video标签 12345&lt;video width=\"320\" height=\"240\" controls preload&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; 您的浏览器不支持 video 标签。&lt;/video&gt; 检测浏览器对属性的支持 原生js实现 1alert( ’pattern’ in document.createElement(‘input’) ) // boolean; jquery实现 12if (!’pattern’ in document.createElement(‘input’)) {} mark标签 用于高亮显示文本。 1&lt;p&gt;这是一段&lt;mark&gt;高亮&lt;/mark&gt;文本&lt;/p&gt;","link":"/2018/06/21/html-tips/"},{"title":"html学习笔记","text":"HTML(HyperText Markup Language)是超文本标记语言，是用来描述网页的一种标记语言。html文档也叫web页面，由浏览器解析。 简介实例解析这是一个标准的html实例： 1234567891011121314151617181920212223242526&lt;!-- 声明为html5文档 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- html是根元素 --&gt;&lt;html lang=\"en\"&gt;&lt;!-- head元素包含了文档的元数据 --&gt;&lt;head&gt; &lt;!-- 这个meta定义了文档编码格式 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- title定义了文档标题 --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;!-- body定义了页面的可见内容 --&gt;&lt;body&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;h3&gt;三级标题&lt;/h3&gt; &lt;p&gt;段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 将上面的代码保存为 .html 或者 .htm 文件即可在浏览器运行， .htm 扩展名和前者没有区别。 基本概念 标签 一个html标签的基本结构是这样的： &lt;tagName&gt;content&lt;/tagName&gt; 元素 html元素和标签是一个概念。 web浏览器 web浏览器是用于读取html/css/js等静态文件的，用于web页面展示。 文档结构这是一个基本的html页面结构： 文档声明12345678&lt;!-- html5 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- html4.01 --&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;!-- xhtml1.0 --&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; 文档编码统一使用utf-8既可： 12&lt;meta charset=\"UTF-8\"&gt;&lt;meta charset=\"utf-8\"&gt; 编辑器 vscode（免费） sublime text（收费，按年付费） vi/vim emacs 可以使用emmet插件提高编码速度。 基础标题html标题有h1到h6 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这是一个标题&lt;/h2&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt; 段落1&lt;p&gt;这是一个段落。&lt;/p&gt; 链接1&lt;a href=\"https://herotiga.github.io/\"&gt;我的博客&lt;/a&gt; 图像1&lt;img loading=\"lazy\" src=\"/images/logo.png\" width=\"640\" height=\"320\" /&gt; 元素html文档由html元素定义。 元素由起始标签和闭合标签组成，他们之间有内容。 有一些html元素内容为空。 空元素在开始标签中关闭： &lt;br /&gt; 。 大多数元素可以有属性。 嵌套html元素可以互相嵌套，html文档本身也是由互相嵌套的html标签组成。 空元素没有内容的元素称之为空元素，空元素在开始标签中进行关闭。在xhtml、xml和未来版本的html中，所有元素都必须要被关闭。建议关闭空标签。 关闭空元素的正确方法：比如 &lt;br /&gt; ，先敲一个空格再敲一个斜杠。 大小写标签html大小写不敏感，不过推荐全小写。在未来的xhtml和html中都强制使用小写。 属性html属性是元素的附加信息。 html元素可以设置属性。 属性可以给元素附加信息。 属性描述于开始标签。 属性和属性值以name=”value”的形式出现。 属性和属性值也要采用小写。 属性实例href 就是a标签的一个属性， https://herotiga.github.io/ 就是这个属性的值。 1&lt;a href=\"https://herotiga.github.io/\"&gt;我的博客&lt;/a&gt; 属性值要放在引号中，单引号双引号都可以，如果属性值含有引号则属性值要用另一个引号，比如： 1name=&quot;here's my blog&quot; 其他属性class，id，style，title这几个是几乎所有的标签都拥有的属性。 标题html标题从大到小依次是h1-h6，这个次序也是最重要到最不重要。标题元素是块元素，浏览器会自动在标题的前后加上空行。 标题元素只能用于标题，不能为了生成大号字体而使用，因为搜索引擎使用标题来索引网页内容。 水平线123&lt;p&gt;1&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;2&lt;/p&gt; 注释12345&lt;!-- 注释 --&gt;&lt;!-- 注释--&gt; 查看源码右击网页，点击查看源文件、源代码既可。 段落html将文档分为若干个段落。 p标签： 1&lt;p&gt;段落&lt;/p&gt; 换行1&lt;p&gt;第一行&lt;br&gt;第二行&lt;br&gt;第三行&lt;/p&gt; 空行和空格浏览器解析html代码的时候，会将连续的空格或者空行压缩为一个空格。 文本格式化12345678910111213141516171819202122232425262728293031&lt;b&gt;加粗&lt;/b&gt;&lt;strong&gt;突出显示&lt;/strong&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;em&gt;强调&lt;/em&gt;&lt;code&gt;电脑输出&lt;/code&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;big&gt;大字体&lt;/big&gt;&lt;small&gt;小字体&lt;/small&gt;&lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;code&gt;计算机输出&lt;/code&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt;&lt;tt&gt;打字机文本&lt;/tt&gt;&lt;samp&gt;计算机代码样本&lt;/samp&gt;&lt;var&gt;计算机变量&lt;/var&gt;&lt;address&gt; Written by &lt;a href=\"mailto:webmaster@example.com\"&gt;Mason&lt;/a&gt;.&lt;br&gt; Visit us at:&lt;br&gt; Example.com&lt;br&gt; Box 564, Disneyland&lt;br&gt; USA&lt;/address&gt;&lt;abbr title=\"全写\"&gt;缩写&lt;/abbr&gt;&lt;acronym title=\"World Wide Web\"&gt;WWW&lt;/acronym&gt;&lt;bdo dir=\"rtl\"&gt;文字从右到左显示。&lt;/bdo&gt;&lt;q&gt;短引用&lt;/q&gt;&lt;blockquote&gt;长引用&lt;/blockquote&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;ins&gt;插入文本&lt;/ins&gt;&lt;cite&gt;引用源&lt;/cite&gt;&lt;dfn&gt;定义一个定义项目&lt;/dfn&gt; 为了将语义和样式分离开，b和i现在不用了，使用strong代替b，使用em代替i。strong和em的样式交由css。 链接链接的作用是从一个页面跳转到另一个页面或者本页面的一个锚点。 代码： 1&lt;a href=\"https://baidu.com/\"&gt;百度&lt;/a&gt; target属性可以定义连接的打开方式： 1&lt;a href=\"https://baidu.com/\" target=\"_blank\"&gt;百度&lt;/a&gt; id属性可以在文档中创建锚点： 123456789&lt;!-- 创建锚点 --&gt;&lt;a id=\"tips\"&gt;锚点&lt;/a&gt;&lt;!-- 创建链接，指向锚点 --&gt;&lt;a href=\"#tips\"&gt;指向锚点的连接&lt;/a&gt;&lt;!-- 创建连接，指向另一个页面的一个锚点 --&gt;&lt;a href=\"https://www.runoob.com/html/html-links.html#tips\"&gt; 指向另一个页面的锚点&lt;/a&gt; tips:始终将 / 加入到url目录的后面： 123&lt;a href=\"https://herotiga.github.io/\"&gt;&lt;/a&gt;&lt;a href=\"https://herotiga.github.io/categories/\"&gt;&lt;/a&gt;&lt;a href=\"https://herotiga.github.io/tags/\"&gt;&lt;/a&gt; 如果不加斜杠就会向服务器产生两次http请求，加上斜杠则只会产生一次http请求。 图片连接： 123&lt;a href=\"#\"&gt; &lt;img src=\"example.jpg\"&gt;&lt;/a&gt; 创建邮件链接： 1234&lt;!-- example 1 --&gt;&lt;a href=\"mailto:someone@example.com?Subject=Hello%20again\" target=\"_top\"&gt;点击发送邮件&lt;/a&gt;&lt;!-- example 2 --&gt;&lt;a href=\"mailto:someone@example.com?cc=someoneelse@example.com&amp;bcc=andsomeoneelse@example.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!\" target=\"_top\"&gt;发送邮件!&lt;/a&gt; 头部头部head元素包含了一些元素，比如style，script，meta，title等等。除此之外还有link，noscript，base元素。 title title元素定义了文档的标题，它会出现在浏览器的标签上。 title元素在html/xhtml文档中是必须的。 title还可以在左边显示logo等等。 1234&lt;head&gt; &lt;link rel=\"shortcut icon\" href=\"url\"&gt; &lt;title&gt;这是一个带图片的标签&lt;/title&gt;&lt;/head&gt; basebase元素定义了基地址，它会作为文档中所有链接的默认链接地址。 1&lt;base href=\"https://herotiga.github.io/\" target=\"_blank\"&gt; linklink元素定义了文档和外部资源的关系。常用于css引入： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt; style定义了文档的样式 123456789&lt;style type=\"text/css\"&gt; body { background-color: yellow; } p { color: blue; }&lt;/style&gt; metameta定义了一些基本的元数据，通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。 meta放置在head中。 1234567891011&lt;!-- 定义关键词 --&gt;&lt;meta name=\"keywords\" content=\"HTML, CSS, XML, XHTML, JavaScript\"&gt;&lt;!-- 定义描述 --&gt;&lt;meta name=\"description\" content=\"免费 Web &amp; 编程 教程\"&gt;&lt;!-- 定义作者 --&gt;&lt;meta name=\"author\" content=\"Runoob\"&gt;&lt;!-- 定时刷新 --&gt;&lt;meta http-equiv=\"refresh\" content=\"30\"&gt; scriptscript标签用于加载js脚本。 样式css（层叠样式表）用于渲染html的样式。 如何使用css 内联样式：在标签中使用style属性。 内部样式表：在head中用style标签包含css代码。 外部引用：在head中使用link引入外部样式表。 tips：最好使用外部引入css。 内联样式实例1： 1&lt;p style=\"color: red;padding: 2px 4px;\"&gt;红色字体，带有内边距&lt;/p&gt; 实例2: 123456&lt;!-- 早期html使用bgcolor来定义背景颜色 --&gt;&lt;body style=\"background-color:yellow;\"&gt; &lt;h2 style=\"background-color:red;\"&gt;这是一个标题&lt;/h2&gt; &lt;p style=\"background-color:green;\"&gt;这是一个段落。&lt;/p&gt;&lt;/body&gt; 内部样式表1234567891011&lt;head&gt; &lt;style type=\"text/css\"&gt; body { background-color: yellow; } p { color: blue; } &lt;/style&gt;&lt;/head&gt; 外部样式表123&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt;&lt;/head&gt; 已经弃用的标签和属性不建议使用的标签： font center strike 不建议使用的属性： bgcolor 图像基本用法图像由img标签定义，url由src定义。 map标签用于定义图像地图 area标签用于定义图像地图中的可点击区域 1&lt;img src=\"\" alt=\"替换文本\"&gt; 指定图像的高和宽是哥好习惯，页面会在加载的时候预留指定尺寸的空间。 1&lt;img src=\"\" alt=\"替换文本\" width=\"480\" height=\"360\"&gt; 提示加载图片需要时间，谨慎使用图片。 表格表格组成表格由table标签定义，tr（表格行）定义表格的一个行，每一行分为若干个单元格，单元格有th（表格表头单元）和td（表格数据单元）组成，单元格里面可以有文本、图片、列表、段落、表单、水平线、表格等等。 实例： 12345678910&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格边框给表格一个边框： 123456&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;Row 1, cell 1&lt;/td&gt; &lt;td&gt;Row 1, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格表头使用th标签定义表头。 1234567891011121314&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 实例 没有边框的表格 123456789101112131415161718192021222324252627&lt;h4&gt;这个表格没有边框:&lt;/h4&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;600&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;这个表格没有边框:&lt;/h4&gt;&lt;table border=\"0\"&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;600&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 带标题（caption）的表格 123456789101112131415&lt;table border=\"1\"&gt; &lt;caption&gt;Monthly savings&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;$50&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 跨行、列的表格 123456789101112131415161718192021222324252627&lt;h4&gt;单元格跨两列:&lt;/h4&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th colspan=\"2\"&gt;Telephone&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;td&gt;555 77 855&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;单元格跨两行:&lt;/h4&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;First Name:&lt;/th&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th rowspan=\"2\"&gt;Telephone:&lt;/th&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;555 77 855&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 单元格边距 1234567891011&lt;h4&gt;有单元格边距:&lt;/h4&gt;&lt;table border=\"1\" cellpadding=\"10\"&gt; &lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Second&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 单元格间距 1234567891011&lt;h4&gt;单元格间距=\"10\":&lt;/h4&gt;&lt;table border=\"1\" cellspacing=\"10\"&gt; &lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Second&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 一个漂亮的表格 https://c.runoob.com/codedemo/3187 标签 Tag Description table 定义表格 th 定义表头单元 td 定义表格数据单元 tr 定义表格行 caption 定义表格标题 colgroup 定义表格列的组 col 定义用于表格列的属性 thead 定义表格的主体 tbody 定义表格的主体 tfoot 定义表格的页脚 列表列表有有序列表（ol）、无序列表（ul）以及自定义列表（dl）。 无序列表ul定义无序列表，列表项会以黑圆点显示。 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表ol定义有序列表，列表项前面会有有序的符号标识。 12345&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 自定义列表自定义列表dl也是列表，不过还是项目和注释的组合。 dl以dt开始，后面是dd。 123456&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 实例 不同类型的有序列表 123456789101112131415161718192021222324252627282930313233343536373839&lt;h4&gt;编号列表：&lt;/h4&gt;&lt;ol&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;大写字母列表：&lt;/h4&gt;&lt;ol type=\"A\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;小写字母列表：&lt;/h4&gt;&lt;ol type=\"a\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;罗马数字列表：&lt;/h4&gt;&lt;ol type=\"I\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;小写罗马数字列表：&lt;/h4&gt;&lt;ol type=\"i\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt; 不同类型的无序列表 12345678910111213141516171819202122232425&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt; 在 HTML 4中 ul 属性已废弃，HTML5 已不支持该属性，因此我们使用 CSS 代替来定义不同类型的无序列表如下：&lt;/p&gt;&lt;h4&gt;圆点列表：&lt;/h4&gt;&lt;ul style=\"list-style-type:disc\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;圆圈列表：&lt;/h4&gt;&lt;ul style=\"list-style-type:circle\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;正方形列表：&lt;/h4&gt;&lt;ul style=\"list-style-type:square\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ul&gt; 嵌套列表 1234567891011&lt;h4&gt;嵌套列表：&lt;/h4&gt;&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea &lt;ul&gt; &lt;li&gt;Black tea&lt;/li&gt; &lt;li&gt;Green tea&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 复杂嵌套列表 12345678910111213141516&lt;h4&gt;嵌套列表：&lt;/h4&gt;&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea &lt;ul&gt; &lt;li&gt;Black tea&lt;/li&gt; &lt;li&gt;Green tea &lt;ul&gt; &lt;li&gt;China&lt;/li&gt; &lt;li&gt;Africa&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 自定义列表 1234567&lt;h4&gt;一个自定义列表：&lt;/h4&gt;&lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt; 区块html可以使用div和span将元素包裹起来。 块元素html元素大致分为块元素和内联元素。 块元素独占一行。 内联元素内联元素不会以新的一行开始。 常见的有：b, td, a, img divdiv是无语义的块容器。 spanspan是无语义的内联容器，用于组合行内元素。 布局布局对网站的外观非常重要。 大多数网站可以使用div和table创建多列布局，用css对元素定位和增添其他样式。不建议使用table布局。 div布局div是用于分组html元素的无语义块容器。 实例：使用5个div创建多列布局 12345678910111213141516&lt;body&gt; &lt;div id=\"container\" style=\"width:500px\"&gt; &lt;div id=\"header\" style=\"background-color:#FFA500;\"&gt; &lt;h1 style=\"margin-bottom:0;\"&gt;主要的网页标题&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"menu\" style=\"background-color:#FFD700;height:200px;width:100px;float:left;\"&gt; &lt;b&gt;菜单&lt;/b&gt;&lt;br&gt; HTML&lt;br&gt; CSS&lt;br&gt; JavaScript&lt;/div&gt; &lt;div id=\"content\" style=\"background-color:#EEEEEE;height:200px;width:400px;float:left;\"&gt; 内容在这里&lt;/div&gt; &lt;div id=\"footer\" style=\"background-color:#FFA500;clear:both;text-align:center;\"&gt; 版权 © runoob.com&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果： table布局table的用途是将数据表格化呈现，table并不是布局工具！ 下面的例子使用三行两列的表格 - 第一和最后一行使用 colspan 属性来横跨两列： 1234567891011121314151617181920212223242526&lt;body&gt; &lt;table width=\"500\" border=\"0\"&gt; &lt;tr&gt; &lt;td colspan=\"2\" style=\"background-color:#FFA500;\"&gt; &lt;h1&gt;主要的网页标题&lt;/h1&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"background-color:#FFD700;width:100px;\"&gt; &lt;b&gt;菜单&lt;/b&gt;&lt;br&gt; HTML&lt;br&gt; CSS&lt;br&gt; JavaScript &lt;/td&gt; &lt;td style=\"background-color:#eeeeee;height:200px;width:400px;\"&gt; 内容在这里&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" style=\"background-color:#FFA500;text-align:center;\"&gt; 版权 © runoob.com&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 效果： 提示 使用外部样式表的好处是，css都在单独的文件中，利于维护。 使用模板可以快速创建布局，通过百度搜索。 消除默认样式： 1234body { padding: 0; margin: 0;} 表单和输入表单用于手机不同类型的用户输入。 表单表单（form）是一个包含表单元素的元素。 表单元素允许用户输入各种内容：文本域textarea，下拉列表select，单选框radio，复选框checkbox。 实例： 123&lt;form&gt; &lt;!-- 表单元素 --&gt;&lt;/form&gt; 输入元素多数情况下输入标签是input，由type属性定义输入类型。 type有以下几类： text 1234&lt;form&gt; First name: &lt;input type=\"text\" name=\"firstname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lastname\"&gt;&lt;/form&gt; password 123&lt;form&gt; Password: &lt;input type=\"password\" name=\"pwd\"&gt;&lt;/form&gt; password会以圆点显示。 radio 单选按钮，name需要一致。 1234&lt;form&gt; &lt;input type=\"radio\" name=\"sex\" value=\"male\" checked=\"checked\"&gt;Male&lt;br&gt; &lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt;Female&lt;/form&gt; 复选框 name需要一致。 1234&lt;form&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\" checked=\"checked\"&gt;I have a bike&lt;br&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\"&gt;I have a car&lt;/form&gt; submit 1234&lt;form name=\"input\" action=\"html_form_action.php\" method=\"get\"&gt; Username: &lt;input type=\"text\" name=\"user\"&gt; &lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt; 点击submit，表单的内容会被提交到action的url。 其他实例 简单下拉列表 12345678&lt;form action=\"\"&gt; &lt;select name=\"cars\"&gt; &lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value=\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"fiat\"&gt;Fiat&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 预选下拉列表 12345678&lt;form action=\"\"&gt; &lt;select name=\"cars\"&gt; &lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value=\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"fiat\" selected&gt;Fiat&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 文本域 123&lt;textarea rows=\"10\" cols=\"30\"&gt;我是一个文本框。&lt;/textarea&gt; 按钮 123&lt;form action=\"\"&gt; &lt;input type=\"button\" value=\"Hello world!\"&gt;&lt;/form&gt; 重置 1&lt;input type=\"reset\" name=\"button\" id=\"button\" value=\"重置\"&gt; 表单实例 带边框的表单 12345678&lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;Personal information:&lt;/legend&gt; Name: &lt;input type=\"text\" size=\"30\"&gt;&lt;br&gt; E-mail: &lt;input type=\"text\" size=\"30\"&gt;&lt;br&gt; Date of birth: &lt;input type=\"text\" size=\"10\"&gt; &lt;/fieldset&gt;&lt;/form&gt; 带输入框和确认按钮的表单 12345&lt;form action=\"demo-form.php\"&gt; First name: &lt;input type=\"text\" name=\"FirstName\" value=\"Mickey\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"LastName\" value=\"Mouse\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 带电子邮件的表单 12345678910&lt;form action=\"MAILTO:someone@example.com\" method=\"post\" enctype=\"text/plain\"&gt; Name:&lt;br&gt; &lt;input type=\"text\" name=\"name\" value=\"your name\"&gt;&lt;br&gt; E-mail:&lt;br&gt; &lt;input type=\"text\" name=\"mail\" value=\"your email\"&gt;&lt;br&gt; Comment:&lt;br&gt; &lt;input type=\"text\" name=\"comment\" value=\"your comment\" size=\"50\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"发送\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt;&lt;/form&gt; 其他表单元素label：定义了input的标签，并使用外框包含起来。fieldset：定义了一组相关的表单元素并使用边框包含起来。legend：定义了fieldset的标题。button：定义了按钮。datalist：指定一个预先定义的输入控件选项列表。output：定义了一个计算结果。 框架使用框架可以在页面中显示另一个页面。 1&lt;iframe src=\"demo_iframe.htm\" width=\"200\" height=\"200\"&gt;&lt;/iframe&gt; width和height默认使用px作为单位，还可以使用百分比。 移除边框： 1&lt;iframe src=\"demo_iframe.htm\" frameborder=\"0\"&gt;&lt;/iframe&gt; 使用iframe显示目标连接页面12&lt;iframe src=\"demo_iframe.htm\" name=\"iframe_a\"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href=\"http://www.runoob.com\" target=\"iframe_a\"&gt;RUNOOB.COM&lt;/a&gt;&lt;/p&gt; 颜色html使用的颜色由RGB构成。 颜色值几种写法： #ff0000，可以简写为#f00 rgb(255, 0, 0) rgba(255, 0, 0, .5)，最后一个参数为透明度 颜色名： 一般不用颜色名。 脚本script标签script标签用于定义脚本。script标签可以直接在中间写代码也可以链接外部脚本文件。JavaScript 最常用于图片操作、表单验证以及内容动态更新。 实例： 123&lt;script&gt; document.write(\"Hello World!\");&lt;/script&gt; noscript标签noscript标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。noscript元素可包含普通HTML页面的body元素中能够找到的所有元素。 只有在浏览器不支持脚本或者禁用脚本时，才会显示noscript元素中的内容： 1234&lt;script&gt; document.write(\"Hello World!\")&lt;/script&gt;&lt;noscript&gt;抱歉，你的浏览器不支持 JavaScript!&lt;/noscript&gt; 字符实体html中的预留字符必须被替换为字符实体。一些在键盘上找不到的字符也可以使用字符实体来替换。 urlurl（统一资源定位符）是一个网页地址。 浏览器通过url从浏览器请求资源。 url规则： 12scheme://host.domain:port/path/filename协议://主机.域名:端口/路径/文件名 常见的协议： http：超文本传输协议，不加密。 https：安全超文本传输协议，加密。 ftp：文件传输协议，上传或下载文件。 file：本机文件。 url编码 url只能采用ascii字符集。 url经常含有ascii之外的字符，所以url必须转化为有效的ascii格式。 url编码使用“%”加后面的两个16进制数字来替换非ascii字符。 url不能包含空格，通常使用“+”替换空格。 速查列表基本文档123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 可见文本...&lt;/body&gt;&lt;/html&gt; 基本标签1234567891011&lt;h1&gt;最大的标题&lt;/h1&gt;&lt;h2&gt; . . . &lt;/h2&gt;&lt;h3&gt; . . . &lt;/h3&gt;&lt;h4&gt; . . . &lt;/h4&gt;&lt;h5&gt; . . . &lt;/h5&gt;&lt;h6&gt;最小的标题&lt;/h6&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化1234567891011121314151617&lt;b&gt;粗体文本&lt;/b&gt;&lt;code&gt;计算机代码&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt;&lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt;&lt;abbr&gt; （缩写） &lt;address&gt; （联系信息） &lt;bdo&gt; （文字方向） &lt;blockquote&gt; （从另一个源引用的部分） &lt;cite&gt; （工作的名称） &lt;del&gt; （删除的文本） &lt;ins&gt; （插入的文本） &lt;sub&gt; （下标文本） &lt;sup&gt; （上标文本） 链接123456普通的链接：&lt;a href=\"http://www.example.com/\"&gt;链接文本&lt;/a&gt;图像链接： &lt;a href=\"http://www.example.com/\"&gt;&lt;img src=\"URL\" alt=\"替换文本\"&gt;&lt;/a&gt;邮件链接： &lt;a href=\"mailto:webmaster@example.com\"&gt;发送e-mail&lt;/a&gt;书签：&lt;a id=\"tips\"&gt;提示部分&lt;/a&gt;&lt;a href=\"#tips\"&gt;跳到提示部分&lt;/a&gt; 图片1&lt;img loading=\"lazy\" src=\"URL\" alt=\"替换文本\" height=\"42\" width=\"42\"&gt; 内部样式1234567891011&lt;style type=\"text/css\"&gt; h1 { color: red; } p { color: blue; }&lt;/style&gt;&lt;div&gt;文档中的块级元素&lt;/div&gt;&lt;span&gt;文档中的内联元素&lt;/span&gt; 无序列表1234&lt;ul&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; 定义列表123456&lt;dl&gt; &lt;dt&gt;项目 1&lt;/dt&gt; &lt;dd&gt;描述项目 1&lt;/dd&gt; &lt;dt&gt;项目 2&lt;/dt&gt; &lt;dd&gt;描述项目 2&lt;/dd&gt;&lt;/dl&gt; 表格12345678910&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 框架1&lt;iframe src=\"demo_iframe.htm\"&gt;&lt;/iframe&gt; 表单123456789101112131415&lt;form action=\"demo_form.php\" method=\"post/get\"&gt; &lt;input type=\"text\" name=\"email\" size=\"40\" maxlength=\"50\"&gt; &lt;input type=\"password\"&gt; &lt;input type=\"checkbox\" checked=\"checked\"&gt; &lt;input type=\"radio\" checked=\"checked\"&gt; &lt;input type=\"submit\" value=\"Send\"&gt; &lt;input type=\"reset\"&gt; &lt;input type=\"hidden\"&gt; &lt;select&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option selected=\"selected\"&gt;香蕉&lt;/option&gt; &lt;option&gt;樱桃&lt;/option&gt; &lt;/select&gt; &lt;textarea name=\"comment\" rows=\"60\" cols=\"20\"&gt;&lt;/textarea&gt;&lt;/form&gt; 实体123&lt; 等同于 &lt;&gt; 等同于 &gt;&amp;#169; 等同于 © 标签速查https://www.runoob.com/html/html-tag-name.html","link":"/2018/02/07/html-tutorial/"},{"title":"html5语义标签用法","text":"html5语义标签就是拥有语义的标签。 语义标签能清楚的向浏览器和开发者描述标签内容。 语义标签 1234567891011121314151617&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;main&gt; &lt;summary&gt;&lt;/summary&gt; &lt;article&gt; &lt;section&gt; &lt;mark&gt;&lt;/mark&gt; &lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;/article&gt; &lt;aside&gt; &lt;details&gt;&lt;/details&gt; &lt;/aside&gt;&lt;/main&gt;&lt;footer&gt;&lt;/footer&gt; 常用布局","link":"/2019/05/18/html5-semantic-tags/"},{"title":"http状态码","text":"XMLHttpRequest.status属性返回一个整数表示服务器响应的http状态码。 XMLHttpRequest.statusText属性返回一个字符串，包含整个状态信息。 状态码 状态信息 意义 200 OK 访问正常 301 Moved Permanently 永久移动 302 Moved temporarily 暂时移动 304 Not Modified 未修改 307 Temporary Redirect 暂时重定向 401 Unauthorized 未授权 403 Forbidden 禁止访问 404 Not Found 未发现指定网址 500 Internal Server Error 服务器发生错误 也就是说：只有2XX和304表示服务器返回是正常状态。 判断服务器返回是否正常： 12345678if (xhr.readyState === 4) { if ( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || (xhr.status === 304) ) { // 处理服务器的返回数据 } else { // 出错 }}","link":"/2018/09/16/http-status-code/"},{"title":"html5学习笔记","text":"html5是html的最新版本，2014年由W3C指定。 html5指定的目的是在移动设备上提供多媒体支持。 html5html5简介html5是下一代html标准。html4.01诞生于1999年。 html5新特性： canvas video，audio 更好的支持本地离线存储。 新的语义容器：article，footer，header，nav，section等等。 新的表单控件：calendar，date，time，email，url，search等等。 html5的声明必须使用： 1&lt;!DOCTYPE html&gt; html5文档实例： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; html5的改进 新元素 新属性 完全支持css3 video，audio 2D、3D制图 本地存储 本地sql数据 web应用 html5多媒体video和audio元素。 html5应用 本地数据存储 访问本地文件 本地sql数据 缓存引用 js worker XHTMLHttpRequest2 html5图形 canvas 内联svg css3 2D转换，3D转换 html5使用css3 新选择器 新属性 动画 2D、3D转换 圆角 阴影 可下载字体 语义元素html5添加了很多语义元素： html5表单新表单元素，新属性，新输入类型，自动验证。 已删除的元素以下的4.01中的元素在html5已经被删除。 acronym applet basefont big center dir font frame frameset noframes strike html5浏览器支持IE9以下的版本兼容html5的方法，使用html5shiv包： 123&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 载入后，初始化新标签的css： 1234567891011article,aside,dialog,footer,header,section,nav,figure,menu { display: block;} html5浏览器支持可以让一些老旧的浏览器支持html5。 现代浏览器都支持html5.浏览器对于无法识别的元素都会作为内联元素处理。 将html5元素定义为块元素html5定义了8个语义元素，这些元素都是块级元素。 为了让旧的浏览器正确显示，可以设置css： 12345678910header,section,footer,aside,nav,main,article,figure { display: block;} 自定义新元素1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;为 HTML 添加新元素&lt;/title&gt; &lt;script&gt; document.createElement(\"myHero\") &lt;/script&gt; &lt;style&gt; myHero { display: block; background-color: #ddd; padding: 50px; font-size: 30px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;myHero&gt;我的第一个新元素&lt;/myHero&gt;&lt;/body&gt;&lt;/html&gt; IE浏览器问题以上的方法可以为IE浏览器添加html5元素，但是不支持IE8及更早的版本。 我们可以使用 Sjoerd Visscher 创建的 “HTML5 Enabling JavaScript”, “ shiv” 来解决该问题: 123&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://html5shiv.googlecode.com/svn/trunk/html5.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 上面的作用是对于IE9以下的版本读取html5.js文件并解析。 123&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 针对IE浏览器html5shiv 是比较好的解决方案。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。 完美的shiv解决方案12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;渲染 HTML5&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一篇文章&lt;/h1&gt; &lt;article&gt; 菜鸟教程 —— 学的不仅是技术，更是梦想！！！ &lt;/article&gt;&lt;/body&gt;&lt;/html&gt; html5新元素和移除的元素html5新元素新的多媒体元素： canvas：定义图形，基于js的绘图API。 video：定义视频。 audio：定义音频。 source：定义video和audio的文件源。 embed：定义嵌入的内容，比如插件。 track：为video和audio之类的元素的媒介规定外部文本轨道。 新的表单元素： datalist：定义选项列表，与input配合使用。 keygen：规定用于表单的秘钥的生成器字段。 output：定义不同类型的输出，比如脚本的输出。 新的语义容器和结构元素： article：定义页面独立的内容区域。 aside：定义页面的侧边栏内容。 bdi：设置文本方向。 command：定义命令按钮，比如单选按钮、复选框、按钮。 details：用于描述文档的细节。 dialog：对话框。 summary：包含details元素的标题。 figure：图像、图标、照片、代码。 fugcaption：定义figure元素的标题。 footer：定义全局或局部的页脚。 header：定义文档头部。 mark：定义标记文本。 meter：定义度量。 nav：定义导航链接部分。 progress：定义任务进度。 ruby：定义ruby注释（中文注音或字符）。 rt：定义字符的解释或者发音。 rp：在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 section：定义文档中的节。 time：定义日期或者时间。 wbr：在文本合适的地方添加换行符。 html5已经移除的元素 acronym applet basefont big center dir font frame frameset noframes strike tt canvascanvas标签定义图形，canvas标签只是图形容器，图形需要靠js脚本绘制。 可以使用js在canvas中绘制路径、盒、圆、字符、图像。 创建画布canvas画布是一个矩形框，默认没有边框和内容。需要制定一个id，width和height。一个页面可以有多个canvas。 1&lt;canvas id=\"mycanvas\" width=\"200\" height=\"100\" style=\"border: 1px red solid;\"&gt;&lt;/canvas&gt; 使用js开始绘图12345678// 首先获得画布var c = document.getElementById(\"mycanvas\");// 获得画布的context对象var ctx = c.getContext(\"2d\");// 填充样式，可以有颜色、渐变、图案ctx.fillStyle = \"#f00\";// 填充一个矩形，x,y,width,heightctx.fillRect(0, 0, 150, 75); canvas坐标canvas是一个二维网络，左上角为(0, 0)。 canvas路径使用以下方法画线： moveTo(x, y)定义线条开始坐标 lineTo(x, y)定义线条结束坐标 stroke()绘制线条 实例：绘制直线 12345var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.moveTo(0, 0);ctx.lineTo(200, 100);ctx.stroke(); 实例：绘制圆形 12345var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.beginPath();ctx.arc(95, 50, 40, 0, 2 * Math.PI);ctx.stroke(); canvas绘制文本使用canvas绘制文本的属性和方法如下： font，定义字体 fillText(text, x, y)，绘制实心文本 strokeText(text, x, y)，在canvas上绘制空心文本 实例：绘制实心文本 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.font = \"30px Arial\";ctx.fillText(\"Hello World\", 10, 50); 实例：绘制空心文本 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.font = \"30px Arial\";ctx.strokeText(\"Hello World\", 10, 50); canvas渐变渐变可以用于填充矩形、圆形、线条、文本等等。 canvas渐变的方法： createLinearGradient(x, y, x1, y1)，创建线性渐变。 createRadialGradient(x, y, r, x1, y1, r1)，创建径向渐变。 使用渐变必须使用两种及以上的颜色。。addColorStop()方法指定颜色停止，参数用坐标描述，0-1。再设置fillStyle()或者strokeStyle()的值为渐变，然后绘制形状。 实例：createLinearGradient() 1234567891011var c = document.getElementById(\"mycanvas\");var ctx = c.getContext(\"2d\");// 创建渐变var grd = ctx.createLinearGradient(0, 0, 200, 0);grd.addColorStop(0, \"red\");grd.addColorStop(1, \"white\");// 填充ctx.fillStyle = grd;ctx.fillRect(10, 10, 150, 80); 实例：createRadialGradient() 1234567891011var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");// 创建渐变var grd = ctx.createRadialGradient(75, 50, 5, 90, 60, 100);grd.addColorStop(0, \"red\");grd.addColorStop(1, \"white\");// 填充渐变ctx.fillStyle = grd;ctx.fillRect(10, 10, 150, 80); canvas绘制图片把一张图片放到canvas中，使用drawImage(image, x, y) 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");var img = document.getElementById(\"scream\");ctx.drawImage(img, 10, 10); 内联svghtml5支持内联svg。 svg是可伸缩矢量图形。svg的特点是： svg用于网络 svg使用XML格式定义图形 svg放大缩小图形质量都不会损失 svg是万维网联盟的标准 svg的优势： svg可以通过编辑器创建和修改 svg可以被搜索、索引、脚本化、压缩 svg可伸缩 svg可以在任何分辨率下打印 svg可以再质量不损失的情况下放大 将svg嵌入html页面123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" height=\"190\"&gt; &lt;polygon points=\"100,10 40,180 190,60 10,60 160,180\" style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\"&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; svg和canvas的区别svg是使用xml描述2d图形的语言，svg基于xml故而可以使用js处理svg事件，适合有大型渲染区域的应用（地图），不适合游戏。canvas是一个画布，通过使用js绘制2d图形，是逐像素渲染的，不支持事件处理，文本渲染能力弱，能够直接保存图像，适合图像密集型游戏。 MathMLMathML的标签是 &lt;math&gt;&lt;/math&gt; 。 MathML基于xml，是用来在网络上书写数学符号和公式的语言。 MathML代码生成：https://latexlive.com/ 拖放（Drag、Drop）拖放是html5标准的一部分，任何元素都能拖放。 拖放：抓取一个对象后拖到另一个位置。 实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1 { width: 350px; height: 70px; padding: 10px; border: 1px solid #aaaaaa; } &lt;/style&gt; &lt;script&gt; function allowDrop(ev) { ev.preventDefault(); } function drag(ev) { ev.dataTransfer.setData(\"Text\", ev.target.id); } function drop(ev) { ev.preventDefault(); var data = ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data)); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt; &lt;div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"&gt;&lt;/div&gt; &lt;br&gt; &lt;img loading=\"lazy\" id=\"drag1\" src=\"/images/logo.png\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"336\" height=\"69\"&gt;&lt;/body&gt;&lt;/html&gt; 解析： 首先，设置元素为可拖动 1&lt;img draggable=\"true\"&gt; 拖动时的行为，ondragstart和setData() drag(): 123function drag(ev) { ev.dataTransfer.setData(\"Text\", ev.target.id);} 放到哪里ondragover ondragover 事件规定在何处放置被拖动的数据。 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用 ondragover 事件的 event.preventDefault() 方法： 1event.preventDefault() 放置ondrop 当放置的时候回发声drop事件。 12345function drop(ev) { ev.preventDefault(); var data = ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data));} 调用preventDefault()来避免浏览器对数据的默认处理（drop事件的默认行为是以链接形式打开） 通过 dataTransfer.getData(“Text”)方法获得被拖的数据。该方法将返回在setData()方法中设置为相同类型的任何数据。 被拖数据是被拖元素的id(“drag1”) 把被拖元素追加到放置元素（目标元素中 实例：来回拖动12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1, #div2 { float: left; width: 100px; height: 35px; margin: 10px; padding: 10px; border: 1px solid #aaaaaa; } &lt;/style&gt; &lt;script&gt; function allowDrop(ev) { ev.preventDefault(); } function drag(ev) { ev.dataTransfer.setData(\"Text\", ev.target.id); } function drop(ev) { ev.preventDefault(); var data = ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data)); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"&gt; &lt;img src=\"img_w3slogo.gif\" draggable=\"true\" ondragstart=\"drag(event)\" id=\"drag1\" width=\"88\" height=\"31\"&gt;&lt;/div&gt; &lt;div id=\"div2\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Geolocation（地理定位）Geolocation（地理定位）用于定位用户的位置（需要获得用户同意）。 获得地理位置使用getCurrentPosition()方法获得用户位置。 实例：获取用户经纬度 1234567891011121314151617var x = document.getElementById(\"demo\");function getLocation() { // 检查是否支持定位 if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(showPosition); } else { // 不支持定位的处理 x.innerHTML = \"该浏览器不支持获取地理位置。\"; }}// 点击按钮的事件function showPosition(position) { x.innerHTML = \"纬度: \" + position.coords.latitude + \"&lt;br&gt;经度: \" + position.coords.longitude;} 实例：在以上的代码中加入错误处理 12345678910111213141516function showError(error) { switch (error.code) { case error.PERMISSION_DENIED: x.innerHTML = \"用户拒绝对获取地理位置的请求。\" break; case error.POSITION_UNAVAILABLE: x.innerHTML = \"位置信息是不可用的。\" break; case error.TIMEOUT: x.innerHTML = \"请求用户地理位置超时。\" break; case error.UNKNOWN_ERROR: x.innerHTML = \"未知错误。\" break; }} 在地图中显示结果需要使用可以使用经纬度的地图服务，谷歌地图或者百度地图： 1234567function showPosition(position) { var latlon = position.coords.latitude + \",\" + position.coords.longitude; var img_url = \"http://maps.googleapis.com/maps/api/staticmap?center=\" + latlon + \"&amp;zoom=14&amp;size=400x300&amp;sensor=false\"; document.getElementById(\"mapholder\").innerHTML = \"&lt;img src='\" + img_url + \"'&gt;\";} 给定位置的信息 更新本地信息 显示用户周围的信息 GPS getCurrentPosition()getCurrentPosition()返回对象： coords.latitude：维度 coords.longitude：经度 coords.accuracy：精度 coords.altitude：海拔 coords.altitudeAccuracy：海拔精度 coords.heading：方向 coords.speed：速度 timestamp：相应日期、时间 其他方法watchPosition()：持续返回用户位置。clearWatch()：停止watchPosition() 实例： 1234567891011121314var x = document.getElementById(\"demo\");function getLocation() { if (navigator.geolocation) { navigator.geolocation.watchPosition(showPosition); } else { x.innerHTML = \"该浏览器不支持获取地理位置。\"; }}function showPosition(position) { x.innerHTML = \"纬度: \" + position.coords.latitude + \"&lt;br&gt;经度: \" + position.coords.longitude;} 实例：百度地图获取经纬度 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入百度 API，\"ak=\" 后面一串码是密钥，最好自己申请--&gt; &lt;script type=\"text/javascript\" src=\"https://api.map.baidu.com/api?v=2.0&amp;ak=7a6QKaIilZftIMmKGAFLG7QT1GLfIncg\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" onclick=\"getLocation()\" value=\"确认\" /&gt; &lt;div id=\"position\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var x = document.getElementById('position'); function getLocation() { // 创建百度地理位置实例，代替 navigator.geolocation var geolocation = new BMap.Geolocation(); geolocation.getCurrentPosition(function(e) { if (this.getStatus() == BMAP_STATUS_SUCCESS) { // 百度 geolocation 的经纬度属性不同，此处是 point.lat 而不是 coords.latitude x.innerHTML = '纬度：' + e.point.lat + '&lt;br/&gt;经度：' + e.point.lng; } else { x.innerHTML = 'failed' + this.getStatus(); } }); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; videohtml5提供了显示视频的标准。 使用12345&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; 您的浏览器不支持Video标签。&lt;/video&gt; 标签详解： 控件controls width、height属性 source元素用于提供多个视频文件，src属性用于指定视频路径。 track元素定义文本轨迹 浏览器对于视频格式的支持 IE：mp4 chrome：mp4、webm、ogg firefox：mp4、webm、ogg safari：mp4 opera：mp4、webm、ogg 视频格式的MIME类型：mp4：video/mp4webm：video/webmogg：video/ogg 使用DOM控制video和audio元素拥有相同的方法、属性和事件，并且可以使用js控制。 方法用于播放、暂停、加载。属性（时长、音量等等）可以被读取和设置。DOM事件通知我视频开始播放、暂停、停止等等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div style=\"text-align:center\"&gt; &lt;button onclick=\"playPause()\"&gt;播放/暂停&lt;/button&gt; &lt;button onclick=\"makeBig()\"&gt;放大&lt;/button&gt; &lt;button onclick=\"makeSmall()\"&gt;缩小&lt;/button&gt; &lt;button onclick=\"makeNormal()\"&gt;普通&lt;/button&gt; &lt;br&gt; &lt;video id=\"video1\" width=\"420\"&gt; &lt;source src=\"mov_bbb.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"mov_bbb.ogg\" type=\"video/ogg\"&gt; 您的浏览器不支持 HTML5 video 标签。 &lt;/video&gt; &lt;/div&gt; &lt;script&gt; var myVideo = document.getElementById(\"video1\"); function playPause() { if (myVideo.paused) myVideo.play(); else myVideo.pause(); } function makeBig() { myVideo.width = 560; } function makeSmall() { myVideo.width = 320; } function makeNormal() { myVideo.width = 420; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; audiohtml5提供了播放音频的标准audio元素。 使用12345&lt;audio controls&gt; &lt;source src=\"horse.ogg\" type=\"audio/ogg\"&gt; &lt;source src=\"horse.mp3\" type=\"audio/mpeg\"&gt; 您的浏览器不支持 audio 元素。&lt;/audio&gt; controls属性提供了播放、暂停、音量控件。 可以使用多个source元素提供多个格式。 浏览器对于音频格式的支持IE：mp3chrome：mp3、wav、oggfirefox：mp3、wav、oggsafari：mp3、wavopera：mp3、wav、ogg 三种音频格式的MIME类型：mp3：audio/mpegogg：audio/oggwav：audio/wav 新的input类型 color date datetime datetime-local email month number 1数量 ( 1 到 5 之间 ): &lt;input type=\"number\" name=\"quantity\" min=\"1\" max=\"5\"&gt; number类型有以下几种属性可以用：disabled, max, maxlength, min, pattern, readonly, required, size, step, value range 1&lt;input type=\"range\" name=\"points\" min=\"1\" max=\"10\"&gt; 可用的属性：max, min, step, value search tel time url week 新表单元素 datalist keygen output datalistdatalist元素规定输入域的选项列表。 datalist属性规定form或者input域应该拥有自动完成功能，当用户开始输入的时候，浏览器在该域下显示填写的选项。实例： 123456789&lt;input list=\"browsers\"&gt;&lt;datalist id=\"browsers\"&gt; &lt;option value=\"Internet Explorer\"&gt; &lt;option value=\"Firefox\"&gt; &lt;option value=\"Chrome\"&gt; &lt;option value=\"Opera\"&gt; &lt;option value=\"Safari\"&gt;&lt;/datalist&gt; keygenkeygen元素的作用是提供一种验证用户的可靠方法，它规定了用于表单的秘钥对生成器字段。 当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书。 实例： 12345&lt;form action=\"demo_keygen.asp\" method=\"get\"&gt; 用户名: &lt;input type=\"text\" name=\"usr_name\"&gt; 加密: &lt;keygen name=\"security\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; outputoutput元素用于不同类型的输出（计算、脚本输出等等）： 12345&lt;form oninput=\"x.value=parseInt(a.value)+parseInt(b.value)\"&gt;0 &lt;input type=\"range\" id=\"a\" value=\"50\"&gt;100 + &lt;input type=\"number\" id=\"b\" value=\"50\"&gt;= &lt;output name=\"x\" for=\"a b\"&gt;&lt;/output&gt;&lt;/form&gt; 新表单属性form元素新属性： autocomplete novalidate input元素新属性： autocomplete autofocus form formaction formenctype formmethod formnovalidate formtarget height, width list min, max multiple pattern (regexp) placeholder required step autocompleteautocomplete属性规定了form和input元素的自动完成功能。当用户开始在元素中输入的时候，浏览器会在域中显示选项。 实例： 123456&lt;form action=\"demo-form.php\" autocomplete=\"on\"&gt; First name:&lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; E-mail: &lt;input type=\"email\" name=\"email\" autocomplete=\"off\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; novalidatenovalidate属性是布尔型，规定了提交表单的时候不应该验证form或者input。 实例：这个表单无需验证 1234&lt;form action=\"demo-form.php\" novalidate&gt; E-mail: &lt;input type=\"email\" name=\"user_email\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; autofocusautofocus属性是一个布尔型，规定了在页面加载的时候某个域自动获取焦点。 实例：页面加载的时候，这个input元素会自动获取焦点 1First name:&lt;input type=\"text\" name=\"fname\" autofocus&gt; input元素的form属性form属性规定了输入域所属的一个或者多个表单。 123456&lt;form action=\"demo-form.php\" id=\"form1\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;Last name: &lt;input type=\"text\" name=\"lname\" form=\"form1\"&gt; input元素的formaction属性formaction属性用于描述表单提交的url地址，该属性会覆盖form元素的action属性。 实例：两个表单提交地址 123456&lt;form action=\"demo-form.php\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt; &lt;input type=\"submit\" formaction=\"demo-admin.php\" value=\"提交\"&gt;&lt;/form&gt; input元素的formenctype属性formenctype属性描述了表单提交到服务器的数据编码，会覆盖form元素的enctype属性。该属性与 type=”submit” 和 type=”image” 配合使用。 实例： 12345&lt;form action=\"demo-post_enctype.php\" method=\"post\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;input type=\"submit\" formenctype=\"multipart/form-data\" value=\"以 Multipart/form-data 提交\"&gt;&lt;/form&gt; formmethod属性formmethod属性定义了表单的提交方式，会覆盖form元素的method属性。该属性可以与 type=”submit” 和 type=”image” 配合使用。 实例： 123456&lt;form action=\"demo-form.php\" method=\"get\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;input type=\"submit\" formmethod=\"post\" formaction=\"demo-post.php\" value=\"使用 POST 提交\"&gt;&lt;/form&gt; formnovalidate属性formnovalidate属性会覆盖form元素的novalidate属性，与submit一起使用。 实例： 12345&lt;form action=\"demo-form.php\"&gt; E-mail: &lt;input type=\"email\" name=\"userid\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt; &lt;input type=\"submit\" formnovalidate value=\"不验证提交\"&gt;&lt;/form&gt; formtarget属性formtarget属性指定一个名称或者一个关键字来指明表单提交数据后的展示。formtarget属性会覆盖form元素的target属性。与submit和image配合使用。 实例： 123456&lt;form action=\"demo-form.php\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"正常提交\"&gt; &lt;input type=\"submit\" formtarget=\"_blank\" value=\"提交到一个新的页面上\"&gt;&lt;/form&gt; width和height属性用于指定image类型input的高度和宽度。 只能用于image类型的input元素 实例： 1&lt;input type=\"image\" src=\"img_submit.gif\" alt=\"Submit\" width=\"48\" height=\"48\"&gt; list属性list属性规定了输入域的datalist，datalist是输入域的选项列表。 实例： 123456789&lt;input list=\"browsers\"&gt;&lt;datalist id=\"browsers\"&gt; &lt;option value=\"Internet Explorer\"&gt; &lt;option value=\"Firefox\"&gt; &lt;option value=\"Chrome\"&gt; &lt;option value=\"Opera\"&gt; &lt;option value=\"Safari\"&gt;&lt;/datalist&gt; min和max属性min、max和step属性用于包含数字的input类型，比如date pickers、number 以及 range。 实例： 12345678Enter a date before 1980-01-01:&lt;input type=\"date\" name=\"bday\" max=\"1979-12-31\"&gt;Enter a date after 2000-01-01:&lt;input type=\"date\" name=\"bday\" min=\"2000-01-02\"&gt;Quantity (between 1 and 5):&lt;input type=\"number\" name=\"quantity\" min=\"1\" max=\"5\" step=\"1\"&gt; multiple属性multiple属性是布尔型属性。 multiple属性规定了input元素可选择多个值，用于email和file类型。 实例：上传多个文件 1Select images: &lt;input type=\"file\" name=\"img\" multiple&gt; pattern属性描述了一个正则表达式用于验证input的value，适用类型有text、search、url、tel、email、password。 实例： 1Country code: &lt;input type=\"text\" name=\"country_code\" pattern=\"[A-Za-z]{3}\" title=\"Three letter country code\"&gt; placeholder属性placeholder属性在输入域提供了提示信息。适用于text, search, url, telephone, email 以及 password。 1&lt;input type=\"text\" name=\"fname\" placeholder=\"First name\"&gt; required属性required属性是一个布尔型属性。带有required属性的输入域必须要填写。使用类型：ext, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。 1Username: &lt;input type=\"text\" name=\"usrname\" required&gt; 语义元素语义元素：有意义的元素，能够清楚地描述其意义以及给浏览器和开发者提示。 新的语义容器 header nav article section aside figcaption figure footer section元素section元素定义了文档中的节，比如章节、页眉或者其他部分。 实例： 1234&lt;section&gt; &lt;h1&gt;WWF&lt;/h1&gt; &lt;p&gt;The World Wide Fund for Nature (WWF) is....&lt;/p&gt;&lt;/section&gt; article元素article元素定义独立的内容。 实例： 1234&lt;article&gt; &lt;h1&gt;Internet Explorer 9&lt;/h1&gt; &lt;p&gt;Windows Internet Explorer 9(缩写为 IE9 )在2011年3月14日21:00 发布。&lt;/p&gt;&lt;/article&gt; nav元素nav元素定义了导航链接部分，不是所有的连接都包含在nav元素中。 实例： 123456&lt;nav&gt; &lt;a href=\"/html/\"&gt;HTML&lt;/a&gt; | &lt;a href=\"/css/\"&gt;CSS&lt;/a&gt; | &lt;a href=\"/js/\"&gt;JavaScript&lt;/a&gt; | &lt;a href=\"/jquery/\"&gt;jQuery&lt;/a&gt;&lt;/nav&gt; aside元素aside元素定义了主内容区域之外的内容（侧边栏），且与主内容相关。 实例： 123456&lt;p&gt;My family and I visited The Epcot center this summer.&lt;/p&gt;&lt;aside&gt; &lt;h4&gt;Epcot Center&lt;/h4&gt; &lt;p&gt;The Epcot Center is a theme park in Disney World, Florida.&lt;/p&gt;&lt;/aside&gt; header元素header定义了文档头部区域，一个文档里可以有多个header。 实例： 1234567&lt;article&gt; &lt;header&gt; &lt;h1&gt;Internet Explorer 9&lt;/h1&gt; &lt;p&gt;&lt;time pubdate datetime=\"2011-03-15\"&gt;&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;Windows Internet Explorer 9(缩写为 IE9 )是在2011年3月14日21:00发布的&lt;/p&gt;&lt;/article&gt; footer元素footer定义了文档的底部区域，通常有连接、作者信息、版权等信息。 1234&lt;footer&gt; &lt;p&gt;Posted by: Hege Refsnes&lt;/p&gt; &lt;p&gt;&lt;time pubdate datetime=\"2012-03-01\"&gt;&lt;/time&gt;&lt;/p&gt;&lt;/footer&gt; figure和figcaption元素figure元素规定了一个独立的内容区域（图片，表格，代码等）。figure元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。figcaption元素规定了figure元素的标题，一般放在figure元素中的最后面。 实例： 1234&lt;figure&gt; &lt;img loading=\"lazy\" src=\"img_pulpit.jpg\" alt=\"The Pulpit Rock\" width=\"304\" height=\"228\"&gt; &lt;figcaption&gt;Fig1. - The Pulpit Pock, Norway.&lt;/figcaption&gt;&lt;/figure&gt; 旧版本浏览器兼容对于不支持html5新元素的浏览器： 123456789header,section,footer,aside,nav,article,figure { display: block;} 对于IE8以及更早的版本： 使用HTML5 Shiv Javascript脚本，放入html中： 123&lt;!--[if lt IE 9]&gt;&lt;script src=\"html5shiv.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 上面的代码需要放在head元素中。 html5 web存储html5 web存储是比cookie更好的本地存储方式。html5 web存储可以在本地存储用户的浏览数据。数据以key/value的形式存在，只对该网页开放使用。 localStorage和sessionStorage对象客户端存储数据的两个对象是： localStorage：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。 sessionStorage：用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。 检查浏览器是否支持这两个对象： 123456if (typeof(Storage) !== \"undefined\") { // 是的! 支持 localStorage sessionStorage 对象! // 一些代码.....} else { // 抱歉! 不支持 web 存储。} localStorage对象localStorage对象存储的数据没有时间限制。 实例： 123456// 存储一组键值对localStorage.sitename = \"菜鸟教程\";// 查找一组键值对并写入一个元素中document.getElementById(\"result\").innerHTML = \"网站名：\" + localStorage.sitename;// 删除一组键值对localStorage.removeItem(\"sitename\"); localStorage对象中的数据都是键值对，sitename是一个key，菜鸟教程是一个值。 localStorage和sessionStorage可使用的API都是一样的，常用的： localStorage.setItem(key, value)，保存一组键值对。 localStorage.getItem(key)，读取一个key的value。 localStorage.removeItem(key)，删除一组键值对。 localStorage.clear()，删除所有数据。 localStorage.key(index)，查询某个index的key。 键值对通常是以字符串存储。 实例：点击转化字符串为数字 1234567if (localStorage.clickcount) { // 类型转换 localStorage.clickcount = Number(localStorage.clickcount) + 1;} else { localStorage.clickcount = 1;}document.getElementById(\"result\").innerHTML = \" 你已经点击了按钮 \" + localStorage.clickcount + \" 次 \"; sessionStorage对象sessionStorage仅用于session会话，关闭标签后数据删除。 实例： 123456if (sessionStorage.clickcount) { sessionStorage.clickcount = Number(sessionStorage.clickcount) + 1;} else { sessionStorage.clickcount = 1;}document.getElementById(\"result\").innerHTML = \"在这个会话中你已经点击了该按钮 \" + sessionStorage.clickcount + \" 次 \"; html5 web sql数据库web sql是一个独立的规范，引入了一组使用sql操作客户端数据库的API。web sql数据库可以再safari、chrome和opera中运行。 核心方法 openDatabase：使用现有的数据库或者新建的数据库创建一个数据库对象。 transaction：用于控制一个事务以及基于这种情况执行提交或者回滚。 executeSql：执行sql查询。 打开数据库使用openDatabase()打开已存在的数据库，若不存在则会创建一个新的数据库： 12var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);参数依次是： 数据库名称、 版本号、 描述文本、 数据库大小、 创建回调 执行查询执行操作使用 database.transaction() 函数： 12345var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function(tx) { // 创建了一个名为LOGS的表 tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');}); 插入数据在上面的基础上插入数据： 123456var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');}); 动态值插入数据： 123456var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function(tx) { // e_id 和 e_log 是外部变量，executeSql 会映射数组参数中的每个条目给 \"?\"。 tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id,log) VALUES (?, ?)', [e_id, e_log]);}); 读取数据123456789101112131415161718192021var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');});db.transaction(function(tx) { tx.executeSql('SELECT * FROM LOGS', [], function(tx, results) { var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++) { alert(results.rows.item(i).log); } }, null);}); 完整实例123456789101112131415161718192021222324var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);var msg;db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")'); msg = '&lt;p&gt;数据表已创建，且插入了两条数据。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg;});db.transaction(function(tx) { tx.executeSql('SELECT * FROM LOGS', [], function(tx, results) { var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++) { msg = \"&lt;p&gt;&lt;b&gt;\" + results.rows.item(i).log + \"&lt;/b&gt;&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; } }, null);}); 删除记录123db.transaction(function(tx) { tx.executeSql('DELETE FROM LOGS WHERE id=1');}); 删除动态id的数据： 123db.transaction(function(tx) { tx.executeSql('DELETE FROM LOGS WHERE id=?', [id]);}); 更新记录123db.transaction(function(tx) { tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=2');}); 更新动态id的数据： 123db.transaction(function(tx) { tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=?', [id]);}); 完整实例123456789101112131415161718192021222324252627282930313233343536var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);var msg;db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")'); msg = '&lt;p&gt;数据表已创建，且插入了两条数据。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg;});db.transaction(function(tx) { tx.executeSql('DELETE FROM LOGS WHERE id=1'); msg = '&lt;p&gt;删除 id 为 1 的记录。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg;});db.transaction(function(tx) { tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=2'); msg = '&lt;p&gt;更新 id 为 2 的记录。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg;});db.transaction(function(tx) { tx.executeSql('SELECT * FROM LOGS', [], function(tx, results) { var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++) { msg = \"&lt;p&gt;&lt;b&gt;\" + results.rows.item(i).log + \"&lt;/b&gt;&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; } }, null);}); html5应用程序缓存（Application Cache）通过创建cache manifest 文件，可以创建离线web应用。 应用程序缓存的优势： 可以离线浏览 已缓存的资源加载更快 减少服务器负载 cache manifest实例12345678&lt;!DOCTYPE HTML&gt;&lt;html manifest=\"demo.appcache\"&gt;&lt;body&gt; 文档内容......&lt;/body&gt;&lt;/html&gt; cache manifest基础为html标签添加manifest属性即可启用应用程序缓存： 12345&lt;!DOCTYPE HTML&gt;&lt;html manifest=\"demo.appcache\"&gt;...&lt;/html&gt; 指定了manifest的页面都会被缓存。 manifest文件的扩展名为： .appcache 。 manifest文件的MIME类型为： text/cache-manifest ，要在web服务器上配置。 manifest文件manifest文件是简单的文本文件，它告诉浏览器被缓存的内容。 manifest文件的三部分： CACHE MANIFEST：在此标题下列出的文件将在首次下载后进行缓存 NETWORK：在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK：此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 这是一个manifest文件： 1234567891011121314151617# 第一行，CACHE MANIFEST，必需CACHE MANIFEST/theme.css/logo.gif/main.js# 联网时下载NETWORK:login.php# 其他所有文件都在联网时下载NETWORK:*# 如果无法联网，则使用文件替换FALLBACK:/html/ /offline.html 更新缓存一旦应用被缓存，它就会保持缓存直到发生下列情况： 用户清空浏览器缓存 manifest 文件被修改（参阅下面的提示） 由程序来更新应用缓存 完整的manifest文件以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 1234567891011CACHE MANIFEST# 2012-02-21 v1.0.0/theme.css/logo.gif/main.jsNETWORK:login.phpFALLBACK:/html/ /offline.html web workersweb workers独立于其他脚本，是运行在后台的js，不影响页面性能。 实例index.html: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;计数： &lt;output id=\"result\"&gt;&lt;/output&gt;&lt;/p&gt; &lt;button onclick=\"startWorker()\"&gt;开始工作&lt;/button&gt; &lt;button onclick=\"stopWorker()\"&gt;停止工作&lt;/button&gt; &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.&lt;/p&gt; &lt;script&gt; var w; function startWorker() { if (typeof(Worker) !== \"undefined\") { if (typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\"); } w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data; }; } else { document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\"; } } function stopWorker() { w.terminate(); w = undefined; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; demo_workers.js: 123456789var i = 0;function timedCount() { i = i + 1; postMessage(i); setTimeout(\"timedCount()\", 500);}timedCount(); 检测浏览器是否支持web worker123456if (typeof(Worker) !== \"undefined\") { // 是的! Web worker 支持! // 一些代码.....} else { //抱歉! Web Worker 不支持} 创建web worker文件demo_workers.js： 123456789var i = 0;function timedCount() { i = i + 1; postMessage(i); setTimeout(\"timedCount()\", 500);}timedCount(); 创建web worker对象在html页面中调用上面写的demo_workers.js文件： 123if (typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\");} 给worker添加一个onmessage事件监听器： 123w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data;}; 终止web worker1w.terminate(); 完整代码html: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;计数： &lt;output id=\"result\"&gt;&lt;/output&gt;&lt;/p&gt; &lt;button onclick=\"startWorker()\"&gt;开始工作&lt;/button&gt; &lt;button onclick=\"stopWorker()\"&gt;停止工作&lt;/button&gt; &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.&lt;/p&gt; &lt;script&gt; var w; function startWorker() { if (typeof(Worker) !== \"undefined\") { if (typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\"); } w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data; }; } else { document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\"; } } function stopWorker() { w.terminate(); w = undefined; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; web worker: 123456789var i = 0;function timedCount() { i = i + 1; postMessage(i); setTimeout(\"timedCount()\", 500);}timedCount(); 关于DOMweb worker文件位于外部，故而web worker无法访问window、document、parent这几个对象。 服务器发送事件（Server-Sent Events）html5服务器发送事件允许网页获得服务器的更新，用途：sns更新、新闻更新等等。 Server-Sent 事件指的是网页自动获取来自服务器的更新。 接收Server-Sent事件通知123456// 创建一个新的EventSource对象，参数是服务器端处理文件路径var source = new EventSource(\"demo_sse.php\");// 出发onmessage事件时更新页面内容source.onmessage = function(event) { document.getElementById(\"result\").innerHTML += event.data + \"&lt;br&gt;\";}; 检测Server-Sent事件支持123456if (typeof(EventSource) !== \"undefined\") { // 浏览器支持 Server-Sent // 一些代码.....} else { // 浏览器不支持 Server-Sent..} 服务器端代码12345678&lt;?phpheader('Content-Type: text/event-stream');header('Cache-Control: no-cache');$time = date('r');echo \"data: The server time is: {$time}\\n\\n\";flush();?&gt; EventSource对象除了onmessage事件，还有onopen，onerror。 websocketwebsocket（ws）是html5提供的一种在单个tcp连接上进行全双工通信的协议。 websocket使得服务器可以主动向客户端推送数据，客户端和服务器只要完成一次握手就可以一直保持连接，并且可以双向传输数据。 在websocket之前要想实现服务器向客户端推送数据需要客户端使用ajax轮询，带宽资源消耗较高。 websocket连接建立后，使用send()向服务器发送数据，使用onmessage事件接受服务器返回的数据。 1var Socket = new webSocket(url, [protocol]); 下面的Socket对象都是这里new的。 websocket属性属性： Socket.readyState：只读，表示连接状态，0 - 表示连接尚未建立，1 - 表示连接已建立，可以进行通信，2 - 表示连接正在进行关闭，3 - 表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount：只读，缓冲区中的字节数。 websocket事件 事件open：Socket.onopen，建立连接时触发。 事件message：Socket.onmessage，客户端接收服务端数据时触发。 事件error：Socket.onerror，通信错误时触发。 事件close：Socket.onclose，连接关闭时触发。 websocket方法 Socket.send()：发送数据。 Socket.close()：关闭连接。 websocket实例websocket通信过程： 首先，客户端要向服务器发起一个http请求，附加头信息： Upgrade: WebSocket 表明这是这是websocket。 然后服务器解析头信息后应答。 这样连接就建立了。 直到客户端、服务端中一方主动关闭连接。 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; function WebSocketTest() { if (\"WebSocket\" in window) { alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:9998/echo\"); ws.onopen = function() { // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); }; ws.onmessage = function(evt) { var received_msg = evt.data; alert(\"数据已接收...\"); }; ws.onclose = function() { // 关闭 websocket alert(\"连接已关闭...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); } } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"sse\"&gt; &lt;a href=\"javascript:WebSocketTest()\"&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; pywebsocket客户端代码已经写好了，还差一个服务器端脚本用来处理websocket（需要python环境运行）。 下载pywebsocket： 1git clone https://github.com/google/pywebsocket.git 执行： 12345python setup.py buildsudo python setup.py install# 查看文档pydoc mod_pywebsocket 开启服务： 12# pywebsocket/mod_pywebsocket下sudo python standalone.py -p 9998 -w ../example/ \bhtml5代码规范 使用正确的文档声明 1&lt;!DOCTYPE html&gt; 使用小写元素名 关闭所有标签 关闭空标签 1&lt;meta charset=\"utf-8\" /&gt; 使用小写属性名 属性值 用引号括起来，单引号双引号均可不过风格要统一。 图片属性 图片使用alt和长宽。 空格和等号 等号前后少用空格。 避免一行代码过长 空行和缩进 不要无故添加空行。为每一个逻辑功能块添加空行，便于阅读。缩进使用两个空格，不使用tab。短代码之间不使用不必要的空行和缩进。 html和body标签 html5中可以省略这两个标签，不过不推荐。 head标签 html5中head可以省略，不过不推荐。 元数据 title元素必须。charset必须。 注释 123456&lt;!-- 这是注释 --&gt;&lt;!-- 这是一个较长评论。 这是 一个较长评论。这是一个较长评论。 这是 一个较长评论 这是一个较长评论。 这是 一个较长评论。--&gt; 样式表 1&lt;link rel=\"stylesheet\" href=\"styles.css\"&gt; 外部js 1&lt;script src=\"myscript.js\"&gt; 使用小写文件名 文件扩展名 html: .htmlcss: .cssjs: .js.htm 也可以，原因是早起DOS系统扩展名只能支持三个字符。","link":"/2018/02/10/html5-tutorial/"},{"title":"慕课网js入门","text":"最近刷了一下慕课网的js入门课程，做了一点笔记。 document对象 12document.write(\"hello\");document.getElementById(\"p1\").style.color = \"blue\"; html中插入js代码 123&lt;script type=\"text/javascript\"&gt; document.write(\"开启JS之旅!\"); //js语句&lt;/script&gt; js代码外链 在html文件中写： 1&lt;script src=\"script.js\"&gt;&lt;/script&gt; 在script.js文件中直接写js代码 js代码位置 我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。放在head部分最常用的方式是在页面中head部分放置 &lt;script&gt; 元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。放在body部分JavaScript代码在网页读取到该语句的时候就会执行。 注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。 每一句JavaScript代码格式: 语句;先来看看下面代码 123&lt;script type=\"text/javascript\"&gt; alert(\"hello!\");&lt;/script&gt; 例子中的 alert(&quot;hello!&quot;); 就是一个JavaScript语句。 一行的结束就被认定为语句的结束，通常在结尾加上一个分号 &quot;;&quot; 来表示语句的结束。 单行注释，在注释内容前加符号 “//”。 123&lt;script type=\"text/javascript\"&gt; document.write(\"单行注释使用'//'\"); // 我是注释，该语句功能在网页中输出内容&lt;/script&gt; 多行注释以”/*“开始，以”*/“结束。 1234567&lt;script type=\"text/javascript\"&gt; document.write(\"多行注释使用/*注释内容*/\"); /* 多行注释 养成书写注释的良好习惯 */&lt;/script&gt; 变量名可以任意取名，但要遵循命名规则: 变量必须使用字母、下划线(_)或者美元符($)开始。 然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。 不能使用JavaScript关键词与JavaScript保留字。 语法 12345if (条件) { 条件成立时执行的代码;} else { 条件不成立时执行的代码;} 假设我们通过年龄来判断是否为成年人，如年龄大于等于18岁，是成年人，否则不是成年人。代码表示如下**:** 12345678910&lt;script type=\"text/javascript\"&gt; var myage = 18; if (myage &gt;= 18) //myage&gt;=18是判断条件 { document.write(\"你是成年人。\"); } else //否则年龄小于18 { document.write(\"未满18岁，你不是成年人。\"); }&lt;/script&gt; 函数 函数是完成某个特定功能的一组语句。如没有函数，完成任务可能需要五行、十行、甚至更多的代码。这时我们就可以把完成特定功能的代码块放到一个函数里，直接调用这个函数，就省重复输入大量代码的麻烦。 如何定义一个函数呢？基本语法如下: 123function 函数名() { 函数代码;} 说明: function定义函数的关键字。 “函数名”你为函数取的名字。 “函数代码”替换为完成特定功能的代码。 我们来编写一个实现两数相加的简单函数, 并给函数起个有意义的名字：“add2”，代码如下： 1234function add2() { var sum = 3 + 2; alert(sum);} 函数调用: 函数定义好后，是不能自动执行的，所以需调用它, 只需直接在需要的位置写函数就ok了, 代码如下: document.write() 12345&lt;script type=\"text/javascript\"&gt; var a = 'hello'; document.write(a + \"&lt;br&gt;\"); document.write('world');&lt;/script&gt; 警告弹窗 12alert(\"字符串\");alert(变量名); 例如 1234&lt;script type=\"text/javascript\"&gt; alert(\"警告\"); alert(\"第二条警告\");&lt;/script&gt; confirm消息对话框 confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。 语法: 1confirm(\"str\"); 参数说明: 12str：在消息对话框中要显示的文本返回值: Boolean值 返回值: 12当用户点击&quot;确定&quot;按钮时，返回true当用户点击&quot;取消&quot;按钮时，返回false 注: 通过返回值可以判断用户点击了什么按钮 看下面的代码: 12345678&lt;script type=\"text/javascript\"&gt; var mymessage = confirm(\"你喜欢JavaScript吗?\"); if (mymessage == true) { document.write(\"很好,加油!\"); } else { document.write(\"JS功能强大，要学习噢!\"); }&lt;/script&gt; prompt消息对话框 弹出消息对话框, 通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。 1prompt(str1, str2); 12str1: 要显示在消息对话框中的文本， 不可修改str2： 文本框中的内容， 可以修改 返回值: 1231. 点击确定按钮，文本框中的内容将作为函数返回值2. 点击取消按钮，将返回null 123456var myname = prompt(\"请输入姓名:\");if (myname != null) { alert(\"你好\" + myname);} else { alert(\"你好我的朋友\");} 打开新窗口 1window.open('URL', '窗口名称', '参数字符串'); 123456789窗口名称：可选参数，被打开窗口的名称。 1.该名称由字母、数字和下划线字符组成。 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。 例如: 打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口： 123&lt;script type=\"text/javascript\"&gt; window.open('http://www.imooc.com', '_blank', 'width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')&lt;/script&gt; 关闭窗口 1234567window.close(); //关闭本窗口窗口对象.close();//关闭指定窗口例如&lt;script style=\"text/javascript\"&gt; var newWindow = window.open('http://www.imooc.com'); newWindow.close();&lt;/script&gt; 注意: 上面代码在打开新窗口的同时，关闭该窗口，看不到被打开的窗口。 DOM 获取id 123document.getElementById(\"这里是id\");var myId = document.getElementById(\"这里是id\");document.write(\"id的标签是\" + myId); innerHTML属性 innerHTML 属性用于获取或替换 HTML 元素的内容。 语法: 1[Object].innerHTML = 'asd' 使用js改变html的样式 12[Object].style.属性 = [new style];Object是通过document.getElementById(\"id\") 获取的元素对象 display属性 123[Object].stytle.display = [value];value: none（ 不显示该元素）block（ 以块元素显示） 控制类名 1[Object].className = \"类名\";","link":"/2018/02/20/imooc-js-junior/"},{"title":"慕课网js进阶","text":"接上面的js进阶部分课程笔记。 基本语法变量命名变量名字可以任意取，只不过取名字要遵循一些规则: 必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字。如下: 12345678正确: mysum _mychar $numa1 错误: 6num //开头不能用数字 %sum //开头不能用除(_ $)外特殊符号,如(% + /等) sum+num //开头中间不能使用除(_ $)外特殊符号，如(% + /等) 变量声明 123var 变量名;var n1, n2; 1b &gt; a &amp;&amp; b &lt; c //“&amp;&amp;”是并且的意思, 读法\"b大于a\"并且\" b小于c \" &amp;&amp; 是逻辑与操作符，只有 &amp;&amp; 两边值同时为真的时候，整个表达式值才为真。 操作符之间的优先级（高到低）: 算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号 如果同级的运算是按从左到右次序进行, 多层括号由里向外。 数组 创建数组语法： 1var myarray = new Array(); 我们创建数组的同时，还可以为数组指定长度，长度可任意指定。 1var myarray = new Array(8); //创建数组，存储8个数据。 创建数组并赋值 123var arr = new Array();arr[0] = 1;arr[1] = 2; 123var arr = new Array(1, 2, 3, 4);或者var arr = [1, 2, 3, 4]; 数组存储的数据可以是任何类型（数字、字符、布尔值等） 调用数组元素 123arr[i];// 或者调用的同时赋值给变量var temp = arr[i]; 数组长度 12var arr = new Array(1, 2, 3, 4);arr.length; // 4 改变数组长度 1arr.length = 10; 二维数组 一维数组，我们看成一组盒子，每个盒子只能放一个内容。 1一维数组的表示: myarray[]; 二维数组，我们看成一组盒子，不过每个盒子里还可以放多个盒子。 1二维数组的表示: myarray[][]; 注意: 二维数组的两个维度的索引值也是从0开始，两个维度的最后一个索引值为(长度-1)。 二维数组的定义 定义方法1 1234567var myarr = new Array(); //先声明一维 for (var i = 0; i &lt; 2; i++) { //一维长度为2 myarr[i] = new Array(); //再声明二维 for (var j = 0; j &lt; 3; j++) { //二维长度为3 myarr[i][j] = i + j; // 赋值，每个数组元素的值为i+j }} 定义方法2 1234var arr = [ [0, 1], [0, 1, 2]]; 编程练习 使用js，把下面数组 var arr = [‘‘, ‘##’, “*”, “&amp;&amp;”, “**“, “##“]; arr[7] = “**”; 在页面显示如下图所示的图案： * ** 第一步：定义一个数组，存储要展示的图形。 123提示: var arr = ['*', '##', \"***\", \"&amp;&amp;\", \"****\", \"##*\"];arr[7] = \"**\"; 第二步：预想一下arr 数组的长度是多少？ 1提示: 使用alert弹出数组的长度，看看是否跟自己的答案一样。 第三步：将数组内容输出，完成达到的效果。 1提示: 想在不同行显示不同数组内容，别忘记&lt;br/&gt;换行标签。 1234var arr = ['*', '##', \"***\", \"&amp;&amp;\", \"****\", \"##*\"];arr[7] = \"**\";alert(arr.length); //8document.write(arr[0] + \"&lt;br&gt;\" + arr[7] + \"&lt;br&gt;\" + arr[2] + \"&lt;br&gt;\" + arr[4]); if语句 123if (condition) { code} if…else 12345if (condition) { // code} else { // code} if…else嵌套 1234567if () {} else if {} else {} switch语句 1234567891011switch (表达式) { case value1: // code1 break; case value2: // code2 break; ... default: // codeLAST} for 123456789for (初始化变量; 循环条件; 循环迭代) { // code}// 例如var a = [1, 2, 3, 4, 5];for (var i = 0; i &lt; a.length; i++) { document.write(a[i] + \"&lt;br&gt;\");} while 123while (condition) { // code} do…while 1234do { // code}while (condition) 好处：至少执行一次代码 break 在while、for、do…while、while循环中使用break语句退出当前循环，直接执行后面的代码。 123456for (初始条件; 判断条件; 循环后条件值更新) { if (特殊情况) { break; } 循环代码} continue 作用：仅仅跳出本次循环，整个循环继续执行 123456for (初始条件; 判断条件; 循环后条件值更新) { if (特殊情况) { continue; } 循环代码} 编程练习 在一个大学的编程选修课班里，我们得到了一组参加该班级的学生数据，分别是姓名、性别、年龄和年级，接下来呢，我们要利用JavaScript的知识挑出其中所有是大一的女生的的名字哦。 学生信息如下： ​ (‘小A’, ‘女’, 21, ‘大一’), (‘小B’, ‘男’, 23, ‘大三’), ​ (‘小C’, ‘男’, 24, ‘大四’), (‘小D’, ‘女’, 21, ‘大一’), ​ (‘小E’, ‘女’, 22, ‘大四’), (‘小F’, ‘男’, 21, ‘大一’), ​ (‘小G’, ‘女’, 22, ‘大二’), (‘小H’, ‘女’, 20, ‘大三’), ​ (‘小I’, ‘女’, 20, ‘大一’), (‘小J’, ‘男’, 20, ‘大三’) 第一步： 把这些数据组成一个数组，方便我们之后操作哦。 1提示: 使用二维数组。 第二步： 筛选数据吧，首先找出都是大一的所有信息 ; 第三步： 最后再一次筛选上一步得到的数据，打印出都是女生的姓名 ; 1提示: 可以用switch 或 if 语句进行筛选。 123456789101112131415161718var infos = [ ['小A', '女', 21, '大一'], ['小B', '男', 23, '大三'], ['小C', '男', 24, '大四'], ['小C', '男', 24, '大四'], ['小D', '女', 21, '大一'], ['小E', '女', 22, '大四'], ['小F', '男', 21, '大一'], ['小G', '女', 22, '大二'], ['小H', '女', 20, '大三'], ['小I', '女', 20, '大一'], ['小J', '男', 20, '大三']];for (var i = 0; i &lt; infos.length; i++) { if (infos[i][3] === \"大一\" &amp;&amp; infos[i][1] === \"女\") { document.write(infos[i][0] + \"&lt;br /&gt;\"); }} 函数 1234function add(a, b) { sum = a + b; alert(sum);} add()调用 函数的定义 123function 函数名() { // 函数体} 函数调用 1.script标签内调用 12345678&lt;script type=\"text/javascript\"&gt; //定义 function func() { alert(\"调用成功\"); } //调用 func();&lt;/script&gt; 2.onclick调用 12&lt;buttun onclick=\"func()\"&gt;&lt;/buttun&gt; 有参数的函数 123function func(参数1， 参数2， 参数3，......) { // code} 有返回值的函数 1234function add(x, y) { sum = x + y; return sum;} 练习 使用javascript代码写出一个函数：实现传入两个整数后弹出较大的整数。 第一步： 编写代码完成一个函数的定义吧。 第二步： 我们来补充函数体中的控制语句，完成函数功能吧。 1提示:再想一想，两个整数比较有三种情况，大于，等于或小于，所以我们需要控制语句判断(if...else if)。 第三步： 写好的函数，我们就可以任意调用函数了。通过函数调用实现两组数值中，返回较大值吧。 1234567function com(a, b) { if (a &gt;= b) { return a; } else { return b; }} 事件 JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。 比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。 主要事件表: onclick事件 1234567891011&lt;script type=\"text/javascript\"&gt; function shuchu123() { document.write('123'); }&lt;/script&gt;&lt;body&gt; &lt;form&gt; &lt;input name=\"buttun\" type=\"buttun\" value=\"提交\" onclick=\"shuchu123()\" /&gt; &lt;/form&gt;&lt;/body&gt; onmouseover事件 onmouseout事件 onfocus事件 当网页中的对象获得聚点时，执行onfocus调用的程序就会被执行。 onblur失去焦点事件 onselect事件 onchange文本框内容改动事件 onload加载事件 事件会在页面加载完成后，立即发生，同时执行被调用的程序。注意： 加载页面时，触发 onload 事件，事件写在 &lt;body&gt; 标签内。 此节的加载页面，可理解为打开一个新页面时。 如下代码, 当加载一个新页面时，弹出对话框“加载中，请稍等…”。 onunload卸载事件 当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。 练习 使用JS完成一个简单的计算器功能。实现2个输入框中输入整数后，点击第三个输入框能给出2个整数的加减乘除。 提示：获取元素的值设置和获取方法为：例：赋值：document.getElementById(“id”）.value = 1； 取值：var = document.getElementById(“id”）.value； 任务 第一步： 创建构建运算函数count()。 第二步： 获取两个输入框中的值和获取选择框的值。 1提示：document.getElementById( id名 ).value 获取或设置 id名的值。 第三步： 获取通过下拉框来选择的值来改变加减乘除的运算法则。 1提示：使用switch判断运算法则。 第四步： 通过 = 按钮来调用创建的函数，得到结果。 注意: 使用parseInt()函数可解析一个字符串, 并返回一个整数。 对象 访问对象属性的语法: 1[objectName]. [propertyName] 访问对象的方法： 1[objectName]. [methodName]() 日期对象 123var time_now = new Date(); //获取当前电脑系统时间var d = new Date(2012, 10, 1); //2012.10.1var d = new Date('Oct 1,2012'); //2012.10.1 我们最好使用下面介绍的“方法”来严格定义时间。 访问方法语法： [日期对象].[方法]Date对象中处理时间和日期的常用方法： getDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下: 实例： 12345678910var d = new Date(); // Wed Apr 01 2020 22:41:15 GMT+0800 (中国标准时间)d.getDate(); // 1d.getFullYear(); // 2020d.getYear(); // 120d.getMonth(); // 3d.getDay(); // 3d.getHours(); // 22d.getMinutes(); // 41d.getSeconds(); // 15d.getTime(); // 1585752075892 String对象toUpperCase(), toLowerCase()123var str = 'sssssssssss';str.toUpperCase(); //输出大写str.toLowerCase(); //输出小写 charAt()charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。 12var str = 'abcd';str.charAt(index); 作用同 str[index]还可以使用它取字符串最后一个字符： 12var str = 'abcd';str.charAt(str.length - 1); indexOf()用于返回指定子串首次出现的位置 1stringObject.indexOf('subString', startPosition); 123456var str = 'abcdaddb'str.indexOf('da', 0);//startPosition若省略则从0开始检索/*返回指定字符首次出现的index*/ 若找不到符合条件的子串则返回-1 split()字符串分割12stringObject.split(separator, howmany)//将字符串分割为字符串数组，并返回该数组 参数 描述 separator 必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。 howmany 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 使用指定符号分割字符串，代码如下: 123var str = 'www.imooc.com'console.log(str.split(\".\"));console.log(str.split(\".\", 2)); 输出： 12[\"www\", \"imooc\", \"com\"][\"www\", \"imooc\"] substring()提取俩下标之间的字符串12stringObject.substring(startPosition, endPosition);//从0开始 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 123var str = 'www.imooc.com'str.substring(3, 6);str.substring(6, 3); 输出： 12\".im\"\".im\" substr()提取指定数目的字符1stringObject.substr(startPos, length); Math()对象123//直接调用，无需创建Math.PI;Math.abs(); Math 对象是一个固有的对象，无需创建实例，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date, String对象的区别。 Math对象的属性（都是大写） Math对象的方法（都是小写） 编写一个随机数生成器：随机生成一个0-100的随机整数。 123function random_int() { return Math.round(Math.random() * 100);} 12345678910111213141516random_int()53random_int()75random_int()20random_int()73random_int()62random_int()15random_int()7random_int()64 ceil()向上取整1Math.ceil(x) //x必须是一个数值,它返回的是大于或等于x，并且与x最接近的整数。 floor()向下取整1Math.floor(x) //返回的是小于或等于x，并且与 x 最接近的整数。 四舍五入round()1Math.round(x) //round() 方法可把一个数字四舍五入为最接近的整数。 random()随机数1Math.random() //random() 方法可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。 Array数组对象1234567//定义var arr = new Array();var arr = new Array(n);var arr = [a, b, c, d];//调用arr[index]; 数组方法： concat()数组连接concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。 1arrayObject.concat(array1, array2, ..., arrayN); 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 12var arr = [1, 2, 3, 4];arr.concat(5, 6); 1[1, 2, 3, 4, 5, 6] 12var arr = [1, 2, 3, 4]arr.concat([5, 6], [7]); 1[1, 2, 3, 4, 5, 6, 7] join()指定分隔符链接数组元素join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。 1arrayObject.join('分隔符') //若省略则默认使用逗号 12var arr = [1, 2, 3, 4];var str = arr.join('-'); 1'1-2-3-4' reverse()翻转数组元素12arrayObject.reverse()//该方法会改变原来的数组，而不会创建新的数组。 12var arr = [1, 2, 3, 4];arr.reverse(); 1[4, 3, 2, 1] slice()选定元素12//slice() 方法可从已有的数组中返回选定的元素。arrayObject.slice(start, end) 该方法并不会修改数组，而是返回一个子数组。 注意： 可使用负值从数组的尾部选取元素。 如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 String.slice() 与 Array.slice() 相似。 数组排序sort()sort() 会变改原数组，包括const数组。 1arrayObject.sort(函数方法) 如果不指定&lt;方法函数&gt;，则按数组元素的unicode码顺序排列。 12var arr = [1, 23, 4, 14];arr.sort(); 1[1, 14, 23, 4] window对象window对象是BOM的核心，window对象指当前的浏览器窗口。 window对象方法: ** ** js计时器1234在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。计时器类型：一次性计时器：仅在指定的延迟时间之后触发一次。间隔性触发计时器：每隔一定的时间间隔就触发一次。 计时器方法： setInterval()计时器每隔一段时间执行代码 1setInterval(code, time); //time以毫秒计时 setInterval() 和 setTimeout() 会返回一个id用于clear。 参数说明： 代码：要调用的函数或要执行的代码串。 交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。 返回值: 一个可以传递给 clearInterval() 从而取消对”代码”的周期性执行的值。 调用函数格式(假设有一个clock()函数): 123setInterval(\"clock()\", 1000);或setInterval(clock, 1000); 我们设置一个计时器，每隔100毫秒调用clock()函数，并将时间显示出来，代码如下: 1234567891011121314151617181920212223&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;计时器&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var clock_id = setInterval(clock, 100) function clock() { var time = new Date(); document.getElementById(\"clock\").value = time; } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type=\"text\" id=\"clock\" size=\"50\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; clearInterval()取消计时器1clearInterval(idOfSetInterval); setTimeout()在页面载入后一次性计时 1setTimeout(code, time); clearTimeout()1clearTimeout(id_of_setTimeout); history对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 12window.history. [属性 / 方法] //window可以不写history.length //history中的url数量 History 对象属性 History 对象方法 ** ** 使用length属性，当前窗口的浏览历史总长度，代码如下： 1234&lt;script type=\"text/javascript\"&gt; var HL = window.history.length; console.write(HL);&lt;/script&gt; 1234//后退window.history.back();//上面相当于下面window.history.go(-1); 1234//前进window.history.forward();//相当于window.history.go(1); 12//指定打开一个历史页面window.history.go(number); location对象1location. [属性 / 方法] location用于获取或设置窗体的URL，并且可以用于解析URL。 location对象属性图示: location 对象属性： ** ** location 对象方法: ** ** navigator对象Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 对象属性: 查看浏览器的名称和版本，代码如下: 1234567&lt;script type=\"text/javascript\"&gt; var browser = navigator.appName; var b_version = navigator.appVersion; document.write(\"Browser name\" + browser); document.write(\"&lt;br&gt;\"); document.write(\"Browser version\" + b_version);&lt;/script&gt; userAgent返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) 1navigator.userAgent 使用userAgent判断使用的是什么浏览器(假设使用的是IE8浏览器), 代码如下: 123456789101112131415function judgeBrowser() { var u_agent = navigator.userAgent; var B_name = \"Failed to identify the browser\"; if (u_agent.indexOf(\"Firefox\") &gt; -1) { B_name = \"Firefox\"; } else if (u_agent.indexOf(\"Chrome\") &gt; -1) { B_name = \"Chrome\"; } else if (u_agent.indexOf(\"MSIE\") &gt; -1 &amp;&amp; u_agent.indexOf(\"Trident\") &gt; -1) { B_name = \"IE(8-10)\"; } document.write(\"B_name:\" + B_name + \"&lt;br&gt;\"); document.write(\"u_agent:\" + u_agent + \"&lt;br&gt;\");}judgeBrowser(); 运行结果: screen对象1window.screen.属性; 对象属性: ** ** 1234567891011screen.availHeight// 1417screen.colorDepth// 24screen.pixDepth// 24screen.height// 1440 DOM(文档对象模型)文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 先来看看下面代码: 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 1. 元素节点：上图中 &lt;html&gt; 、 &lt;body&gt; 、 &lt;p&gt; 等都是元素节点，即标签。 2. 文本节点: 向用户展示的内容，如 &lt;li&gt;...&lt;/li&gt; 中的JavaScript、DOM、CSS等文本。 3. 属性节点: 元素属性，如 &lt;a&gt; 标签的链接属性 href=&quot;http://www.imooc.com&quot; 。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body, 它的子节点3个li, 它的兄弟结点h2、P。 DOM操作: 注意:前两个是document方法。 getElementsByName()方法返回带有指定名称的节点对象的集合。 12document.getElementsByName(name);//通过元素的name属性查找元素 name属性不唯一，可能返回多个元素组成的数组而不是一个元素 getElementsByTagName()方法返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。 1document.getElementsByTagName(tagname) 说明: Tagname是标签的名称，如p、a、img等标签名。 和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。 看看下面代码，通过getElementsByTagName()获取节点。 getElementById, getElementsByName和getElementsByTagName的区别以人来举例说明，人有能标识身份的身份证，有姓名，有类别(大人、小孩、老人)等。 ID 是一个人的身份证号码，是唯一的。所以通过getElementById获取的是指定的一个人。 Name 是他的名字，可以重复。所以通过getElementsByName获取名字相同的人集合。 TagName可看似某类，getElementsByTagName获取相同类的人集合。如获取小孩这类人，getElementsByTagName(“小孩”)。 把上面的例子转换到HTML中，如下: 1&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby1\"&gt; 音乐 input标签就像人的类别。 name属性就像人的姓名。 id属性就像人的身份证。 方法总结如下: 注意：方法区分大小写 通过下面的例子(6个name=”hobby”的复选项，两个按钮)来区分三种方法的不同: 12345678&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby1\"&gt; 音乐&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby2\"&gt; 登山&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby3\"&gt; 游泳&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby4\"&gt; 阅读&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby5\"&gt; 打球&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby6\"&gt; 跑步&lt;input type=\"button\" value=\"全选\" id=\"button1\"&gt;&lt;input type=\"button\" value=\"全不选\" id=\"button1\"&gt; document.getElementsByTagName(“input”)，结果为获取所有标签为input的元素，共8个。 document.getElementsByName(“hobby”)，结果为获取属性name=”hobby”的元素，共6个。 document.getElementById(“hobby6”)，结果为获取属性id=”hobby6”的元素，只有一个，”跑步”这个复选项。 getAttribute()方法1elementNode.getAttribute(name); 说明: elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点。 name：要想查询的元素节点的属性名字 看看下面的代码，获取h1标签的属性值： 运行结果: h1标签的ID ：alinkh1标签的title ：getAttribute()获取标签的属值 setArrribute()方法setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。 语法： 1elementNode.setAttribute(name,value) 说明： 1.name: 要设置的属性名。 2.value: 要设置的属性值。 注意： 把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。 类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。 节点属性在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称 nodeValue ：节点的值 nodeType ：节点的类型 一、nodeName 属性: 节点的名称，是只读的。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document 二、nodeValue 属性：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 访问子节点childNodes访问旋顶元素节点下的所有子节点的列表，返回值为一个数组 1elementNode.childNodes 访问子节点的第一项和最后一项1234//访问第一个子节点node.firstChild//等于node.childNodes[0] 1234//访问最后一个子节点node.lastChild//等于node.childNodes[node.length - 1] 访问父节点parentNode1elementNode.parentNode 访问兄弟节点12nodeObject.nextSibling //右兄弟nodeObject.previousSibling //左兄弟 插入节点appendChild()12appendChild(newNode)//在指定节点的最后一个子节点列表之后添加一个新的子节点。 插入节点insertBefore()12insertBefore(newnode, node)//insertBefore() 方法可在已有的子节点前插入一个新的子节点。 删除节点removeChild()12nodeObject.removeChild(node)//removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。 替换元素节点replaceChild()12node.replaceChild(newnode, oldnew)//replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 创建元素节点createElement12document.creatElement(tagName)//要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。 创建文本节点createTextNode1document.createTextNode(data) 浏览器窗口可视区域大小获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法: 一、对于IE9+、Chrome、Firefox、Opera 以及 Safari： • window.innerHeight - 浏览器窗口的内部高度 • window.innerWidth - 浏览器窗口的内部宽度 二、对于 Internet Explorer 8、7、6、5： • document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。 • document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。 或者 Document对象的body属性对应HTML文档的 &lt;body&gt; 标签 • document.body.clientHeight • document.body.clientWidth 在不同浏览器都实用的 JavaScript 方案： 1234var w = document.documentElement.clientWidth || document.body.clientWidth;var h = document.documentElement.clientHeight || document.body.clientHeight; 网页尺寸scrollHeight和scrollWidth获取网页内容高度和宽度 一、针对IE、Opera: scrollHeight 是网页内容实际高度，可以小于 clientHeight。 二、针对NS、FF: scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 三、浏览器兼容性 1234var w=document.documentElement.scrollWidth || document.body.scrollWidth;var h=document.documentElement.scrollHeight || document.body.scrollHeight; 注意: 区分大小写 scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。 网页尺寸offsetHeightoffsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。 一、值 offsetHeight = clientHeight + 滚动条 + 边框。 二、浏览器兼容性 1234var w = document.documentElement.offsetWidth || document.body.offsetWidth;var h = document.documentElement.offsetHeight || document.body.offsetHeight; 网页卷去的距离与偏移量我们先来看看下面的图： scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。 scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。 offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。 offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。 注意: 1. 区分大小写 2. offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。 编程挑战现在利用之前我们学过的JavaScript知识，实现选项卡切换的效果。 效果图: 文字素材: 房产： ​ 275万购昌平邻铁三居 总价20万买一居​ 200万内购五环三居 140万安家东三环​ 北京首现零首付楼盘 53万购东5环50平​ 京楼盘直降5000 中信府 公园楼王现房 家居: ​ 40平出租屋大改造 美少女的混搭小窝​ 经典清新简欧爱家 90平老房焕发新生​ 新中式的酷色温情 66平撞色活泼家居​ 瓷砖就像选好老婆 卫生间烟道的设计 二手房： ​ 通州豪华3居260万 二环稀缺2居250w甩​ 西3环通透2居290万 130万2居限量抢购​ 黄城根小学学区仅260万 121平70万抛!​ 独家别墅280万 苏州桥2居优惠价248万 任务大家先思考和分析实现思路，然后在动手实现 一、HTML页面布局 123提示:选项卡标题使用ul..li选项卡内容使用div 二、CSS样式制作 12345提示:整个选项卡的样式设置选项卡标题的样式设置选项卡内容的样式设置一开始只显示一个选项卡内容，其它选项卡内容隐藏。 三、JS实现选项卡切换 1234提示:获取选项卡标题和选项卡内容选项卡内容多个，需要循环遍历来操作，得知哪个选项卡和哪个选项内容匹配通过改变DOM的css类名称,当前点击的选项卡显示，其它隐藏。","link":"/2018/02/26/imooc-js-senior/"},{"title":"面试会问到的linux命令","text":"总结一下面试中会问到的linux命令。 ls 常用命令： 12ls -lls --color=auto 输出信息： 第一列：第一个字为文件类型，后面三组分别是所属用户权限、所属组权限和其他用户所属权限，r (2)、w (4)、e (1)分别是读、写、执行。若为-则表示没有权限。 第二列：硬连接数量，硬连接就是允许一个文件有多个有效路径名。 第三列：为文件所属用户。 第四列：为文件所属组。 第五列：为文件大小。 第六列：为文件被修改的时间。 最后一列：为文件名。 可以使用chown改变所属用户，用chgrp改变所属组。 nohup 不要挂起命令 1nohup &lt;command&gt; &gt;file.name 2 &gt;&amp;1 &amp; 1表示标准输出，2表示标准错误输出。2&gt;1&amp;表示将两者合并。 ps 查看当前正在运行的程序使用ps -ef 1ps -ef | grep &lt;progress&gt; awk 下面的命令作用是将.csv文件按照“,”分割并打印第一列和第二列。 1awk -F \",\" '{print 2}' filename.csv 下面的命令作用是获取第三列的最大值。 1awk 'BEGIN{max=0}{if(3&gt;max)max=3}END{print max}' tar 解压缩命令。 参数： -c: 压缩。 -x: 解压缩。 -t: 列出tar文件包含的文件信息。 -r: 附加新的文件到包中。 常用写法： 1234567891011# 压缩、实时显示、强制打包为tartar -cvf &lt;filename&gt;.tar &lt;filename&gt;# 解压缩、实时显示、强制解包tartar -xvf &lt;filename&gt;.tar# 用gzip压缩、实时显示、强制打包为tar.gztar -zcvf &lt;filename&gt;.tar.gz &lt;filename&gt;# 用gzip解压缩、实时显示、强制解包tar.gztar -zxvf &lt;filename&gt;.tar.gz scp scp可以再多个服务器中相互复制传输文件。 常用写法： 将文件A复制到位于网络上的B位置。 1scp -r A B rm 慎用rm。 linux没有回收站机制，将rm命令alias为mv并将要删除文件移入一个目录既可创建回收站机制。 watch 动态监控命令执行结果。 mac没有watch命令，brew安装： 1brew install watch 例子1：每隔一秒高亮显示http连接数变化。 1watch -n 1 -d 'pstree | grep http' 例子2：每隔十秒输出系统的平均负载。 1watch -n 10 'cat /proc/loadavg' df 查看磁盘使用情况。 常用命令： 1df -h tcpdump 和它类似的工具在windows中是wireshark，其采用底层库winpcap/libpcap实现。采用了bpf过滤机制。下面我们看看提供的不同参数的含义。 参数名 含义 -n 使用IP地址表示主机。使用数字表示端口 -i 指定要监听的端口。如果为”-i any”表示住区所有网卡数据包 -v 输出诸如ip数据包中的TTL更加详细的信息 -t 不打印时间戳 -e 显示以太网帧头部信息 -c 仅仅抓取指定数量的数据包 -x 按照十六进制显示数据包内容 -X 不仅仅输出-x结果还输出十六进制对应的ASCII字符 -s 设置抓包时的抓包长度 -w 将输出结果定向到某个文件，一般为pcap后缀 -r 从文件读取数据包并显示数字表示端口 -i 指定要监听的端口。如果为”-i any”表示住区所有网卡数据包 -v 输出诸如ip数据包中的TTL更加详细的信息 -t 不打印时间戳 -e 显示以太网帧头部信息 -c 仅仅抓取指定数量的数据包 -x 按照十六进制显示数据包内容 -X 不仅仅输出-x结果还输出十六进制对应的ASCII字符 -s 设置抓包时的抓包长度 -w 将输出结果定向到某个文件，一般为pcap后缀 -r 从文件读取数据包并显示 知道了相关参数，下面看几个案例 执行任务 执行命令 捕获特定网口数据包 tcpdump -i eth0 捕获特定个数(1000)的包 tcpdump -c 1000 -i eth0 将捕获的包保存到文件 tcpdump -w a.pcap -i eth0 读取pcap格式的包 tcpdump -r a.pcap 增加捕获包的时间戳 tcpdump -n -ttt -i eth0 指定捕获包的协议类型 tcpdump -i eth0 arp 捕获指定端口 tcpdump -i eth0 post 22 捕获特定目标ip+port的包 tcpdump -i eth0 dst address and port 22 捕获DNS请求和响应 tcpdump -i eth0 -s0 port 53 匹配Http请求头 tcpdump -s 0 -v -n -l | egrep -i “POST /|GET /|Host:” 将捕获的包保存到文件 tcpdump -w a.pcap -i eth0 读取pcap格式的包 tcpdump -r a.pcap 增加捕获包的时间戳 tcpdump -n -ttt -i eth0 指定捕获包的协议类型 tcpdump -i eth0 arp 捕获指定端口 tcpdump -i eth0 post 22 捕获特定目标ip+port的包 tcpdump -i eth0 dst address and port 22 捕获DNS请求和响应 tcpdump -i eth0 -s0 port 53 匹配Http请求头 tcpdump -s 0 -v -n -l | egrep -i “POST /|GET /|Host:” lsof 列出当前打开的文件描述符工具，可以得知描述符被声明进程使用。 参数 描述 -i 显示sokcet文件描述符 -c 显示指定的命令打开的所有文件描述符 -t 仅显示打开了目标文件描述符的进程pid 例子： 执行任务 命令 列出所有的网络链接 lsof -i 列出所有udp的网络链接 lsof -i udp 列出谁在使用某个端口 lsof -i :3306 列出谁在使用特定的tcp端口 lsof -i tcp:80 根据文件描述范围列出文件信息 lsof -d 2-3 nc 瑞士军刀，它用来快速构建网络链接。常用来调试客户端程序。 参数 描述 -i 设置数据包传送的时间间隔 -l 以服务器方式运行。默认为客户端运行 -k 重复接受并处理某个端口上的所有链接 -p 以客户端运行时强制其使用指定端口 -C 将CR和LF两个字符作为结束符 -u 使用udp协议。默认tcp协议 -X nc客户端余代理服务器通信时默认为socks5协议。 -z 扫描目标机器某个范围服务是否开启 例子： 执行任务 执行命令 扫描机器A端口号在30-40的服务 nc -z A 30-40 连接服务器A 端口号为5000 nc -C A 5000 传送文件 MachineA:nc -v -n ip portE:\\a.exe netstat 网络信息统计。 可以查看网卡接口、路由表。 参数 描述 -n 使用IP地址表示主机 -a 显示结果中包含监听的socket -t 仅显示TCP连接 -r 显示路由信息 -i 显示网卡接口数据流量 -c 每隔1s输出一次 -o 显示socket定时器的信息 -p 显示socket所属的进程的PID和名字 例子： 执行任务 执行命令 列出所有连接 netstat -a 只列出TCP或者UDP netstat -at/netstat -au 列出监听中的连接 netstat -tnl 获取进程名、进程号以及用户 ID nestat -nlpt 打印统计信息 netstat -s netstat持续输出 netstat -ct 打印active状态的连接 netstat -atnp | grep ESTA 查看服务是否运行(npt) netstat -aple| grep ntp vmstat 实时输出系统进程信息和内存信息以及cpu占用。 参数 描述 -f 显示系统自启动以来执行的fork次数 -s 显示内存相关统计信息 -d 显示磁盘相关统计信息 -p 显示指定磁盘分区统计信息 count 采样次数。 vmstat输出信息字段： 字段名 描述 procs r表示等待运行的而进程数目。b表示处于不可中断睡眠状态的进程数目 memory swpd：使用的虚拟内存量。free：空闲内存量。buff：用作缓冲区的内存量。cache：用作缓存的内存量。 swap si：从磁盘换入的内存量（/s）。so：交换到磁盘的内存量（/s）。 io bi：从块设备接收的块（blocks/s）。bo：发送到块设备的块（blocks/s）。 system in：每秒中断的次数，包括时钟。cs：每秒上下文切换的次数。 mpstat 用于实时监测多个处理器系统中的每个cpu的状态，需要先安装sysstat。 输出信息字段： 字段 描述 cpu 表示当前条信息属于哪个cpu的数据 %usr 进程运行在用户空间所占cpu运行时间的比例 %nice nice值为负的进程运行在用户空间的时间占cpu总运行时间的比例 %iowait cpu等待磁盘操作的时间占cpu总运行时间的比例 %irq cpu用于处理硬件中断时间占cpu总运行时间的比例 %soft cpu用于处理软件中断的时间占cpu用运行时间的比例 %steal 一对虚拟cpu。当超级管理员在处理某个虚拟cpu时，另一个等待它处理完才能运行。这段等待时间表示为steal时间占总运行时间的比例 %guest 运行虚拟cpu时间占cpu总运行时间的比例 %idle 系统空闲时间占cpu总运行时间的比例 split 将文件分割为多个文件。 例子：将README.md文件每隔3行分割为一个文件。 1split -3 README.md wc wc命令的作用是统计文件的字节数、字数、列数。若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。 -c或–bytes或——chars：只显示Bytes数；-l或——lines：只显示行数；-w或——words：只显示字数。 more/less head/tail diff 其他linux命令查询：man","link":"/2020/05/04/interview-linux-commands/"},{"title":"Java复习笔记（一）","text":"Day01: 2020.09.04 今天开始复习java，一天复习一点。 复习资料来自：菜鸟教程：java 概述背景Java是Sun Microsystems在1995年发布的高级程序设计语言。 Sun Microsystems是IT及互联网技术服务公司（已被甲骨文收购）Sun Microsystems 创建于1982年。主要产品是工作站及服务器。 Java可以运行在ARM和x86多个平台上，比如windows、macos、linux、unix等等。 Java有什么： Java语言 JVM Java API Javac等工具 jdk：1，2，3，4jre（Java运行时环境）：2，3 从底层到顶层：JVM -&gt; JRE -&gt; JDK HelloWorld老规矩，现在写第一个java程序：HelloWorld.java 下面创建java文件，文件名要和类名相同。 创建HelloWorld.java文件： 1touch HelloWorld.java HelloWorld.java： 12345public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World\"); }} 上面代码中的String args[]和String[] args都可以，但是还是推荐使用String[] args以避免歧义。 编译并运行12345678# 将java文件编译为class字节码文件javac HelloWorld.java# 运行，无需加.class扩展名java HelloWorld# outputHello World 简介java体系java有三个体系：Java EE（企业版）,Java SE（标准版）,Java ME（微型版）。我使用了Java SE的jdk。 java特性 简单 面向对象 分布式 健壮性 安全 体系结构中立 可移植 解释型 高性能 多线程 动态 java历史1995年5月23日，Java语言诞生 java开发工具硬件要求：内存1G以上。系统要求：linux、macos、windows。JDK：7、8…编辑器：notepad、sublime text（收费）、vscode（开源且免费）等等。IDE：eclipse（开源且免费）、idea（收费）等等。 编辑器/IDE这里我主要使用vscode和idea。 开发环境配置开发java需要在机器上安装oracle jdk（java开发工具包）或者OpenJDK。 我这里使用Java SE 8。 查看是否安装成功： 安装成功！ 基础语法一个Java程序可以认为是一系列对象的集合，而这些对象通过彼此的方法来协同。 几个基本概念下面十几个重要的概念： 对象：对象是类的一个实例，有状态和行为。 类：是一个模板，描述一类对象的状态和行为。 方法：方法就是行为，逻辑运算、数据修改等所有动作都是在方法中修改的。 实例变量：每个对象都有独特的实例变量，对象的状态由实例变量的值决定。 第一个java程序实例： 12345678public class HelloWorld { /* 第一个Java程序 * 它将打印字符串 Hello World */ public static void main(String[] args) { System.out.println(\"Hello World\"); // 打印 Hello World }} 保存 编译 运行： 创建文件：HelloWorld.java 编写代码 编译：javac HelloWorld.java 运行：java HelloWorld 基本语法几条tips： java大小写敏感。 类名首字母大写，并且如果类名是由多个单词组成，那么每个单词首字母都要大写。 方法名以小写开头，采用驼峰式命名。 java文件名和类名要相同。 主方法入口：public static void main(String[] args){}，在最后的{}中编写代码。 标识符类名、变量名、方法名都叫做标识符。 标识符规则： 只能以A-Z,a-z,$,_开始。 第一个字符之后可以用A-Z,a-z,$,_以及数组。 关键字不能作为标识符。 标识符大小写敏感。 修饰符java中的修饰符用来修饰类中的属性和方法。 修饰符种类： 访问控制修饰符：default,public,protected,private 非访问控制修饰符：final,abstract,static,synchronized 变量java变量类型： 局部变量 类变量（静态变量） 成员变量（非静态变量） 数组数组是存储在堆上的对象，可以保存多个同类型的变量。 枚举所谓枚举就是：限制了变量只能是预先设定好的值。 实例： 1234567891011class FreshJuice { enum FreshJuiceSize{ SMALL, MEDIUM, LARGE } FreshJuiceSize size;}public class FreshJuiceTest { public static void main(String[] args){ FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.medium; }} 关键字java关键字有这些： 注释支持单行、多行注释，编译器会忽略注释。编译器还会忽略空白行。 12345678910public class HelloWorld { public static void main(String[] args) { // 单行注释方法一 /* 单行注释方法二 */ /* 多行注释 * 多行注释 */ System.out.println(\"Hello World\"); }} 继承java可以使用继承来重用已存在的类，被继承的类称之为超类，派生出来的类称之为子类。 接口java中的接口可以理解我对象之间相互通信的协议。 关于Java的编译运行 由图可见，.java源文件经过编译后生成.class字节码文件，然后交由JVM解释运行。故而从性能而言，java还是不如c/cpp这些编译型语言。 对象和类java的基本概念： 封装 继承 多态 抽象 类 对象 实例 方法 重载 对象：对象是类的一个实例，有状态和行为。类：类是一个模板，描述一类对象的状态和行为。 对象对象就是类的实例，有自己的属性和方法。 类类就是对象的模板，是对对象的抽象。 实例： 12345678910111213public class Dog{ String breed; int age; String color; void barking(){ } void hungry(){ } void sleeping(){ }} 一个类可以包含这几种变量：局部变量，成员变量，类变量。局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。 构造方法每个类都有构造防范，如果没有定义则编译器会自动提供一个默认的构造方法。 在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 实例： 12345678public class Puppy{ public Puppy(){ } public Puppy(String name){ // 这个构造器仅有一个参数：name }} 创建对象对象是由类创建的。 如何创建对象？使用关键字new创建新对象： 首先声明一个对象。 使用new创建对象。 初始化对象。 12345678910public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); }} 访问对象变量和方法123456/* 实例化对象 */Puppy myPuppy = new Puppy( \"tommy\" );/* 访问类中的变量 */myPuppy.age;/* 访问类中的方法 */myPuppy.barking(); 实例123456789101112131415161718192021222324252627public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); }} 运行： 源文件声明规则 一个源文件只能有一个public类。 一个源文件可以有多个非public类。 源文件名要和public类名相同。 如果一个类定义在某个包中，那么package语句要在源文件首行。 如果源文件包含import语句，import应该放在package语句和类定义之间。如果没有package语句则import要放在源文件最前面。 import和package对源文件中定义的所有类都有效，在同一源文件中，不能给不同的类不同的包声明。 类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。还有特殊的类比如内部类和匿名类。 java包包用来对类和接口分类。 import实例：下面代码将会使编译器载入java_installation/java/io路径下的所有类。 1import java.io.*; 实例现在创建两个类：Employee和EmployeeTest，Employee类没有主函数，EmployeeTest有主函数。这里EmployeeTest调用了Employee的属性和方法。 Employee.java: 12345678910111213141516171819202122232425262728293031import java.io.*; public class Employee{ String name; int age; String designation; double salary; // Employee 类的构造器 public Employee(String name){ this.name = name; } // 设置age的值 public void empAge(int empAge){ age = empAge; } /* 设置designation的值*/ public void empDesignation(String empDesig){ designation = empDesig; } /* 设置salary的值*/ public void empSalary(double empSalary){ salary = empSalary; } /* 打印信息 */ public void printEmployee(){ System.out.println(\"名字:\"+ name ); System.out.println(\"年龄:\" + age ); System.out.println(\"职位:\" + designation ); System.out.println(\"薪水:\" + salary); }} EmployeeTest.java: 1234567891011121314151617181920import java.io.*;public class EmployeeTest{ public static void main(String[] args){ /* 使用构造器创建两个对象 */ Employee empOne = new Employee(\"RUNOOB1\"); Employee empTwo = new Employee(\"RUNOOB2\"); // 调用这两个对象的成员方法 empOne.empAge(26); empOne.empDesignation(\"高级程序员\"); empOne.empSalary(1000); empOne.printEmployee(); empTwo.empAge(21); empTwo.empDesignation(\"菜鸟程序员\"); empTwo.empSalary(500); empTwo.printEmployee(); }} 编译运行： 12javac EmployeeTest.javajava EmployeeTest 运行结果： 12345678名字:RUNOOB1年龄:26职位:高级程序员薪水:1000.0名字:RUNOOB2年龄:21职位:菜鸟程序员薪水:500.0 基本数据类型变量就是用来存储数据的，java创建变量的时候会向内存申请空间。内存管理系统根据变量的类型为其分配内存空间，改内存空间仅能用于存储改类型的数据。 实例： 12// 申请一个内存空间，类型为int，并将数字7存入int x = 7; java两大数据类型： 内置数据类型 引用数据类型 内置数据类型java内置了8中基本数据类型，其中有6种数字数据类型（4个整型+2个浮点型），一个字符数据类型，一个布尔型。 byte byte类型是8位、有符号、二进制补码表示的整数。最小值是-128（-2^7），最大值是127（2^7-1），默认值为0。byte类型的用处是节约空间，因为byte类型的空间占用只有int类型的1/4，主要是代替整数。 实例： 1byte a = 3; short short类型是16位、有符号、二进制补码表示的整数。最小值是-32768（-2^15），最大值是32767（2^15 - 1），默认值为0。一个short变量的空间占用是int类型的1/2。 实例： 1short s = 1000; int int类型是32位、有符号、二进制补码表示的整数。最小值是-2,147,483,648（-2^31），最大值是2,147,483,647（2^31 - 1），默认值为0。一般整型变量默认为int类型。 实例： 1int a = 10000; long long类型是64位、有符号的、二进制补码表示的整数。最小值是-9,223,372,036,854,775,808（-2^63），最大值是9,223,372,036,854,775,807（2^63 -1），默认值为0L。long类型主要是用在对于数字需求比较大的系统上。 实例： 12// 大小写皆可，不过为了区分它和1，建议采用大写的Llong a = 100000L; float float类型是单精度、32位、符合IEEE754标准的浮点数。float在存储大型浮点数组的时候可以节省内存空间。默认值为0.0f。浮点数不能用于表示精确的值。 实例： 1float f1 = 234.5f; double double类型是双精度的、64位、符合IEEE754标准的浮点数。浮点数默认类型为double类型。double也不能表示精确的值。默认值0.0d 实例： 1double d1 =123.4; boolean boolean类型是表示一个比特的信息。boolean取值只有true和false。默认值false。 实例： 1boolean opened = true; char char类型是一个单一的16位unicode字符。最小值\\u0000（即为0），最大值\\uffff（即为65,535）。char类型可以存储任意字符。 实例： 1char words = 'this'; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class PrimitiveTypeTest { public static void main(String[] args) { // byte System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE); System.out.println(\"包装类：java.lang.Byte\"); System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE); System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE); System.out.println(); // short System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE); System.out.println(\"包装类：java.lang.Short\"); System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE); System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE); System.out.println(); // int System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE); System.out.println(\"包装类：java.lang.Integer\"); System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE); System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE); System.out.println(); // long System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE); System.out.println(\"包装类：java.lang.Long\"); System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE); System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE); System.out.println(); // float System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE); System.out.println(\"包装类：java.lang.Float\"); System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE); System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE); System.out.println(); // double System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE); System.out.println(\"包装类：java.lang.Double\"); System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE); System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE); System.out.println(); // char System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE); System.out.println(\"包装类：java.lang.Character\"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println(\"最小值：Character.MIN_VALUE=\" + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println(\"最大值：Character.MAX_VALUE=\" + (int) Character.MAX_VALUE); } } 输出： 12345678910111213141516171819202122232425262728293031323334基本类型：byte 二进制位数：8包装类：java.lang.Byte最小值：Byte.MIN_VALUE=-128最大值：Byte.MAX_VALUE=127基本类型：short 二进制位数：16包装类：java.lang.Short最小值：Short.MIN_VALUE=-32768最大值：Short.MAX_VALUE=32767基本类型：int 二进制位数：32包装类：java.lang.Integer最小值：Integer.MIN_VALUE=-2147483648最大值：Integer.MAX_VALUE=2147483647基本类型：long 二进制位数：64包装类：java.lang.Long最小值：Long.MIN_VALUE=-9223372036854775808最大值：Long.MAX_VALUE=9223372036854775807基本类型：float 二进制位数：32包装类：java.lang.Float最小值：Float.MIN_VALUE=1.4E-45最大值：Float.MAX_VALUE=3.4028235E38基本类型：double 二进制位数：64包装类：java.lang.Double最小值：Double.MIN_VALUE=4.9E-324最大值：Double.MAX_VALUE=1.7976931348623157E308基本类型：char 二进制位数：16包装类：java.lang.Character最小值：Character.MIN_VALUE=0最大值：Character.MAX_VALUE=65535 java中各个类型的默认值： 实例：输出各个数据类型的默认值 1234567891011121314151617181920212223public class Test { static boolean bool; static byte by; static char ch; static double d; static float f; static int i; static long l; static short sh; static String str; public static void main(String[] args) { System.out.println(\"Bool :\" + bool); System.out.println(\"Byte :\" + by); System.out.println(\"Character:\" + ch); System.out.println(\"Double :\" + d); System.out.println(\"Float :\" + f); System.out.println(\"Integer :\" + i); System.out.println(\"Long :\" + l); System.out.println(\"Short :\" + sh); System.out.println(\"String :\" + str); }} 输出： 123456789Bool :falseByte :0Character:Double :0.0Float :0.0Integer :0Long :0Short :0String :null 引用类型引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明的时候被指定为一个特定类型比如Puppy等等，一旦声明就不能改变。 对象、数组都是引用数据类型。 所有引用类型默认值都是null。 一个引用变量可以用来引用任何与之兼容的类型。 实例： 1Site site = new Site(\"cool\"); 常量常量也就是不能被修改的量。 如何定义常量？使用final关键字修饰常量： 1final double PI = 3.1415; 正如上面缩写，常量名为了便于识别一般使用全大写。 字面量字面量：\b其实，字面量的意思就是“字面上的量”，比如java中的一个数字66就是一个字面量，还有&quot;this is a line of string!&quot;就是一个字面量，还比如true和false也是字面量。 字面量表示的是如何表达一个值，所以在声明并赋值变量的时候，赋值符号=后面的;前面的就是字面量。 byte,int,long,short都可以用十进制、八进制、十六进制表示。前缀0表示八进制，前缀0x表示十六进制。实例： 123int decimal = 100;int octal = 0144;int hexa = 0x64; java的字符串字面量是由两个引号包裹的字符串： 123\"Hello World\"\"two\\nlines\"\"\\\"This is in quotes\\\"\" 除此之外，字符串还可以包含任意unicode字符： 12char a = '\\u0001';String a = \"\\u0001\"; 转义字符：换行：\\n回车：\\r换页符：\\f退格：\\b空字符：\\0空格：\\s制表符：\\t双引号：\\&quot;单引号：\\'反斜杠：\\\\八进制字符：\\ddd16进制unicode字符：\\uxxx 类型转换整型、常量、字符型数据可以混合运算。转换从低级到高级。 12低级 --------------------------------------- 高级byte,short,char —&gt; int —&gt; long —&gt; float —&gt; double 数据类型转换规则： 对boolean类型不能转换。 不能将对象类型转换为不相关类的对象。 将容量大的类型转换为小容量的类型的时候需要使用强制类型转换。 转换可能导致数据溢出或者精度损失。 浮点数转换到整数是通过舍弃小数得到的。 实例： 123456789// 声明一个int型变量i并赋值128int i = 128;// 对i进行强制类型转换为byte型，因为byte最大值为127，故而强制类型转换会导致溢出byte b = (byte)i;// 浮点数转换为整数(int)12.3 == 12;(int)-45.89f == -45 自动类型转换规则：转换前的数据类型的位数要低于转换后的数据类型。 实例： 12345678910public class ZiDongLeiZhuan{ public static void main(String[] args){ char c1='a';//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println(\"char自动类型转换为int后的值等于\"+i1); char c2 = 'A';//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println(\"char类型和int计算后的值等于\"+i2); }} 输出： 12char自动类型转换为int后的值等于97char类型和int计算后的值等于66 上面字符对应的数字要查ASCII码。 强制类型转换规则：转换的数据类型必须兼容。 格式：新类型 新变量名 = (新类型)旧变量名比如：byte b = (byte)a; 实例： 1234567public class QiangZhiZhuanHuan{ public static void main(String[] args){ int i1 = 123; byte b = (byte)i1;//强制类型转换为byte System.out.println(\"int强制类型转换为byte后的值等于\"+b); }} 输出： 1int强制类型转换为byte后的值等于123 隐含强制类型转换 整数的默认类型是int 浮点型不存在隐含强制类型转换，因为定义float/double的时候必须在浮点数后面加上f/F或者d/D。 Day01: 2020.09.04","link":"/2020/09/04/java-review-01/"},{"title":"Java复习笔记（二）","text":"Day02: 2020.09.05 变量类型java中的所有变量使用之前都必须要声明。 声明实例： 123456int a, b, c;int d = 3, e = 4;byte z = 2;String str = \"this is a line of string\";double pi = 2.14;char x = 'a'; java支持的变量类型有：类变量：独立于方法之外的变量，用static修饰。实例变量：独立于方法之外的变量，没有static修饰。局部变量：类的方法中的变量。 123456789101112public class Variable{ // 类变量 static int count = 0; // 实例变量 String str = 'asd'; public void method(){ // 局部变量 int a = 1; }} 局部变量 局部变量声明在方法、构造方法或者语句块中。 局部变量在方法、构造方法、或者语句块被执行的时候创建，执行完毕就会被销毁。 访问修饰符不能用于局部变量。 局部变量只在声明它的方法、构造方法或者语句块中可见。 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后必须要初始化才能使用。 实例1：age是一个局部变量，定义在pupAge()中，age的作用域就限制在该方法中。Test.java: 12345678910111213141516public class Test{ // pupAge()方法 public void pupAge(){ int age = 0; age = age + 7; System.out.println(\"小狗的年龄是：\" + age); } // 主函数，调用pupAge() public static void main(String[] args){ // new一个Test类的实例 Test test = new Test(); // 调用Test类的pupAge()方法，如果成功的话则第一次会输出7，而且再次运行也会是输出7 test.pupAge(); }} 第一次运行输出： 1小狗的年龄是：7 第二次运行输出： 1小狗的年龄是：7 可以看到age并没有再次+7，也就是说age变量仅限于执行中，执行完毕age就被销毁了。 实例2：下面的局部变量age变量没有初始化，故而javac的时候会报错。 12345678910111213public class Test{ public void pupAge(){ // 局部变量age没有初始化 int age; age = age + 7; System.out.println(\"小狗的年龄是 : \" + age); } public static void main(String[] args){ Test test = new Test(); test.pupAge(); }} 编译出错：variable number might not have been initialized。变量还没有被初始化。 实例变量 声明在一个类中，但是在方法、构造方法和语句块之外。 当一个对象被实例化后，每个实例变量的值就跟着确定。 实例变量在对象创建的时候创建，在对象被销毁的时候销毁。 实例变量的值至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方法获取实例变量信息。 实例变量可以声明在使用前或者使用后。 访问修饰符可以修饰实例变量。 实例变量对于类中的方法、构造方法或者语句块是可见的，一般情况下应该吧实例变量设为私有，通过使用访问修饰符可以使实例变量对子类可见。 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 实例：Employee.java 123456789101112131415161718192021222324252627import java.io.*;public class Employee{ // 这个实例变量对子类可见 public String name; // 私有变量，仅在该类可见 private double salary; //在构造器中对name赋值 public Employee (String empName){ name = empName; } //设定salary的值 public void setSalary(double empSal){ salary = empSal; } // 打印信息 public void printEmp(){ System.out.println(\"名字 : \" + name ); System.out.println(\"薪水 : \" + salary); } public static void main(String[] args){ Employee empOne = new Employee(\"RUNOOB\"); empOne.setSalary(1000.0); empOne.printEmp(); }} 编译并运行： 12名字 : RUNOOB薪水 : 1000.0 类变量（静态变量） 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 实例：Employee.java 123456789101112import java.io.*; public class Employee { //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = \"开发人员\"; public static void main(String[] args){ salary = 10000; System.out.println(DEPARTMENT+\"平均工资:\"+salary); }} 输出： 1开发人员平均工资:10000.0 如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT。 修饰符修饰符的分类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。 一共有4中访问控制修饰符： default（即不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private: 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 public: 对所有类可见。使用对象：类、接口、变量、方法。 protected: 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 默认访问修饰符：不使用任何关键字。 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 Day02: 2020.09.05","link":"/2020/09/05/java-review-02/"},{"title":"jQuery学习笔记（一）","text":"学习一下jquery jquery入门 jquery 是一个js库，它简化了js编程。 jquery实例： jquery入口函数12345$(document).ready(function() { $(\"div\").click(function() { $(this).hide(); });}); jquery前置知识： html css javascript jquery的功能有： html元素抓取 html元素操作 css操作 html事件函数 js特效和动画 html DOM的遍历和修改 ajax utilities 使用jquery主要因为用jquery的企业多。 关于jquery对IE的支持： jquery2以上不支持IE6.，7，8。 如果要支持IE6.，7，8，选择jquery1.9. 一般使用jquery1.x就可以了。 条件注释，判断IE版本自动选择jquery版本： 123456&lt;!--[if lt IE 9]&gt; &lt;script src=\"jquery-1.9.0.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;!--[if gte IE 9]&gt;&lt;!--&gt;&lt;script src=\"jquery-2.0.0.js\"&gt;&lt;/script&gt;&lt;!--&lt;![endif]--&gt; jquery安装下载jquery分为开发环境版本（未压缩）和生产环境版本（已压缩），从jquery官网下载：https://jquery.com/download/ 。 引入方法一： 将下载的 jquery.js 文件放到项目目录下。 html中引入： 1&lt;script src=\"jquery.js\"&gt;&lt;/script&gt; html5中引入js不需要加上 type=&quot;text/javascript&quot; 。 方法二： 使用静态资源cdn，比如75cdn。 使用cdn的好处是如果用户之前访问了某些网站加载过jquery文件则无需再次加载。 1&lt;script src=\"https://lib.baomitu.com/jquery/1.12.4/jquery.js\"&gt;&lt;/script&gt; 控制台查看页面使用的jquery版本： 1$.fn.jquery jquery语法基本语法通过jquery，我们可以选取（query）页面元素，并对元素进行操作（actions）。 jquery基础语法： 1234$(selector).action();// 美元符号定义了jquery// selector使用css选择器语法选取html元素// action()对选取的元素执行一些操作 实例： 12$(this).hide();$(\"p.test\").hide(); 文档就绪事件所有的jquery代码都要写在文档就绪事件函数中（或者说jquery入口函数）。 jquery入口函数是在DOM全都加载完毕后执行。 12345678910111213141516&lt;!--引入jquery--&gt;&lt;script src=\"js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;!--写法一--&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function() { // jquery code });&lt;/script&gt;&lt;!--写法二--&gt;&lt;script type=\"text/javascript\"&gt; $(function() { // jquery code });&lt;/script&gt; js入口函数：在DOM以及所有外部资源都加载完毕后执行 123window.onload = function() { // js code} jquery选择器jquery选择器可以对单个元素或者多个元素进行操作。 jquery除了支持css选择器之外，还有自己的选择器。 下面是常用的jquery选择器： 123456789101112131415161718192021222324252627282930$(\"*\")$(this)$(\"tag\")$(\"#id\")$(\".class\")$(\"tag.class\")$(\"tag#id\")$(\"p:first\") // 选取第一个p元素$(\"ul li:first\") // 选取第一个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素$(\"ul li:first-child\") // 选取每个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素$(\"[href]\")$(\"a[target='_blank']\")$(\"a[target!='_blank']\")$(\":button\") // 选取所有 type=\"button\" 的 &lt;input&gt; 元素 和 &lt;button&gt; 元素$(\"tr:even\") // 选取偶数位置的 &lt;tr&gt; 元素$(\"tr:odd\") // 选取奇数位置的 &lt;tr&gt; 元素$(\"#id, .class\") // 复合选择器$(\"div p span\") // 层级选择器 //div下的p元素中的span元素$(\"div&gt;p\") // 父子选择器div下的所有p元素$(\"div+p\") // 相邻元素选择器div后面的p元素(仅一个p)$(\"div~p\") // 兄弟选择器div后面的所有p元素(同级别)$(\".p:last\") // 类选择器加过滤选择器 第一个和最后一个（first 或者 last）$(\"div p:eq(2)\") // 索引选择器div下的第三个p元素（索引是从0开始）$(\"p:contains(test)\") // 内容过滤选择器，包含text内容的p元素$(\":empty\") // 内容过滤选择器，所有空标签（不包含子标签和内容的标签）parent相反$(\":hidden\") // 所有隐藏元素$(\"input:enabled\") // 选取所有启用的表单元素$(\":disabled\") // 所有不可用的元素$(\"input:checked\") // 获取所有选中的复选框单选按钮等$(\"select option:selected\") // 获取选中的选项元素 tips： 最好将jquery代码放入一个单独的js文件中。 比如： 1234&lt;head&gt; &lt;script src=\"jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"js/my_jquery_code.js\"&gt;&lt;/script&gt;&lt;/head&gt; jquery事件常用的jquery事件常用的jquery事件： 鼠标事件： click dblclick mouseenter mouseleave hover 键盘事件： keypress：按下触发，返回ascii代码，对于修饰键无效。 keydown：只要按着就不停地触发，返回按键代码。 keyup：松开按键触发，返回按键代码。 表单事件： submit change focus blur 窗口事件： load resize scroll unload jquery事件方法语句123$(\"input\").click(function() { // actions}); jquery常用事件方法 $(document).ready() jquery入口函数。 click() 元素被点击时触发函数。 123$(\"p\").click(function() { $(this).hide();}); dblclick() 双击元素触发函数。 123$(\"p\").dblclick(function() { $(this).hide();}); mouseenter() 鼠标指针进入元素时触发。 123$(\"#p1\").mouseenter(function() { alert('您的鼠标移到了 id=\"p1\" 的元素上!');}); mouseleave() 鼠标指针离开元素的时候触发。 123$(\"#p1\").mouseleave(function() { alert(\"再见，您的鼠标离开了该段落。\");}); 除此之外还有： mousedown()：按下鼠标时触发 mouseup()：松开鼠标时触发 hover()：悬停时触发 focus()：获取焦点时触发 blur()：失去焦点时触发 tips keypress, keydown, keyup的区别:1.keydown：在键盘上按下某键时发生, 一直按着则会不断触发（opera浏览器除外）, 它返回的是键盘代码;2.keypress：在键盘上按下一个按键，并产生一个字符时发生, 返回ASCII码。注意: shift、alt、ctrl等键按下并不会产生字符，所以监听无效 , 换句话说, 只有按下能在屏幕上输出字符的按键时keypress事件才会触发。若一直按着某按键则会不断触发。3.keyup：用户松开某一个按键时触发, 与keydown相对, 返回键盘代码. 实例：拿到按下的键的按键代码 123$(window).keydown(function() { var val = event.which;}); 实例：给事件处理函数传递参数，语法： jQueryObject.keypress( [[ data ,] handler ] ); 123456789var validKeys = { start: 65, end: 90};$(\"#keys\").keypress(validKeys, function(event) { var keys = event.data; //拿到validKeys对象. return event.which &gt;= keys.start &amp;&amp; event.which &lt;= keys.end;});","link":"/2018/06/09/jquery-tutorial-1/"},{"title":"jQuery学习笔记（二）","text":"第二部分是jquery的效果。 jquery显示隐藏jquery的效果有显示、隐藏、切换、滑动、淡入淡出、动画。 隐藏和显示使用 hide() 和 show() 。 语法： 12$(selector).hide(speed, callback);$(selector).show(speed, callback); speed参数规定了速度，可以是slow，fast或者毫秒数。 实例： 12345678910111213$(\"#hide\").click(function() { $(\"p\").hide(1000， callback);});$(\"#show\").click(function() { $(\"p\").show(1000, callback);});$(\"#hide\").click(function() { $(\"div\").hide(1000, \"linear\", function() { window.alert(\"已经隐藏\"); });}); 缓动函数可以是linear或者swing。 toggle()toggle() 用于切换hide()和show()。 语法： $(selector).toggle(speed, callback); 123$(\"button\").click(function() { $(\"p\").toggle();}); tips 如果写成callback()则会立即执行函数。 callback可以是匿名函数。 jquery淡入淡出jquery有四种淡入淡出方法。 fadeIn() fadeOut() fadeToggle() fadeTo() fadeIn()将已经隐藏的元素淡入地显示。 语法： $(selector).fadeIn(speed, callback); 实例： 12345$(\"button\").click(function() { $(\"#div1\").fadeIn(); $(\"#div2\").fadeIn(\"slow\"); $(\"#div3\").fadeIn(3000);}); fadeOut()将显示的元素淡出地隐藏。 语法： $(selector).fadeOut(speed, callback); 实例： 12345$(\"button\").click(function() { $(\"#div1\").fadeOut(); $(\"#div2\").fadeOut(\"slow\"); $(\"#div3\").fadeOut(3000);}); fadeToggle()fadeToggle()可以在fadeIn()和fadeOut()之间切换。 语法： $(selector).fadeToggle(speed, callback); 实例： 12345$(\"button\").click(function() { $(\"#div1\").fadeToggle(); $(\"#div2\").fadeToggle(\"slow\"); $(\"#div3\").fadeToggle(3000);}); fadeTo()将元素渐变为指定的透明度（0-1）。 语法： $(selector).fadeTo(speed, opacity, callback); speed是必须的参数。 实例： 12345$(\"button\").click(function() { $(\"#div1\").fadeTo(\"slow\", 0.15); $(\"#div2\").fadeTo(\"slow\", 0.4); $(\"#div3\").fadeTo(\"slow\", 0.7);}); jquery滑动滑动着隐藏和显示元素。 slideDown(), slideUp(), slideToggle() slideDown()slideDown()用于向下（显示）滑动元素。 语法： $(selector).slideDown(speed, callback); 实例： 1234$(\"#flip\").click(function() { // 这里#panel要设为display: none; $(\"#panel\").slideDown();}); slideUp()用于向上滑动元素（隐藏）。 语法： $(selector).slideUp(speed, callback); 实例： 123$(\"#flip\").click(function() { $(\"#panel\").slideUp();}); slideToggle()用于在slideDown()和slideUp()中切换。 实例： 先要将panel隐藏 123$(\"#flip\").click(function() { $(\"#panel\").slideToggle();}); jquery动画animate()可以自定义动画。 animate()语法： $(selector).animate({params}, speed, callback); params参数定义动画的css。 实例： 123456// 先将position设置为positioned$('button').click(function() { $('div').animate({ left: '100px' }, 1000, callback);}); 操作多个属性实例： 123456789$(\"button\").click(function() { // 这里每条css属性后面用的是逗号不是分号，属性名使用驼峰式 $(\"div\").animate({ left: '250px', opacity: '0.5', height: '150px', width: '150px' }, 1000, callback);}); 使用相对值实例： 1234567$(\"button\").click(function() { $(\"div\").animate({ left: '250px', height: '+=150px', width: '+=150px' });}); 使用预定义的值实例： 12345$(\"button\").click(function(){ $(\"div\").animate({ height:'toggle' });}); 使用队列如果创建了多个animate()则jquery会逐一运行。 停止动画在动画停止之前可以使用stop()手动停止动画。 语法：$(selector).stop(stopAll, goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 默认地，stop() 会清除在被选元素上指定的当前动画。 实例： 123$('div').click(function() { $('input').stop();}); callback()callback()在动画完成后执行。 chainingjquery支持链式操作，可以将一系列方法写成一个链。 实例： 1$(\"#p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000); 也可以这样写： 123$(\"#p1\").css(\"color\",\"red\") .slideUp(2000) .slideDown(2000);","link":"/2018/06/10/jquery-tutorial-2/"},{"title":"jQuery学习笔记（四）","text":"jquery遍历 jquery遍历就是查找元素，从一个元素开始沿着这个元素移动并到达期望请选择的元素。 遍历 在DOM中存在这几种关系： 父子元素 兄弟元素 祖先元素，后代元素 祖先 parent()：返回被选元素的父元素。 parents()：返回被选元素的所有祖先元素直到根元素。 parentsUntil()：返回两个给定元素之间的所有祖先元素。 使用过滤器： 123456789// parents()过滤器$(document).ready(function(){ $(\"span\").parents(\"ul\");});// parentsUntil()$(document).ready(function(){ $(\"span\").parentsUntil(\"div\");}); 后代 children()：返回被选元素的所有直接子元素。 find()：返回被选元素的所有后代元素。 也可以使用过滤器。 兄弟兄弟节点拥有相同的父元素。 siblings()：返回被选元素的所有兄弟元素。 next()：返回被选元素的下一个兄弟元素。 nextAll()：返回被选元素的后面的所有兄弟元素。 nextUntil()：返回介于两个给定参数之间的所有兄弟元素。 prev()：返回被选元素的上一个兄弟元素。 prevAll()：返回被选元素的前面的所有兄弟元素。 prevUnitl()：返回介于两个给定参数之间的所有兄弟元素。 过滤过滤是为了缩小搜索的范围。 first()：返回被选元素的第一个元素。 last()：返回被选元素的最后一个元素。 eq()：选择指定index的元素。 filter()：返回被选元素中匹配的元素。 not()：返回被选元素中不匹配的元素。 filter()和not()相反。","link":"/2018/06/11/jquery-tutorial-4/"},{"title":"jQuery学习笔记（三）","text":"这篇是jquery操作DOM的部分。 捕获元素和属性获取内容和属性值 text()：获取或设置元素的文本内容。 html()：获取或设置元素的内容。 val()：获取或设置表单字段的值。 实例： 1234567891011$(\"#btn1\").click(function() { alert(\"Text: \" + $(\"#test\").text());});$(\"#btn2\").click(function() { alert(\"HTML: \" + $(\"#test\").html());});$(\"#btn1\").click(function() { alert(\"值为: \" + $(\"#test\").val());}); attr()：获取和设置元素的属性值。 实例： 123456789101112131415161718192021222324// 获取$(\"button\").click(function() { alert($(\"#runoob\").attr(\"href\"));});// 设置$(\"button\").click(function() { $(\"#runoob\").attr(\"href\", \"http://www.runoob.com/jquery\");});// 同时设置多个属性值$(\"button\").click(function() { $(\"#runoob\").attr({ \"href\": \"http://www.runoob.com/jquery\", \"title\": \"jQuery 教程\" });});// attr()回调函数$(\"button\").click(function() { $(\"#runoob\").attr(\"href\", function(i, origValue) { return origValue + \"/jquery\"; });}); 设置内容和属性值设置内容和属性值使用的也是上面三个方法。 实例： 1234567891011$(\"#btn1\").click(function() { $(\"#test1\").text(\"Hello world!\");});$(\"#btn2\").click(function() { $(\"#test2\").html(\"&lt;b&gt;Hello world!&lt;/b&gt;\");});$(\"#btn3\").click(function() { $(\"#test3\").val(\"RUNOOB\");}); 设置内容可以有回调函数，回调函数有两个参数，第一个参数是被选元素列表中当前元素的下标，第二个参数是旧值。 实例： 1234567891011$(\"#btn1\").click(function() { $(\"#test1\").text(function(i, origText) { return \"旧文本: \" + origText + \" 新文本: Hello world! (index: \" + i + \")\"; });});$(\"#btn2\").click(function() { $(\"#test2\").html(function(i, origText) { return \"旧 html: \" + origText + \" 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: \" + i + \")\"; });}); tips attr()：自定义属性用attr() prop()：元素固有属性用prop() 添加元素 append()：在被选元素中最后面插入内容。 prepend()：在被选元素中最前面插入内容。 after()：在被选元素后面插入内容。 before()：在被选元素前面插入内容。 实例： 12$('p').append('abc');$('p').prepend('abc'); 实例： 1234567function appendText() { var text1 = '&lt;p&gt;文本-1。&lt;/p&gt;'; var text2 = $(\"&lt;p&gt;&lt;/p&gt;\").text(\"文本-2。\"); var text3 = document.createElement(\"p\"); text3.innerHTML = '文本'; $('p').append(text1, text2, text3);} 实例： 12$(\"img\").after(\"在后面添加文本\");$(\"img\").before(\"在前面添加文本\"); 实例： 1234567function afterText() { var text1 = '&lt;p&gt;文本-1。&lt;/p&gt;'; var text2 = $(\"&lt;p&gt;&lt;/p&gt;\").text(\"文本-2。\"); var text3 = document.createElement(\"p\"); text3.innerHTML = '文本'; $('p').after(text1, text2, text3);} 删除元素 remove()：删除被选元素及其子元素。 empty()：删除被选元素的子元素。 实例： 12$('div').remove();$('div').empty(); 还可以传一个参数（选择器）来选择要删除的元素： 1$(\"p\").remove(\".italic\"); 获取和设置css操作css addClass()：给元素添加类。 removeClass()：移除类。 toggleClass()：切换添加删除类。 css()：获得或者设置css属性。 实例： 123456789101112131415161718192021// 添加类$(\"button\").click(function() { $(\"h1,h2,p\").addClass(\"blue\"); $(\"div\").addClass(\"important warn alert\");});// 移除类$(\"button\").click(function() { $(\"h1,h2,p\").removeClass(\"blue\");});// 切换类$(\"button\").click(function() { $(\"h1,h2,p\").toggleClass(\"blue\");});// css()$(\"p\").css(\"background-color\");$(\"p\").css(\"background-color\",\"yellow\");$(\"p\").css({\"background-color\":\"yellow\",\"font-size\":\"200%\"});$(\"p\").eq(index).css(); jquery盒子模型 width()：取得或设置元素的宽度。 height()：取得或设置元素的高度。 innerWidth()：取得元素的width加上左右padding。 innerHeight()：取得元素的height加上上下padding。 outerWidth()：取得元素的width加上左右padding和border-width。 outerHeight()取得元素的height加上上下padding和border-width。","link":"/2018/06/11/jquery-tutorial-3/"},{"title":"jQuery学习笔记（五）","text":"Ajax（异步js和XML）是浏览器和服务器交换数据的技术，它实现了在不刷新页面的情况下对于页面的局部刷新。 jquery提供了多个Ajax方法，可以 GET/POST 服务器数据。 load()load() 是从服务器家在数据并将返回的数据写入到页面元素中。 语法： $(selector).load(URL,data,callback); URL：请求的地址。data：随请求发送到服务器的数据（键值对集合）。callback：load()完成后的回调函数。 实例： 12$(\"#div1\").load(\"demo_test.txt\");$(\"#div1\").load(\"demo_test.txt #p1\"); callback()的参数： responseTxt：包含调用成功时的结果内容 statusTXT：包含调用的状态 xhr：包含XMLHttpRequest对象 实例： 12345678$(\"button\").click(function() { $(\"#div1\").load(\"demo_test.txt\", function(responseTxt, statusTxt, xhr) { if (statusTxt == \"success\") alert(\"外部内容加载成功!\"); if (statusTxt == \"error\") alert(\"Error: \" + xhr.status + \": \" + xhr.statusText); });}); GET/POST浏览器请求服务器数据有两种方式：GET和POST。 GET：从指定url请求数据，可能会返回缓存数据。 POST：向指定url提交数据，不会缓存数据。 GET和POST的不同 $.get()语法： $.get(URL, callback); 实例： 12345$(\"button\").click(function() { $.get(\"demo_test.php\", function(data, status) { alert(\"数据: \" + data + \"\\n状态: \" + status); });}); $.post()语法： $.post(URL, callback); 实例： 123456789$(\"button\").click(function() { $.post(\"/try/ajax/demo_test_post.php\", { name: \"菜鸟教程\", url: \"http://www.runoob.com\" }, function(data, status) { alert(\"数据: \\n\" + data + \"\\n状态: \" + status); });}); GET和POST的区别1、发送的数据数量 在 GET 中，只能发送有限数量的数据，因为数据是在 URL 中发送的。在 POST 中，可以发送大量的数据，因为数据是在正文主体中发送的。 2、安全性 GET 方法发送的数据不受保护，因为数据在 URL 栏中公开，这增加了漏洞和黑客攻击的风险。POST 方法发送的数据是安全的，因为数据未在 URL 栏中公开，还可以在其中使用多种编码技术，这使其具有弹性。 3、加入书签中 GET 查询的结果可以加入书签中，因为它以 URL 的形式存在；而 POST 查询的结果无法加入书签中。 4、编码 在表单中使用 GET 方法时，数据类型中只接受 ASCII 字符。在表单提交时，POST 方法不绑定表单数据类型，并允许二进制和 ASCII 字符。 5、可变大小 GET 方法中的可变大小约为 2000 个字符。POST 方法最多允许 8 Mb 的可变大小。 6、缓存 GET 方法的数据是可缓存的，而 POST 方法的数据是无法缓存的。 7、主要作用 GET 方法主要用于获取信息。而 POST 方法主要用于更新数据。","link":"/2018/06/11/jquery-tutorial-5/"},{"title":"jQuery学习笔记（六）","text":"如何在项目中同时使用jquery和其他类库。 noConflict()noConflict() 的作用是避免 $ 和其他类库冲突。 noConflict()会释放对 $ 标识符的控制，这样其他脚本就可以使用它了。 实例： 123456$.noConflict();jQuery(document).ready(function() { jQuery(\"button\").click(function() { jQuery(\"p\").text(\"jQuery 仍然在工作!\"); });}); 也可以创建自己的缩写，noConflict()可返回对 jQuery 的引用，可以把它存入变量，以供稍后使用。 123456var jq = $.noConflict();jq(document).ready(function() { jq(\"button\").click(function() { jq(\"p\").text(\"jQuery 仍然在工作!\"); });}); 如果你的jQuery代码块使用 $ 简写，并且您不愿意改变这个快捷方式，那么您可以把 $ 符号作为变量传递给ready方法。这样就可以在函数内使用 $ 符号了，而在函数外，依旧不得不使用 jQuery ： 123456$.noConflict();jQuery(document).ready(function($) { $(\"button\").click(function() { $(\"p\").text(\"jQuery 仍然在工作!\"); });});","link":"/2018/06/12/jquery-tutorial-6/"},{"title":"《JavaScript高级程序设计》：第一章","text":"一个完整的javascript实现由ES、DOM、BOM组成。 ES实现的宿主环境有浏览器、node、flash。 ECMA-262ECMA-262规定了： 语法 类型 语句 关键字 保留字 操作符 对象 ES就是对实现了以上标准规定的各个方面内容的语言的描述。 JavaScript实现了ES，Adobe ActionScript也实现了ES。 DOMDOM概念文档对象模型是应用程序编程接口（API）。 DOM把整个页面映射为一个多层节点结构。 借助DOM提供的API，开发者可以自由的控制页面内容和结构。 DOM级别Level1：DOM core 和 DOM HTML构成。 DOM core：规定了如何映射基于XML的文档结构。 DOM HTML：在core的基础上扩展添加了针对HTML的对象和方法。 Level2：在原来的DOM基础上扩充了鼠标和用户界面事件、范围、遍历等等模块。增加了css支持。 Level3：进一步扩展了DOM，引入了统一方式加载和保存文档的方法。 level0：实际上不存在level0，只是DOM历史中的一个参照点，指的是ie4.0和navigator4.0最初支持的DHTML。 BOM浏览器对象模型。 小结JS构成：ES，DOM，BOM。 ES：由ECMA-262定义，提供核心语言功能。 DOM：提供访问和操作网页内容的方法和接口。 BOM：提供和浏览器交互的方法和接口。","link":"/2019/01/08/js-advanced-chapter-01/"},{"title":"《JavaScript高级程序设计》：第二章","text":"如何在在html文档中使用javascript。 script标签script标签定义了6个属性： async：可选，立即下载但不妨碍页面中的其他操作，只对外部脚本文件有效。 charset：可选，表示src指定的代码字符集，基本不用这个属性。 defer：可选，表示延迟到文档完全解析和渲染后执行，只对外部脚本文件有效。 language：已废弃。 src：可选，外部脚本路径。 type：可选，可以看成language的替代品，表示MIME类型，值可以为”text/javascript”或者不写。 只要不包含async和defer，浏览器会从上到下依次解析js文件。 引入js的方式 html文件中嵌入js代码。 123&lt;script type=\"text/javascript\"&gt; // js code&lt;/script&gt; html文件中包含外部js代码。 1&lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt; 以上方式若在标签中嵌入js代码会被浏览器忽略。 可以包含来自外域的js文件，利用这点可以包含位于cdn上的js文件来提高下载速度。 标签的位置为了避免因为下载js文件带来的阻塞，一般将&lt;script&gt;放在body标签中的最后面。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html code --&gt; &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 延迟脚本defer属性：表明脚本执行不影响页面构造，会延迟到页面解析完运行。浏览器会立刻下载但延迟执行。 最好只包含一个带defer属性的脚本。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"main.js\" defer=\"defer\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html code --&gt;&lt;/body&gt;&lt;/html&gt; 一般不使用defer而是将标签放在body中最后面。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html code --&gt; &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 异步脚本async也只用于外部脚本文件，作用是告诉浏览器立刻下载但是不能保证按照指定的顺序下载。 故而只能用于不依赖脚本顺序的情况。 html中使用async： 1&lt;script type=\"text/javascript\" src=\"main.js\" async&gt;&lt;/script&gt; XHTML中使用async： 1&lt;script type=\"text/javascript\" src=\"main.js\" async=\"async\"&gt;&lt;/script&gt; 一般不用async。 在XHTML中用法本节内容可以跳过，应该遵循html5标准。 嵌入脚本与外部脚本推荐使用包含外部脚本。 优点：可维护，可缓存，适应未来。 noscript标签让页面平稳退化，只有浏览器不支持或未开启js的时候会显示&lt;noscript&gt;中的内容，放在body中。 123&lt;body&gt; &lt;noscript&gt;javascript没有开启或浏览器不支持&lt;/noscript&gt;&lt;/body&gt;","link":"/2019/01/09/js-advanced-chapter-02/"},{"title":"js模块化编程与AMD规范","text":"模块就是实现特定功能的一组方法。 随着前端项目的日渐庞大，前端工程模块化成为必须。 原始写法定义： 1234567function func1() { // statement}function func2() { // statement} 使用： 12func1();func2(); 缺点： 函数名污染了全局变量 可能与其他模块冲突 模块之间的依赖关系不明显 对象写法将模块写成一个对象。 定义： 12345var module_name = new Object({ count: 0, func1: function() {}, func2: function() {}}); 使用：module_name.func1();module_name.count 缺点：会暴露模块的所有属性和方法，外部可以随意改写模块。 IIFE使用立即执行函数可以不暴露模块中的属性和方法。 定义： IIFE写法1234567891011121314var module_name = (function(){ var count = 0; var func1 = function() { }; var func2 = function() { }; return { func1: func1, func2: func2 };})(); 这样外部就无法读取模块内部的属性和方法了。 放大模式module_name模块12345var module_name = (function(mod){ mod.func3 = function() { // statement }})(module_name); module_name模块被添加了一个新的方法func3()，也就是被放大了。 宽放大模式就是让放大模式的参数可以为空对象。 1234var module_name = (function (mod) { // ... return mod;})(window.module_name || {}); 输入全局变量模块是独立的，想要在模块内部调用全局变量必须显式地将变量传入模块。 123var module_name = (function(brand_a, brand_b){ // ...})(samsung, apple); 模块规范流行的js模块规范有CommonJS和AMD。 CommonJS（适合后端）node.js的模块化就是参考CommonJS设计的。 CommonJS使用require()加载模块。 require()1var math = require('math'); 调用模块中的方法12var math = require('math');math.add(1,2); 浏览器环境上面使用CommonJS如果运行在浏览器会有问题，浏览器要等待require()完成才能继续执行。 故而，为了采用异步加载，AMD诞生了。 AMD规范（适合浏览器端）AMD就是异步模块定义，加载是异步的。 AMD规范的实现有require.js和curl.js AMD也是用require()加载模块，但是有两个参数。 1require([module1, module2], callback);","link":"/2020/12/18/js-modularize-and-amd/"},{"title":"使用jsDelivr+github自建静态资源CDN","text":"发现用了几年的sm.ms没有以前好用了，白天加载图片速度巨慢，原因可能是sm.ms在大陆已经没有cdn节点了。故而选择折腾一个新图床来提高页面加载速度。 一阵搜寻发现jsDelivr还可以用来作图床并且在国内速度还很不错，于是搞了个jsDelivr的图床。 jsDelivr官网：https://www.jsdelivr.com/ 新建github仓库仓库名称随意，根据需求可以选择性添加描述和README.md这里新建仓库名为：CDN git clone仓库到本地1git clone &lt;repo&gt; 提交现在就可以向本地仓库中加入需要做cdn的资源文件了。然后提交到github仓库： 123git add .git commit -m 'info'git push jsDelivr支持单个文件最大20MB。提交过慢可以参考我之前配置git代理的文章：git配置本地代理 releases点击CDN仓库的raleases并创建新的版本。生成releases的作用是给不同的版本代码以不同的资源版本，便于管理。个人使用的话还是建议不要生成。 引用引用特定版本资源：https://cdn.jsdelivr.net/gh/用户名/仓库名@版本号/文件路径引用最新资源：https://cdn.jsdelivr.net/gh/用户名/仓库名/文件路径 tipsreleases用于区分不同版本项目所用的静态资源文件，但并非必须。不适用版本号将直接引用最新资源。个人用途建议不用releases，直接引用即可。 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/ 反复测了几张图，比sm.ms真的是快多了以后慢慢把在sm.ms上的图片搬过去。 测试 还有就是markdown的写作今天从Typora转向VScode了，Typora的bug真的是太多了。Typora不光优点明显缺点也很明显，不然怎么到了2020年了Typora还是测试版呢。 刷新缓存jsdelivr不会自动刷新已经更新了的文件，需要手动访问URL刷新。 方法：将资源url中最前面的cdn替换为purge即可。","link":"/2020/06/07/jsdelivr-cdn/"},{"title":"初识JVM","text":"JVM，也就是Java Virtual Machine（Java虚拟机），JVM是虚构出来的计算机，它的作用是在物理计算机上模仿各种计算机功能实现的。 Java能“一次编译，到处运行”的原因就是JVM屏蔽了不同操作系统和不同硬件的差异，这样Java开发者就可以无需考虑平台差异，只需要面向JVM编程即可。 JVM的本质是一个程序，当它开始执行class文件的时候就执行class文件中的指令。JVM上运行的是 .class 字节码文件，字节码文件是由 .java 文件经过编译器javac编译产生的，可以在JRE（JVM+Java类库）上运行。 正是由于JVM上面运行的是 .class ，所以不仅是Java，只要是能编译成 .class 的语言都可以在JVM上运行。比如python，python可以通过编译器jython将 .py 编译为 .class ，然后在JVM上运行。除此之外还有：kotlin, scala, clojure, groovy, jruby, ceylon, eta, haxe, fantom, rhino。 JVM的组成：堆，方法区，栈，本地方法栈，程序计数器等等。其中方法回收堆和方法区是共享区，而栈、程序计数器和本地方法栈区是JVM的。 JVM、JRE和JDK三者的关系JDK（Java开发工具包）包含了Java语言、JVM、Java API和Javac等工具。JRE（Java运行时环境）包含了JVM和Java API。也就是说：JDK包含了JRE，JRE又包含了JVM。 层级图示： JVM的实现原理类装载器（ClassLoader）类装载器（ClassLoader），负责装载class文件，然后交由execution engine执行。类装载器：启动类加载器（JVM实现的一部分）和用户自定义类加载器（Java程序的一部分）。 本地方法栈（native method stack）本地方法栈的作用是登记native方法，然后在execution engine执行的时候加载本地方法库。 栈（stack）又叫内存栈，栈负责java程序的运行，在线程创建的时候创建出来，在线程销毁的时候释放。 程序计数器（program counter）是方法区中的方法字节码由引擎读取下一条指令。 方法区（method area）是线程共享的。 堆（heap）用于存储对象实例。堆的内存空间需要JVM GC回收。 本地接口（native interface）用于融合不同的编程语言。 参考 wikipedia: JVM","link":"/2020/09/06/jvm-primary/"},{"title":"初识JVM调优","text":"关于jvm调优，其实大多数项目不需要jvm调优，需要调优的往往是比较极端的业务。 是否需要调优一般项目不需要调优，加xms和xmx参数就可以了。即使是高并发服务也不需要调优，jvm本身就是为低延时、高并发、大吞吐的服务设计和优化的。 1java -Xms1g -Xmx2g -jar abc.jar 对于项目来说，主要还是要将精力放在项目本身的调优。 jvm调优的前提是对服务的全面监控和性能数据的收集以及我们对jvm的运行原理的非常熟悉。 首先需要了解系统的运行状况，如果系统的响应时间很短，资源占用也不高，那么这种调优是没什么意义的。系统运行状况参数： 响应时间 TPS（每秒处理事务数量） 资源占用量（系统性能受限于最差的那个） jvm调优主要针对一些极端的项目，比如一些对吞吐量要求高而对时延要求不高的服务，就像12306。针对12306这种服务，可能需要调整一些参数，比如让gc中的generation分布更加合理。 如何调优jvm调优主要包括：1. 合理分配jvm内存空间。2. 选择适合的gc回收器。 合理分配jvm内存空间：jvm内存分配不合理的表现是频繁的gc从而降低系统的吞吐量和增加响应时间。 主要方法是调整堆内存空间以减少Full GC，调整新生代减少MinorGC，设置合理的Eden和Survivor区的比例。 选择合理的垃圾回收器 垃圾回收主要回收堆（主要是对象）和方法区（主要是废弃常量和类），需要响应快可以选择CMS和G1，需要吞吐高可以选择Parallel Scavenge。 jvm调优大部分调的是gc参数，主要是下面几点： 最大堆和最小堆的大小 gc算法 新生代的大小 jdk8及以前：gc算法会自动在Parallel和CMS中选择，新生代根据经验调节大小，这样就达到了性能和STW的平衡。 jdk9开始的版本：gc默认算法变为G1，只需要调整最大堆大小和STW期望值既可。","link":"/2020/09/07/jvm-tuning/"},{"title":"flex布局","text":"flex简单布局： 1234567891011.container { display: -webkit-flex; display: flex;}nav { width: 200px;}.flex-column { -webkit-flex: 1; flex: 1;} flex复杂布局： 1234567891011121314151617181920212223.container { display: -webkit-flex; display: flex;}.initial { -webkit-flex: initial; flex: initial; width: 200px; min-width: 100px;}.none { -webkit-flex: none; flex: none; width: 200px;}.flex1 { -webkit-flex: 1; flex: 1;}.flex2 { -webkit-flex: 2; flex: 2;} flex居中布局： 123456789.vertical-container { height: 300px; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center;}","link":"/2020/04/30/layout-flex/"},{"title":"学习资源","text":"收录开发资料、设计资料以及各种电子书。 html&amp;css 《css权威指南》 《css世界》 《css揭秘》 《head first html &amp; css》 MDN css-tricks，google: 关键词 css-tricks 阮一峰博客，google: 关键词 阮一峰 张鑫旭，google: 关键词 张鑫旭 codrops css2.1中文spec js 《javascript DOM编程艺术》 《javascript高级程序设计》 《javascript语言精粹》 《javascript权威指南》 《你不知道的javascript》 《javascript设计模式》 《高性能javascript》 《web性能权威指南》 MDN 阮一峰js教程 阮一峰es6教程 算法 《学习javascript数据结构与算法第三版》 《我的第一本算法书》 《算法图解》 计算机网络 《http权威指南》 《图解http》 《图解tcp/ip第五版》","link":"/2018/10/06/learning-assets/"},{"title":"开源围棋人工智能leela-zero的使用和学习","text":"最近迷恋上了围棋， AlphaGo 不开放API，了解到一个开源的围棋AI叫 leela-zero ，小试一下。 安装及编译（macos） 方法一：macos可以直接brew安装leela-zero 1brew install leela-zero 方法二：手动编译 1234567891011121314git clone https://github.com/leela-zero/leela-zerocd leela-zerogit submodule update --init --recursivebrew install boost cmake zlibmkdir build &amp;&amp; cd buildcmake ..cmake --build .# 测试./tests 交互leela-zero无法直接使用，需要先安装一个GUI并通过GTP协议与其进行交互，支持GTP2。 主要有下面几种： Lizzie：Leela Zero的专门客户 Sabaki LeelaSabaki GoReviewPartner 参考 project: leela-zero","link":"/2020/11/15/leela-zero/"},{"title":"linux运维基础","text":"上周末刷了个慕课网的linux基础运维课程，感觉初入linux还是需要及时总结一下加强记忆的。 https://www.imooc.com/learn/175 https://www.imooc.com/learn/111 shell内置命令：cd：进入家目录（若登录用户为root则进入root目录） cd xxx：进入本文件夹下的xxx目录 cd /xxx：进入根目录下的xxx目录 cp file1/dir1 file2/dir2：将文件1或者文件夹1复制到文件2或文件夹2（若源文件夹下有文件则需加上-r选项来递归复制） mv file dir：将文件复制到目录下 mv filename1 filename2：将文件2重命名为文件1 rm -rf file/dir：删除文件或目录（包括目录下的文件），该命令是不会提示是否删除的，所以用之前要看好是否要删除 mkdir dir：创建dir目录 touch file：创建file文件 ls：以简要信息显示当前目录下所有文件 ls -l：以列表形式显示当前目录下所有文件 ll=ls -l ls -lh：以人性化列表形式显示当前目录下所有文件 locate file：按文件名搜索文件（该命令直接搜索updatedb这个文件，该文件每次重启或者第二天都会刷新） whereis cmd：搜索cmd命令并显示位置和帮助文档 which cmd：搜索cmd命令并显示别名和位置 whatis file：查找文件 echo $PATH：显示搜索目录 pwd：显示当前工作目录 精确匹配搜索：find scale condition： find /root -name xxx（默认区分大小写） find /root -iname filename（不区分大小写） find /root -user root find /root -nouser find / -mtime +10 ​ -atime ​ -ctime +10十天前 -10十天内 10第十天当天 find dir -size 25k：查找大小为25k的文件 find dir -size +25k：查找大小大于25k的文件 find dir -size -25k：查找大小小于25k的文件 单位k，M，G等 find /etc -size +20k -a -size -50k：查找20k-50k之间的文件 find /etc -size +20k -o -size -50k：查找20k-50k之间的文件 以上后面空格+-exec ls -lh{} ; 标识将以上的结果交由后面处理 grep -r（无的）/-i（不分大小写） xxx ：在xxx文件中查找size man cmd：显示cmd命令的帮助文档（先要安装：yum install man） cmd –help：获取cmd命令的选项 whereis cmd：有文档则为外装的 help cmd：获取内部命令cmd的帮助文档 info：整个文档 压缩： zip long.zip long:文件 zip -r long.zip long：目录 解压： unzip long.zip gzip long gzip -d","link":"/2018/02/05/linux-basic/"},{"title":"命令行下有趣的工具","text":"持续收集linux实用的命令行工具。 wttr.in 获取天气 获取当前所在位置天气： 1curl wttr.in 效果： 获取制定城市天气： 1curl wttr.in/shanghai 效果： 参数 加参数-o保存为文件 1curl -o weather.html wttr.in/shanghai 封装为脚本 1234567891011121314#!/bin/shset -euxCITY=shanghaiLANGUAGE=\"zh-CN\"UNIT=mUA=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36\"curl \\ -H \"Accept-Language: $LANGUAGE\" \\ -H \"User-Agent: $UA\" \\ -o result.html \\ wttr.in/$CITY?format=4\\&amp;$UNIT bashtopbashtop bashtop是一个开源的linux资源监视器。 其主要作用是用于展示当前 Linux 系统的处理器、内存、硬盘、网络和进程等各项资源的使用情况与统计报告。 这款工具功能众多，但比较亮眼的，主要是以下几项： 可高效响应的操作界面 可显示所选进程的详细统计信息 可过滤进程 可轻松切换不同排序 可自动缩放网络使用情况图标 支持多个不同主题风格的配置","link":"/2020/03/25/linux-command-tools/"},{"title":"linux使用技巧","text":"记录一些linux使用技巧。 command !! !!命令指向最近执行的一条命令，当我们使用apt-get安装软件的时候有时候会忘了写sudo，这个时候只需要如下既可： 1sudo !! cd - 返回刚才的目录。 ^old^new 比如： 1echo \"goed\" 错误将good写成了goed。 只需要^e^o既可。 代码： 12echo \"goed\"^e^o 回车既可。 man ascii 显示ascii码表。 有时候需要用到ascii码的时候就不需要打开浏览器然后再打开google搜索了。 ctrl-x e 快速启动默认编辑器。 netstat -tlnp 列出本机进程监听的端口号。 tail -f /path/to/file.log | sed ‘/^Finished: SUCCESS$/ q’ 1tail -f /path/to/file.log | sed '/^Finished: SUCCESS$/ q' 当log文件里面出现Finished: SUCCESS的时候退出tail，用于实时监控并且过滤log是否出现了某条记录。 ssh user@server bash &lt; /path/to/local/script.sh 用到了输入重定向。在远程服务器运行本地一个脚本文件。 screen -d -m -S some_name ping my_router 后台运行一段不终止的程序，可以随时查看它的状态。 -d -m参数启动分离模式，-S指定一个session标识。 可以通过-R命令重新挂载一个标识的session。 参考：man screen或者tldr screen wget 下载一个网站： 1wget --random-wait -r -p -e robots=off -U mozilla https://www.baidu.com curl 1curl www.baidu.com lsof -i 实时查看本机网络服务活动状态。 python -m SimpleHTTPServer 将当前目录设置为HTTP服务目录，并可以通过8000端口访问： 1234python -m SimpleHTTPServer# 默认运行在8000端口http://localhost:8000/ 列出我最常用的十条命令 123history | awk '{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a]\" \" CMD[a]/count*100 \"% \" a }' | grep -v \"./\" | column -c3 -s \" \" -t | sort -nr | nl | head -n10 tools cmatrix cmatrix是一款在命令行下显示黑客帝国中代码雨的插件，简直是中二少年的福音啊。 12345# 安装brew install cmatrix# 运行cmatrix cmatrix还有个进阶版叫unimatrix，效果差不多，不过可配置的东西很丰富。 neofetch neofetch是一款显示系统信息的工具。 官网：https://www.cyberciti.biz/howto/neofetch-awesome-system-info-bash-script-for-linux-unix-macos/ 12345# 安装brew install neofetch# 使用neofetch lolcat lolcat是一款将输出信息变为彩虹色的工具。 12345# 安装brew install lolcat# 使用ls -lha | lolcat tldr 我们知道man的替代品有info（英文手册）和cman（中文的man）。 除此之外还有tldr，tldr是直接给出了命令的常用用法。 1tldr ls","link":"/2020/08/06/linux-tips-01/"},{"title":"mac卸载java8","text":"卸载java8换成java11 LTS。 12345sudo rm -rf /Library/Internet\\ Plug-Ins/JavaAppletPlugin.pluginsudo rm -rf /Library/PreferencesPanes/JavaControlPanel.prefPanesudo rm -rf ~/Library/Application\\ Support/Java# jdk版本使用ls /Library/Java/JavaVirtualMachines/查询sudo rm -rf /Library/Java/JavaVirtualMachines/[jdk version]","link":"/2020/09/26/mac-uninstall-jdk8/"},{"title":"mac使用技巧与问题汇总","text":"汇总一下mac使用技巧和常用软件和问题。 常用的brew命令homebrewlink1234567891011121314151617181920212223242526272829303132# 搜索软件包brew search [software]# 安装软件包brew install [software]# 卸载软件包brew uninstall [software]# 更新软件包brew update# 更新指定的软件包brew upgrade [software]# 显示已经安装的软件包brew list# 查看软件信息brew info [software]# 用浏览器打开软件信息页面brew home [software]# 查看需要更新的软件brew outdated# 查看包依赖brew reps# 查看帮助brew help 常用的软件包 代替 cat 的工具：bat，支持语法高亮、同时显示行号，使用: bat xx.yyy 安装： brew install bat man 命令的替代品：tldr 安装： brew install tldr 命令行显示动态的火焰，运行: aafire 安装: brew install aalib 命令行显示黑客帝国数字雨，运行: cmatrix 安装: brew install cmatrix 在命令行中开火车，运行：sl 安装: brew install sl 在命令行把输出变成七彩，运行: ls | lolcat，需要配合其他程序使用 安装: brew install lolcat 把你的命令行变成海洋馆，运行: asciiquarium 安装: brew install asciiquarium 会说话的 ascii 奶牛, 运行：cowsay &lt;你想说的话&gt; 安装: brew install cowsay mac自带的say命令 say hello","link":"/2019/06/25/mac-usage/"},{"title":"markdown精粹及工作流","text":"这是一片markdown的使用教程，以及一点使用markdown的工作方式。 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 段落 段落尾部敲至少两个空格后回车。 12段落1 段落2 段落后面回车一个空行 123段落1段落2 字体123*斜体***加粗*****加粗斜体*** 分割线连续三个以上的*或者- 12***--- 效果 删除线用~~包裹文本 1~~删除我~~ 文本 效果真的很好 下划线1&lt;u&gt;文本&lt;/u&gt; 文本 注脚文本[^注脚文本] 1文本[^注脚文本] 列表无序列表使用*空格，或者-/+空格 12* 第一项* 第二项 第一项 第二项 有序列表使用数字+.空格 121. 第一项2. 第二项 列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可 区块引用开头&gt;空格 123&gt; 引用的内容&gt; 引用的内容&gt; 引用的内容 引用的内容 引用的内容 引用的内容 可嵌套 第一层引用 第二层引用 第三层引用 可在区块中使用列表，也可在列表中使用区块 代码 短代码使用一对反引号`包裹 code 长代码使用三个反引号+langType+回车 123$(document).ready(function () { //js code}); 代码区块（无高亮）,代码区块使用 4 个空格或者一个制表符（Tab 键。 ​ code line1 ​ code line2 连接url123[链接名称](链接地址)or&lt;https://www.google.com&gt; google or https://www.google.com 高级链接1[title]: url 图片1![属性文本](url) 12![属性文本](url \"标题\")鼠标hover图片的时候会显示标题 1[图片]: https://cdn.pixabay.com/photo/2016/01/02/01/59/oranges-1117628_960_720.jpg 表格使用|分割单元，使用-分割表头和其他 123| 姓名 | 年龄 | 性别 || ---- | ---- | ---- || 小明 | 10 | 男 | 效果： 姓名 年龄 性别 小明 10 男 还有对齐什么的，使用过于麻烦，typora直接右键插入表格 高级标签不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持：kbd,b,i,em,sup,sub,br等标签 例子： windows用户按ctrl+F4关闭本窗口 mac用户按commad+Q退出程序 我是黑体 我是斜体 强调 210=1024 &lt;br&gt;标签 转义想要显示**文本**的话在符号前加\\ 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。 世界上最美的公式:欧拉公式123$$ e^{ \\pm i\\theta } = \\cos \\theta \\pm i\\sin \\theta$$ $$e^{ \\pm i\\theta } = \\cos \\theta \\pm i\\sin \\theta$$ 工作流我是用的是Typora，一般的markdown写作流是这样的： touch file.md后先写上文章标题 1# 文章标题 写上一段引言，不用很多，几十个字足够 1本文档旨在提炼出markdown写作中最常用的语法以及本人的工作流。 生成目录树toc（部分md写作工具支持），toc会随着你的标题而自动生成。 1[toc] 效果（hexo不支持toc故而放截图）： 文章一级内容用## 标题，文章二级内容用### 标题，以此类推，除了文章标题，内容尽量不要超过三层 列表要使用有序或无序列表，尽量不要直接回车换行 每个文档至少配一张图，hexo支持显示在文章顶部。图片文件放在md文件同目录下的assets目录下，或者使用sm.ms这样的图床，新浪图床尽量别用图片已经丢了好多了。 写技术文档避免不了要引入代码，一般短代码使用两个反引号包裹，大段代码使用三个反引号加上语言名称然后回车。 需要高亮而又非代码的文本我一般用三个反引号回车，这样文本就不会被高亮了。 最后一步查看toc目录看看是否有层级错误，检查文章逻辑，补充要点。","link":"/2020/03/10/markdown%E7%B2%BE%E7%B2%B9%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"title":"使用md5,sha1,sha256校验文件","text":"为了校验文件的真实性，我们使用哈希算法来校验文件的唯一性。 文件经过哈希算法会生成一个唯一的字符串，我们使用的软件经过哈希函数计算返回字符串用来和软件作者给出的字符串进行对比即可知道该文件是否有被修改。 常用的hash函数有三种，按照安全性排列：md5 &lt; sha1 &lt; sha256。 使用linux获取哈希值123md5sum filenamesha1sum filenamesha25sum filename 获取哈希值并与哈希文件比对123md5sum -c filename.md5filesha1sum -c filename.sha1filesha256sum -c filename.sha256file macos安装md5sha1sum: 1brew install md5sha1sum 123md5sum filenamesha1sum filenameshasum -a256 filename 我一般就使用macos上的自带的md5命令： 1md5 filename window方法一：安装GUI软件：quick hash或者其他软件均可。 方法二：powershell: 1certutil -hashfile or 1Get-FileHash Cmdlet or 1Get-FileHash -Algorithm MD5 or 12sha1 filenamesha256 filename","link":"/2019/08/02/md5-sha1-sha256/"},{"title":"机器学习学习顺序","text":"推荐一个机器学习大佬：https://morvanzhou.github.io/","link":"/2019/01/09/ml-learning-order/"},{"title":"什么是MVC模式","text":"MVC模式是架构模式的一种。MVC模式将应用程序分成三层：Model（模型），View（视图），Controller（控制）。 很多人将三层架构误以为是MVC在使用 三层架构和MVC相似之处是也分为三层，分别是UI层（表示用户界面），BLL层（表示业务逻辑），DAL层（表示数据访问）。 MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。 View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。 图示：（使用flowchart designer） 视图层：提供给用户操作界面。 控制层：负责将用户在视图层的操作提取数据并进行相关操作。 数据层：程序操作的数据。 这三层紧密联系又相互独立，每一层不影响其他层。 每一层都对外提供API供上层调用，这样就实现了模块化，极大方便了维护和升级。","link":"/2020/05/26/mvc/"},{"title":"使用neofetch和lolcat美化输出","text":"官网：https://www.cyberciti.biz/howto/neofetch-awesome-system-info-bash-script-for-linux-unix-macos/ 安装12brew install neofetchbrew install lolcat 使用使用neofetch查看本机信息： 1neofetch 使用lolcat彩虹化输出信息颜色： 1ls -lha | lolcat 当然也可以使用neofetch配合lolcat将输出的本机信息彩虹化： 1neofetch | lolcat 疗效单独使用fetch： fetch+lolcat：","link":"/2020/07/17/neofetch/"},{"title":"python3学习笔记","text":"初学python，不想一上来就直接写helloworld，了解一门语言的发展和语言的特性也是非常重要的，所以笔记会比较详细。 python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。python具有很强的可读性。python3相对python2是较大的一个升级并且没有考虑向下兼容。 简介 python是解释型语言 python是交互式语言 python是面向对象的语言 python是初学者的语言 发展历史 Python 2.0 于 2000 年 10 月 16 日发布，增加了实现完整的垃圾回收，并且支持 Unicode。Python 3.0 于 2008 年 12 月 3 日发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性后来也被移植到旧的Python 2.6/2.7版本。Python 3.0 版本，常被称为 Python 3000，或简称 Py3k。相对于 Python 的早期版本，这是一个较大的升级。Python 2.7 被确定为最后一个 Python 2.x 版本，它除了支持 Python 2.x 语法外，还支持部分 Python 3.1 语法。 特点 易于学习 易于阅读 易于维护 广泛的标准库 交互模式 可移植 可扩展 数据库 GUI编程 可嵌入 缺点 运行速度较慢 国内使用较少 中文文档少 应用领域 云计算 web 科学计算、人工智能 运维 金融 GUI 爬虫 等等还有很多 查看版本查看python版本： 1python3 -V 可以输入 python3 命令进入交互式编程界面。 HelloWorld12#!/usr/bin/python3print(\"Hello World!\") 将上面的代码保存为HelloWorld.py，然后使用python3命令运行。 环境搭建安装 python官网：https://www.python.org/ 在官网下载源码编译安装或者直接下载安装包既可，macos和linux可以使用包管理器安装。 环境变量配置https://www.runoob.com/python3/python3-install.html","link":"/2018/05/01/python3-tutorial/"},{"title":"redis安装和初步配置","text":"记录一下安装redis的过程。 安装redis前提是有homebrew 1brew install redis 初步配置homebrew安装的软件会在/usr/local/etc下面 redis配置文件为/usr/local/etc/redis.conf 修改redis运行方式为守护进程方式： 1vim /usr/local/etc/redis.conf 修改daemonize为yes。 注释掉bind 127.0.0.1，作用是允许远程访问。 protected-mode yes改为protected-mode no 修改requirepass为自定义密码。 保存。 启动服务端 方法一 1brew services start redis 方法二 1redis-server /usr/local/etc/redis.conf 查看redis进程1ps aux | grep redis 启动redis客户端默认端口6379 1redis-cli 关闭redis 正常关闭 1redis-cli shutdown 强制关闭（可能会丢失数据） 1sudo pkill redis-server brew关闭redis服务 1brew services stop redis brew重启redis服务 1brew services restart redis","link":"/2020/01/02/redis-installation/"},{"title":"使用require.js","text":"require.js 是一个js模块加载器。 官网：require.js require.js是为了解决两个问题： 传统多个js文件会导致网页响应时间变长，require.js实现了js文件的异步加载以避免网页失去响应。 管理模块之间的依赖性，便于代码的维护。 使用require.js 官网下载require.js，放到js目录下。 在代码中引入require.js，可以把它放到网页底部，或者可以放在head中（如下）。 1&lt;script src=\"js/require.js\" defer async=\"true\"&gt;&lt;/script&gt; 引入自己的js文件，如果我们自己的js文件名叫main.js，则这样引入。 1&lt;script src=\"js/require.js\" data-main=\"js/main\"&gt;&lt;/script&gt; 书写主模块上面的main.js是主模块，也就是js的入口文件。 可以在主模块中依赖其他模块，使用 require() （AMD规范定义的）就可以引入其他模块。 123require(['moduleA', 'moduleB', 'moduleC'], function(moduleA, moduleB, moduleC) { // some code here}); 上面的三个模块会被异步加载，加载完毕才会运行。 那么js代码写在哪里呢？ 其实只要写在require()中的回调函数中就可以。 加载模块在上面的require()语句中使用了三个模块，require.js默认三个模块都和main.js在同一目录下，如果要加载其他目录的模块则需要配置 require.config() 方法。 require.config() 写在main.js中，参数是一个对象。 12345678require.config({ paths: { 'moduleA': 'lib/moduleA.min', 'moduleB': 'lib/moduleB.min', 'moduleC': 'lib/moduleC.min', 'remoteD': 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min' }}); 也可以设置base目录： 12345678910require.config({ baseUrl: 'js/lib'; paths: { 'moduleA': 'lib/moduleA.min', 'moduleB': 'lib/moduleB.min', 'moduleC': 'lib/moduleC.min', 'remoteD': 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min' }}); require.js每个模块都是一个单独的js文件。可以使用requirejs optimizer工具将多个模块合并到一个模块中以减少http请求。 AMD模块写法require.js加载的模块采用AMD书写规范。 定义一个名为module.js的module模块，下面是一个单独的文件。 123456789define(function() { var add = function(x, y) { return x + y; }; return { add: add };}); 使用模块： 123require(['module'], function(module) { module.add(1, 2);}); 如果要定义的模块依赖其他的模块，则这样写： 123456789define(['module1', 'module2'], function() { var add = function(x, y) { return x + y; }; return { add: add };}); 加载非规范的模块比如要加载 underscore 和 backbone 这两个模块： 1234567891011require.config({ shim: { 'underscore': { exports: '_' }, 'backbone': { deps: ['underscore', 'jquery'], exports: 'Backbone' } }}); exports字段配置输出的变量名。deps字段表示依赖的模块。 实例：定义jquery插件 12345678require.config({ shim: { 'jquery.scroll': { deps: ['jquery'], exports: 'jQuery.fn.scroll' } }}); 插件 domready：让回调函数在DOM加载完毕后运行。 text、image：允许require.js加载文本和图片。 json：用于加载json。 markdown：加载markdown文件。 tips 类似require.js的还有SeaJS","link":"/2020/12/19/require-js/"},{"title":"响应式设计","text":"总结一下css的响应式设计。 可视区域viewport是页面的可视区域。 针对移动端优化： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; user-scalable ：用户是否可以手动缩放。 网格视图响应式网格视图一半是12cols，宽度100%，自动伸缩。 创建响应式网格： 12345678910111213141516171819202122232425&lt;style&gt;* { box-sizing: border-box;}.header { border: 1px solid red; padding: 15px;}.menu { width: 25%; float: left; padding: 15px; border: 1px solid red;}.main { width: 75%; float: left; padding: 15px; border: 1px solid red;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"header\"&gt;&lt;h1&gt;Chania&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"menu\"&gt;&lt;ul&gt;&lt;li&gt;The Flight&lt;/li&gt;&lt;li&gt;The City&lt;/li&gt;&lt;li&gt;The Island&lt;/li&gt;&lt;li&gt;The Food&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=\"main\"&gt;&lt;h1&gt;The City&lt;/h1&gt;&lt;p&gt;Chania is the capital of the Chania region on the island of Crete. The city can be divided in two parts,the old town and the modern city.&lt;/p&gt;&lt;p&gt;Resize the browser window to see how the content respond to the resizing.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 一列对应8.33%的宽度。 创建不同宽度对应的class： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.col-1 { width: 8.33%;}.col-2 { width: 16.66%;}.col-3 { width: 25%;}.col-4 { width: 33.33%;}.col-5 { width: 41.66%;}.col-6 { width: 50%;}.col-7 { width: 58.33%;}.col-8 { width: 66.66%;}.col-9 { width: 75%;}.col-10 { width: 83.33%;}.col-11 { width: 91.66%;}.col-12 { width: 100%;} 所有的列左浮动： 12345[class*=\"col-\"] { float: left; padding: 15px; border: 1px solid red;} 每一行使用div包裹： 1234&lt;div class=\"row\"&gt; &lt;div class=\"col-3\"&gt;...&lt;/div&gt; &lt;div class=\"col-9\"&gt;...&lt;/div&gt;&lt;/div&gt; 清除浮动： 12345.row:after { content: \"\"; clear: both; display: block;} 媒体查询例子： 12345@media only screen and (max-width: 500px) { body { background-color: lightblue; }} 添加断点：为不同的设备添加断点以判断设备。 桌面端优先 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 桌面端样式 */.col-1 { width: 8.33%;}.col-2 { width: 16.66%;}.col-3 { width: 25%;}.col-4 { width: 33.33%;}.col-5 { width: 41.66%;}.col-6 { width: 50%;}.col-7 { width: 58.33%;}.col-8 { width: 66.66%;}.col-9 { width: 75%;}.col-10 { width: 83.33%;}.col-11 { width: 91.66%;}.col-12 { width: 100%;}@media only screen and (max-width: 768px) { /* 移动端样式 */ [class*=\"col-\"] { width: 100%; }} 移动端优先 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 移动端样式 */[class*=\"col-\"] { width: 100%;}@media only screen and (min-width: 768px) { /* 桌面端样式 */ .col-1 { width: 8.33%; } .col-2 { width: 16.66%; } .col-3 { width: 25%; } .col-4 { width: 33.33%; } .col-5 { width: 41.66%; } .col-6 { width: 50%; } .col-7 { width: 58.33%; } .col-8 { width: 66.66%; } .col-9 { width: 75%; } .col-10 { width: 83.33%; } .col-11 { width: 91.66%; } .col-12 { width: 100%; }} 移动端、pad、桌面端兼容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/* 手机端样式 */[class*=\"col-\"] { width: 100%;}@media only screen and (min-width: 600px) { /* pad样式 */ .col-m-1 { width: 8.33%; } .col-m-2 { width: 16.66%; } .col-m-3 { width: 25%; } .col-m-4 { width: 33.33%; } .col-m-5 { width: 41.66%; } .col-m-6 { width: 50%; } .col-m-7 { width: 58.33%; } .col-m-8 { width: 66.66%; } .col-m-9 { width: 75%; } .col-m-10 { width: 83.33%; } .col-m-11 { width: 91.66%; } .col-m-12 { width: 100%; }}@media only screen and (min-width: 768px) { /* 桌面端样式 */ .col-1 { width: 8.33%; } .col-2 { width: 16.66%; } .col-3 { width: 25%; } .col-4 { width: 33.33%; } .col-5 { width: 41.66%; } .col-6 { width: 50%; } .col-7 { width: 58.33%; } .col-8 { width: 66.66%; } .col-9 { width: 75%; } .col-10 { width: 83.33%; } .col-11 { width: 91.66%; } .col-12 { width: 100%; }} 查询横竖屏：横屏landscape、竖屏portrait。 12345@media only screen and (orientation: landscape) { body { background-color: lightblue; }} 响应式图片&lt;img&gt; 图片： width属性设置为100%，配合max-width避免图片放大。 或者直接使用max-width设置为100%，效果同上。 背景图片： 背景图片可以相应式的调整大小和缩放，有下面三种方法。 background-size 属性设置为 “contain”，按比例自适应缩放。 background-size 属性设置为 “100% 100%”，拉伸充满整个元素。 background-size 属性设置为 “cover”，按比例拉伸直到充满整个元素。 使用媒体查询让不同的设备显示不同的图片： 123456789body { background-image: url('img_smallflower.jpg');}@media only screen and (min-width: 400px) { body { background-image: url('img_flowers.jpg'); }} 可以使用min-device-width替代min-width。 还可以使用html5的 &lt;picture&gt; 元素为不同的设备提供不同的图片，该元素类似于video和audio。 12345&lt;picture&gt; &lt;source srcset=\"img_smallflower.jpg\" media=\"(max-width: 400px)\"&gt; &lt;source srcset=\"img_flowers.jpg\"&gt; &lt;img src=\"img_flowers.jpg\" alt=\"Flowers\"&gt;&lt;/picture&gt; 响应式视频 使用max-width 1234video { max-width: 100%; height: auto;} 自动填充容器 1234video { width: 100%; height: auto;} 框架使用bootstrap快速创建响应式布局。 例子： 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"http://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css\"&gt; &lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"http://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;我的第一个 Bootstrap 页面&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-4\"&gt; ... &lt;/div&gt; &lt;div class=\"col-sm-4\"&gt; ... &lt;/div&gt; &lt;div class=\"col-sm-4\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/06/01/responsive-design/"},{"title":"将闲置主机作为云计算平台","text":"如果你有一个闲置的主机比如PC，可以为其安装linux或者就使用windows，为其安装OpenSSH将其变为linux server，从而我们就可以用性能较弱的mac搭配一些linux命令就可以在PC上进行高性能或者长时间的运算。 linux安装openssh 12345# ubuntusudo apt-get install openssh-server# centossudo yum install openssh-server windows安装openssh 先下载openssh-win61.zip并解压至C:\\Program Files\\OpenSSH 打开powershell并进入C:\\Program Files\\OpenSSH 安装 1powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 启动openssh并设置openssh自启动 12sc config sshd start= autonet start sshd 配置参考：https://www.jianshu.com/p/6e5bc39d386e 在云端运行本地脚本比如我要在server上运行本地的一个python脚本test.py： 1ssh root@192.168.0.101 python3 &lt; ~/Desktop/test.py tips: python3是服务器端python3的命令，&lt;是重定向，~/Desktop/test.py是本地的python文件。 在云端和本地之间传输文件12345678# 将本地的~/Desktop/test.py文件复制到云端root@192.168.0.101下的~/Desktop目录scp ~/Desktop/test.py root@192.168.0.101:~/Desktop# 将本地的~/Desktop/test.py以及~/Desktop/test2.py文件复制到云端root@192.168.0.101下的~/Desktop目录scp ~/Desktop/{test,test2}.py root@192.168.0.101:~/Desktop# 反之亦可，将云端文件传输到本地scp root@192.168.0.101:~/Desktop/b.py ~/Desktop 在云端执行命令双引号中的代表在云端环境执行的命令 1ssh root@192.168.0.101 \"python3 ~/Desktop/test.py\"","link":"/2020/06/09/run-on-linux-server/"},{"title":"服务器的容错、灾备和高可用","text":"容错、备灾和高可用比较容易混淆。 容错基于容错技术，硬件上采用冗余设计，保证在故障时切换到临时服务器。 灾备指的是发生灾难的时候能让服务回复正常的能力。 此时业务一般已经遭受到了灾难性毁灭，灾备进行的是抢救性工作，也就是如何抢救数据减少损失。 高可用也就是高耐久度，比如服务器无法保证一年100%在线，而尽量缩短离线率就称之为高可用。","link":"/2019/06/26/server-problems/"},{"title":"短链接原理及设计","text":"经常看到社交app以及短信中出现推销的链接很短。那么这是如何做到的呢？还有为什么要将长链接做短呢？这篇文章就探索一下什么是短链接，短链接的原理是什么，以及如何设计一个高性能的短链接。 什么是短链接例子这是一个真实的短链接： https://dwz.cn/4kuYDdGu 点击跳转后其真实的长链接为： https://app.smzdm.com/xiazai/?json=%7B%22url%22%3A%22https%3A%2F%2Ftest.smzdm.com%2Fp%2F10192%2F%3Futm_source%3D083002%26utm_medium%3D083002%26utm_campaign%3D083002%22%2C%22channel_name%22%3A%22test%22%2C%22article_id%22%3A%2210192%22%2C%22linkVal%22%3A%2210192%22%2C%22frompage%22%3A%22message%22%2C%22targetpage%22%3A%22test%22%2C%22roll_type%22%3A%222%22%2C%22download%22%3A%220%22%2C%22open_from%22%3A%22message%22%2C%22open_target%22%3A%22test%22%7D 优点发现了什么？ 原本的长链接真的太长了！有没有？ 故而，短链接的优点就是短，所以经常出现在对链接长度有限制的平台比如微博。其实短链接还有其他的优点，不过都是基于短链接长度短而来的衍生优势。 缺点那么问题来了，短链接带来的缺点又有什么？是响应时间的变长，其实短链接是靠时间换空间的一个东西。 原理我们分析一下刚才点击短链接到最终得到真实链接的过程： 客户端点击短链接后访问短链接服务器，服务器302暂时重定向到真实的url。所以说短链接是用时间换空间。 那么服务器用301还是302呢？用302。为什么？ 301，代表 永久重定向，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301。 302，代表 临时重定向，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302！ 短链接的设计哈希算法我们对比长链接和短链接，发现有一个共同点：都是由域名+域名后面一串字符构成。其实也就是将长链接域名后面的一长串映射成为了短链接的一短串。也就是说，我们的任务就是将长的那一串经可能变短。 想到了什么？对，哈希算法可以做到。不过常见的md5、sha系列的输出都太长，md5输出是128bit，sha1已经是输出最短的了也有160bit的输出。这个长度的输出太长了，而且md5，sha等哈希算法都是加密算法，所以对服务器的性能消耗较高，故而不适合作为长链接映射为短链接的哈希算法。 MurmurHash算法是一种非加密型哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的 key，MurmurHash的随机分布特征表现更良好，非加密也就意味着MurmurHash的性能比md5等好得多。 MurmurHash算法可选两种长度：32bit和128bit。32bit已经很够用了。 MurmurHash的输出是一串十进制数，可以将其转为62进制从而进一步压缩。 短链接工具 https://sina.lt/ http://tool.chinaz.com/tools/dwz.aspx 参考 高性能短链接设计：长链接 高性能短链接设计：短链接 怎么样？打开短链接是不是感觉比长链接要慢一点？","link":"/2020/08/31/short-url/"},{"title":"ssh远程登录","text":"总结一下ssh配置以及常用操作。 ssh是用于远程登录计算机的一种协议，用于安全地登录远程服务器。 远程登录主机 1$ ssh -p port_num user_name@ip_address ssh建立流程 远程主机收到用户ssh请求后把自己的公钥发送给用户。 用户端使用发来的公钥加密登录密码并且发送给远程主机。 远程主机用私钥解密用户端发来的登录密码，验证密码正确性。 这中间存在安全风险：如果有人截获了用户的登录请求并伪造服务器公钥发送给用户，用户几乎无法辨认真假，因为ssh的公钥没有公正都是自己签发的。故而，如果有人监听了用户的网络数据，则完全可以伪造服务器公钥骗取用户的登录密码。 这就是“中间人攻击”。 当用户登录进服务器后，服务器会在~/.ssh/known_hosts中保存公钥，以后服务器就不会再提示。 登录 为了解决每次都要输入密码的麻烦，可以使用公钥登录。 原理：用户将自己的公钥存储在远程主机上，登录的时候远程主机给用户发送一串随机字符串，用户用私钥加密后发给远程主机，远程主机用事先存储的公钥解密，成功则允许用户登录。 首先确保/etc/ssh/sshd_config中的如下三项开启： 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 开启后，重启ssh服务： 1234567891011# centos6$ service sshd restart# centos7+$ systemctl restart sshd.service# ubuntu$ service ssh restart# debian$ /etc/init.d/ssh restart 确保以上配置开启后。 首先，用户端生成公钥： 1$ ssh-keygen 一般不用设置。 现在~/.ssh下会生成公钥id_rsa.pub和私钥id_rsa。 再将公钥上传至远程主机： 1$ ssh-copy-id user@host 添加公钥到authorized_keys文件末尾 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 完成！ 总之，公钥用来加密，私钥用来解密。 使用ssh建立数据通路 看命令： 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 单引号中的再远程主机上执行，最后面将``~/.ssh/id_rsa.pub`输入重定向到远程主机，也就是说ssh可以再本地和远程之间建立命令和数据通道。 比如： 将本地src目录打包压缩传输到了远程服务器，远程服务器执行对本地传来的文件一个解压缩处理。中间的|是管道符，作用是将左侧命令的输出作为右侧命令的输入。 1$ cd &amp;&amp; tar -zcv src | ssh user@host 'tar xz' 同理，逆操作，将服务器上的src目录打包压缩后传输到本地并使用tar解压缩包。 1$ ssh user@host 'tar cz src' | tar zxv 本地远程查看服务器进程： 1$ ssh user@host 'ps aux | grep httpd' 绑定本地端口 让8080端口的数据通过ssh上传至远程主机： 1$ ssh -D 8080 user@host 此时ssh会建立socket监听本地8080，并将8080端口收到的数据自动通过ssh上传至远程主机。 可以通过这种方式加密端口。 本地端口转发 假设本地主机localhost与remotehost无法直接通信，有一台中间主机middlehost可以同时连接两台主机。 那么就可以设置本地端口转发至middlehost。 下面：指定本地ssh绑定端口2121，指定middlehost将所有数据转发到目标主机的21端口（21为ftp端口）。 1$ ssh -L 2121:remotehost:21 middlehost 参数分别是本地端口：目标主机：目标主机端口。 这个技术的作用是在本不能互相通信的localhost与remotehost之间建立了一条以middlehost为中继的ssh隧道。 下面是一个比较有趣的例子。 1$ ssh -L 5900:localhost:5900 host3 它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。 另一个例子是通过host3的端口转发，ssh登录host2。 1$ ssh -L 9001:host2:22 host3 这时，只要ssh登录本机的9001端口，就相当于登录host2了。 1$ ssh -p 9001 localhost 上面的-p参数表示指定登录端口。 远程端口转发 本地端口转发是指定本地端口的转发，而远程端口转发就是绑定远程端口的转发。 假设host1与host2无法通信，host3是一台内网主机可以连接外网的host1，但是host1不能连接host3。 这种情况解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。 我们在host3执行下面的命令： 1$ ssh -R 2121:host2:21 host1 R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。 绑定之后，我们在host1就可以连接host2了： 1$ ftp localhost:2121 这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。","link":"/2019/11/04/ssh/"},{"title":"什么是系统调用","text":"计算机操作系统中对系统调用的解释已经很清楚了，看到一篇公众号文章，做了个脑图。","link":"/2019/01/11/system-call/"},{"title":"hexo写作模板","text":"hexo模版如下 12345678910111213title: {{ title }}date: {{ date }}updated:toc: truetags: - tag1 - tag2categories: - [cate1] - [cate2]thumbnail:permalink:comments: Summary paragraph 1&lt;!-- more --&gt; Content paragraph","link":"/2018/05/29/template/"},{"title":"对于当前社会中的学习的思考","text":"概述人类文明从工业革命开始直到现在的移动互联网时代以及即将到来的人工智能时代，其两百年间所取得的科学技术的成就远超过去几千年的总和。 \b在科学技术飞速发展的同时，借助于互联网和移动互联网的兴起，大量的知识和经验在其中被不断的输出到人类社会的知识库中，并且借助于终端设备和网络的普及使得大量的人可以以极低的成本和门槛接触到大量的专业知识。 同时，大量的专业知识也在其中得以被高速的迭代升级。举个例子：两百年前的一个普通人只要学会纺织或者打铁就能靠此技能安生立命一辈子。但是当代社会变化速度过快，\b几年前的技能已经不能满足当前的社会要求了，前端的发展甚至几个月都会又一次巨变。 持续学习、持续实践软件开发中有一个概念叫持续集成(CI)、持续部署(CD)。就我个人而言，我希望我自己可以做到持续学习(CL)、持续实践(CP)。持续学习、持续实践是什么意思呢？\b就是持续的吸收工作所需要的技术和适应当前社会生存所需要的各种技能和心态的调整，并且在持续的学习中进行对固化思维的持续更新。再在实际工作和生活中将学习的内容得以实践。 终身学习由持续学习便引来了终身学习。 大多数人怎么想我不管，对我来说，人生不只是：毕业&gt;结婚&gt;生娃&gt;养娃&gt;教育娃&gt;等娃结婚&gt;娃为自己养老送终，这么简单。 从很早我就发现我和常人不一样，我对自己的判断是：我和人群中的大多数人不一样，我是人群中能够翻出一些水花的人。 所以终身学习就成了我去年开始的slogan。我以前从来没立过slogna，但是我发现我现在需要终身学习，所以slogan就是博客的profile上面的那句”A lifelong learner”。 学习什么对于我一个互联网行业的从业者而言，学习的内容除了更新的技术和其他计算机技术之外，还有如下内容： 对于行业发展趋势的预测和判断。 对于国家政策推动产业的了解。 对于未来人们生活方式变化的了解。","link":"/2020/09/01/think-about-learning/"},{"title":"TypeScript学习笔记","text":"TypeScript 是JavaScript的超集且支持ES6标准，由微软开发。 TypeScript是设计用来开发大型应用的，可以编译成js并运行在浏览器上。 语言特性ts扩展的内容TypeScript是js的扩展，扩展的内容如下： 类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 await 以及从ECMA2015一直了如下内容： 类 模块 lambda函数的箭头语法 可选参数和默认参数 ts和js的区别ts是js的超集，它扩展了js的语法。 ts通过类型注解提供编译时的静态类型检查。 ts可以处理已有的js代码并只对其中的ts代码进行编译。 实例12const str : string = \"this is a string.\"console.log(str); 安装npm安装12345# 使用npm全局安装tscnpm install -g typescript# 查看是否安装成功tsc -v 编译将ts编译为js代码： 123# ts文件扩展名为.tstsc demo.tstsc demo1.ts demo2.ts demo3.ts 运行ts已经被编译成了js文件，使用node命令运行js。 1node demo.js 基本语法TypeScript程序由模块、函数、变量、语句和表达式以及注释组成。 编译参数tsc常用编译参数： 1234567891011121314151617181920212223242526# 显示帮助信息--help# 载入扩展模块--module# 设置ECMA版本--target# 额外生成一个.d.ts扩展名的文件。tsc ts-hw.ts --declaration# 删除文件的注释--removeComments# 编译多个文件并合并到一个输出的文件--out# 生成一个 sourcemap (.map) 文件。sourcemap 是一个存储源代码与编译代码对应位置映射的信息文件。--sourcemap# 在表达式和声明上有隐含的 any 类型时报错--module noImplicitAny# 在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。--watch 保留关键字 保留关键字 123456789101112break as catch switchcase if throw elsevar number string getmodule type instanceof typeofpublic private enum exportfinally for while voidnull super this newin return true falseany extends static letpackage implements interface functionnew try yield constcontinue do 空白和换行 ts会忽略空格、tab和换行。 ts区别大小写 ts中分号可选 建议使用分号。 注释 建议每段代码都写注释以提高程序可读性。 编译器会忽略注释。 ts支持的注释类型： 12345// 单行注释/*多行注释。*/ 面向对象TypeScript是面向对象的编程语言。 面向对象有两个重要概念：对象和类。 类：类是一个模板，描述一类对象的状态和行为。 对象：对象是类的实例，有状态和行为。 方法：方法是类的操作的实现步骤。 实例： 12345678910111213// 定义一个类class Person { // 定义一个name方法 name():void { console.log(\"wangwei\") } }// 创建Person这个类的实例masonvar mason = new Person(); // 调用mason这个实例的name方法mason.name(); 现在将这个ts编译为js，编译之后的js代码为： 123456789var Person = /** @class */ (function() { function Person() {} Person.prototype.name = function() { console.log(\"wangwei\"); }; return Person;}());var mason = new Person();mason.name(); 基本数据类型 any关键字声明任意类型。 TypeScript针对类型不明确时提供了any类型。 三种用途： 变量的值会动态改变。 1234567let x: any = 1;x = 'abc';x = true;x = 2; 改写原有代码的时候，使用any类型可以允许在编译的时候可选择的包含或者移除类型检查。 12345let x: any = 4;x.ifItExists();x.toFixed(); 定义存储各种类型数据的数组的时候使用any。 12let arr: any[] = [1,'a string',true];arr[0] = 'new string'; number关键字声明数字类型，采用双精度64位浮点数，可以用来表示整数和分数。 1234567891011// 声明并赋值一个二进制数let num: number = 0b10101;// 声明并赋值一个八进制数let num: number = 0o712;// 声明并赋值一个十进制数let num: number = 9;// 声明并赋值一个十六进制数let num: number = 0xf100a; string关键字声明字符串类型，使用单引号或者双引号表示字符串，反引号`定义多行文本和内嵌表达式。 1234let name: string = 'mason';let age: number = 18;let gender: string = 'male';let words: string = `我的名字叫${name}，今年${age}岁，性别${gender}。`; boolean关键字声明布尔型，两个值为true和false。 1let fake: boolean = false; number[]来声明数组类型。 12345// 在元素类型后面加上[]即可声明数组let arr: number[] = [1,2,3];// 或者使用数组泛型let arr: Array&lt;number&gt; = [1,2,3]; 元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。 1234567891011// 声明元组，元组各个位置上的数据类型要相符，下面尝试赋值let x: [string, number];// 赋值正常x = ['asd',1];// 赋值报错x = [1,'add'];// 输出asdconsole.log(x[0]); enum关键字，枚举类型用于定义数值集合。 123enum Color {Red, Green, Blue};let c: Color = Color.Blue;console.log(c); void关键字用于标识方法没有返回值。 123function func(): void { console.log('done');} null关键字标识对象值缺失。 js中的null表示什么都没有。null是一个只有一个值的特殊类型，表示一个空对象引用。typeof null 得到 object 。 undefined关键字用于初始化变量为一个未定义的值。 js中的undefined是一个没有设置值的变量。 never是其他类型的子类型，代表不会出现的值。 声明为never类型的变量只能被never类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）。 123456789101112131415161718192021let x: never;let y: number;// 运行错误，数字类型不能转为never类型x = 123;// 运行正确，never类型可以赋值给never类型x = (()=&gt;{ throw new Error('exception')})();// 运行正确，never类型可以赋值给数字类型y = (()=&gt;{ throw new Error('exception')})();// 返回值为never的函数可以是抛出异常的情况function error(message: string): never { throw new Error(message);}// 返回值为never的函数可以是无法被执行到的终止点的情况function loop(): never { while (true) {}} JavaScript是弱类型语言故而没有整数类型，TypeScript是强类型语言但是只能用number关键字声明数字并且不区分整数和浮点数故而也没有整数类型。 可以使用|来支持多种类型 1let x: number | null | undefined; tips： 如果某个属性的值是计算出来的，则它后面的一个变量必须初始化，否则编译报错。 变量声明变量用于引用内存地址。 变量可以看做是存储数据的容器。 ts变量命名规则：变量名由数字、字母和 _ 以及 $ 构成，且不能以数字开头。 变量使用前必须声明。 各种声明方式： 1234567891011// 声明变量类型并初始化var [var_name]: [data_type] = [value];// 声明变量但不初始化，值默认为undefinedvar [var_name]: [data_type];// 声明变量并初始化，但不设置类型，此时变量可以是任意类型var [var_name] = [value];// 声明变量，不设置类型和初始化，类型可以是任意类型，值默认为undefinedvar [var_name]; 实例： 12345678var uname:string = \"mason\";var score1:number = 90;var score2:number = 41.5var sum = score1 + score2console.log(\"名字: \"+uname)console.log(\"第一个科目成绩: \"+score1)console.log(\"第二个科目成绩: \"+score2)console.log(\"总成绩: \"+sum) 变量名不能使用 name ，会与 windows.name 冲突。 编译为js： 12345678var uname = \"mason\";var score1 = 90;var score2 = 41.5;var sum = score1 + score2;console.log(\"名字: \" + uname);console.log(\"第一个科目成绩: \" + score1);console.log(\"第二个科目成绩: \" + score2);console.log(\"总成绩: \" + sum); ts是强类型语言，声明类型和字面量类型不同则编译错误： 12// 声明为number类型却复制为string类型，编译错误var num: number = \"this is a string.\"; 类型断言类型断言(Type Assertion)可以用于手动指定一个值的类型，也就是将一个变量改变为另一个类型。 12345// 方法一&lt;类型&gt;值// 方法二，在tsx中必须使用该方法值 as 类型 实例： 12345// 声明变量为string类型var str = '1';// 使用方法一将其变为number类型var str2: number = &lt;number&gt; &lt;any&gt; str; 关于断言： 当A类型是B类型的子集或者A类型是B类型的父集，A类型都能被成功断言为A类型，这个是为了安全考虑，若强行断言则可以使用any。 类型断言不是类型转换，类型转换是在程序运行时完成的，而类型断言则是纯粹的编译时语法。 类型推断当没有给出类型的时候，tsc会利用类型推断来推断类型。 如果缺乏声明而导致不能推断出类型，则默认其类型为 any 。 123456// 注意这里不是js声明，这里是ts声明变量，却没有声明类型，类型推断为numbervar num = 2;// 这里num已经被推断为number却赋值了string类型，故而编译失败num = 'this is a string.';console.log(num); 变量作用域ts中的变量作用域： 全局作用域：全局变量定义在程序结构的外部，在任何位置都可以调用。 类作用域：也称之为字段，类变量声明在一个类里面且在类的方法外面。可以使用类的对象访问。类变量可以使静态的，可以通过类名直接访问。 局部作用域：局部变量，生命在一个代码块中，作用域就在这个代码块。 实例： 123456789101112131415// 全局变量var global_var = 1;class Numbers { // 实例变量 template_var = 13; // 静态变量 static static_var = 14; varNum(): void { // 局部变量 var scoped_var = 123; }} 这是上面的四种变量对应的访问方式： 1234567891011// 全局变量console.log(global_var);// 实例变量，需要先new一个实例var obj = new Numbers();console.log(obj.template_var);// 静态变量console.log(Numbers.static_var);// 局部变量外部无法访问，只能在其所在的代码块访问 更多参考：https://ts.xcatliu.com/basics/type-assertion.html 运算符ts有以下几种运算符： 算术运算符 逻辑运算符 关系运算符 按位运算符 赋值运算符 三元/条件运算符 字符串运算符 类型运算符 算数运算符有 + , - , * , / , % , ++ , -- ，其中 ++ , -- 还有写在值之前和之后之分。 比如 ++ ，写在值之前是先自增再用，写在值之后是先用再自增。 关系运算符关系运算法计算表达式是 true 还是 false 。 关系运算符有这些： == , != , &gt; , &lt; , &gt;= , &lt;= 。 逻辑运算符逻辑运算符用于测定变量或者值之间的逻辑。 逻辑运算符有这些： &amp;&amp; , || , ! 。 其中 &amp;&amp; 和 || 可以短路： &amp;&amp; 左边为 true 则返回右边的， || 之前的变量或值为 true 则返回 &amp;&amp; 之前的变量或值。 位运算符位运算符是对变量按位进行二进制操作（有一元操作符和二元操作符）。 位运算符有这些： &amp;：按位与处理两个长度相同的二进制数。 |：按位或处理两个长度相同的二进制数。 ~：取反，取反是一元运算符，对一个二进制数的每一位执行逻辑反操作。 ^：按位异或运算，对等长二进制模式按位或二进制数的每一位执行逻辑异按位或操作。操作的结果是如果某位不同则该位为 1，否则该位为 0。 &lt;&lt;：把 &lt;&lt; 左边的运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数指定移动的位数，高位丢弃，低位补 0。 &gt;&gt;：把 &gt;&gt; 左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数指定移动的位数。 &gt;&gt;&gt;：无符号右移，与有符号右移位类似，除了左边一律使用0 补位。 123alert: 这里b是3，按位取反后为什么是-4？(~b) =&gt; -4 赋值运算符赋值运算符有： = , += , -= , *= , /= 。 三元运算符语法： condition ? expression1 : expression2 三元运算符 ? 有三个操作数，第一个操作数为 true 则返回第二个操作数，为 false 则返回第三个操作数。 实例： 12var num: number = -1;var result = num &gt;= 0 ? \"大于0\" : \"小于0\"; 类型运算符 typeof：一元运算符，返回数据类型。 1234var num: number = 12;console.log(typeof num);// 结果：number instanceof：判断对象是否是指定类型。 其他运算符 符号运算符：用于取负值。 字符串运算符（链接运算符）：用于拼接两个字符串。 条件语句条件语句用于基于不同的条件执行不同的操作。 if语句if语句由布尔表达式和多个语句组成。 语法： 1234567891011121314151617181920// type1if (expression) { // statement}// type2if (expression) { // statement1} else { // statement2}// type3if (expression) { // statement1} else if () { // statement2} else { // statement3} switch…case语句switch...case 语句允许测试一个变量等于多个值时的情况，每一个值都是一个case，被测变量以此检查case。 switch…case语句规则： expression是一个常量表达式（整形或者枚举型）。 case可以与多个，后面跟一个值和冒号。 expression和exp必须要是相同的数据类型。 expression和exp相等时执行case后面的语句，直到遇到break;跳出switch。 如果语句不包含break则顺序往下面的case执行直到遇到break。 switch可以有多个default，放置在switch最后面。 语法： 12345678910111213141516switch(expression) { case exp1: { // statement break; // 可选 } case exp2: { // statement break; // 可选 } ... ... ... default: { // statement }} 循环for循环123for (init; condition; inc) { // statement} 下面是 for 循环的控制流程解析： init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为 true，则执行循环主体。如果为 false，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为 true，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为 false 时，for 循环终止。 在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。 condition 可以是任意的表达式，当条件为 true 时执行循环，当条件为 false 时，退出循环。 实例：计算5的阶乘5! 123456var result: number = 1;for (let count: number = 5; count &gt; 0; count--) { result = result * count;}console.log(result);// 120 for…in循环for…in循环用于一组值的集合或列表进行迭代输出。 123for (var val in list) { // statement} val 为string或者any。 实例： 1234567891011121314var num: any;var str: any = \"a b c\";for (num in str) { console.log(str[num]);}/* a b c*/ for…of, forEach, every, some for...of是es6中引入的代替for...in和forEach()，用于创建一个循环来迭代可迭代的对象，支持新的迭代协议。 可以使用for…of遍历数组、字符串、映射（maps）、集合（sets）等等可迭代的数据结构。 实例： 12345let someArray = [1, \"string\", false]; for (let entry of someArray) { console.log(entry); // 1, \"string\", false} forEach , every 和 some 是js中的循环语法，ts也支持这几种循环。 forEach123456let list = [1,2,3];list.forEach((val, idx, array) =&gt; { // val: 当前值 // idx：当前index // array: Array}); every12345678let list = [4, 5, 6];list.every((val, idx, array) =&gt; { // val: 当前值 // idx：当前index // array: Array return true; // Continues // Return false will quit the iteration}); while123while (condition) { // statement} do…whiledo...while 中的statement代码至少被执行一次。 123do { // statement} while (); break用法： 在循环内使用的时候会终止并跳出当前循环。 switch…case中使用跳出switch。 语法： 1break; continuecontinue跳过当前循环开始下一个循环。 语法： 1continue; 无限循环for和while都可以创建无限循环（死循环）。 1234567for (;;) { // statement}while (true) { //statement} 函数函数是一组ts语句。 函数声明包括函数的名称、返回值类型和参数。 函数的定义123456789// 一个名为func的函数function func() { // statement}// 匿名函数function () { // statement} 调用函数调用上面的 func 函数。 1func(); 函数返回值有时我们希望函数能返回一个值用于调用它的地方，通过return语句可以返回一个值并停止函数的执行。 1234function func(): string { // statement return str;} 一个函数只能有一个return，返回值类型要和函数定义的返回值类型一样。 带参数的函数123function func(param1: number, param2: string,param3: boolean) { //statement} 可选参数和默认参数 可选参数 使用问号 ? 表示可选参数，且只能放在后面。 1234// 这里第三个参数是可选的function func(param1: number, param2: string,param3?: boolean) { //statement} 默认参数 1234这里给第三个参数默认值`true`function func(param1: number, param2: string,param3: boolean = true) { //statement} 剩余参数用于不知道向函数传多少个参数的时候。 使用 ...restOfName 表示剩余参数，是一个数组。 12345function buildName(firstName: string, ...restOfName: string[]) { return firstName + \" \" + restOfName.join(\" \");} let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); 匿名函数匿名函数就是没有函数名的函数。 匿名函数用的时候动态声明。 也可以将匿名函数赋值给变量，这种就叫做函数表达式。 1let func = function () { //statement } 匿名函数立即执行123(function () { // statement})(); 构造函数ts也支持js的 new Function() 来定义函数。 1var res = new Function ([arg1[, arg2[, ...argN]],] functionBody); 实例： 123var myFunction = new Function(\"a\", \"b\", \"return a * b\"); var x = myFunction(4, 3); console.log(x); 递归函数递归函数就是在函数内部调用自身。 12345678function factorial(number) { if (number &lt;= 0) { // 停止执行 return 1; } else { return (number * factorial(number - 1)); // 调用自身 } }; console.log(factorial(6)); // 输出 720 lambda函数lambda 函数就是箭头函数。 单个参数 () 可选，单行函数体则 {} 也是可选的，如果没有参数则要保留一堆括号 () 。 语法： 1234567// 单行( [param1, parma2,…param n ) =&gt; statement;// 多行( [param1, parma2,…param n] )=&gt; { statement;} 实例： 1var foo = (x: number) =&gt; x++; 上面的代码等同于： 123var foo = function(x) { return x++;}; 函数重载重载就是调用的函数相同但是参数不同，返回值类型可以不同。 每个重载的方法都要有独一无二的参数类型列表。 重载的例子： 1234567891011// 参数类型不同function func(`str`): void;function func(1): void;// 参数数量不同function func(n1:number): void;function func(n1: number, n2: number): void;// 参数类型顺序不同function func(num: number, str: string): void;function func(str: string, num: number): voidl 如果参数类型不同，则参数类型要设置为 any 。 参数数量不同，要将不同的参数设置为可选。 实例：参数数量和类型不同 123456789function disp(s1:string):void; function disp(n1:number,s1:string):void; function disp(x:any,y?:any):void { console.log(x); console.log(y); } disp(\"abc\") disp(1,\"xyz\"); Number对象ts也支持Number对象，Number对象是原始数据类型的包装对象。 1var num = new Number(1); Number对象属性 MAX_VALUE：可表示的最大的数字。 MIN_VALUE：可表示的最小的数字。 NaN：not a number。 POSITIVE_INFINITY：正无穷。 NEGATIVE_INFINITY：负无穷。 prototype：Number 对象的静态属性。使您有能力向对象添加属性和方法。 constructor：返回对创建此对象的Number函数的引用。 实例： 1234567891011121314console.log(\"最大值为: \" + Number.MAX_VALUE); console.log(\"最小值为: \" + Number.MIN_VALUE); console.log(\"负无穷大: \" + Number.NEGATIVE_INFINITY); console.log(\"正无穷大:\" + Number.POSITIVE_INFINITY);function employee(id:number,name:string) { this.id = id this.name = name }var emp = new employee(123,\"admin\") employee.prototype.email = \"admin@runoob.com\" console.log(\"员工号: \"+emp.id) console.log(\"员工姓名: \"+emp.name) console.log(\"员工邮箱: \"+emp.email) 输出： 1234员工号: 123员工姓名: admin员工邮箱: admin@runoob.com Number对象方法 toExponential()：将数字转化为指数计数法。 toFixed()：将数字指定小数点位数并转化为字符串。 toLocaleString()：把数字转换为字符串，使用本地数字格式顺序。 toPrecision()：把数字格式化为指定的长度。 toString()：把数字转换为字符串，使用指定的基数。数字的基数是2 ~ 36之间的整数。若省略该参数，则使用基数10。 valueOf()：返回一个Number对象的原始数字值。 String对象String对象用于处理字符串。 12var str = new String('this is a string.');var str = 'this is a string.'; String对象属性 constructor：对创建该对象的构造函数的引用。 length：返回字符串的长度。 prototype：可以向对象添加属性和方法。 String对象方法 charAt()：返回在指定位置的字符。 charCodeAt()：返回在指定的位置的字符的Unicode编码。 concat()：连接两个或更多字符串，并返回新的字符串。 indexOf()：返回某个指定的字符串值在字符串中首次出现的位置。 lastIndexOf()：从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 localeCompare()：用本地特定的顺序来比较两个字符串。 match()：查找找到一个或多个正则表达式的匹配。 replace()：替换与正则表达式匹配的子串。 search()：检索与正则表达式相匹配的值。 slice()：提取字符串的片断，并在新的字符串中返回被提取的部分。 split()：把字符串分割为子字符串数组。 substr()：从起始索引号提取字符串中指定数目的字符。 substring()：提取字符串中两个指定的索引号之间的字符。 toLocaleLowerCase()：根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射。 toLocaleUpperCase()：据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射。 toLowerCase()：把字符串转换为小写。 toString()：返回字符串。 toUpperCase()：把字符串转换为大写。 valueOf()：返回指定字符串对象的原始值。 Array对象ts如何声明数组： 12345// 声明一个变量为site的字符串类型的数组var sites: string[];// 初始化sites = ['twitter','google','amazon']; 或者声明并初始化： 1var sites: string[] = ['baidu','google','amazon']; 如果数组声明时未设置类型，则会被认为是 any 类型，在初始化时根据第一个元素的类型来推断数组的类型。 访问数组： 1234var sites: string[];sites = ['baidu','google','amazon'];console.log(sites[0]); 使用Array对象创建数组Array创建对象的时候可以接受两种值。 数组的长度。 初始化数组的元素。 1var sites: string[] = new Array(3); 或者： 1var sites: string[] = new Array('google','baidu','amazon'); 数组结构也可以将数组元素赋值给变量： 12var arr: number[] = [1,2];var [x,y] = arr; 数组迭代123456var nums:number[] = [1,2,3,4];var i:any;for (i in nums) { console.log(nums[i]);} 多维数组可以将一个数组作为另一个数组的元素，这就是多维数组。 二维数组定义： 1var arr: number[][] = [[1,2,3],[4,5,6]]; 数组在函数中的使用 作为参数传递到函数进行操作。 作为函数的返回值。 12345function returnArray():string[] { return new Array('google','facebook','amazon');}// 这里会返回一个数组 数组方法 concat()：连接多个数组。 1234var alpha = ['a','b','c'];var nums = [1,2,3];var alphaConcatNums = alpha.concat(nums); every()：检测数组元素是否都符合条件。 123456789// 声明并初始化待检测数组var arr = [1,2,3,4,5,6];// 定义检测函数function isBigEnough(element, index, array) { return (element &gt;= 3);}console.log(arr.every(isBigEnough)); filter()：检测数值元素并返回符合条件的数组。 123456789// 声明并初始化待检测数组var arr = [1,2,3,4,5,6];// 定义检测函数function isBigEnough(element, index, array) { return (element &gt;= 3);}console.log(arr.filter(isBigEnough)); forEach()：为数组的每一个元素都执行一次回调函数。 1234let nums = [1,2,3];nums.forEach(function (element) { console.log(element);}); indexOf()：返回一个元素所在的索引位置，找不到则返回-1. 1console.log([1,2,3,4].indexOf(2)); join()：将数组的所有元素都放入一个字符串。 12345678910var arr = ['i','have','a','pen'];console.log(arr.join());// i,have,a,penconsole.log(arr.join(', '));// i, have, a, penconsole.log(arr.join('+'));// i+have+a+pen lastIndexOf()：返回指定字符串最后出现的位置（会从最后面向前搜索）。 123var index = [12, 5, 8, 130, 44].lastIndexOf(8); console.log(\"index is : \" + index ); // 2 map()：用指定函数梳理数组中每一个元素并返回处理后的数组。 123var numbers = [1, 4, 9]; var roots = numbers.map(Math.sqrt); console.log(\"roots is : \" + roots ); // 1,2,3 pop()：删除数组的最后一个元素并返回删除的元素。 1234var numbers = [1, 4, 9]; var element = numbers.pop(); console.log(\"element is : \" + element ); // 9 push()：向数组添加元素并返回新数组的长度。 12345var numbers = [1, 4, 9]; var length = numbers.push(16); console.log(length);// 4 reduce()：从左到右将数组元素计算为一个值。 12345678var arr = [1,2,3,4];var total = arr.reduce(function (a,b) { return a + b;});console.log(total);// 10 reduceRight()：从右到左将数组元素计算为一个值。 reverse()：反转数组的元素顺序。 12345var arr = [1,2,3,4];var reverseArr = arr.reverse();console.log(reverseArr);// [4,3,2,1] shift()：删除并返回数组的第一个元素。 1234var arr = [1,2,3,4].shift();console.log(arr);// 1 slice()：选取数组的一部分并返回一个新数组。 123var arr = [\"orange\", \"mango\", \"banana\", \"sugar\", \"tea\"]; console.log(\"arr.slice( 1, 2) : \" + arr.slice( 1, 2) ); // mangoconsole.log(\"arr.slice( 1, 3) : \" + arr.slice( 1, 3) ); // mango,banana some()：检测数组中是否存在符合条件的元素并返回布尔值。 12345678910function isBigEnough(element, index, array) { return (element &gt;= 10); } var retval = [2, 5, 8, 1, 4].some(isBigEnough);console.log(\"Returned value is : \" + retval ); // false var retval = [12, 5, 8, 1, 4].some(isBigEnough); console.log(\"Returned value is : \" + retval ); // true sort()：对数组元素进行排序。 123var arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); var sorted = arr.sort(); console.log(\"Returned string is : \" + sorted ); // banana,mango,orange,sugar splice()：从数组中添加或者删除元素。 12345678var arr = [\"orange\", \"mango\", \"banana\", \"sugar\", \"tea\"]; var removed = arr.splice(2, 0, \"water\"); console.log(\"After adding 1: \" + arr ); // orange,mango,water,banana,sugar,tea console.log(\"removed is: \" + removed); removed = arr.splice(3, 1); console.log(\"After removing 1: \" + arr ); // orange,mango,water,sugar,tea console.log(\"removed is: \" + removed); // banana toString()：把数组转换为字符串，并返回结果。 123var arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); var str = arr.toString(); console.log(\"Returned string is : \" + str ); // orange,mango,banana,sugar unshift()：向数组的开头添加一个或更多元素，并返回新的长度。 1234var arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); var length = arr.unshift(\"water\"); console.log(\"Returned array is : \" + arr ); // water,orange,mango,banana,sugar console.log(\"Length of the array is : \" + length ); // 5 Map对象Map对象是es6引入的，用于保存键值对并且能记住键的原始插入顺序。 创建Map12345678// 声明let myMap = new Map();// 声明并用数组的方式传入键值对let myMap = new Map([ [\"key1\", \"value1\"], [\"key2\", \"value2\"] ]); Map属性与方法 map.clear()：删除map对象的所有键值对。 map.set()：设置键值对，返回该对象。 map.get()：读取键对应的值，不存在则返回undefined。 map.has()：查询map对象中是否存在某个键对应的值，返回布尔值。 map.delete()：删除map对象中的键值对，成功返回true，失败返回false。 map.size：返回map对象的长度，也就是键值对的个数。 map.keys()：返回一个Iterator对象（迭代器），包含了map对象中每个元素的键。 map.values()：返回一个Iterator对象，包含了map对象中每个元素的值。 实例： 123456789101112131415161718let nameSiteMapping = new Map();nameSiteMapping.set(\"Google\", 1);nameSiteMapping.set(\"Runoob\", 2);nameSiteMapping.set(\"Taobao\", 3);console.log(nameSiteMapping.get(\"Runoob\")); //40console.log(nameSiteMapping.has(\"Taobao\")); //trueconsole.log(nameSiteMapping.has(\"Zhihu\")); //falseconsole.log(nameSiteMapping.size); //3console.log(nameSiteMapping.delete(\"Runoob\")); // trueconsole.log(nameSiteMapping);nameSiteMapping.clear(); //清除 Mapconsole.log(nameSiteMapping); 使用es6编译： 1tsc --target es6 test.ts 运行结果： 1234567892truefalse3trueMap { 'Google' =&gt; 1, 'Taobao' =&gt; 3}Map {} 迭代Map使用for…of迭代： 12345678910111213141516171819202122232425let nameSiteMapping = new Map(); nameSiteMapping.set(\"Google\", 1);nameSiteMapping.set(\"Runoob\", 2);nameSiteMapping.set(\"Taobao\", 3); // 迭代 Map 中的 keyfor (let key of nameSiteMapping.keys()) { console.log(key); } // 迭代 Map 中的 valuefor (let value of nameSiteMapping.values()) { console.log(value); } // 迭代 Map 中的 key =&gt; valuefor (let entry of nameSiteMapping.entries()) { console.log(entry[0], entry[1]); } // 使用对象解析for (let [key, value] of nameSiteMapping) { console.log(key, value); } 使用es6编译： 1tsc --target es6 test.ts 执行结果： 1234567891011GoogleRunoobTaobao123Google 1Runoob 2Taobao 3Google 1Runoob 2 元组数组中存储的元素类型都是一样的，如果要在数组中存储不同类型的元素则用元组。 定义元组1var mytuple = [val1,val2,val3...]; 实例： 12345678var mytuple = [1,'asd',false];或者var mytuple = [];mytuple[0] = 1;mytuple[1] = 'asd';mytuple[2] = false; 访问元组1mytuple[index]; 元组的运算 push()：向元组最后面添加元素。 pop()：删除元组最后面一个元素并返回被删除的元素。 更新元组可以改变元组元素。 结构元组1234var a =[10,\"Runoob\"] var [b,c] = a console.log( b ) console.log( c ) 联合类型可以通过使用管道符 | 将变量设置为多种类型。 1type1 | type2 | type3 实例： 123var val: string | number;val = 12;val = 'string.'; 将联合类型作为函数的参数使用： 12345678910111213function disp(name:string|string[]) { if(typeof name == \"string\") { console.log(name) } else { var i; for(i = 0;i&lt;name.length;i++) { console.log(name[i]) } } } disp(\"Runoob\") console.log(\"输出数组....\") disp([\"Runoob\",\"Google\",\"Taobao\",\"Facebook\"]) 联合类型数组将数组声明为联合类型： 123456789101112131415var arr:number[]|string[]; var i:number; arr = [1,2,4] console.log(\"**数字数组**\") for(i = 0;i&lt;arr.length;i++) { console.log(arr[i]) } arr = [\"Runoob\",\"Google\",\"Taobao\"] console.log(\"**字符串数组**\") for(i = 0;i&lt;arr.length;i++) { console.log(arr[i]) } 接口接口的定义 接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。 ts接口的定义： 12interface interface_name {} 实例： 12345678910111213141516171819202122232425262728// 定义了接口IPersoninterface IPerson { firstName:string, lastName:string, sayHi: ()=&gt;string } // 定义了类型为IPerson的变量customervar customer:IPerson = { firstName:\"Tom\", lastName:\"Hanks\", sayHi: ():string =&gt;{return \"Hi there\"} } console.log(\"Customer 对象 \") console.log(customer.firstName) console.log(customer.lastName) console.log(customer.sayHi()) var employee:IPerson = { firstName:\"Jim\", lastName:\"Blakes\", sayHi: ():string =&gt;{return \"Hello!!!\"} } console.log(\"Employee 对象 \") console.log(employee.firstName) console.log(employee.lastName) 接口不能编译为js。 联合类型和接口在接口中使用联合类型： 12345678910111213141516171819interface RunOptions { program:string; commandline:string[]|string|(()=&gt;string); } // commandline 是字符串var options:RunOptions = {program:\"test1\",commandline:\"Hello\"}; console.log(options.commandline) // commandline 是字符串数组options = {program:\"test1\",commandline:[\"Hello\",\"World\"]}; console.log(options.commandline[0]); console.log(options.commandline[1]); // commandline 是一个函数表达式options = {program:\"test1\",commandline:()=&gt;{return \"**Hello World**\";}}; var fn:any = options.commandline; console.log(fn()); 接口和数组接口中可以将数组的index和value设置为不同类型。 接口的继承接口的继承就是一个接口可以继承多个接口。使用关键字 extends 。 使用： 123interface_A extends interface_Binterface_A extends interface_B, interface_C, interface_D 实例：单继承 1234567interface Person { age:number } interface Musician extends Person { instrument:string } 实例：多继承 123456789interface IParent1 { v1:number } interface IParent2 { v2:number } interface Child extends IParent1, IParent2 { } 类类的定义ts是面向对象的js。 类描述了所创建对象的共同的属性和方法。 ts支持面向对象的所有特性：类、接口等。 ts类的定义： 12345class class_name { // 字段：是类里面声明的变量。字段表示对象的有关数据。 // 构造函数：类实例化时调用，可以为类的对象分配内存。 // 方法：方法为对象要执行的操作。} 实例： 12class Person {} 创建类的数据成员1234567891011121314class Car { // 字段 engine:string; // 构造函数 constructor(engine:string) { this.engine = engine; } // 方法 disp():void { console.log(\"发动机为 : \"+this.engine) } } 实例化使用 new 来实例化类的对象。 12345var object_name = new class_name([ arguments ]);var obj = new Car(\"Engine 1\");obj.var_name;obj.function_name(); 实例： 1234567891011121314151617181920212223class Car { // 字段 engine:string; // 构造函数 constructor(engine:string) { this.engine = engine } // 方法 disp():void { console.log(\"函数中显示发动机型号 : \"+this.engine) } } // 创建一个对象var obj = new Car(\"XXSY1\") // 访问字段console.log(\"读取发动机型号 : \"+obj.engine) // 访问方法obj.disp() 类的继承使用关键字 extends 继承父类，只能继承一个父类。 1class class_A extends class_B 实例： 123456789101112131415161718class Shape { Area:number constructor(a:number) { this.Area = a } } class Circle extends Shape { disp():void { console.log(\"圆的面积: \"+this.Area) } } var obj = new Circle(223); obj.disp()// 圆的面积: 223 ts中一个类只能继承一个父类，但是支持多重继承。 123456789101112class Root { str:string; } class Child extends Root {} class Leaf extends Child {} // 多重继承，继承了 Child 和 Root 类 var obj = new Leaf(); obj.str =\"hello\" console.log(obj.str)// hello 继承类的方法重写子类继承了父类以后，子类可以对父类的方法重写。 super 关键字是对父类的引用，可以使用 super 引用父类的属性和方法。 12345678910111213class PrinterClass { doPrint():void { console.log(\"父类的 doPrint() 方法。\") } } class StringPrinter extends PrinterClass { // 重写doPrint doPrint():void { super.doPrint() // 调用父类的函数 console.log(\"子类的 doPrint()方法。\") } } static关键字static 关键字用于定义类的数据成员（属性和方法）为静态，静态成员可以通过类名调用。 12345678910class StaticMem { static num:number; static disp():void { console.log(\"num 值为 \"+ StaticMem.num) } } StaticMem.num = 12 // 初始化静态变量StaticMem.disp() // 调用静态方法 instanceof运算符用于判断对象是否是指定的类型。 12345class Person{ } var obj = new Person() var isPerson = obj instanceof Person; console.log(\"obj 对象是 Person 类实例化来的吗？ \" + isPerson);// obj 对象是 Person 类实例化来的吗？ true 访问控制修饰符ts中可以使用访问控制修饰符来保护对类、变量、方法和构造方法的访问。 public：默认值，共有，在任何地方都可以被访问。 protected：受保护的，只可以被自己和子类和父类访问。 private：私有的，只能被其定义所在的类访问。 12345678class Encapsulate { str1:string = \"hello\" private str2:string = \"world\" } var obj = new Encapsulate() console.log(obj.str1) // 可访问 console.log(obj.str2) // 编译错误， str2 是私有的 类和接口类可以用 implements 关键字实现接口并将 interest 字段作为类的属性使用。 1234567891011121314151617interface ILoan { interest:number } class AgriLoan implements ILoan { interest:number rebate:number constructor(interest:number,rebate:number) { this.interest = interest this.rebate = rebate } } var obj = new AgriLoan(10,1) console.log(\"利润为 : \"+obj.interest+\"，抽成为 : \"+obj.rebate )// 利润为 : 10，抽成为 : 1 对象对象的定义对象是键值对的集合。 12345678var object_name = { key1: \"value1\", // 标量 key2: \"value\", key3: function() { // 函数 }, key4:[\"content1\", \"content2\"] //集合} 1234567var sites = { site1:\"Runoob\", site2:\"Google\" }; // 访问对象的值console.log(sites.site1) console.log(sites.site2) 类型模板js对象添加方法： 12345678var sites = { site1: \"Runoob\", site2: \"Google\"};sites.sayHello = function() { return \"hello\";} ts中的对象必须是特定类型的实例： 123456789var sites = { site1: \"Runoob\", site2: \"Google\", sayHello: function () { } // 类型模板};sites.sayHello = function () { console.log(\"hello \" + sites.site1);};sites.sayHello(); 鸭子类型鸭子类型是动态类型的一种风格，是多态的一种形式。 123456789101112131415interface IPoint { x:number y:number } function addPoints(p1:IPoint,p2:IPoint):IPoint { var x = p1.x + p2.x var y = p1.y + p2.y return {x:x,y:y} } // 正确var newPoint = addPoints({x:3,y:4},{x:5,y:1}) // 错误 var newPoint2 = addPoints({x:1},{x:4,y:3}) 命名空间命名空间是用来解决命名重名的问题。命名空间定义了标识符的可见范围。ts中使用 namespace 来定义命名空间。 定义命名空间： 1234namespace SomeNameSpaceName { export interface ISomeInterfaceName { } export class SomeClassName { } } 使用 export 关键字让外部可以调用 SomeNameSpaceName 中的类和接口。 在另一个命名空间调用： 1SomeNameSpaceName.SomeClassName; 如果一个命名空间在一个单独的ts文件中，使用 /// 引用它： 1/// &lt;reference path = \"SomeFileName.ts\" /&gt; 嵌套命名空间可以将一个命名空间定义在另一个命名空间里面, 成员的访问使用点号。 模块 TypeScript 模块的设计理念是可以更换的组织代码。模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的JavaScript模块加载器是服务于 Node.js 的 CommonJS 和服务于 Web 应用的 Require.js。此外还有有 SystemJs 和 Webpack。 使用 export 关键字导出模块： 1234// 文件名 : SomeInterface.ts export interface SomeInterface { // 代码部分} 使用 import 关键字导入上面的模块： 1import someInterfaceRef = require(\"./SomeInterface\"); 声明文件声明 TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。 实例：ts获取id在js中： 1234// js中使用jquery获取id$('#foo');// 或jQuery('#foo'); 在ts中： 123// 用declare关键字定义它的类型declare var jQuery: (selector: string) =&gt; any;jQuery('#foo'); 上面代码的编译结果是： 1jQuery('#foo'); 声明文件声明文件以 .d.ts 结尾。 声明文件或者模块： 12declare module Module_Name {} ts引入声明文件： 1/// &lt;reference path = \" runoob.d.ts\" /&gt; 实例：这是一个第三方库文件：CalcThirdPartyJsLib.js 1234567891011121314151617var Runoob;(function(Runoob) { var Calc = (function() { function Calc() {} }) Calc.prototype.doSum = function(limit) { var sum = 0; for (var i = 0; i &lt;= limit; i++) { sum = sum + i; } return sum; } Runoob.Calc = Calc; return Calc;})(Runoob || (Runoob = {}));var test = new Runoob.Calc(); 在ts中引用上面的文件，在声明文件中要这样写： 12345declare module Runoob { export class Calc { doSum(limit:number) : number; }} 把声明文件加入到ts中： 1234/// &lt;reference path = \"Calc.d.ts\" /&gt; var obj = new Runoob.Calc(); // obj.doSum(\"Hello\"); // 编译错误console.log(obj.doSum(10)); 然后编译ts文件。 然后在html中引入编译后的文件以及第三方库文件： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=\"CalcThirdPartyJsLib.js\"&gt;&lt;/script&gt; &lt;script src=\"CalcTest.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 总结接口、类、对象、命名空间、模块以及声明文件需要再配合其他资料理解一下。 参考 https://www.runoob.com/typescript/ts-tutorial.html https://www.tslang.cn/docs/handbook/basic-types.html https://ts.xcatliu.com/","link":"/2020/12/03/typescript-tutorial/"},{"title":"vscode的配置及使用技巧","text":"收录一下vscode的使用技巧。 修改资源管理器文件排序方式 设置中搜索sort order，找到工作区Explorer: Sort Order修改为modified（按照修改日期排序）。","link":"/2019/02/09/vscode-tips/"},{"title":"webpack入门","text":"webpack是一个前端资源加载、打包工具。webpack会根据模块的依赖关系进行静态分析，将这些模块按照指定的规则生成对应的静态资源。webpack可以将多种静态资源转换成一个静态文件，减少了请求。 安装1cnpm install webpack -g 创建项目 新建项目目录 1mkdir app 创建index.html和test.js文件 index.html： 12345678&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"bundle.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; test.js文件： 1document.write(\"It works.\"); 打包1webpack test.js bundle.js 上面的命令将test.js编译成了bundle.js文件。 实例test2.js： 1module.exports = \"It works from test2.js.\"; 更新 test.js 文件： 1document.write(require(\"./test2.js\")); 使用webpack打包： 1webpack test.js bundle.js webpack会根据模块的依赖关系进行静态分析，这些文件会被打包进bundle.js中。webpack会给每一个模块分配一个唯一的id并通过这个id索引和访问模块。页面启动的时候，会先执行test.js中的代码，其他模块会在运行require的时候运行。 loaderwebpack本身只能处理js模块。如果要处理其他类型的文件需要使用loader进行转换。 在项目目录下安装css-loader和style-loader： 1cnpm install css-loader style-loader js文件中require css文件既可。 自动绑定需要的loader并打包： 1webpack test.js bundle.js --module-bind 'css=style-loader!css-loader' 配置文件可以将一些编译选项放在配置文件中便于管理。创建webpack.config.js文件： 12345678910111213module.exports = { entry: \"./test.js\", output: { path: __dirname, filename: \"bundle.js\" }, module: { loaders: [{ test: /\\.css$/, loader: \"style-loader!css-loader\" }] }}; 下面只需要执行webpack命令既可生成bundle.js文件： 1webpack webpack会默认载入当前目录下的webpack.config.js文件。 插件可以通过cnpm安装一些内置插件： 1cnpm install webpack --save-dev 下面安装BannerPlugin，用于在文件头部输出一些注释信息，下面修改webpack.config.js： 123456789101112131415161718var webpack = require('webpack');module.exports = { entry: \"./test.js\", output: { path: __dirname, filename: \"bundle.js\" }, module: { loaders: [{ test: /\\.css$/, loader: \"style-loader!css-loader\" }] }, plugins: [ new webpack.BannerPlugin('webpack实例') ]}; 然后运行 webpack 命令既可。 开发环境让编译的输出更加人性化： 1webpack --progress --colors 监听模式或者说增量编译： 1webpack --progress --colors --watch 可以使用webpack-dev-server，自动运行webpack自动编译和刷新页面： 12345# 安装cnpm install webpack-dev-server -g# 运行webpack-dev-server --progress --colors","link":"/2019/01/02/webpack-tutorial/"},{"title":"技术周报-01","text":"技术周报","link":"/2020/07/19/weekly-01/"},{"title":"youtube快捷键","text":"youtube网页按ctrl+/来查看youtube网页端快捷键。","link":"/2018/11/27/youtube-shortcut-key/"},{"title":"使用markdown写作","text":"markdown是一种简单的文本标记语言，本篇文章也是用markdown写的。 markdown可以用于微信公众号、简书、知乎以及hexo、wordpress等等文章的书写。 markdown文件的扩展名为.md。 markdown文件借助一些markdown编辑器比如Typora就可以导出为pdf、html、word、epub、LaTex、Media Wiki等文件格式。 以上的&lt;!-- more --&gt;是hexo中用来分割summary和article的语法。 推荐阅读书籍《了不起的Markdown》，不过掌握一个markdown好像也不需要专门读一本书。 目录用来生成文章目录，看渲染器是否支持。 1[toc] 标题123456# h1## h2### h3#### h4##### h5###### h6 12345一级标题=======二级标题------- 文本基本文本样式12345*斜体***粗体*****粗体斜体***~~删除线~~&lt;u&gt;下划线&lt;/u&gt; 脚注12需要添加角注的内容[^角注标题][^角注标题]: 角注内容 段落用一个空行来表示开启一个新的段落。 列表 列表可以与列表嵌套。 引用可以与列表互相嵌套。 无序列表使用-或者* +，以下使用-。 12- item1- item2 12345- item1 - item1.1- item2 - item2.1 - item2.2 有序列表121. item12. item2 清单123- [ ] 买衣服- [ ] 买菜- [ ] 学习 引用引用可以与列表互相嵌套。 单行： 1&gt; 这是一段引用的内容 多行： 123&gt; row1&gt; row2&gt; row3 嵌套： 123&gt; 第一层引用&gt; &gt; 第二层引用&gt; &gt; &gt; 第三层引用 分割线123---***+++ 表格Markdown制作表格使用 |来分隔不同的单元格，使用- 来分隔表头和其他行。 根据冒号的位置决定对齐方式。 语法： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 示例： 123| 姓名 | 性别 | 年龄 || :-- | --: | :--: || 小明 | 男 | 12 | 姓名 性别 年龄 小明 男 12 链接基本链接alt可以省略。 123[title](url \"alt\")或者&lt;url&gt; 高级链接 文档最下方先定义变量。 在文档中引用，给定链接名称和变量名。 12[谷歌官网][google][google]: https://www.google.com/ 图片基本用法1![title](url \"alt\") 高级用法高级用法同高级链接，先定义变量和值，再在文中引用链接名称和变量名。 12[风景图片][view][view]: image_url 其他用法markdown无法指定图片宽高，可以使用&lt;img&gt;标签代替。 1&lt;img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\"&gt; 代码小段代码 ，类似于行内元素： 1`code` 大段代码 ，类似于块元素： 先写三个反引号，紧接着加上语言，然后换行写代码，再在最后一行写三个反引号。 这里markdown中嵌套代码无法被hexo正确解析，所以不放代码了。 高级用法支持的html标签markdown支持的html标签：kbd b i em sup sub br等等。 1234567&lt;kbd&gt;ctrl&lt;/kbd&gt;&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;em&gt;强调&lt;/em&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;br&gt;换行 转义字符在特殊符号前面加上\\来表示该符号。 1\\* 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符$$ 包裹TeX 或 LaTeX格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： 12345678$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ 流程图 代码来自菜鸟教程 hexo无法解析流程图，故而在本博客看不到效果。 故而hexo只能使用制图软件作图 下面的代码都要放在三个反引号包裹的代码块内。 横向流程图 语言：mermaid 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 效果： 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 竖向流程图 语言：mermaid 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C{条件a} C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 效果： 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C{条件a} C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 标准流程图 语言：flow 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 效果： 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 标准流程图（横向） 语言：flow 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 效果： 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op UML时序图 语言：sequence 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ 效果： 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ UML时序图（复杂） sequence 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 效果： 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 UML时序图（标准） 语言：mermaid 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 效果： 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 甘特图 语言：mermaid 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h 效果： 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h","link":"/2020/03/10/%E4%BD%BF%E7%94%A8markdown%E5%86%99%E4%BD%9C/"},{"title":"前端开发中的各种引入","text":"总结一下前端开发中常使用的各种引入方式。 html中引入外部样式文件 123&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\"&gt;&lt;/head&gt; html中引入文档样式表 1&lt;style type=\"text/css\"&gt;&lt;/style&gt; @import引入外部样式表 写在style标签里面或者css文件里面。 3.1 在css文件中@import 1@import url(css/style.css); 3.2 在style标签中@import 123&lt;style type=\"text/css\"&gt; @import url(css/style.css);&lt;/style&gt; 3.3 指定样式媒体 123@import url(css/screen.css) screen;@import url(css/print.css) print;@import url(css/commom.css)screen print;","link":"/2019/06/30/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%95%E5%85%A5/"},{"title":"前端开发常用字体","text":"serif(衬线体)Times Georgia New Century Schoolbook sans-serif(非衬线体)Helvetica Geneva Verdana Arial Univers monospaceCourier Courier New Andale Mono cursive(手写体)Zapf Chancery Author Comic Sans fantasyWestern Woodblock Klingon","link":"/2018/12/09/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%AD%97%E4%BD%93/"},{"title":"详解响应式网页设计","text":"总结一下响应式设计，包括响应式页面和响应式图片。 响应式页面包括根据不同设备&lt;link&gt;不同的css样式文件，还有css中使用@media规则。 响应式页面 首先在&lt;head&gt;中加入&lt;meta&gt;： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt; user-scalable=no 能够解决iPad切换横屏之后触摸才能回到具体尺寸的问题 表示网页默认宽度等于屏幕宽度，原始缩放比例为100%。 不能使用绝对宽度，只能用em,%。 对于元素宽度，不能使用px，只能用百分比或者auto。 123header { width: 80%;} 对于字体带下，不能使用px，只能使用em等相对单位。 123456789/*body字体大小设置为10px*/body { font-size: 62.5%;}/*h1字体大小设置为15px*/h1 { font-size: 1.5em;} 使用float使文档在横向放不下的时候自动换行，小心绝对定位的使用。 使用媒体查询选择性使用css 12345&lt;!-- 如果宽度小于400px则使用tinyScreen.css --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-device-width: 400px)\" href=\"tinyScreen.css\" /&gt;&lt;!-- 如果宽度在400到600则使用smallScreen.css --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (min-width: 400px) and (max-device-width: 600px)\" href=\"smallScreen.css\" /&gt; 也可以在css中引入外部样式： 1@import url(\"tinyScreen.css\") screen and (max-device-width: 400px); @media规则 以上媒体查询的作用是根据不同的宽度选择不同的css文件。 而@media的作用是根据不同的宽度选择不同的样式，也就是说只有符合@media后面的规则，声明块才会生效。 语法规则：@media media_type and （media_feature）{} 12345@media screen and (max-width: 400px) { body { background-color:#111; }} 设置多种屏幕宽度的样式： 12@media only screen and (min-width: 768px) and (max-width: 1024px) {}@media only screen and (min-width: 320px) and (max-width: 767px) {} 对于页面响应式设计，还可以通过写一个common.css，媒体查询为移动端后再写单独的mobile.css来覆写common.css里面的一些样式来达到响应式，或者直接就将多个适配样式写在一个css里面，像下面这样： 123@media only screen and (min-device-width : 320px) and (max-device-width : 480px) {}@media only screen and (min-width : 321px) {}@media only screen and (max-width : 320px) {} 关于媒体查询中的关键词：and only not only用来指定媒体类型： 1@media only screen and (max-width: 1920px;) {} not用来排除媒体类型： 1@media not print and (max-width: 1000px) {} max-device-width和max-width的区别： max-device-width是设备的屏幕宽度。 max-width是浏览器宽度。 区别就是，在pc上查看网页的时候，缩放网页，max-device-width不执行css，因为设备宽度没变。而max-width执行css，因为显示宽度发生了变化。 那么什么时候用max-device-width什么时候用max-width？ 通常来说，移动端用max-device-width，pc端用max-width。这也符合了我们的生活经验，使用手机缩放网页网页没有发生变化，而使用浏览器缩放网页网页会发生变动。 图片自适应 图片自适应：给图片指定最大宽度，如果超过就缩小，如果图片小就原尺寸显示。 1234img { width: auto; max-width: 100%;} 图片、视频自适应： 1234img,object { width: auto; max-width: 100%;} 老版本IE： 123img { width: 100%;} 此外，windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的专有命令： 123img { -ms-interpolation-mode: bicubic;} 或者，Ethan Marcotte的imgSizer.js。 1234addLoadEvent(function() { var imgs = document.getElementById(\"content\").getElementsByTagName(\"img\"); imgSizer.collate(imgs); }); 不过，最好还是根据不同大小的屏幕加载不同分辨率的图片。 响应式图片为此，img标签引入了srcset属性： 1x,1.5x,2x为像素密度描述符，用来让浏览器识别，1x可省略。 描述符还可以是320w,480w等等。 1234&lt;img srcset=\"pic-320.jpg 1x, pic-480.jpg 1.5x, pic-640.jpg 2x\" src=\"pic.jpg\"&gt; 浏览器会根据设备像素密度选择合适的图片，如果没有合适的则使用src图片。 还可以使用sizes指定不同规则的屏幕使用不同的图片： sizes属性后面可以有多个以逗号隔开的段，每段前面是一个媒体查询，空格后面是要给该规格屏幕所指定的图片显示宽度。最后256px为缺省值。 注意：100vw为100%的屏幕宽度。 1234567&lt;img srcset=\"pic-320.jpg 320w, pic-480.jpg 480w, pic-640.jpg 640w\" sizes=\"{max-width: 320px} 100vw, {max-wdith: 640px} 25vw, 256px\" src=\"pic.jpg\"&gt; 浏览器对以上代码的执行：根据设备屏幕宽度从sizes选择图片显示宽度，再从secset中找出最接近的图片加载。故而sizes是要和srcset配合使用的，src为缺省值。 picture标签picture是容器标签，内部有source和img。 写法如下： 12345&lt;picture&gt; &lt;source media=\"(max-width: 500px)\" srcset=\"cat-vertical.jpg\"&gt; &lt;source media=\"(min-width: 501px)\" srcset=\"cat-horizontal.jpg\"&gt; &lt;img src=\"cat.jpg\" alt=\"cat\"&gt;&lt;/picture&gt; 浏览器会根据source标签中的media依此判断设备屏幕是否符合，一旦遇到符合的media则选择其后面的srcset图片，如果所有source中的media都不符合则使用img标签中的src。 下面是一个综合例子： 1234567891011&lt;picture&gt; &lt;source srcset=\"homepage-person@desktop.png, homepage-person@desktop-2x.png 2x\" media=\"(min-width: 990px)\"&gt; &lt;source srcset=\"homepage-person@tablet.png, homepage-person@tablet-2x.png 2x\" media=\"(min-width: 750px)\"&gt; &lt;img srcset=\"homepage-person@mobile.png, homepage-person@mobile-2x.png 2x\" alt=\"Shopify Merchant, Corrine Anestopoulos\"&gt;&lt;/picture&gt; 使用source的type属性用来加载不同格式的图片： 12345&lt;picture&gt; &lt;source type=\"image/svg+xml\" srcset=\"logo.xml\"&gt; &lt;source type=\"image/webp\" srcset=\"logo.webp\"&gt; &lt;img src=\"logo.png\" alt=\"ACME Corp\"&gt;&lt;/picture&gt; 浏览器对以上代码，从上往下，依此检测是否支持image/svg+xml image/webp，一旦遇到支持的就使用这个srcset图片，若都不支持就使用img。","link":"/2020/03/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"},{"title":"在hexo中加入gitbook","text":"写一下如何在hexo中添加gitbook。 添加目录 进入blog/source/下 创建目录：mkdir gitbook 修改_config.yml文件 打开根目录下的_config.yml文件 找到skip_render，并按如下形式配置： 12345# 默认配置应该是这样的skip_render: README.md# 添加对gitbook目录的不解析，星号有两个代表对该目录下所有文件和目录都不解析skip_render: [README.md,gitbook/**] 工作流 gitbook放置在本地，每次gitbook build后就将build的内容cp到blog/source/gitbook目录下即可。 然后hexo d -g部署到服务器后，gitbook的路径比如我的ownpress.icu/gitbook即可，再写入配置文件增加新的连接或者按钮即可。","link":"/2020/06/27/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5gitbook/"},{"title":"如何使用记忆宫殿","text":"记忆宫殿这种记忆法在上初中的时候听说过。起初是看《读心神探》中的一个案件讲述了两个世界记忆大师，当时就觉得很震撼以为只是编剧效果而已，结果本科的时候发现图书馆里真的有记忆宫殿的书。现在感觉自己急需系统的记忆方法，故而学习一下记忆宫殿这种古老而又实用的记忆法。 ​ 在学习记忆宫殿之前，我先回忆一下我以往的记忆方法和记忆习惯，这非常重要。 对于语文中的古诗和宋词，我采用的是将每一句诗形象化为一张图片，第一句到最后一句就形成了类似放电影一样的小段场景，并且尽量使得场景要尽可能合理化。加之以朗读的方式加强口腔肌肉记忆和听觉记忆。 对于数字的记忆我并没有什么好的方法，基本就是靠读出来产生听觉记忆，比如圆周率pi前几位是$3.141592653$，阿伏伽德罗常数是$ 6.02 \\times 10^{23} $。 对于历史就是在大脑中模拟历史事件发生。 对于政治内容，由于政治课内容有一定的逻辑性，故而采用想象事件并使事件步骤化并且合理化步骤来记忆。 对于图形，比如地理中的各种地图、数学中的函数图像，我还是能很段时间就记住的，毕竟图像才是对不容易被大脑忽视的。 ​ 我总结下来的我所认为的记忆宫殿的方法（我发现记忆宫殿的效果真的很恐怖）： 建造宫殿，也就是先选择一个自己非常熟悉（熟悉到可以闭着眼睛想象场景里面什么位置有什么）的房间、建筑或者其他场景。并且这个场景还不能太单一，比如极简装修的客厅。这是不可以的，因为这直接决定了这个宫殿可以存储记忆的多少。 这里创建一个这样的场景：这是一个loft户型（有两层），一楼是一个客厅，客厅中间有一个木制的茶几，有三张独立的沙发椅放置在茶几的左边右边和后边，茶几的前面是客厅的墙壁，墙壁上挂着一台液晶电视，电视的下面是一个电视机柜，电视和电视机柜的右边是一个储物柜。电视的左边是一块空地，空地忘前面就是一个扶手梯用于进入二楼。 场景就是这么简单，我要做的就是做到在闭眼的情况下假设你坐在客厅的沙发上，你要想像出你坐在这个位置上以后这个客厅的其他东西的位置，一定要在脑子中渲染一遍这个模型，这样才会有身临其境的印象。将模型渲染为图像的过程是极其重要的。 比如现在我要记忆这么几个词语：成功，干红，苹果，电话，照射，花瓶，孩子，玩具，中国，红星，美女 一共11个词语，这些词语看似杂乱无章，限定时间让一般人记忆的话基本上都是靠机械性的朗读，然后也没记住几个。 这11个词语记忆的难点就是动词，名词都有。 现在你闭上眼睛，想象你自己处在你所建立的好的这个记忆宫殿也就是客厅里面，你是一个成功的企业家，电视机所在的位置为客厅的北边，你做在的位置是东边的沙发上，你看着南边（正对着电视）的沙发上坐着一个美女，她是你的妻子，你的妻子面前的茶几上放着一盘苹果。妻子左手边有一台电话以及一个落地灯，落地灯正开着并照射着沙发所在的区域。你站起来走过茶几来到客厅西边的一块空地，你的孩子正在空地上玩着玩具，你摸摸他的头，然后回到客厅中央，也就是电视和茶几中间，你看着电视上正在播放着新闻，新闻内容是南海某国渔船进入了我国南海海域非法作业，电视上出现了一副中国地图，地图上除了指出了事发海域坐标之外还有一颗红星非常显眼，那就是中国的首都北京。你看完了新闻继续走到了客厅的东边，还记得那里有什么吗？那里是一个储物柜，透过玻璃柜门，你选了一瓶法国波尔多的干红拿到茶几上起开酒瓶开始与你的妻子共享。 现在，你已经完成了这个事件的演绎，这个过程就称之为编码，什么是编码？就是将信息以特定的形式存储起来。现在你已经完成了对于这11个词语的存储！你已经将11个动词名词变成了客厅这个对象的属性和方法。 演绎的过程越真实，越有情节，越带感情，那么编码这个过程就会越牢固。 现在，我们已经完全记住了这11个单词。不信吗？我之前也不信，可是当我在两个小时前看完这个方法之后，我两个小时后再回忆这11个词，我竟然一个词都没忘记。 现在我们试着回忆刚才我们所演绎的场景，你闭上眼睛进入这个客厅，将你所扮演的角色和移动轨迹回忆一下，你将会回忆起所有的词语。一小时后你再回忆一下这个客厅以及你所扮演的角色和经过的地方，依然可以回忆出11个词。第二天再回忆一下，依然可以！ 当时我使用记忆宫殿记忆11个词的时间很短，也就大脑中演绎了一下，也没当回事。可是当我写这个文章的时候我才发现我真的一个词不少的全都记住了，我决定深入学习记忆宫殿这个记忆法。 我分析了一下我在记忆的过程中发生了什么：我创造了一个存放记忆的宫殿，我把自己带入这个宫殿扮演一个角色，我从一点到另外一个点，中间经历了一些东西和人，最后我走到终点。期间我所经过的所有东西和人都被我赋予了属性或者方法，我在回忆的过程中不断的经历和感受我演绎的时候所经历过的东西和人，我不断的联想起了这些东西的名称或者这些东西的方法名称。这就完成了读取记忆宫殿信息的过程，也就是对于信息的读取过程。 像平常记忆一样，经常回忆这个过程可以加深记忆，不过记忆宫殿可以达到长期记忆的作用。 ​ 待阅读书籍：《与爱因斯坦月球漫步》，《多米尼克的记忆魔法书》，《我最想要的记忆魔法书》。","link":"/2020/03/26/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BF%86%E5%AE%AB%E6%AE%BF/"},{"title":"htop：一款unix交互进程管理器","text":"htop - an interactive process viewer for Unix 下载下载源码：http://hisham.hm/htop/releases/ 下载完毕后tar -zxvf解包。 安装进入解包完的目录 1234# 编译安装./configuresudo makesudo make install 疗效","link":"/2020/07/08/%E5%AE%89%E8%A3%85htop/"},{"title":"干掉Adobe Creative Cloud在Macos中的启动项","text":"Adobe Creative Cloud是安装PS、AI等Adobe软件安装时自动安装的，可是流氓的Adobe会在macos启动后自启动好几个Adobe的后台进程，研究了一下如何干掉所有的自启动进程。 结束相关进程首先，打开macos的活动监视器手动选中所有adobe的进程并强制结束。 删除相关文件在以下目录中寻找com.adobe开头的文件并删除。 ~/Library/LaunchAgents /Library/LaunchAgents /Library/LaunchDaemons 最好不要删除gc文件。 进入：/Applications/Utilities/Adobe Creative Cloud目录下，删除CCLibrary, CCXProcess, CoreSync文件夹。 修改设置进入：系统偏好设置&gt;扩展，关闭所有的adobe的扩展。 done!","link":"/2020/06/24/%E5%B9%B2%E6%8E%89Adobe-Creative-Cloud%E5%9C%A8Macos%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E9%A1%B9/"},{"title":"开启vim代码高亮","text":"vim安装完后默认没有开启代码高亮，尽管开发使用GUI的编辑器和IDE，但是但是有时候也需要用vim看一下或者临时小修改一下代码。 vim代码高亮配色文件的路径是：/usr/share/vim/vim/vim81/colors 上面的vim81为版本，直接cd到/usr/share/vim/vim/下进入版本目录下查看colors既可，配色文件都是.vim为扩展名。 添加配置信息： 1vim ~/.vimrc 123set nu colorscheme &lt;theme&gt;syntax on theme为配色文件名称。","link":"/2020/06/24/%E5%BC%80%E5%90%AFvim%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/"},{"title":"所谓编译型语言和解释型语言的误区","text":"什么是解释型语言？什么是编译型语言？python是解释型语言？clang是编译型语言？java是解释型语言？no，no，no。其实这种根深蒂固的说法是错的。 一门编程语言本身并不具有是解释型语言还是编译型的属性，准确的说法是：某个语言的特定实现是编译型或者解释型的。 比如javascript这个语言，它既有解释型的实现比如早期浏览器的js引擎，也有编译型的实现比如chrome的v8引擎。 再拿一个后端的语言scheme为例，chichen scheme为scheme提供了两套实现方式，一个是解释器csi，另一个是编译器csc。 故而，所谓的编译型、解释型并不是一门语言本身固有的属性，而是语言实现的特性。","link":"/2020/09/02/%E6%89%80%E8%B0%93%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AF%E5%8C%BA/"},{"title":"所谓面向过程、面向对象以及函数式语言的误区","text":"java是面向对象语言？clang是面向过程语言？lisp是函数式编程语言？ 比如python和javascript，我们既可以用他们写出函数式编程的代码，也可以用他们写出面向对象风格的代码，还可以写出两者兼具的代码。 即使是java也可以用其写出函数式风格的代码。 还有common lisp这种函数式编程语言的代表也可以写出面向对象的代码。 因此，一刀切的将语言分为面向对象、面向过程、函数式是不科学的。 其实每一门语言都拥有多种特性。","link":"/2020/09/03/%E6%89%80%E8%B0%93%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80/"},{"title":"文件命名规范","text":"《中文技术文档写作规范》规定了文件的命名规范： “文件名建议只使用小写字母，不使用大写字母。” “为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。” 故而，一言以蔽之“文件名一律小写”。 有下面几点缘由： linux系统大小写敏感，windows和macos大小写不敏感。所以如何文件名大小写混用或者大写的话就可能造成文件识别问题。 小写字母更易读，这个我们从小就阅读的小写字母课本，自然不用说。 易用，与系统目录区分开来。 便携，大大减少了我们按shift来回切换大小写的不必要的工作量。 命令行下还不用-i参数。 总结： 文件名使用全小写或者小写加连词线。 比如： main.js index-header.vue","link":"/2020/03/25/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"title":"什么是新基建","text":"什么是新基建？ 新型基础设施建设（简称：新基建），主要包括5G基站建设、特高压、城际高速铁路和城市轨道交通、新能源汽车充电桩、大数据中心、人工智能、工业互联网七大领域，涉及诸多产业链 ，是以新发展理念为引领，以技术创新为驱动，以信息网络为基础，面向高质量发展需要，提供数字转型、智能升级、融合创新等服务的基础设施体系。2020年3月，中共中央政治局常务委员会召开会议提出，加快5G网络、数据中心等新型基础设施建设进度。2020年5月7日，从上海市政府新闻发布会上介绍的《上海市推进新型基础设施建设行动方案（2020-2022年）》获悉，上海初步梳理排摸了这一领域未来三年实施的第一批48个重大项目和工程包，预计总投资约2700亿元。2020年5月22日，《2020年国务院政府工作报告》提出，重点支持“两新一重”（新型基础设施建设，新型城镇化建设，交通、水利等重大工程建设）建设。 图片来自所长林超：https://www.bilibili.com/video/BV1H7411y7Hh?from=search&amp;seid=18115219843630947634 新基建的7个领域： 新基建机遇： 5G产业机会图： 4G发牌： 5G产业地图： 做内容需要有设计感、故事感、娱乐感、意义感、同理心，要去像人一样思考而不是像机器一样。 后动优势(late-mover advantage；Second-mover advantage；又称为次动优势、后发优势、先动劣势)是指相对于行业的先进入企业，后进入者由于较晚进入行业而获得的较先动企业不具有的竞争优势，通过观察先动者的行动及效果来减少自身面临的不确定性而采取相应行动，获得更多的市场份额。例如：研发成本优势、行业风险把握优势等。 出来卖的三个维度：","link":"/2020/06/22/%E6%96%B0%E5%9F%BA%E5%BB%BA/"},{"title":"构造大数","text":"给你三个3，你会用来怎么构造一个尽可能大的数呢？ 根据初等数学中的运算符，我们最多能进行如下构造： $3+3+3=9$ $3 * 3 * 3=27$ $3^{3^3}=3^{27}$ ${3!}^{ {3!}^{3!} }=6^{6^6}=6^{46656}$ $6^{46656}$这个数已经足够大了，但是我们最大只能构造出这个数吗？ 事实的确不是这样的。通过以上的几种构造方法，我们可以发现虽然可用的数只有三个3，但是我们仍然通过使用不同的数学运算符构造出了量级相差巨大的几个数。 那么思路很明显了！我们只需要创造一个新的运算符并且给定这个运算符特定的运算规则不就可以创造出比$6^{46656}$大的数了吗？ 答案是肯定的！ 介绍一个新的运算符：高德纳箭头 请看，高德纳箭头是由计算机科学家Donald Ervin Knuth提出的，而他又是Tex的创始人。高德纳箭头的运算规则如下： $3↑3=3^{3}=27$ $3↑↑3=3↑3↑3=3↑{3^3}=3^{3^{3} }$ 以此类推，运算符从右往左结合。 由此下面介绍葛立恒数： 这个数光它的箭头的位数的位数的位数的位数……..的位数就有$3↑↑↑↑3$这么庞大。（此处有63个位数，虽然严禁套娃，但是没办法，这个数字不套娃根本表示不出来） 请注意，光是$3↑↑↑↑3$已经是大到不可想象的数字了。你可以想象如果将宇宙分割成以普朗克尺度为边长的立方体，类似于切豆腐。即使是这样，以普朗克尺度为边长的立方的个数都远远小于$3↑↑↑↑3$，甚至比$3↑↑↑↑3$小到忽略不计，更别提葛立恒数$G(64)$本身有多大了！（括号内数字为葛立恒数的层数） 比葛立恒数大得多的数有很多，比较著名的一个叫tree(3)，不过国内关于tree(3)的资料太少了，有机会再补全tree(3)。 总结：我们要构造一个大数只需要创造一个新的运算符号以及给予它相应的运算规则就可以了。运算符就是一个符号，长什么样由自己决定，关键在于如何为这个运算符设计一个运算规则使得在两个基数经过这个运算符运算后能尽可能的大。 Tips: 这是我的第一篇数学文章，发现了hexo&amp;markdown中的数学公式的一些坑： 行内数学公式使用$包裹公式，块公式使用$$来包裹公式块。 相邻的符号之间用空格隔开。 运算块使用一对花括号{}来包裹式子。 更多的坑待挖掘。 参考： 1. 维基百科：葛立恒数","link":"/2020/03/20/%E6%9E%84%E9%80%A0%E5%A4%A7%E6%95%B0/"},{"title":"清除浮动","text":"前面的元素设置了float: left，那么后面的元素会识别不到前面的元素从而被前面的元素遮挡 12&lt;div class=\"box_1\"&gt;&lt;/div&gt;&lt;div class=\"box_2\"&gt;&lt;/div&gt; 123456789101112.box_1 { width: 100px; height: 100px; background-color: red; float: left;}.box_2 { width: 100px; height: 100px; background-color: yellow; clear: both;} 效果：.box_1和.box_2会各自独占一行。 如果一个元素设置了浮动，对于该元素清除浮动只需要对其父元素之后的元素清除浮动，然后父元素的高度就不会塌陷 这里使用伪元素来插入父元素之后的元素，并将其设置为clear: both 1234&lt;div class=\"parent\"&gt; &lt;div class=\"son_1\"&gt;&lt;/div&gt; &lt;div class=\"son_2\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.son_1 { width: 50%; float: left;}.son_2 { width: 50%; float: right;}.parent::after { content: ''; display: block; clear: both;} 编写.clearfix::after降低工作量 12345.clearfix::after { content: ''; display: block; clear: both;} 以后只需要在父元素class上加clearfix即可。","link":"/2018/06/01/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"title":"用node.js写一个server","text":"在桌面创建一个用于存放server的目录，并且创建server.js 12345cd ~/Desktop/mkdir node-servercd node-servertouch server.jsvim server.js 编写服务器server.js 123456789101112131415161718192021222324var http = require('http')var fs = require('fs')var url = require('url')var port = process.argv[2]if(!port){ console.log(\"请指定端口号，比如\\nnode server.js 8888\") process.exit(1)}var server = http.createServer(function(request, response){ var parsedUrl = url.parse(request.url, true) var path = request.url var query = '' if(path.indexOf('?') &gt;= 0){ query = path.substring(path.indexOf('?')) } var pathNoQuery = parsedUrl.pathname var queryObject = parsedUrl.query var method = request.method console.log('得到 HTTP 路径\\n' + path) console.log('查询字符串为\\n' + query) console.log('不含查询字符串的路径为\\n' + pathNoQuery) response.write('hi') response.end()})server.listen(port)console.log('监听 ' + port + ' 成功\\n请打开 http://localhost:' + port) 运行server.js服务器 1node server.js 8888 这里一个括号空格都不能错，如果报错则百度一下错误代码。这样server.js就成功运行起来了，server.js开始监听8888端口，开始接受来自client的服务请求。 测试 保持这个gitbash窗口运行，新建一个gitbash窗口curl一下http://localhost:8888/docName来测试一下server.js是否能响应请求 服务器正确监听到curl对于8888端口的请求并打印出请求的路径，并给出response：hi，而后end了这个response，此时client收到应答结束了会话回到了可以输入命令行的界面，而server继续处于等待请求的状态，我们使用ctrl+c来中断server.js的进程。 使用 curl -s -v — “http://localhost:8888/docName” 可以查看完整的请求和响应 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041var http = require('http')var fs = require('fs')var url = require('url')var port = process.argv[2]if(!port){ console.log(\"请指定端口号，比如\\nnode server.js 8888\") process.exit(1)}var server = http.createServer(function(request, response){ var parsedUrl = url.parse(request.url, true) var path = request.url var query = '' if(path.indexOf('?') &gt;= 0){ query = path.substring(path.indexOf('?')) } var pathNoQuery = parsedUrl.pathname var queryObject = parsedUrl.query var method = request.method console.log('HTTP 路径为\\n' + path) if(path == '/style.js'){ response.setHeader('Content-Type', 'text/css; charset=utf-8') response.write('body{background-color: #ddd;}h1{color: red;}') response.end() }else if(path == '/script.html'){ response.setHeader('Content-Type', 'text/javascript; charset=utf-8') response.write('alert(\"这是JS执行的\")') response.end() }else if(path == '/index.css'){ response.setHeader('Content-Type', 'text/html; charset=utf-8') response.write('&lt;!DOCTYPE&gt;\\n&lt;html&gt;' + '&lt;head&gt;&lt;link rel=\"stylesheet\" href=\"/style.js\"&gt;' + '&lt;/head&gt;&lt;body&gt;' + '&lt;h1&gt;你好&lt;/h1&gt;' + '&lt;script src=\"/script.html\"&gt;&lt;/script&gt;' + '&lt;/body&gt;&lt;/html&gt;') response.end() }else{ response.statusCode = 404 response.end() }})server.listen(port)console.log('监听 ' + port + ' 成功\\n请打开 http://localhost:' + port)","link":"/2019/05/24/%E7%94%A8node-js%E5%86%99%E4%B8%80%E4%B8%AAserver/"},{"title":"算法Day01:青蛙跳台阶","text":"问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 示例 1： 输入：n = 2输出：2示例 2： 输入：n = 7输出：21提示： 0 &lt;= n &lt;= 100 来源：力扣（LeetCode） 算法思想：输入n为台阶个数，f(n)为方式种类个数，f(0) = 0,f(1) = 1,f(2) = 2,f(n) = ?，如果第一次跳一个台阶则这种情况下的方式个数为f(n-1)，如果第一次跳两个台阶则这种情况下方式个数为f(n-2)。故而f(n)=f(n-1)+f(n-2). 斐波那契数列：1，1，2，3，5，8，13… 前两个数之和构成第三个数。 下面编写递归算法： 123456function fibo(n) { if(n &lt; 1) return 0; if(n === 1) return 1; if(n === 2) return 2; if(n &gt; 2) return fibo(n-1)+fibo(n-2);}","link":"/2020/03/22/%E7%AE%97%E6%B3%95Day01/"},{"title":"网页性能优化","text":"参考阮一峰老师的文章总结一下网页性能问题以及优化，包括css和js的方法。 网页生成过程 HTML代码转化成DOM。 CSS代码转化成CSSOM（CSS Object Model）。 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）。 生成布局（layout），即将所有渲染树的所有节点进行平面合成。 将布局绘制（paint）在屏幕上。 其中影响性能的是4和5。这两步称之为“渲染”，在网页使用的过程中最少渲染一次，在用户访问网页的过程中还可能发生多次渲染。 那么，什么情况下网页会重新渲染呢？ dom改变 样式改变 事件发生 以上任意一项发生改变，网页就会重拍和重绘。 重排必然导致重绘，而重绘不一定导致重排。 提高性能于是乎，我们提高性能的思路就是：降低重排和重绘的频率和单次成本以减少出发浏览器对于网页的重新渲染（重排，重绘）。 尽量不要把读操作和写操作放在一个语句里。 1234567891011// bad examplediv.style.left = div.offsetLeft + 10 + \"px\";div.style.top = div.offsetTop + 10 + \"px\";// 拆开写// good examplevar left = div.offsetLeft;var top = div.offsetTop;div.style.left = left + 10 + \"px\";div.style.top = top + 10 + \"px\"; 一般来说： 样式表越简单，重新渲染就越快。 DOM层级越高，成本越高。 table渲染成本高于div。 技巧： DOM的多个读操作放一起写，不要读写操作穿插。 对于重排而言，缓存可以提高性能避免下次不必要的重排。 不要一次次改变样式，尽量一次性改变样式。 尽量使用离线DOM来改变样式 如果将一个元素display: none，再对该元素进行100次操作，最后恢复原本display。总计用了两次渲染。避免了在元素显示的情况下不必要的100次渲染。 absolute fixed sticky渲染开销小，是由DOM决定的。 只在必要情况下将display设置为非none，这样可以极大减少渲染次数。对于visibility: hidden元素，只会重排一次，可能重绘多次。 可以使用虚拟DOM库。 使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染。 刷新率浏览器刷新率为60hz，当页面滚动时，浏览器会对网页以每秒60次的频率重新渲染。 也就是说，每隔$ 1000/60=16.7 $毫秒，浏览器就要渲染完毕一帧的画面。 解决办法是使用web worker，主线程用于ui渲染，worker线程用来渲染其他的任务。 network面板打开chrome开发者工具的network面板。 点击原点开始录制，然后模仿用户操作，再点一下原点完成录制。 事件模式：查看影响性能的原因。蓝色表示载入，黄色表示js，则色表示渲染，绿色表示重绘图。 帧模式：用于查看每帧耗时，越高耗时越多。 两条线，上面一条表示30帧，低于这条线就能以高于30帧的频率渲染，下面是60帧线，低于它代表可以达到每秒60帧以上。 window.requestAnimationFrame()使用一些js方法调节渲染提高性能。 这里window.requestAnimationFrame()，可以将一些代码放到下一次渲染时一起渲染。 这是一个让elements中的每一个元素高度增加一倍的方法doubleHeight() 12345678function doubleHeight (element) { // read operation var currentHeight = element.clientHeight; // write operation element.style.height = (currentHeight * 2) + 'px'}elements.forEach(doubleHeight); 这里浏览器对于该方法的渲染过程是：依此渲染每一个elements中元素的高度，并且每一个元素都要进行一次read和一次write。这就严重影响了性能。 使用window.requestAnimationFrame()将read和write分离，使得所有的write放到下一次执行。 123456789function doubleHeight (element) { // read var currentHeight = element.clientHeight; // 使用window.requestAnimationFrame() window.requestAnimationFrame(function () { element.style.height = (currentHeight * 2) + 'px'; });}elements.forEach(doubleHeight); 这样浏览器会一次性读取每一个elements中元素的高度，并在浏览器下一次渲染时一次性将所有的elements中的元素高度写为原来的两倍。 window.requestAnimationFrame()的应用场景：scroll事件监听函数以及animation。 window.requestIdleCallback()这个函数指定当只有一帧的末尾有空闲时间才会执行毁掉函数。 1requestIdleCallback(fn,1000); 上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。 1000表示指定毫秒数，作用是如果1000ms内每一帧都没有空闲时间，就强制执行fn，也就是一个deadline的作用。 函数 fn 可以接受一个 deadline 对象作为参数。 123456789requestIdleCallback(function someHeavyComputation(deadline) { while(deadline.timeRemaining() &gt; 0) { doWorkIfNeeded(); } if(thereIsMoreWorkToDo) { requestIdleCallback(someHeavyComputation); }}); 上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。 deadline对象有一个方法和一个属性：timeRemaining() 和 didTimeout。 （1）timeRemaining() 方法 timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮requestIdleCallback。 前面的示例代码之中，只要当前帧还有空闲时间，就不断调用doWorkIfNeeded方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮requestIdleCallback。 （2）didTimeout属性 deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。 timeRemaining方法返回0 didTimeout 属性等于 true 因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。 123456789function myNonEssentialWork (deadline) { while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0) doWorkIfNeeded(); if (tasks.length &gt; 0) requestIdleCallback(myNonEssentialWork);}requestIdleCallback(myNonEssentialWork, 5000); 上面代码确保了，doWorkIfNeeded 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。 requestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有Chrome支持，不过其他浏览器可以用垫片库。 网络性能优化包括了静态文件做cdn，压缩代码，以及压缩图片等等。","link":"/2020/03/25/%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"自定义html元素","text":"html5标准可以自定义的元素，但是没有默认样式。 我可以在html中加一个元素并在css中给它样式。这样就创造了一个元素。 这样我们就能写出语义非常好的html。 复用自定义元素123&lt;user-defined&gt; &lt;a href='#'&gt;链接&lt;/a&gt;&lt;/user-defined&gt; 现在将&lt;user-defined&gt;的元素和样式封装为user-defined.html就可以复用了。 先在&lt;head&gt;中引入： 1&lt;link rel=\"import\" href=\"user-defined.html\"&gt; 再使用： 1&lt;user-defined&gt;&lt;/user-defined&gt; 注意：自定义元素标准custom elements与HTML Imports，HTML Template、Shadow DOM构成了web components规范。目前这个规范只有chrome支持 custom elements自定义元素命名规范：必须包含-","link":"/2019/06/03/%E8%87%AA%E5%AE%9A%E4%B9%89html%E5%85%83%E7%B4%A0/"},{"title":"解决github上图片无法显示的问题","text":"最近国内访问github会因为dns的原因导致图片不显示，可以修改本地hosts来解决。 找到hosts文件macos：路径：/etc/hosts windows:路径：C:\\Windows\\System32\\drivers\\etc\\hosts 修改hosts文件在hosts文件中追加以下配置信息： 123456789101112131415161718# GitHub Start 192.30.253.112 Build software better, together 192.30.253.119 gist.github.com151.101.184.133 assets-cdn.github.com151.101.184.133 raw.githubusercontent.com151.101.184.133 gist.githubusercontent.com151.101.184.133 cloud.githubusercontent.com151.101.184.133 camo.githubusercontent.com151.101.184.133 avatars0.githubusercontent.com151.101.184.133 avatars1.githubusercontent.com151.101.184.133 avatars2.githubusercontent.com151.101.184.133 avatars3.githubusercontent.com151.101.184.133 avatars4.githubusercontent.com151.101.184.133 avatars5.githubusercontent.com151.101.184.133 avatars6.githubusercontent.com151.101.184.133 avatars7.githubusercontent.com151.101.184.133 avatars8.githubusercontent.com # GitHub End 完美解决~ 参考 https://www.jianshu.com/p/752211238c1b https://sspai.com/post/43248 https://zhuanlan.zhihu.com/p/107196957","link":"/2020/06/23/%E8%A7%A3%E5%86%B3github%E4%B8%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"解决termius下不支持中文的问题","text":"发现在termius下中文文件名乱码的问题. 1vim ~/.zshrc 插入: 1export LANG=en_US.UTF-8 done!","link":"/2020/07/04/%E8%A7%A3%E5%86%B3termius%E4%B8%8B%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"详解css中的单位","text":"我看过的一些文章和《css权威指南》都没有太简洁明了的让我们理解css中的单位，反而css权威指南这本书还将简单问题复杂化了很多，故而我自己总结一下css中的单位。 绝对单位和相对单位我发现《css世界》和《css权威指南》里面对于绝对单位和相对单位的描述有出入，故而先介绍一下什么是绝对单位以及什么是相对单位。 绝对单位：比如，某公司规定员工工作日每天需要工作8小时，这个“小时”就是绝对单位，因为8小时是固定长度的。 相对单位：比如，某公司规定员工的工作时长需要符合手头工作量，工作量多就得加班，工作量少当然也不可能提前下班，这里“工作时长需要符合手头工作量”就是个相对单位，因为这个工作时长是相对于工作量而言的，是不确定的。 css中的单位css中的绝对单位就是单位配合数值后所确定的元素视觉大小是绝对的，而相对单位就是单位加上数值后表示的元素视觉大小是不确定的。 绝对单位有：pt,pc,in,cm,mm 相对单位有：em,ex,px,rem,vw,vh,vmin,vmax,%,ch px 相对单位，这个单位是网上文章中错误最多的单位，有的文章说是相对单位，有的说是绝对单位。其实px是相对单位，代表1像素，一个像素的大小是不确定的，比如：有两台电脑，一台是1080p分辨率，一台是2k分辨率，并且两台电脑屏幕比例和面积一样，像素的大小就是屏幕面积除以像素个数，故而很明显两台电脑的像素大小是不一样的，并且分辨率低的像素大小要大于分辨率高的像素大小。故而，同样是16px的字体，分辨率低的那个电脑显示出来的字体就要比分辨率高的字体大。 故而以下的字体为什么是相对单位以及为什么是绝对单位就明了了。 em 相对单位，相对于当前字体大小进行计算。 如果设置font-size：em相对于父元素字体大小计算。 关于em，可以用来调整浏览器默认字体大小基准： 浏览器默认16px，计算出10px = 0.625em，那么就将body的font-size声明为0.625em 123body { font-size: 62.5%;} 此时文档中的字体大小1em就是10px，以后我们要使用各种不同大小的字体只要： 1234a { /*12px*/ font-size: 1.2em;} 注意，如果嵌套的话： 123&lt;p class=\"p1\"&gt; &lt;p class=\"p2\"&gt;&lt;/p&gt;&lt;/p&gt; 123456789body { font-size: 62.5%;}.p1 { font-size: 1.2em;}.p2 { font-szie: 1.2em;} 这样就使得.p1变为12px，而.p2相对于.p1的1.2倍就是1.44em，也就是14.4px。 这里要.p2也使用12px就要这样写:font-size: 1em来继承.p1的大小。 ex 相对单位，相对于当前字体的小写x高度进行计算，x的高度通常是字体高度的一半（1ex = 0.5em）。 rem 相对单位，相对于root节点html元素的字体大小（16px）进行计算。 这个单位统一使用html元素大小为基准，避免了多层嵌套使用em后的大小叠加，可以用于需要多设备适配的项目。 先将html元素设置为10px作为基准： 123html { font-size: 62.5%;} vw 相对单位，相对于viewpoint width进行计算，1vw=视窗宽度的1%。 vh 相对单位，相对于viewpoint height进行计算，1vh=视窗高度的1%。 vmin 相对单位，取vw和vh中较小的那个值。 vmax 相对单位，取vw和vh中较大的那个值。 百分比% 相对单位，取相对于父元素的百分比。 in 绝对单位 cm 绝对单位 mm 绝对单位 pt 绝对单位，1 pt = 1/72 in pc 绝对单位，1 pc = 1/6 inch = 12 pt ch 相对单位，以当前字体中的数字0为基准计算。","link":"/2020/03/27/%E8%AF%A6%E8%A7%A3css%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BD%8D/"},{"title":"《锋利的jQuery》笔记","text":"读完了《锋利的jquery——第二版》，写点笔记。","link":"/2018/07/02/%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E7%AC%94%E8%AE%B0/"},{"title":"阮一峰js标准参考教程笔记（未完待续）","text":"入门篇导论javascript正在向全栈发展。 历史ECMAScript是标准，javascript是es的实现。 基本语法变量声明可以在一条语句中声明多个变量： 1var a,b; 变量提升js引擎先解析代码，获取所有被声明的变量，再一行一行运行。故而所有变量的声明语句都会被提升到代码顶部，这就叫做变量提升。 比如： 12console.log(a);var a = 1; 会被js引擎解析为： 123var a;console.log(a);a = 1; 输出：undefined，表示a变量已经被声明，但未被赋值。 标志符命名标志符命名规范： 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 注释js注释： 12345// 单行注释/* 多行注释*/ if12345678if () 语句; if () 语句;if () { } 注意js中的等于号 赋值符： = 相等运算符： == 严格相等运算符： === if…else12345if () { } else { } 123456789if () {} else if () {} else if () {} else {} else代码块总是与离自己最近的那个if语句配对。 switch如果需要用多个if...else语句，则考虑使用switch简化： 12345678910switch (fruit) { case \"apple\": // ... break; case \"banana\": // ... break; default: // ...} break语句不能少，否则会接下去执行下一个case代码块。 12345678910switch (mark) { case 90: console.log(90); break; case 80: console.log(80); break; default: console.log('no data');} 而且switch后面和case后面都可以使用表达式。 注意：比对的时候采用的是严格等于，不会发生类型转换 三元运算符1(条件) ? 表达式1 : 表达式2 若条件为真，则执行表达式1，否则则执行表达式2。 三元运算符用法：根据给定的n的奇偶性返回信息： 12345function judge(n) { console.log('数字n是：'+(n%2 === 0? '偶数' : '奇数'));}judge(n); 12345judge(12)VM2126:2 数字n是：偶数judge(11)VM2126:2 数字n是：奇数 循环while循环：1while (条件) {语句} for循环123for (初始化循环变量;循环条件;循环变量递增) { 语句;} 例子： 123for (let i = 0; i &lt; 10 ; i++) { console.log(i);} do…while与while类似，唯一区别是do...while线运行一次再判断条件。 123do { 语句;} while (条件); break与continue两个都是有跳转作用的语句。 break用于跳出代码块或循环。 continue用于跳出本次循环，返回循环结构头部开始下一轮循环。 labelJavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句; 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++){ for (var j = 0; j &lt; 3; j++){ if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); } }// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 12345678foo: { console.log(1); break foo; console.log('本行不会输出');}console.log(2);// 1// 2 上面代码执行到break foo，就会跳出区块。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++){ for (var j = 0; j &lt; 3; j++){ if (i === 1 &amp;&amp; j === 1) continue top; console.log('i=' + i + ', j=' + j); } }// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 数据类型概述一共有6种： number：包括整数和小数。 string：字符串。 boolean：true, false。 undefined：未定义或者不存在。 null：值为空。 object：值的集合。 原始类型：number, boolean,string 合成类型：object 特殊类型：undefined,null 注意： typeof用来检测一个未声明的变量也是返回undefined 现在判断一个变量是否值为undefined： 123if (v === \"undefined\") { // ... } instanceof运算符可以区分数组和对象： 12345var o = {};var a = [];o instanceof Array // falsea instanceof Array // true null,undifined,booleanNull,undefined两者都为false 1null == undefined // true 12Number(null) // 0Number(undefined) // NaN 对于null和undefined，大致可以像下面这样理解。 null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) { return x;}f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() {}f() // undefined 布尔值有true和false 下面运算会返回布尔值： !(true) === !== == != &gt; &lt; &gt;= &lt;= 以下都会被转化为false，其余均为true： undefined null false 0 NaN &quot;&quot;以及单引号 注意：[] {}都是true 数值整数和浮点数js内部，所有数字都是以64位二进制的浮点数形式存在。 11 === 1.0 // true 也就是说js中其实只有浮点数而没有整数。 浮点数不够精确，所以设计浮点数的运算要小心： 123450.1 + 0.2 === 0.3 // false0.3 / 0.1 // 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1) // false 以上代码得到不和预期结果的原因是0.1，0.2，0.3这种浮点数在js中无法准确表示。 js的64位浮点数结构，从左往右： 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 这意味着，绝对值小于2的53次方的整数，即-2^53 到2^53，都可以精确表示。 js对于15位的十进制数都可以精确处理。 数值范围如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 12Number.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-324 数值的表示二进制：0b1101，有前缀0b 十进制：35，没有前缀0 八进制：021，有前缀0且只用到了0-7 十六进制：0xFF，有前缀0x 科学计数法：123e3 123*10^3 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示： （1）小数点前的数字多于21位。 （2）小数点后的零多于5个。 特殊数值0 +0和-0这三个数是一样的。 唯一有需要注意的是作为分母的时候，分式的正负号不同。 NaN15 - 'x' // NaN 以上的代码会先将字符串x转化为数值，x不是数值所以结果为NaN。 还有数学计算会出现NaN： 1Math.acos(2) // NaN 但是： 1typeof NaN // 'number' NaN不等于任何值 1NaN === NaN // false NaN在布尔运算中被当做false NaN与任何数运算，结果都是NaN InfinityInfinity表示正无穷，-Infinity表示负无穷。 Infinity大于一切数值，除了NaN。-Infinity同理。 与数值相关的全局方法parseInt()，用于将字符串转化为整数： 12parseInt('123'); // 123parseInt(' 123'); // 123 如果parseInt()中的不是字符串，则会先转化为字符串再转化为整数。 1parseInt(1.23); // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 1parseInt('15px') // 15 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt('abc') // NaNparseInt('.3') // NaNparseInt('') // NaNparseInt('+') // NaNparseInt('+1') // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt('0x10') // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt('011') // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt('1e+21') // 1parseInt(0.0000008) // 8// 等同于parseInt('8e-7') // 8 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 1234parseInt('1000',10); // 1000parseInt('1000',2); // 8parseInt('1000', 6) // 216parseInt('1000', 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt('10', 37) // NaNparseInt('10', 1) // NaNparseInt('10', 0) // 10parseInt('10', null) // 10parseInt('10', undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN: 12parseInt('1546', 2) // 1parseInt('546', 2) // NaN parseFloat()用于将一个字符串转化为浮点数： 1parseFloat('3.14'); // 3.14 如果字符串符合科学计数法，则会进行相应的转换： 12parseFloat('314e-2'); // 3.14parseFloat('0.0314e+2'); // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分: 1parseFloat('3.14as d qwe'); // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat('\\t\\v\\r12.34\\n ') // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat('FF2') // NaNparseFloat('') // NaN isNaN()只对数值有效，可以判断一个值是否为NaN： 12isNaN(NaN) // trueisNaN(1) // false 如果传入的值不是数值会被转化为数值： 123isNaN('asdfa'); // true// 相当于isNaN(Number('asdfa')); // true 出于同样的原因，对于对象和数组，isNaN也返回true。 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN(['123']) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值。 因此，使用isNaN之前，最好判断一下数据类型。 123function myIsNaN(value) { return typeof value === 'number' &amp;&amp; isNaN(value);} 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) { return value !== value;} isFinite()判断一个值是否为正常数值： 123456isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 字符串12'asd'&quot;asd&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号. 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234var str = 'line1\\line2\\line3\\line4'; 还可以用加号连接多个字符串： 12345var longString = 'this ' + 'is '+ 'a '+ 'long ' + 'string.'; 如果想输出多行字符串，有一种利用多行注释的变通方法： 12345678910(function () { /*line 1line 2line 3*/}).toString().split('\\n').slice(1, -1).join('\\n')// \"line 1// line 2// line 3\" 转义字符 \\0 ：null（\\u0000） \\b ：后退键（\\u0008） \\f ：换页符（\\u000C） \\n ：换行符（\\u000A） \\r ：回车键（\\u000D） \\t ：制表符（\\u0009） \\v ：垂直制表符（\\u000B） \\' ：单引号（\\u0027） \\&quot; ：双引号（\\u0022） \\\\ ：反斜杠（\\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义： 123var str = 'abc\\\\d';console.log(str);// abc\\d 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = 'hello';s[0] // \"h\"s[1] // \"e\"s[4] // \"o\"// 直接对字符串使用方括号运算符'hello'[1] // \"e\" 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123'abc'[3] // undefined'abc'[-1] // undefined'abc'['x'] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符: 12345678910var s = 'hello';delete s[0];s // \"hello\"s[1] = 'a';s // \"hello\"s[5] = '!';s // \"hello\" 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 length属性length返回字符串的长度，也是无法改变的。 12345678var s = 'hello';s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。 12var s = '\\u00A9';s // \"©\" 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 12var f\\u006F\\u006F = 'abc';foo // \"abc\" base64JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = 'Hello World!';btoa(string) // \"SGVsbG8gV29ybGQh\"atob('SGVsbG8gV29ybGQh') // \"Hello World!\" 注意，这两个方法不适合非 ASCII 码的字符，会报错。 1btoa('你好') // 报错 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法： 12345678910function b64Encode(str) { return btoa(encodeURIComponent(str));}function b64Decode(str) { return decodeURIComponent(atob(str));}b64Encode('你好') // \"JUU0JUJEJUEwJUU1JUE1JUJE\"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // \"你好\" 对象什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 1234var obj = { foo: 'hello', bar: 'world'} 对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。 1234var obj = { 'foo': 'hello', 'bar': 'world'} 如果键名是数值，会被自动转为字符串： 1234567891011121314151617181920var obj = { 1: 'a', 3.2: 'b', 1e2: true, 1e-2: true, .234: true, 0xFF: true};obj// Object {// 1: \"a\",// 3.2: \"b\",// 100: true,// 0.01: true,// 0.234: true,// 255: true// }obj['100'] // true 上面代码中，对象obj的所有键名虽然看上去像数值，实际上都被自动转成了字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错： 1234567891011// 报错var obj = { 1p: 'Hello World'};// 不报错var obj = { '1p': 'Hello World', 'h w': 'Hello World', 'p+q': 'Hello World'}; 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用： 1234567var obj = { p: function (x) { return 2 * x; }};obj.p(1) // 2 如果属性的值还是一个对象，就形成了链式引用。 12345var o1 = {};var o2 = { bar: 'hello' };o1.foo = o2;o1.foo.bar // \"hello\" 上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加： 1234var obj = { p: 123, m: function () { ... },} 属性可以动态创建，不必在对象声明时就指定： 123var obj = {};obj.foo = 123;obj.foo // 123 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量： 12345678var o1 = {};var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量： 12345var o1 = {};var o2 = o1;o1 = 1;o2 // {} 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝： 12345var x = 1;var y = x;x = 2;y // 1 上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 属性的读取读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符： 123456var obj = { p: 'Hello World'};obj.p // \"Hello World\"obj['p'] // \"Hello World\" 如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理： 123456789var foo = 'bar';var obj = { foo: 1, bar: 2};obj.foo // 1obj[foo] // 2 上面代码中，引用对象obj的foo属性时，如果使用点运算符，foo就是字符串；如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar。 方括号运算符内部还可以使用表达式。 12obj['hello' + ' world']obj[3 + 3] 数字键可以不加引号，因为会自动转成字符串。 数字键可以不加引号，因为会自动转成字符串。 123456var obj = { 0.7: 'Hello World'};obj['0.7'] // \"Hello World\"obj[0.7] // \"Hello World\" 上面代码中，对象obj的数字键0.7，加不加引号都可以，因为会被自动转为字符串。 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 123456var obj = { 123: 'hello world'};obj.123 // 报错obj[123] // \"hello world\" 上面代码的第一个表达式，对数值键名123使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。 属性的赋值1234var obj = {};obj.foo = 'hello';obj['bar'] = 'world'; JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。 123456var obj = { p: 1 };// 等价于var obj = {};obj.p = 1; 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = { key1: 1, key2: 2};Object.keys(obj);// ['key1', 'key2'] 属性的删除delete命令用于删除对象的属性，删除成功后返回true。 123456var obj = { p: 1 };Object.keys(obj) // [\"p\"]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 注意，删除一个不存在的属性，delete不报错，而且返回true。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 in运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。 123var obj = { p: 1 };'p' in obj // true'toString' in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 1234var obj = {};if ('toString' in obj) { console.log(obj.hasOwnProperty('toString')) // false} for…in循环for...in循环用来遍历一个对象的全部属性。 123456789101112var obj = {a: 1, b: 2, c: 3};for (var i in obj) { console.log('键名：', i); console.log('键值：', obj[i]);}// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = { name: '老张' };for (var key in person) { if (person.hasOwnProperty(key)) { console.log(key); }}// name with语句它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 123with (对象) { 语句;} 1234567891011121314151617181920212223// 例一var obj = { p1: 1, p2: 2,};with (obj) { p1 = 4; p2 = 5;}// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0]){ console.log(href); console.log(title); console.log(style);}// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = {};with (obj) { p1 = 4; p2 = 5;}obj.p1 // undefinedp1 // 4 建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) { console.log(p1 + p2);}// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 函数函数声明函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 函数三种声明方法： function命令 123function func(s) { console.log(s);} 1func('asd'); 函数表达式 123var func = function(s) { console.log(s);}; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 123456789var print = function x(){ console.log(typeof x);};x// ReferenceError: x is not definedprint()// function 上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。 1var f = function f() {}; Function构造函数 12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) { return x + y;} 上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 12345678var foo = new Function( 'return \"hello world\";');// 等同于function foo() { return 'hello world';} 总的来说，这种声明函数的方式非常不直观，几乎无人使用。 函数重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 123456789function f() { console.log(1);}f() // 2function f() { console.log(2);}f() // 2 上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。 函数名提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 123f();function f() {} 表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 123f();var f = function (){};// TypeError: undefined is not a function 上面的代码等同于下面的形式。 123var f;f();f = function () {}; 上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。 注意，如果像下面例子那样，采用function命令和var赋值语句声明同一个函数，由于存在函数提升，最后会采用var赋值语句的定义。 123456789var f = function () { console.log('1');}function f() { console.log('2');}f() // 1 上面例子中，表面上后面声明的函数f，应该覆盖前面的var赋值语句，但是由于存在函数提升，实际上正好反过来 函数的属性和方法 name属性 12function f1() {}f1.name // \"f1\" name属性的一个用处，就是获取参数函数的名字。 1234567var myFunc = function () {};function test(f) { console.log(f.name);}test(myFunc) // myFunc 上面代码中，函数test内部通过name属性，就可以知道传入的参数是什么函数。 length属性 函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 12function f(a,b) {}f.length; // 2 toString()函数的toString方法返回一个字符串，内容是函数的源码。 对于那些原生的函数，toString()方法返回function (){[native code]}。 函数内部的注释也可以返回。 作用域闭包目的：从函数外部获取函数内部变量 方法：通过在函数内部加一层内层函数，内层函数的作用是console.log()出外层函数变量以及return内部函数自己来实现。 代码： 1234567891011function a(){ var n = 111111; function b(){ console.log(n); } return b;}var result = a();result()； 总结： 由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 数组IIFE（立即调用的函数表达式）代码： 123(function(){ /* code */ }()); //用()把函数定义调用语句包进去// 或者(function(){ /* code */ })(); //用()把函数定义语句单独包起来 上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错. 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () { var tmp = newData; processData(tmp); storeData(tmp);}()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 eval作用：将字符串当做语句执行。 123var s = 'console.log(\"done\");' //定义字符串eval(s); //输出doneeval('console.log(\"done\");'); //直接将代码写进eval('code'); 算数运算符 加法运算符：x + y 减法运算符： x - y 乘法运算符： x * y 除法运算符：x / y 指数运算符：x ** y 余数运算符：x % y 自增运算符：++x 或者 x++ 自减运算符：--x 或者 x-- 数值运算符： +x 负数值运算符：-x 异或运算“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，a^=b; b^=a; a^=b;，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。 1234var a = 'a',b = 'b'a ^= b;b ^= a;a ^= b; //交换完成 位运算开关作用位运算符可以用作设置对象属性的开关。 假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。 1234var FLAG_A = 1; // 0001var FLAG_B = 2; // 0010var FLAG_C = 4; // 0100var FLAG_D = 8; // 1000 上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。 然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。 123456var flags = 5; // 二进制的0101if (flags &amp; FLAG_C) { // ...}// 0101 &amp; 0100 =&gt; 0100 =&gt; true 上面代码检验是否打开了开关C。如果打开，会返回true，否则返回false。 现在假设需要打开A、B、D三个开关，我们可以构造一个掩码变量。 12var mask = FLAG_A | FLAG_B | FLAG_D;// 0001 | 0010 | 1000 =&gt; 1011 上面代码对A、B、D三个变量进行二进制或运算，得到掩码值为二进制的1011。 有了掩码，二进制或运算可以确保打开指定的开关。 1flags = flags | mask; 二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。 1flags = flags &amp; mask; 异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。 1flags = flags ^ mask; 二进制否运算可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。 1flags = ~flags; 运算符优先级这五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。 顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。 注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。 12var x = 1;(x) = 2; 上面代码的第二行，如果圆括号具有求值作用，那么就会变成1 = 2，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值。 这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果。 123(exprssion)// 等同于expression 函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。 123456function f() { return 1;}(f) // function f(){return 1;}f() // 1 上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数。 圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。 12(var a = 1)// SyntaxError: Unexpected token var 派生错误总结以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个函数，代表错误提示信息（message）。 1234567var err1 = new Error('出错了！');var err2 = new RangeError('出错了，变量超出有效范围！');var err3 = new TypeError('出错了，变量类型无效！');err1.message // \"出错了！\"err2.message // \"出错了，变量超出有效范围！\"err3.message // \"出错了，变量类型无效！\" 对象不同数据类型的Object.prototype.toString方法返回值如下。 数值：返回[object Number]。 字符串：返回[object String]。 布尔值：返回[object Boolean]。 undefined：返回[object Undefined]。 null：返回[object Null]。 数组：返回[object Array]。 arguments 对象：返回[object Arguments]。 函数：返回[object Function]。 Error 对象：返回[object Error]。 Date 对象：返回[object Date]。 RegExp 对象：返回[object RegExp]。 其他对象：返回[object Object]。 这就是说，Object.prototype.toString可以看出一个值到底是什么类型。 12345678Object.prototype.toString.call(2) // \"[object Number]\"Object.prototype.toString.call('') // \"[object String]\"Object.prototype.toString.call(true) // \"[object Boolean]\"Object.prototype.toString.call(undefined) // \"[object Undefined]\"Object.prototype.toString.call(null) // \"[object Null]\"Object.prototype.toString.call(Math) // \"[object Math]\"Object.prototype.toString.call({}) // \"[object Object]\"Object.prototype.toString.call([]) // \"[object Array]\" 利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。 123456789101112var type = function (o){ var s = Object.prototype.toString.call(o); return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();};type({}); // \"object\"type([]); // \"array\"type(5); // \"number\"type(null); // \"null\"type(); // \"undefined\"type(/abcd/); // \"regex\"type(new Date()); // \"date\" 在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。 1234567891011121314151617181920212223var type = function (o){ var s = Object.prototype.toString.call(o); return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();};['Null', 'Undefined', 'Object', 'Array', 'String', 'Number', 'Boolean', 'Function', 'RegExp'].forEach(function (t) { type['is' + t] = function (o) { return type(o) === t.toLowerCase(); };});type.isObject({}) // truetype.isNumber(NaN) // truetype.isRegExp(/abc/) // true Array对象Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。 12345// badvar arr = new Array(1, 2);// goodvar arr = [1, 2]; Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。 1234var arr = [1, 2, 3];typeof arr // \"object\"Array.isArray(arr) // true 上面代码中，typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。 push()，pop()push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 123456var arr = [];arr.push(1) // 1arr.push('a') // 2arr.push(true, {}) // 4arr // [1, 'a', true, {}] 上面代码使用push方法，往数组中添加了四个成员。 pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。 1234var arr = ['a', 'b', 'c'];arr.pop() // 'c'arr // ['a', 'b'] 对空数组使用pop方法，不会报错，而是返回undefined。 1[].pop() // undefined push和pop结合使用，就构成了“后进先出”的栈结构（stack）。 12345var arr = [];arr.push(1, 2);arr.push(3);arr.pop();arr // [1, 2] 上面代码中，3是最后进入数组的，但是最早离开数组。 shift()，unshift()shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 1234var a = ['a', 'b', 'c'];a.shift() // 'a'a // ['b', 'c'] shift方法可以遍历并清空一个数组。 12345678var list = [1, 2, 3, 4, 5, 6];var item;while (item = list.shift()) { console.log(item);}list // [] push和shift结合使用，就构成了“先进先出”的队列结构（queue）。 unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 1234var a = ['a', 'b', 'c'];a.unshift('x'); // 4a // ['x', 'a', 'b', 'c'] unshift方法可以接受多个参数，这些参数都会添加到目标数组头部。 123var arr = [ 'c', 'd' ];arr.unshift('a', 'b') // 4arr // [ 'a', 'b', 'c', 'd' ] splice()splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 1arr.splice(start, count, addElement1, addElement2, ...); splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 123var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2) // [\"e\", \"f\"]a // [\"a\", \"b\", \"c\", \"d\"] 上面代码从原数组4号位置，删除了两个数组成员。 123var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2, 1, 2) // [\"e\", \"f\"]a // [\"a\", \"b\", \"c\", \"d\", 1, 2] 上面代码除了删除成员，还插入了两个新成员。 起始位置如果是负数，就表示从倒数位置开始删除。 12var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(-4, 2) // [\"c\", \"d\"] 上面代码表示，从倒数第四个位置c开始删除两个成员。 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。 1234var a = [1, 1, 1];a.splice(1, 0, 2) // []a // [1, 2, 1, 1] 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。 123var a = [1, 2, 3, 4];a.splice(2) // [3, 4]a // [1, 2] JavaScript 标准参考教程（alpha）标准库Array 对象GitHub TOP Array 对象来自《JavaScript 标准参考教程（alpha）》，by 阮一峰 目录 构造函数 静态方法 Array.isArray() 实例方法 valueOf()，toString() push()，pop() shift()，unshift() join() concat() reverse() slice() splice() sort() map() forEach() filter() some()，every() reduce()，reduceRight() indexOf()，lastIndexOf() 链式使用 参考链接 教程新地址：wangdoc.com/javascript。 构造函数Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。 123var arr = new Array(2);arr.length // 2arr // [ empty x 2 ] 上面代码中，Array构造函数的参数2，表示生成一个两个成员的数组，每个位置都是空值。 如果没有使用new，运行结果也是一样的。 123var arr = new Array(2);// 等同于var arr = Array(2); Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。 12345678910111213141516171819// 无参数时，返回一个空数组new Array() // []// 单个正整数参数，表示返回的新数组的长度new Array(1) // [ empty ]new Array(2) // [ empty x 2 ]// 非正整数的数值作为参数，会报错new Array(3.2) // RangeError: Invalid array lengthnew Array(-3) // RangeError: Invalid array length// 单个非数值（比如字符串、布尔值、对象等）作为参数，// 则该参数是返回的新数组的成员new Array('abc') // ['abc']new Array([1]) // [Array[1]]// 多参数时，所有参数都是返回的新数组的成员new Array(1, 2) // [1, 2]new Array('a', 'b', 'c') // ['a', 'b', 'c'] 可以看到，Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。 12345// badvar arr = new Array(1, 2);// goodvar arr = [1, 2]; 注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。 1234567891011var a = new Array(3);var b = [undefined, undefined, undefined];a.length // 3b.length // 3a[0] // undefinedb[0] // undefined0 in a // false0 in b // true 上面代码中，a是一个长度为3的空数组，b是一个三个成员都是undefined的数组。读取键值的时候，a和b都返回undefined，但是a的键位都是空的，b的键位是有值的。 静态方法Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。 1234var arr = [1, 2, 3];typeof arr // \"object\"Array.isArray(arr) // true 上面代码中，typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。 实例方法valueOf()，toString()valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。 12var arr = [1, 2, 3];arr.valueOf() // [1, 2, 3] toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。 12345var arr = [1, 2, 3];arr.toString() // \"1,2,3\"var arr = [1, 2, 3, [4, 5, 6]];arr.toString() // \"1,2,3,4,5,6\" push()，pop()push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 123456var arr = [];arr.push(1) // 1arr.push('a') // 2arr.push(true, {}) // 4arr // [1, 'a', true, {}] 上面代码使用push方法，往数组中添加了四个成员。 pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。 1234var arr = ['a', 'b', 'c'];arr.pop() // 'c'arr // ['a', 'b'] 对空数组使用pop方法，不会报错，而是返回undefined。 1[].pop() // undefined push和pop结合使用，就构成了“后进先出”的栈结构（stack）。 12345var arr = [];arr.push(1, 2);arr.push(3);arr.pop();arr // [1, 2] 上面代码中，3是最后进入数组的，但是最早离开数组。 shift()，unshift()shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 1234var a = ['a', 'b', 'c'];a.shift() // 'a'a // ['b', 'c'] shift方法可以遍历并清空一个数组。 12345678var list = [1, 2, 3, 4, 5, 6];var item;while (item = list.shift()) { console.log(item);}list // [] push和shift结合使用，就构成了“先进先出”的队列结构（queue）。 unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 1234var a = ['a', 'b', 'c'];a.unshift('x'); // 4a // ['x', 'a', 'b', 'c'] unshift方法可以接受多个参数，这些参数都会添加到目标数组头部。 123var arr = [ 'c', 'd' ];arr.unshift('a', 'b') // 4arr // [ 'a', 'b', 'c', 'd' ] join()join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 12345var a = [1, 2, 3, 4];a.join(' ') // '1 2 3 4'a.join(' | ') // \"1 | 2 | 3 | 4\"a.join() // \"1,2,3,4\" 如果数组成员是undefined或null或空位，会被转成空字符串。 12345[undefined, null].join('#')// '#'['a',, 'b'].join('-')// 'a--b' 通过call方法，这个方法也可以用于字符串或类似数组的对象。 123456Array.prototype.join.call('hello', '-')// \"h-e-l-l-o\"var obj = { 0: 'a', 1: 'b', length: 2 };Array.prototype.join.call(obj, '-')// 'a-b' concat()concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 1234567891011['hello'].concat(['world'])// [\"hello\", \"world\"]['hello'].concat(['world'], ['!'])// [\"hello\", \"world\", \"!\"][].concat({a: 1}, {b: 2})// [{ a: 1 }, { b: 2 }][2].concat({a: 1})// [2, {a: 1}] 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。 12[1, 2, 3].concat(4, 5, 6)// [1, 2, 3, 4, 5, 6] 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。 1234567var obj = { a: 1 };var oldArray = [obj];var newArray = oldArray.concat();obj.a = 2;newArray[0].a // 2 上面代码中，原数组包含一个对象，concat方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变。 reverse()reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。 1234var a = ['a', 'b', 'c'];a.reverse() // [\"c\", \"b\", \"a\"]a // [\"c\", \"b\", \"a\"] slice()slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。 1arr.slice(start, end); 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。 1234567var a = ['a', 'b', 'c'];a.slice(0) // [\"a\", \"b\", \"c\"]a.slice(1) // [\"b\", \"c\"]a.slice(1, 2) // [\"b\"]a.slice(2, 6) // [\"c\"]a.slice() // [\"a\", \"b\", \"c\"] 上面代码中，最后一个例子slice没有参数，实际上等于返回一个原数组的拷贝。 如果slice方法的参数是负数，则表示倒数计算的位置。 123var a = ['a', 'b', 'c'];a.slice(-2) // [\"b\", \"c\"]a.slice(-2, -1) // [\"b\"] 上面代码中，-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。 123var a = ['a', 'b', 'c'];a.slice(4) // []a.slice(2, 1) // [] slice方法的一个重要应用，是将类似数组的对象转为真正的数组。 12345Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })// ['a', 'b']Array.prototype.slice.call(document.querySelectorAll(\"div\"));Array.prototype.slice.call(arguments); 上面代码的参数都不是数组，但是通过call方法，在它们上面调用slice方法，就可以把它们转为真正的数组。 splice()splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 1arr.splice(start, count, addElement1, addElement2, ...); splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 123var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2) // [\"e\", \"f\"]a // [\"a\", \"b\", \"c\", \"d\"] 上面代码从原数组4号位置，删除了两个数组成员。 123var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2, 1, 2) // [\"e\", \"f\"]a // [\"a\", \"b\", \"c\", \"d\", 1, 2] 上面代码除了删除成员，还插入了两个新成员。 起始位置如果是负数，就表示从倒数位置开始删除。 12var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(-4, 2) // [\"c\", \"d\"] 上面代码表示，从倒数第四个位置c开始删除两个成员。 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。 1234var a = [1, 1, 1];a.splice(1, 0, 2) // []a // [1, 2, 1, 1] 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。 123var a = [1, 2, 3, 4];a.splice(2) // [3, 4]a // [1, 2] sort()sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 1234567891011['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11][10111, 1101, 111].sort()// [10111, 1101, 111] 上面代码的最后两个例子，需要特殊注意。sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。 1234[10111, 1101, 111].sort(function (a, b) { return a - b;})// [111, 1101, 10111] 上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。 123456789101112[ { name: \"张三\", age: 30 }, { name: \"李四\", age: 24 }, { name: \"王五\", age: 28 }].sort(function (o1, o2) { return o1.age - o2.age;})// [// { name: \"李四\", age: 24 },// { name: \"王五\", age: 28 },// { name: \"张三\", age: 30 }// ] map()map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。 123456789var numbers = [1, 2, 3];numbers.map(function (n) { return n + 1;});// [2, 3, 4]numbers// [1, 2, 3] 上面代码中，numbers数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。 map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。 1234[1, 2, 3].map(function(elem, index, arr) { return elem * index;});// [0, 2, 6] 上面代码中，map方法的回调函数有三个参数，elem为当前成员的值，index为当前成员的位置，arr为原数组（[1, 2, 3]）。 map方法还可以接受第二个参数，用来绑定回调函数内部的this变量（详见《this 变量》一章）。 123456var arr = ['a', 'b', 'c'];[1, 2].map(function (e) { return this[e];}, arr)// ['b', 'c'] 上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。 12345var f = function (n) { return 'a' };[1, undefined, 2].map(f) // [\"a\", \"a\", \"a\"][1, null, 2].map(f) // [\"a\", \"a\", \"a\"][1, , 2].map(f) // [\"a\", , \"a\"] 上面代码中，map方法不会跳过undefined和null，但是会跳过空位。 参考 阮一峰javascript教程","link":"/2018/03/08/%E9%98%AE%E4%B8%80%E5%B3%B0js%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"},{"title":"预处理器less的使用","text":"css预处理器：使用一种新的语言书写css代码，通过编译后生成普通css文件，我们所要做的就是安装预处理器以及学习使用它的语法，然后编译生成目标css文件。 css预处理器的优势是：提供了css复用机制，减少冗余代码，同时也提高了代码的可维护性，极大提升了css开发效率。 sass和less都是css预处理器。 less扩展了css语言，加入了变量、Mixin、函数等特性。 less可以运行在node或者浏览器。 安装使用node引入： 安装 1234$ npm install -g less# 查看是否安装成功$ less --version 编译 12345678# 编译$ lessc common.less# 编译并指定目标文件$ lessc common.less common.css# 编译并指定目标文件并压缩$ lessc --clean-css common.less common.min.css 标签引入： 12&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\" /&gt;&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js\" &gt;&lt;/script&gt; less代码写在styles.less中，script标签引入less.js，可以使用国内静态资源库替换上面的。比如75cdn： 12&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\" /&gt;&lt;script crossorigin=\"anonymous\" integrity=\"sha384-Xx4jwiERWTGivWIlK2V3UtQRXPRlrLtnx0+zsIL2/eiJGcRkOQ6CpFTNXCX6jwAV\" src=\"https://lib.baomitu.com/less.js/3.10.3/less.min.js\"&gt;&lt;/script&gt; 变量变量书写形式：@var，只能在作用域内有效，不可以重复定义变量： 1234567@cos_width: 10px;@cos_height: @cos_width * 2;header { width: @cos_width; height: @cos_height;} 赋值：只要保持单位统一或可相互转换，就可以进行运算，包括颜色在内： 123456@base: 5%;@filler: @base * 2;@other: @base + @filler;color: #888 / 4;background-color: @base-color +#111; 混入mixin就是将一组属性从一个规则集混入到另一个规则集中。 比如，我们创造一组属性： 12345/*源规则集*/.bordered { border-top: 1px red solid; border-bottom: 1px #000 dotted;} 现在我们想要在其他地方使用这组属性，使用.bordered()语句： 12345// 目标规则集div { color: #111; .bordered();} 嵌套less嵌套和sass一样 普通css代码： 123456789#header { color: black;}#header .navigation { font-size: 12px;}#header .logo { width: 300px;} 使用less写： 123456789#header { color: black; .navigation { font-size: 12px; } .logo { width: 300px; }} 可以将伪元素选择器和混入以及嵌套一起用，比如这是一个.clearfix： 12345678910111213.clearfix { display: block; zoom: 1; &amp;:after { content: ' '; display: block; font-size: 0; height: 0; clear: both; visibility: hidden; }} 在元素中调用.clearfix，注意：以上代码中的&amp;代表父元素（同sass）。 123div { .clearfix();} @规则嵌套和冒泡@规则可以和选择器以相同的方式嵌套，@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡。 123456789101112.component { width: 300px; @media (min-width: 768px) { width: 600px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } @media (min-width: 1280px) { width: 800px; }} 计算less可以使用加减乘除对数字颜色以及变量使用。算术运算符在使用的时候会进行单位换算，以最左侧类型为准，若无意义则忽略单位。 1234567@var1: 5cm + 10mm; //6cm@var2: 2 - 3cm - 5mm //-1.5cm @var3: 5%;@var4: @var3 * 2; //10%@var5: 2cm * 3cm; //6cm 对颜色计算： 12@color_base: #248 / 2; //#124@color_new: @color_base + #111; //#235 对于calc()函数：less不会计算出来，会保留calc()让css运算。 转义比如给一个变量赋值min-width: 768px Less3.5开始，无需转义，可以直接简写为：@min768: (min-width: 768px) 123456@min768: (min-width: 768px);.element { @media @min768 { font-size: 1.2rem; }} 函数less内置了一些函数用于转换颜色、处理字符串、运算。 注意：less不提供自定义函数！sass可以自定义函数！ 12345678@base: #f04615;@width: 0.5;.class { width: percentage(@width); //50% color: saturate(@base,5%); background-color: spin(lighten(@base, 25%),8);} 命名空间和访问符有时，出于组织结构或仅仅是为了提供一些封装的目的，你希望对mixin进行分组。你可以用 less 更直观地实现这一需求。假设你希望将一些mixin和变量置于 #bundle 之下，为了以后方便重用或分发： 123456789101112#bundle() { .button { display: block; border: 1px solid black; background-color: grey; &amp;:hover { background-color: white; } } .tab { ... } .citation { ... }} 现在，如果我们希望把 .button 类混合到 #header a 中，我们可以这样做： 1234#header a { color: orange; #bundle.button(); // 还可以书写为 #bundle &gt; .button 形式} 注意：如果不希望它们出现在输出的 CSS 中，例如 #bundle .tab，请将 () 附加到命名空间（例如 #bundle()）后面。 映射mapsless3.5开始，可以将mixin和规则集作为一组值的映射使用： 123456789#colors() { main: blue; second: green;}.div { color: #colors[main]; border: 1px solid #colors[second];} 作用域1234567@var: red;div { @var: white; header { color: @var; // white }} 1234567@var: red;div { header { color: @var; // white } @var: white;} 以上代码只是第二层嵌套的@var顺序不一致，但是header中引用的都是white。故而变量随用随定义。 注释第一种：/*注释*/可以单行可以多行，在css文件中会被保留在原码中。 1/*注释*/ 第二种：//注释单行注释，在less文件中，但是编译后的css文件中没有。 1//注释 import123@import \"style.less\" //如果是.less文件，则扩展名可以省略@import \"style.css\"","link":"/2019/11/10/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8less%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"预处理器sass的使用","text":"sass是一种css预处理器，它是css的扩展语言。基本思想是：使用sass语言编写sass代码，最终编译为普通的css文件。sass让我们的css代码变得更加高效和可维护。但是sass也仅能够提高写css的效率，对于css而言还是要掌握好基础。 本篇文章总结一下sass的用法。 安装由于sass由ruby编译，故而需要先安装ruby，而mac自带ruby。下面开始安装sass： gem（需ruby）安装： 1234# gem换国内源$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/# gem安装sass，如果遇到提示说没有写权限就加上sudo$ sudo gem install sass npm（需node）安装： 123$ npm install -g sass# or$ cnpm install -g sass brew安装： 1$ brew install sass/sass/sass window choco安装： 1$ choco install sass 查看是否安装成功： 1$ sass --version 使用注意：sass文件扩展名为.scss 12345# 编译scss文件$ sass style.scss# 编译scss文件并保存至目标目录$ sass style.scss style.css sass提供四种编译风格： nested：默认值，嵌套缩进的css代码。 expanded：没有缩进、扩展的css代码。 compact：简介的css代码。 compressed： 压缩的css代码。 生产环境使用第四种： 1$ sass --style compressed style.scss style.css sass监听： 12345# 监听文件$ sass --watch style.scss:style.css# 监听目录$ sass --watch project/sass_dir 变量语法： 1$var: value; sass变量可以是字符串、数字、颜色值、布尔值、列表还有null。 sass变量使用$符号开头，变量可以重复定义。 同一个变量定义了多次是可以的，不过作用域不同。 定义并使用变量。 1234567/*声明变量*/$blue: rgb(0,99,99);/*使用变量*/div { color: $blue;} 如果变量需要嵌套在字符串中，就需要写在#{}中。 1234567/*声明变量*/$side: left;/*属性名嵌套变量*/.div { border-#{$side}-radius: 4px;} 计算 12345body { margin: (10px/2); madding: 10px + 20px; width: $var * 10%;} 嵌套 选择器嵌套 比如下面这个选择器是我们原生css的写法： 123article section { color: #000;} 在scss中的写法： 12345article { section { color: #000; }} !global关键字用来定义全局变量，如果有同名变量已经被定义过，则使用这个关键词可以覆盖： 12345678$mycolor: yellow;h1 { $mycolor: red !global; color: $mycolor; //red}p { color: $mycolor; //red} 以上$mycolor是一个全局变量，全局可用。 一般来说对于全局变量，我们将它统一放在一个global.scss文件中，然后要用的使用使用@include来包含。 属性嵌套 原生css写法： 1234p { border-color: red; border-width: 1px;} 改写带sass写法： 123456p { border: { color: red; width: 1px; }} 就是将属性视为选择器，但是注意所有属性的后面要加上冒号。 使用&amp;引用父元素： 原生css： 123a:hover { color: red;} 改写为sass: 12345a { &amp;:hover { color: red; }} 这里的&amp;就指代父元素a。 4.4 sass注释 三种注释方式按照权重排序：/*!重要注释*/ &gt; /*注释*/ &gt; //注释。 第一种：/*注释*/css原生注释，可以单行可以多行，在scss文件以及css文件中均被保留在原码中。 第二种：//注释，单行注释，在scss文件中，但是编译后的css文件中没有。 第三种：重要注释，写法： 123/*! 重要注释*/ 用出是表明这个注释非常重要，编译后依然存在，甚至压缩编译后依然存在。用于声明版权。 引入@import用来引入外部文件： 123456@import \"path/style.scss\";// import scss文件可以不带扩展名@import \"path/style\" // import css文件需要写全名@import \"path.style.css\"; 引入后就可以在当前文件使用import进来文件的变量 重用 继承 sass允许一个选择器继承另一个选择器，使用@extend selector 123456789// 先声明一个选择器的属性.class_1 { border: 1px red solid;}// 另一个选择器继承上面的.class_2 { @extend .class_1;} Mixin Mixin用于定义一个代码块，用于后续重用。 定义代码块：@mixin selector {}，调用代码@@include selector; 12345678910// 定义代码块@mixin block_left { float: left; margin-left: 10px;}// 调用代码块div { @include block_left;} 定义代码块的同时可以指定参数和缺省： 12345678910// 定义新的代码块和参数@mixin block_left($value: 10px) { float: left; margin-left: $value;}// 使用div { @include block_left(10px);} mixin中也可以混入： 1234@mixin mix3 { @include mix1; @include mix2;} 颜色函数sass颜色函数用于生成系列颜色。 1234lighten(#cc3,10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c partials如果你不希望将一个 Sass 的代码文件编译到一个 CSS 文件，你可以在文件名的开头添加一个下划线。这将告诉 Sass 不要将其编译到 CSS 文件，比如_filename.scss 但是，在导入语句中我们不需要添加下划线，导入：@import filename.scss 不要将带下划线与不带下划线的同名文件放置在同一个目录下，比如，_colors.scss 和 colors.scss 不能同时存在于同一个目录下，否则带下划线的文件将会被忽略。 条件@if 123p { @if 1+1=2 {border: red 1px solid}} @else 12345@if 2&gt;1 { border: 1px red solid;} @else { border: 1px blue solid;} 循环@for循环： 12345@for $i from 1 to 10 { .block-#{$1} { border: 1px red solid; }} @while循环： 12345678$i: 6;@while $i &gt; 0 { div#{$i} { border: 1px red solid; } $i: $i - 1;} @each，作用类似于for： 12345@each $member in a,b,c,d { .#{$member} { background-image: url(\"/image/#{$member}.jpg\"); }} 自定义函数123456789// 定义一个double函数用于将参数double@function double($n) { @return $n * 2;}// 调用double函数，并传参#sidebar { with: double(100px);} 注意点 如果scss文件中有中文，则需要在文件最上方加入： 1@charset \"utf-8\" sass中的-和_作用相同。","link":"/2019/11/09/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8sass%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"RSA","slug":"RSA","link":"/tags/RSA/"},{"name":"LaTex","slug":"LaTex","link":"/tags/LaTex/"},{"name":"animation","slug":"animation","link":"/tags/animation/"},{"name":"css三角形","slug":"css三角形","link":"/tags/css%E4%B8%89%E8%A7%92%E5%BD%A2/"},{"name":"dns","slug":"dns","link":"/tags/dns/"},{"name":"emmet","slug":"emmet","link":"/tags/emmet/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"md5","slug":"md5","link":"/tags/md5/"},{"name":"sha1","slug":"sha1","link":"/tags/sha1/"},{"name":"sha256","slug":"sha256","link":"/tags/sha256/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"template","slug":"template","link":"/tags/template/"},{"name":"响应式","slug":"响应式","link":"/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"记忆宫殿","slug":"记忆宫殿","link":"/tags/%E8%AE%B0%E5%BF%86%E5%AE%AB%E6%AE%BF/"},{"name":"构造大数","slug":"构造大数","link":"/tags/%E6%9E%84%E9%80%A0%E5%A4%A7%E6%95%B0/"},{"name":"清除浮动","slug":"清除浮动","link":"/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"name":"渲染","slug":"渲染","link":"/tags/%E6%B8%B2%E6%9F%93/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"sass","slug":"sass","link":"/tags/sass/"}],"categories":[{"name":"ai","slug":"ai","link":"/categories/ai/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"latex","slug":"latex","link":"/categories/latex/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"math","slug":"math","link":"/categories/math/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"yaml","slug":"yaml","link":"/categories/yaml/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"assembly","slug":"assembly","link":"/categories/assembly/"},{"name":"ui","slug":"ui","link":"/categories/ui/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"deno","slug":"deno","link":"/categories/deno/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"shell","slug":"shell","link":"/categories/shell/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"jquery","slug":"jquery","link":"/categories/jquery/"},{"name":"methodology","slug":"methodology","link":"/categories/methodology/"},{"name":"architecture","slug":"architecture","link":"/categories/architecture/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"cs","slug":"cs","link":"/categories/cs/"},{"name":"ts","slug":"ts","link":"/categories/ts/"},{"name":"tips","slug":"tips","link":"/categories/tips/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"weekly","slug":"weekly","link":"/categories/weekly/"},{"name":"business","slug":"business","link":"/categories/business/"}]}