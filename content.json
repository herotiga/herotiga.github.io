{"pages":[{"title":"阅读","text":"文档前端 Vue.js: https://v3.cn.vuejs.org/, https://staging-cn.vuejs.org/ Vue-router: https://router.vuejs.org/zh/ Vuex: https://vuex.vuejs.org/zh/ Vue SSR: https://v3.cn.vuejs.org/guide/ssr.html, https://v3.cn.vuejs.org/guide/ssr/introduction.html Element Plus: https://element-plus.gitee.io/zh-CN/ axios: http://www.axios-js.com/zh-cn/ Fetch API: https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API TypeScript: https://www.tslang.cn/docs/home.html React: https://zh-hans.reactjs.org/, https://zh-hans.react.dev/ Ant Design: https://ant.design/index-cn Babel: https://www.babeljs.cn/docs/ webpack: https://www.webpackjs.com/concepts/ gulp: https://www.gulpjs.com.cn/ jQuery: https://www.jquery123.com/, https://jquery.cuishifeng.cn/, http://hemin.cn/jq/, https://www.runoob.com/manual/jquery/ RxJS: https://cn.rx.js.org/ Canvas: https://www.canvasapi.cn/ WebGL: https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API ECharts: https://echarts.apache.org/zh/index.html uniapp: https://uniapp.dcloud.net.cn/ Android Android: https://developer.android.com/courses?hl=zh-cn AndServer: https://yanzhenjie.com/AndServer/ 后端 Node.js: http://dev.nodejs.cn/learn, https://nodejs.org/zh-cn/docs/guides/, https://www.nodeapp.cn/, https://nodejs.cn/en/learn Express: https://www.expressjs.com.cn/ koa: https://www.koajs.com.cn/ nest.js: https://nest.nodejs.cn/ PM2: https://pm2.keymetrics.io/ MySQL: https://www.runoob.com/mysql/mysql-tutorial.html python: https://www.runoob.com/python3/python3-tutorial.html Java: https://www.runoob.com/java/java-tutorial.html 客户端 Electron: https://www.electronjs.org 跨端 React Native: https://www.react-native.cn/, https://www.reactnative.cn/ Flutter: https://flutter.cn/, https://www.flutterchina.club/ Dart: https://dart.cn/ uniapp: https://uniapp.dcloud.net.cn/ 游戏 Cocos: https://www.cocos.com/docs 数据科学 numpy: https://numpy.net/, https://www.numpy.org.cn/ pandas: https://www.pypandas.cn/ 人工智能 人工智能入门: http://c.biancheng.net/ml_alg/what-is-ai.html 集成电路 verilog: https://vlab.ustc.edu.cn/guide/doc_verilog.html, https://www.runoob.com/w3cnote/verilog-tutorial.html 书籍计算机基础 《数据结构（c语言版）——严蔚敏》 《计算机组成原理——唐朔飞》 《计算机组成原理——白中英》 《计算机组成与设计：硬件/软件接口》 《计算机操作系统(第三版)——汤子瀛》 《计算机网络(第5版)——谢希仁》 前端 《head first html &amp; css》 《案例学web前端开发》 《css权威指南第三版》 《css权威指南第四版》 《css世界》 《css选择器世界》 《css揭秘》 《精通CSS 高级Web标准解决方案 第3版》 《JavaScript DOM编程艺术》 《阮一峰-JavaScript教程》 《ES6标准入门》 《JavaScript高级程序设计第三版》 《JavaScript语言精粹》 《高性能JavaScript》 《JavaScript DOM高级程序设计》 《JavaScript设计模式》 《你不知道的JavaScript》 《锋利的jQuery》 《Vue.js 3.0从入门到精通》 《Vue.js设计与实现》 《深入浅出WebAssembly》 《WebAssembly标准入门》 《GitHub入门》 Java 《Java核心技术卷一》 Node.js 中文文档：http://dev.nodejs.cn/learn, https://nodejs.cn/en/learn 《深入浅出Node.js》 《狼书卷1》 《狼书卷2》 数据库 《MySQL必知必会》 《高性能MySQL》 Linux 《Linux就该这样学》 《Linux命令行大全》 安全 《Metasploit渗透测试指南》 《渗透测试实践指南：必知必会的工具与方法》 《白帽子讲Web安全》 《黑客攻防技术宝典》web版 《破坏之王-DDoS攻击与防范深度剖析》 《Kali渗透测试技术实战》 架构 《大型网站技术架构——核心原理与案例分析》 算法 《剑指offer——第二版》 《算法笔记》 《算法导论》 《算法谜题》 人工智能 《人工智能产品经理》 《智能的本质》 集成电路 《图解芯片技术》 数学 《数学之美》 《计算机科学中的数学–信息与智能时代的必修课》 《马同学数学》 《吴军数学通识讲义》 物理学 《1小时看懂相对论（漫画版）》 《相对论——天津人民出版社》 课程 《极客时间——玩转git三剑客》 《拉钩——程序员的数学课》 方法论 《如何高效学习》 经济商业 《激荡三十年》","link":"/books/index.html"},{"title":"About","text":"write more, code less.不要去写大而全的笔记，记录难点和疑点才是提高能力的路径。 A dropout master, majored in machine learning. Interests Math Physics Cosmology Computer Science Finance Contact Email：herotiga@vip.qq.com WeChat: @herotiga","link":"/about/index.html"},{"title":"职业规划及成长目标","text":"","link":"/career/index.html"},{"title":"文档","text":"","link":"/docs/index.html"},{"title":"日志","text":"记录工作和学习，时常反思，加速进步。","link":"/journal/index.html"},{"title":"论文","text":"暂无","link":"/paper/index.html"},{"title":"Plan","text":"长远计划 成为一个合格的前端开发工程师。 成为一个合格的全栈开发工程师。 成为一个具备深厚计算机科学素养的工程师。 成为一个像稚晖君一样厉害的工程师。","link":"/plan/index.html"},{"title":"技术栈","text":"Front-end html/html5 canvas/svg css/css3 emmet sass/less bootstrap es6+ javascript typescript jquery ramda rxjs json/xml vue-cli/vue.js/vue-router/vuex axios/vue-resource nuxt.js pinia element-ui/element-plus Avue antd vue http websocket XHR/fetch react/react-router/redux/react-redux next.js jsx/tsx ant design vite webpack/gulp/grunt babel jslint/eslint layui echarts/d3 moment.js/day.js math.js/decimal.js loadash npm/yarn/pnpm chrome devtools 原生微信小程序 uniapp Android Java/kotlin ViewModel/LiveData AndroidX Jetpack Compose AndServer SQLite ADB BLE MQTT Glide Gradle Node.js node.js express koa npm/yarn/pnpm nvm pm2 Java Java netty Spring Boot Spring Cloud Maven MyBatis RabbitMQ Elasticsearch fastjson Python python3 flask django numpy pandas Database SQL MySQL/MariaDB SQLite MongoDB Web SQL IndexedDB Redis Linux iptables/firewalld apache/nginx shell centos/RHEL/ubuntu/arch/manjaro MCU micropython VCS git svn IDE/editor Jetbrains IDE Visual Studio Visual Studio Code Sublime Text HBuilderX 微信小程序开发工具 Vi/Vim Android Studio UI/UX Adobe Photoshop Adobe Illustrator Sketch Axure RP draw.io","link":"/stack/index.html"},{"title":"自媒体计划","text":"概述自媒体这份工作收益巨大，youtube上很多主业程序员的博主都通过youtube得到了比本职工作多得多的收益，比如脑洞乌托邦、老高等等。 油管有个youtuber叫老胡油管研究院可以很好地指导我这种新手。 平台国外：YouTube，没什么可说的，长视频全网上传基本上90%的收益都会来自youtube，通过加入adsense来给视频加入广告得到收益。 国内：长视频平台有bilibili、优爱腾，短视频平台有西瓜快手抖音等等。 内容做自己真正感兴趣的内容以及自己擅长的内容。就我来说我对什么东西都感兴趣，所以比较适合做杂谈类节目或者深耕一个类型的内容创作。就我擅长的东西而言，我可以在抖音快手做唱歌短视频。 变现长视频平台：youtube平台的变现通过adsense插入广告来获益，不过我的视频最多插入三个广告否则会开始影响用户体验，youtube还可以通过接业配来获益。 bilibili由于没有广告，所以只能通过视频恰饭来获取收益。 优爱腾的收益太少了，基本可以忽略不计。 短视频平台：通过打赏、带货获益。 灵感 百万富翁之路利用了所有人都想成为百万富翁的心理，获得subscribe的概率很大。并且可以利用自媒体来监督自己成为百万富翁。 观众从视频中获取了我积极向上努力奋斗的精神感染，我自己也通过自媒体观众的压力为自己创收，两全其美。","link":"/wemedia/index.html"},{"title":"项目","text":"","link":"/project/index.html"}],"posts":[{"title":"Node.js开发笔记——EventEmitter","text":"Node.js使用的是事件驱动模型。 可以通过EventEmitter来实现事件的监听和触发，Node.js中其他的异步API也都是通过继承EventEmitter实现的。 addListener/removeListener为指定的事件添加一个监听器，可以为同一个事件添加多个监听器。 js123456789101112131415const events = require('node:events')// 创建EventEmitter实例const ee = new events.EventEmitter()// 为同一个事件添加多个监听器ee.addListener('event_name', handler1)ee.addListener('event_name', handler2)ee.addListener('event_name', handler3)// 移除事件上指定的监听器ee.removeListener('event_name', handler1)// 移除事件上所有的监听器ee.removeAllListener('event_name') on/emiton方法和addListener是一样的，on是简写。 js1234567// 监听事件，可以接受参数ee.on('event_name', (arg1, arg2, ...) =&gt; {})// 触发事件，可以携带参数ee.emit('event_name', arg1, arg2, ...) once可以使用once为事件添加单词监听器，监听器最多只会执行一次。 js1ee.once('event_name', handler) setMaxListeners/defaultMaxListenersEventEmitter默认限制了给同一个事件最大只能添加10个监听器，使用setMaxListeners可以指定限制数量。 js1ee.setMaxListeners(100) 或者可以直接设置默认最大数量： js123// 设置为0解除限制ee.defaultMaxListeners = 0ee.defaultMaxListeners = 100 listeners获取指定事件上绑定的所有的监听器。 js1const listeners = ee.listeners('event_name') newListener事件EventEmitter中的特殊事件。 js1234ee.on('newListener', (event, listener) =&gt; { console.log(`Event name: ${event}`) console.log(`Listener function: ${listener}`)}) removeListener事件EventEmitter中的特殊事件。 js1234ee.on('removeListener', (event, listener) =&gt; { console.log(`Event name: ${event}`) console.log(`Listener function: ${listener}`)}) error事件EventEmitter中的特殊事件。 js12345ee.on('error', (arg1, arg2, ...) =&gt; {})ee.emit('error', arg1, arg2, ...) 在实际使用时，我们一般通过自定义类继承EventEmitter来实现。","link":"/2024/06/03/EventEmitter/"},{"title":"CSR, SSR, SSG分析","text":"前端开发中有三种渲染技术，分别是CSR（客户端渲染）、SSR（服务端渲染）、SSG（服务端静态站点生成）。 我们根据具体需求的不同来使用不同的技术。 CSR（客户端渲染）CSR是目前前端开发中最常用的渲染方式。 CSR渲染方式下，服务端提供给客户端静态html文件、css文件、js文件等，客户端获取到文件后在客户端渲染。 CSR的优点 响应速度快：浏览器在html加载好后就可以渲染页面，无需等待各种接口请求的结果。 交互性好：因为页面的大部分处理逻辑在客户端执行，所以可以提供更加动态和交互性的用户体验。 服务器压力小：因为渲染是在客户端进行的，而服务端只需要提供数据接口，所以服务端压力小。 容易跨平台开发：CSR的逻辑主要是在客户端，所以可以更容易开发跨平台的应用。 部署简单：只需要部署build出来的代码即可。 CSR的缺点 首屏加载时间长：因为需要下载很多静态文件，会导致首屏加载时间长，可能会出现白屏。 不利于SEO：由于数据是在客户端渲染的，所以不利于搜索引擎爬取页面内容。 SSR（服务端渲染）SSR是在服务端渲染页面的技术。 SSR的渲染方式下，服务端收到客户端的请求后会根据用户请求的页面和数据来渲染完整的页面，然后将渲染好的页面返回给客户端，客户端直接渲染完整的页面。 SSR的优点 首屏加载速度快：由于页面由服务端渲染完成了，所以客户端直接拿来渲染即可。 利于SEO：由于页面以及数据已经在服务端渲染好了，所以搜索引擎爬取时就可以获取到完整的页面，利于SEO。 降低了客户端负载：由于渲染是在服务端完成的，客户端没有了渲染压力，降低了客户端负载，负载从客户端转移到了服务端。 更安全：客户端不直接操作数据，所以减少了客户端可能得安全风险。 更好的可访问性：SSR确保了网页的内容对于无法执行js的用户依然可以访问，提高了站点的可访问性。 SSR的缺点 服务端负载大：服务端承担了页面渲染的工作，导致了服务端负载上升。 开发变得复杂：SSR需要考虑组件在客户端和服务端的运行，导致了开发变得复杂。 不适用于动态内容页面：对于频繁更新的页面，SSR不适合。 SSG（服务端静态站点生成）SSG是在构建项目时生成静态站点的技术。 SSG方式下，我们需要编写模板文件以及数据文件，然后在构建时将这些文件转为静态的页面文件，这些页面文件会被部署到服务器上，用户在请求这些页面的时候会直接返给用户这些提前生成的页面文件而无需实时生成。 SSG的优点 性能好：此时用户请求页面后，服务端直接返回给客户端提前生成好的页面文件，故而速度很快。 安全性好：服务端只提供静态文件，故而降低了安全风险。 容易部署：SSG最终生成的是静态文件，所以很容易部署。 适合静态网站：SSG适合不经常更新的网站。 利于SEO：由于页面以及数据已经在服务端渲染好了，所以搜索引擎爬取时就可以获取到完整的页面，利于SEO。 SSG的缺点 动态性不好：页面是静态生成的，故而不好实现复杂的动态交互。 构建时间长：大型站点构建时间可能很长。 不适合动态内容：频繁更新会消耗服务端大量的资源（构建）。","link":"/2024/05/15/CSR-SSR-SSG/"},{"title":"Express路由配置","text":"服务器端路由是指：服务器端根据客户端请求的不同路径、http方法来执行不同的处理逻辑。 静态路由配置123456789101112131415161718192021// 引入expressconst express = require('express')// 创建服务器const server = express()// 配置路由，第一个参数是路径，第二个参数是处理函数server.get('/', (req, res) =&gt; { res.send('hello')})server.get('/about', (req, res) =&gt; { res.send('about')})const port = 3333// 启动服务器server.listen(port, () =&gt; { console.log('server started on port 3333')}) 动态路由配置动态路由是指：路径中带有参数的路由。 在express中，可以使用:param来定义动态参数。 123456server.get('/user/:userId', (req, res) =&gt; { const userId = req.params.userId // 根据userId处理逻辑}) 模块化管理路由一般不会将路由直接写在server中，可以将所有的路由划分模块，然后引入。 创建模块化路由的步骤 创建路由模块文件。 调用express.Router()创建路由对象。 在路由对象上挂载具体的路由。 使用module.exports向外共享路由对象。 使用server.use()注册路由模块。 代码实例，先创建路由模块，比如这里创建了user相关的两个路由： userRouter123456789101112131415161718const express = require('express')// 创建路由对象const router = express.Router()// 挂载具体路由router.get('/user/list', (req, res) =&gt; { // 处理路由})router.post('/user/add', (req, res) =&gt; { // 处理路由})// 向外导出路由module.exports = router 在创建server的文件中导入上面的模块： 12345678910const express = require('express')const server = express()// 导出模块const userRouter = require('./userRouter')// 注册路由模块server.use(userRouter)server.listen(80, () =&gt; { console.log('server started on port 80')}) 为模块添加前缀 12// 此处省略其他代码server.use('/api', userRouter) 路由中间件除了静态路由和动态路由之外，还可以使用路由中间件来拦截路由并进行处理。 路由中间件是一个函数，它可以访问请求对象 (req)、响应对象 (res) 和应用中的下一个中间件函数 (next)。中间件函数可以执行各种任务，如修改请求和响应对象、执行身份验证、日志记录等。 1234567server.use((req, res, next) =&gt; { // 执行一些处理 console.log('执行了中间件函数') // 执行下一个中间件函数或者路由处理函数 next()}) 错误处理下面定义了一个错误处理中间件，发生错误时会打印错误信息，向客户端返回一个500状态码和响应。 12345server.use((err, req, res, next) =&gt; { console.error(err) res.status(500).send('服务器错误')}) 处理跨域客户端在发送请求之前会先发送一个OPTIONS请求，用于试探服务器是否能接受请求。如果服务端响应404、403、500就会停止继续请求。 下面的代码是处理这种情况的： 123456789101112server.all('*', (req, res, next) =&gt; { res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Headers', 'Content-Type') res.header('Access-Control-Allow-Methods', '*') res.header('Content-Type', 'application/json;charset=utf-8') if (req.method.toLowerCase() === 'options') { res.send(200) } else { next() }}) 完整实例123456789101112131415161718192021222324252627282930313233343536373839const express = require('express')const server = express()// 处理跨域server.all('*', (req, res, next) =&gt; { res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Headers', 'Content-Type') res.header('Access-Control-Allow-Methods', '*') res.header('Content-Type', 'application/json;charset=utf-8') if (req.method.toLowerCase() === 'options') { res.send(200) //让options尝试请求快速结束 } else { next() }})// 中间件server.use((req, res, next) =&gt; { console.log('执行了中间件函数') next()})// 动态路由server.get('/users/:userId/books/:bookId', (req, res) =&gt; { const userId = req.params.userId const bookId = req.params.bookId res.send(`User ID: ${userId}, Book ID: ${bookId}`)}) // 错误处理中间件server.use((err, req, res, next) =&gt; { console.error(err.stack) res.status(500).send('服务器错误')}) // 启动服务server.listen(3333, () =&gt; { console.log('server started on port 3333')})","link":"/2024/04/21/Express%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/"},{"title":"JSON笔记","text":"JSON官网：JSON JSON：JavaScript Object Notation(JavaScript 对象表示法)。 JSON是用于存储和交换文本信息的语法，类似XML但是比XML更小、更快、更易解析。 JSON文件的扩展名为.json JSON文件的MIME类型为application/json 一个JSON实例： 123456789101112{ \"students\": [ { \"name\": \"wang\", \"age\": \"22\" }, { \"name\": \"lee\", \"age\": \"18\" } ]} students这个对象是包含两个记录（对象）的数组。 什么是JSON JSON是javascript对象表示法 JSON是轻量级的文本数据交换格式 JSON独立于语言，JSON解析器和库支持很多语言。 JSON具有自我描述性 转化为JS对象JSON在语法上和javascript对象的代码相同。 故而，javascript可以使用eval()，可以使用JSON数据来生成原生javascript对象。 JSON vs XML同一个实例。 JSON写法： 1234567{ \"sites\": [ { \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" }, { \"name\":\"google\" , \"url\":\"www.google.com\" }, { \"name\":\"微博\" , \"url\":\"www.weibo.com\" } ]} XML写法： 1234567891011&lt;sites&gt; &lt;site&gt; &lt;name&gt;菜鸟教程&lt;/name&gt; &lt;url&gt;www.runoob.com&lt;/url&gt; &lt;/site&gt; &lt;site&gt; &lt;name&gt;google&lt;/name&gt; &lt;url&gt;www.google.com&lt;/url&gt; &lt;/site&gt; &lt;site&gt; &lt;name&gt;微博&lt;/name&gt; &lt;url&gt;www.weibo.com&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; 详细对比（同上图）： 相同点 不同点 JSON也是纯文本 没有结束标签 JSON也具有自我描述性 更简短 JSON也具有层级结构 读写速度更快 JSON也可以通过javascript解析 能使用js内置的eval()解析，而XML需要使用XML解析器 JSON数据也可以使用AJAX传输 能使用数组 JSON也可以被大多数编程语言使用 不使用保留字 JSON.parse()：将一个JSON字符串转化为js对象。 JSON.stringify()：将js值转化为JSON字符串。 应用领域： 使用JSON 使用XML 获取 JSON 字符串 获取 XML 文档 JSON.Parse 解析 JSON 字符串 使用 XML DOM 迭代循环文档 接数据解析出来复制给变量 为什么使用JSON 读取JSON字符串 eval()处理JSON字符串 语法JSON语法是javascript语法的子集。 语法规则 数据为键值对 键值对之间用逗号分隔 用大括号保存对象 用中括号保存数组 键值对1\"key\" : \"value\" 等于以下javascript代码： 1key = \"value\" JSON值 数字，整数和浮点数 字符串，在双引号中 布尔值，true或者false 数组，[1,2,3] 对象，{ key : value } null JSON数字 123{ \"age\": 30} JSON对象 1234{ \"name\": \"wang\", \"age\": 20} JSON数组 数组可以包含多个对象 12345678910111213141516{ \"students\": [ { \"name\": \"wong\", \"url\": \"www.wong.com\" }, { \"name\": \"lee\", \"url\": \"www.lee.com\" }, { \"name\": \"chan\", \"url\": \"www.chan.com\" } ]} 上面的对象students是包含了三个对象的数组，每个对象代表一条记录。 JSON布尔值 123{ \"married\": false} JSON null值 123{ \"name\": null} JSON使用js语法 因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。 通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值： 12345var sites = [ { \"name\":\"runoob\" , \"url\":\"www.runoob.com\" }, { \"name\":\"google\" , \"url\":\"www.google.com\" }, { \"name\":\"微博\" , \"url\":\"www.weibo.com\" }]; 访问对象数组中第一项： 1sites[0].name; 1runoob JSON对象语法1{ \"name\":\"runoob\", \"alexa\":10000, \"site\":null } key必须为字符串，value可以是任意的JSON数据类型。 key和value之间用冒号分隔。 每个键值对之间用逗号分隔。 访问123456789101112var obj,x;obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null}// 使用点访问x = obj.name;// 使用key访问x = obj[\"name\"]; 遍历for…in循环遍历对象属性： 1234var obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null };for (x in obj) { document.getElementById(\"demo\").innerHTML += x + \"&lt;br&gt;\";} 1234var obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null };for (x in obj) { document.getElementById(\"demo\").innerHTML += obj[x] + \"&lt;br&gt;\";} 嵌套JSON对象中可以包含另一个JSON对象： 123456789obj = { \"name\":\"runoob\", \"alexa\":10000, \"sites\": { \"site1\":\"www.runoob.com\", \"site2\":\"m.runoob.com\", \"site3\":\"c.runoob.com\" }} 访问： 123x = obj.sites.site1;// 或者x = obj.sites[\"site1\"]; 修改123obj.sites.site1 = \"www.google.com\";// 或者obj.sites[\"site1\"] = \"www.google.com\"; 删除使用delete关键字删除JSON对象的属性值： 123delete obj.sites.site1;// 或者delete obj.sites[\"site1\"] JSON数组数组作为JSON对象：1[ \"Google\", \"Runoob\", \"Taobao\" ] JSON数组中的值必须是JSON数据类型中的一种。 JSON对象中的数组12345{ \"name\":\"网站\", \"num\":3, \"sites\":[ \"Google\", \"Runoob\", \"Taobao\" ]} 访问： 1x = obj.sites[0]; 遍历 for…in遍历 123for (i in obj.sites) { x += obj.sites[i] + \"&lt;br&gt;\";} for循环遍历 123for (i = 0; i &lt; obj.sites.length; i++) { x += obj.sites[i] + \"&lt;br&gt;\";} 嵌套JSON对象中数组可以包含另一个数组或者另一个JSON对象： 123456789obj = { \"name\":\"网站\", \"num\":3, \"sites\": [ { \"name\":\"Google\", \"info\":[ \"Android\", \"Google 搜索\", \"Google 翻译\" ] }, { \"name\":\"Runoob\", \"info\":[ \"菜鸟教程\", \"菜鸟工具\", \"菜鸟微信\" ] }, { \"name\":\"Taobao\", \"info\":[ \"淘宝\", \"网购\" ] } ]} 使用for-in遍历数组： 123456for (i in obj.sites) { x += \"&lt;h1&gt;\" + obj.sites[i].name + \"&lt;/h1&gt;\"; for (j in obj.sites[i].info) { x += obj.sites[i].info[j] + \"&lt;br&gt;\"; }} 修改数组值1obj.sites[1] = \"Github\"; 删除数组元素使用delete关键字 1delete obj.sites[1]; delete关键字以上使用到了delete关键字，删除数值的元素，数组的大小不变。delete 运算符并不是彻底删除元素，而是删除它的值，但仍会保留空间。 运算符 delete 只是将该值置为undefined，而不会影响数组长度，即将其变为稀疏数组。 JSON.parse()作用JSON通常用于与服务器交换数据。 在接收服务器数据时一般是字符串。 我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。 用法1JSON.parse(text[, reviver]) 参数： text：必需，有效的JSON字符串。 reviver：可选，一个转换结果的函数，将为对象的每个成员调用此函数。 实例假设我们从服务器收到了以下数据： 1{ \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" } 使用JSON.parse()将上面的数据转化为javascript对象： 1var obj = JSON.parse('{ \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" }'); 首先得确保接收到的数据为JSON，否则会出错。 解析完成，使用JSON数据： 123456&lt;p id=\"demo\"&gt;&lt;/p&gt; &lt;script&gt; var obj = JSON.parse('{ \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" }'); document.getElementById(\"demo\").innerHTML = obj.name + \"：\" + obj.site;&lt;/script&gt; 从服务器接受JSON数据使用AJAX从服务器请求JSON，然后解析为js对象： 123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { myObj = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myObj.name; }};xmlhttp.open(\"GET\", \"/try/ajax/json_demo.txt\", true);xmlhttp.send(); 从服务器接受JSON数组如果从服务器收到的是JSON数组，则使用JSON.parse会将其转化为js数组： 123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { myArr = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myArr[1]; }};xmlhttp.open(\"GET\", \"/try/ajax/json_demo_array.txt\", true);xmlhttp.send(); 异常JSON不能存储Date对象。 如果要存储Date对象需要将其转换为字符串，然后再将字符串转化为Date对象。 12345var text = '{ \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"}';var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate); document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期: \" + obj.initDate; 我们可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数。 123456789var text = '{ \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"}';var obj = JSON.parse(text, function (key, value) { if (key == \"initDate\") { return new Date(value); } else { return value;}}); document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期：\" + obj.initDate; 解析函数使用JSON存储函数的方法是将函数转化为字符串然后再转化为函数，不过最好不要再JSON中存储函数。 12345var text = '{ \"name\":\"Runoob\", \"alexa\":\"function () {return 10000;}\", \"site\":\"www.runoob.com\"}';var obj = JSON.parse(text);obj.alexa = eval(\"(\" + obj.alexa + \")\"); document.getElementById(\"demo\").innerHTML = obj.name + \" Alexa 排名：\" + obj.alexa(); JSON.stringify()使用JSON.stringify()将javascript对象转化为字符串： 1JSON.stringify(value[, replacer[, space]]) 参数： value：必需，待转换的js值（通常是数组或者对象）。 replacer：可选，用于转换结果的函数或者数组。 space：可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。 javascript对象转换假设我们向服务器发送以下数据： 1var obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\"}; 使用JSON.stringify()将上面的数据转化为字符串： 1var myJSON = JSON.stringify(obj); myJSON为字符串。 下面发送myJSON到服务器： 1document.getElementById(\"demo\").innerHTML = myJSON; javascript数组转换还可以将js数组转化为JSON字符串： 12var arr = [ \"Google\", \"Runoob\", \"Taobao\", \"Facebook\" ];var myJSON = JSON.stringify(arr); 使用： 1document.getElementById(\"demo\").innerHTML = myJSON; 异常 解析数据 使用JSON存储Date对象的话要将其转化为字符串： 12var obj = { \"name\":\"Runoob\", \"initDate\":new Date(), \"site\":\"www.runoob.com\"};var myJSON = JSON.stringify(obj); 然后再将字符串转化为Date对象。 解析函数 JSON存储函数的话，JSON.stringify()会将js对象的函数删除，包括键和值。 12var obj = { \"name\":\"Runoob\", \"alexa\":function () {return 10000;}, \"site\":\"www.runoob.com\"};var myJSON = JSON.stringify(obj); 可以在执行JSON.stringify()之前将函数转化为字符串： 123var obj = { \"name\":\"Runoob\", \"alexa\":function () {return 10000;}, \"site\":\"www.runoob.com\"};obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); JSON使用将JSON转换为javascript对象用于获取服务器JSON数据的时候，将JSON转换为javascript对象，然后使用在网页中。 实例创建字符串： 1234var txt = '{ \"sites\" : [' +'{ \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" },' +'{ \"name\":\"google\" , \"url\":\"www.google.com\" },' +'{ \"name\":\"微博\" , \"url\":\"www.weibo.com\" } ]}'; eval()可以将JSON文本转换为js对象。 1var obj = eval(\"(\" + txt + \")\"); 在网页中使用js对象： 1234567891011// 创建js字符串var txt = '{ \"sites\" : [' +'{ \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" },' +'{ \"name\":\"google\" , \"url\":\"www.google.com\" },' +'{ \"name\":\"微博\" , \"url\":\"www.weibo.com\" } ]}';// 创建js对象var obj = eval(\"(\" + txt + \")\");document.getElementById(\"name\").innerHTML=obj.sites[0].name document.getElementById(\"url\").innerHTML=obj.sites[0].url JSON解析器由于eval()可以执行任何js代码，故而有安全隐患。 使用JSON解析器将JSON转换为js对象更安全。 JSONP概念JSONP：JSON with Padding，是JSON的一种使用模式，可以跨域读取数据。 浏览器的同源策略出于安全考虑对域有所限制，JSONP就是跨域的一种方式。 应用客户端访问：https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction 客户端期望返回数据：[&quot;customername1&quot;,&quot;customername2&quot;] 客户端真实返回数据：callbackFunction([&quot;customername1&quot;,&quot;customername2&quot;]) 服务器端jsonp.php： 123456789&lt;?phpheader('Content-type: application/json');//获取回调函数名$jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);//json数据$json_data = '[\"customername1\",\"customername2\"]';//输出jsonp格式的数据echo $jsoncallback . \"(\" . $json_data . \")\";?&gt; 客户端callbackFunction()： 123456789101112&lt;script type=\"text/javascript\"&gt;function callbackFunction(result, methodName){ var html = '&lt;ul&gt;'; for(var i = 0; i &lt; result.length; i++) { html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; } html += '&lt;/ul&gt;'; document.getElementById('divCustomers').innerHTML = html;}&lt;/script&gt; 页面： 1&lt;div id=\"divCustomers\"&gt;&lt;/div&gt; 客户端完整代码： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JSONP 实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"divCustomers\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function callbackFunction(result, methodName) { var html = '&lt;ul&gt;'; for (var i = 0; i &lt; result.length; i++) { html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; } html += '&lt;/ul&gt;'; document.getElementById('divCustomers').innerHTML = html; } &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction\"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以上代码由jQuery实现： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JSONP 实例&lt;/title&gt; &lt;script src=\"https://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"divCustomers\"&gt;&lt;/div&gt; &lt;script&gt; $.getJSON(\"https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?\", function (data) { var html = '&lt;ul&gt;'; for (var i = 0; i &lt; data.length; i++) { html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;'; } html += '&lt;/ul&gt;'; $('#divCustomers').html(html); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考 菜鸟教程：JSON教程","link":"/2018/05/10/JSON-notes/"},{"title":"生成UUID","text":"ts生成UUID ts123456const getUUID = (): string =&gt; { const TEMP_URL = URL.createObjectURL(new Blob()) const UUID = TEMP_URL.toString() URL.revokeObjectURL(TEMP_URL) //释放这个url return UUID.substring(UUID.lastIndexOf('/') + 1)}","link":"/2023/06/02/JS%E7%94%9F%E6%88%90UUID/"},{"title":"事件循环(EventLoop)","text":"JavaScript是单线程语言，JavaScript中的任务分为同步任务(sync task)和异步任务(async task)。遇到执行函数会将其放入调用栈(先进后出)中，遇到setTimeout/setInterval等异步任务时，会把它放入到消息队列中，等主线程的任务执行完成以后，再回过头执行消息队列中的异步任务，如果异步任务中仍然有异步任务，会继续放入消息队列，以此类推，便形成了一个事件循环。 同步任务：在主线程上排队。异步任务：在任务队列中排队，等待通知进入主线程执行。 事件循环执行过程 所有同步任务都在主线程上执行，形成一个执行栈。 主线程之外存在一个任务队列，js引擎会将异步任务的完成事件存入该队列等待主线程读取。 执行栈中的同步任务都执行完毕后，js引擎会读取执行任务队列中的任务。 主线程不断循环重复以上第三步。 任务队列(task queue)任务队列可以看做是消息队列，耗时长的任务比如读写磁盘、ajax、或者比如带有callback的事件等完成后就会在任务队列中添加事件，表示该任务可以进入执行栈。 异步任务必须指定callback，当任务队列中的事件被主线程读取时就会执行回调函数。 主线程中的堆(heap)和栈(stack)heap and stack: 主线程运行时产生堆和栈，栈中的代码调用很多外部的API，这些API在任务队列中添加各种事件。栈中的代码执行完毕，主线程就会读取任务队列中的事件执行回调函数。 执行栈中的代码总是在读取任务队列之前被执行。 定时器(timer) setTimeout setInterval 这两个函数只有在当前执行栈清空后才会执行callback。 setTimeout(fn, 0) 含义是：fn会等到同步任务和任务队列中的任务都处理完才会被执行。实际上：setTimeout最短延迟时间为4ms。","link":"/2021/09/23/EventLoop/"},{"title":"《JavaScript DOM编程艺术》读书笔记","text":"JavaScript简史DOM可以给文档增加交互能力。 ECMAScript对javascript进行了标准化。 JavaScript为了蹭当时红极一时的Java的流量故而叫做javascript。 DOM是文档对象模型，它是一种API，程序和脚本可以通过这个接口动态地访问和修改文档的内容、结构和样式。 JavaScript语法使用js的两种方式 将js代码放入&lt;head&gt;标签中。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // code &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 将js代码放入一个单独的js文件中，在html中用&lt;script&gt;标签引入。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"js/main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 将2中的&lt;script&gt;放入&lt;/body&gt;之前，以快速加载网页。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"js/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;script&gt;标签中没必要写type=&quot;text/javascript&quot;属性 语法注释12345// 单行注释/* 多行注释*/ 变量赋值：mood = 'happy'; 声明：var mood; 声明并赋值：var mood = 'happy'; 一次声明并赋值多个变量：var mood = 'happy', age = 33; 变量名命名：字母、数字、美元符号、下划线，第一个字符不允许为数字，可以适当在变量名中间插入下划线一边阅读或者使用驼峰式。但是通常命名函数名、方法名、对象属性名用驼峰式。 js是弱类型语言 数据类型 字符串 数值 布尔值 数组 对象 条件语句if语句 123if () { } 12345if () { } else { } 1234567if () { } else if () { } else { } 比较操作符123456789&gt;&lt;&gt;=&lt;======!=!== 使用===和!== 逻辑操作符123&amp;&amp;||! 循环while 123while () { } do…while 至少执行一次 123do { } while (); for 123for (var i = 0; i &lt; 10; i++) { } 函数123function f() { } 调用 1f(); 例子1：将两个数相乘并返回结果 1234function multiply(num1,num2) { var total = num1 * num2; return total;} 例子2：华氏摄氏度转换 12345function convertToCelsius(temp) { var result = temp -32; result = result /1.8; return result;} 命名变量名用下划线分割单词，命名函数用驼峰式 1234var crew_name = 'wang';function getCrewsInfo() { } 变量作用域全局变量声明在js脚本中，作用域是整个js文件。 局部变量，也就是声明在函数内部，作用域就是这个函数内部。 12345678function square(num) { total = num * num; return total;}var total = 50;var number = square(20);alert(number);// 400 需要用var声明局部变量： 1234function square(num) { var total = num * num; return total;} 注意，函数内部变量一定要用var声明以避免二义性。 对象对象是键值对 123{ name: value;} 比如Person对象的属性和方法的调用： 12Person.age;Person.eat(); 创建一个Person实例： 123var mason = new Person;mason.age;mason.mood; 内置对象，比如Array对象 12var arr = new Array(5);arr.length; 还有宿主对象，比如浏览器提供的对象。 DOMD：文档 O：对象 M：模型 文档中的每一个节点都是一个对象。 DOM就是将网页文档转化为一棵以&lt;html&gt;为根的树。 DOM由节点构成，有些节点可以包含其他的节点，节点有三种：元素节点，文本节点，属性节点。 元素节点可以包含其他节点。 文本节点总是被元素节点包含。 属性节点总是被元素节点包含。 例子： 1&lt;p title=\"p_title\"&gt;标题&lt;/p&gt; DOM：元素节点p里面包含了一个title属性子节点和一个“标题”文本子节点。 获取元素getElementById getElementsByTagName 取得文档所有元素节点： 1var nodes = getElementsByTagName('*'); 以上的DOM方法还可以在任意一个节点对象上调用： 12var temp1 = document.getElementById('header');var temp2 = temp1.getElementsByTagName('div'); getElementsByClassName 获取带有多个类名的元素： 1document.getElementsByClassName('div p'); 通过以上DOM方法取得节点后赋值给变量再进行其他操作。 获取设置属性获取元素后可以获取其属性和设置其属性。 getAttribute 只能在元素节点上调用 12345var temp = getElementById('header');var t = temp.getAttribute('title');if (t) { alert(t);} setAttribute 12var temp = getElementById('header');temp.setAttribute('title','这里是标题'); 案例：javascript图片库图库demo： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;图片库&lt;/title&gt; &lt;style&gt; body { padding: 0; margin: 0; } &lt;/style&gt; &lt;script&gt; // 参数是一个a元素 function showPic(whichpic) { var placeholder = document.getElementById('placeholder'); var source = whichpic.getAttribute('href'); placeholder.setAttribute('src',source); var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text; } function countBodyChildren() { var body_element = document.getElementsByTagName('body')[0]; console.log(body_element.childNodes.length); } window.onload = countBodyChildren; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;snapshots&lt;/h1&gt; &lt;ol&gt; &lt;li&gt;&lt;a title=\"title1\" href=\"img/1.jpg\" onclick=\"showPic(this);return false;\"&gt;img 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a title=\"title2\" href=\"img/2.jpg\" onclick=\"showPic(this);return false;\"&gt;img 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a title=\"title3\" href=\"img/3.jpg\" onclick=\"showPic(this);return false;\"&gt;img 3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a title=\"title4\" href=\"img/4.jpg\" onclick=\"showPic(this);return false;\"&gt;img 4&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;img id=\"placeholder\" src=\"img/placeholder.jpg\" alt=\"\" height=\"666px\"&gt; &lt;p id=\"description\"&gt;标题&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; nodeType 元素节点的nodeType为1 属性节点的nodeType为2 文本节点的nodeType为3 这里发现了vscode的go live插件不能正确显示改变后的title，垃圾 最佳实践平稳退化1window.open(url,name,features); 1window.open('https://www.baidu.com','baidu','width: 400,height: 150'); 伪协议123function pop(website){ window.open(website,'baidu','width: 400,height: 150');} 1&lt;a href=\"javascript:pop('https://baidu.com');\"&gt;link&lt;/a&gt; 尽量不用伪协议调用js代码。 window.onload = func; 向后兼容对象检测： 123if (document.getElementById) { } 兼容： 1234window.onload = function() { if (!document.getElementById) return false; // ...} 性能考虑 尽量少访问DOM，尽量减少标记 合并脚本，并放在&lt;/body&gt;之前 压缩脚本 案例：图片库改进版123window.onload = function() { } 1234567891011function addloadEvent(func) { var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = func; } else { window.onload = function() { oldonload(); func(); } }} 现在再添加函数只需要：addloadEvent(firstFunc) onkeypress 动态创建标记传统技术：document.write innerHTML DOM方法：createElement createTextNode appendChild insertBefore document.body parentNode firstChild lastChild insertBefore nextSibling 编写insertAfter函数： 12345678function insertAfter(newElement,targetElement) { var parent = targetElement.parentNode; if (parent.lastChild == targetElement) { parent.appendChild(newElement); } else { parent.insertBefore(newElement,targetElement.nextSibling); }} Ajax局部更新页面而不同刷新 XMLHttpRequest对象创建对象： ie： 1var request = new ActiveXObject('Msxml2.XMLHTTP.3.0'); 其他浏览器： 1var request = new XMLHttpRequest(); 编写getHTTPObject.js文件 12345678910111213function getHTTPObject() { if (typeof XMLHttpRequest == 'undefined') XMLHttpRequest = function () { try {return new ActiveXObject(\"Msxml2.XMLHTTP.6.0\");} catch (e) {} try {return new ActiveXObject(\"Msxml2.XMLHTTP.3.0\");} catch (e) {} try {return new ActiveXObject(\"Msxml2.XMLHTTP\");} catch (e) {} return false; } return new XMLHttpRequest();} var request = new getHTTPObject();返回一个XMLHttpRequest对象。 XMLHttpRequest对象的方法： open GET,POST,SEND 是否异步 编写getNewContent.js 123456789101112131415161718function getNewContent() { var request = getHTTPObject(); if (request) { request.open('GET','example.txt',true); request.onreadystatechange = function() { if (request.readyState == 4) { var para = document.createElement('p'); var txt = document.createTextNode(request.responseText); para.appendChild(txt); document.getElementById('new').appendChild(para); } }; request.send(null); } else { alert('sorry,your browser dont support XMLHttpRequest'); }}addLoadEvent(getNewContent); 充实文档的内容CSS-DOMelement.style是一个对象 element.style.property引用节点属性，如果属性名是用连字符的则改写为驼峰式。 但是以上只能返回行内样式，不能用来操作外部样式。 通过用DOM去修改元素的className来达到切换样式的目的。 1element.className = value; addClass函数： 12345678function addClass(element,value) { if (!element.className) { element.className = value; } else { newClassName = element.className + ' ' + value; element.className = newClassName; }} 用js实现动画效果var variable = setTimeout(func,delay); clearTimeout(variable); parseInt() parseFloat() html5canvas &lt;video&gt; controls addEventListener 综合示例js库jQuery prototype etc 常用代码addClassaddClass()用于为节点对象添加新类名。 参数：元素节点，新类名。 12345678910function addClass(element,value) { if (!element.className) { element.className = value; } else { newClassName = element.className; newClassName += ' '; newClassName += value; element.className = newClassName; }} insertAfterinsertAfter()用于将新节点插到目标节点后面。 参数：新节点，目标节点。 12345678function insertAfter(newElement,targetElement) { var parent = targetElement.parentNode; if (parent.lastChild == targetElement) { parent.appendChild(newElement); } else { parent.insertBefore(newElement,targetElement.nextSibling); }} addLoadEvent用于添加页面onload后立刻执行的函数。 参数为需要立刻执行的函数。 1234567891011function addLoadEvent(func) { var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = func; } else { window.onload = function() { oldonload(); func(); } }} 调用： 1addLeadEvent(func);","link":"/2018/03/01/JavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"},{"title":"《JavaScript语言精粹》读书笔记","text":"做点笔记。 精华null 语法 避免使用/* */来写注释，使用//写注释。 js不允许获取对象属性的时候使用点运算获取属性名为js保留字的属性。 超过js数字表示极限的值都会被认为是Infinity。 字符串不可被改变。 falsy：false, null, undefined, '', 0, NaN。 truthy：不是以上falsy的都属于truthy。 对象 对象中的属性名如果不是合法的变量名，则需要用括号包裹。 对象中的属性名如果是合法的变量名，则可以用.代替[&quot;&quot;]。 可以使用||给一个默认值。 var a = b = c = {}三个变量都指向同一个对象，var a = {}, b = {}, c = {}三个变量指向不同的对象。 函数 函数也是对象，可以被保存在变量、对象、数组中。 函数也可以作为参数或者返回值。 一个函数可以定义在另一个函数里，里层函数可以获取外层函数中的局部变量以沟通函数和函数外，称之为闭包。 调用函数的时候会中断当前执行的函数，将控制权交给新函数并给新函数传参。 函数出了接受形参，还接受this和arguments这两个参数。 当函数被保存在对象中的一个属性中时，就叫做对象的方法。 this的指向。 构造函数首字母大写，并且只能new调用。 arguments其实是一个类数组对象。 函数总是会有返回值，如果没有指定返回值则返回undefined。 如果函数被调用时前面有new，且返回值不是对象，则返回this。 在 Function 原型链上添加一个原型方法method，用于给函数对象添加方法： 123456Function.prototype.method = function(name, func) { if (!this.prototype[name]) { this.prototype[name] = func; } return this;} js没有尾递归优化，深度递归可能栈溢出。 尾递归：是一种在函数最后执行递归调用语句的特殊形式的递归。 尽量在文件或者函数顶部申明用到的所有变量。 回调函数可以异步处理数据。 级联：将没有return的函数返回this就可以创造级联，也就是链式调用。 柯里化 记忆: 存储中间结果来优化算法，比如可以优化斐波那契数列的递归算法。 继承 不同于其他语言使用类来继承，js使用原型prototype来继承。 构造函数要以大写开头。 尽量使用对象而不是参数序列来作为传入的参数。 这章有些地方没看懂，有时间再看一遍。 数组 给数组添加非index的属性名不会改变数组的length。 正则null 方法null 代码风格null 优美的特性null 附录A：毒瘤 全局变量 作用域 自动插入分号 保留字（引用对象中的属性名恰好和保留字一样时需要用obj['property']的方式引用） typeof() parseInt() 浮点数不精确（可以通过先乘以一个数变为整数，运算完了再除回来） NaN 伪数组 Falsy hasOwnProperty() 对象 附录B：糟粕 不要用==和!= 不要用with 不要用eval，同理也不应该用Function构造器，也不要给setTimeout和setInterval传字符串参数。 不要用continue 注意switch穿越 尽量不用++和-- 位运算符在js中实际运行很慢。 包装对象，不要使用new创建包装对象，直接申明字面量即可。 使用首字母大写命名构造函数，使用new掉用构造函数。 不要使用void 附录C：JSLintnull","link":"/2022/04/29/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"JavaScript异步编程","text":"JavaScript异步编程的进化历程：callback -&gt; Promise -&gt; Generator -&gt; async/await 异步的意思是该代码与其他代码的关系是异步执行的，而在该代码自己内部是同步执行的。 js的异步机制： 所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 回调函数（callback）回调函数是js中常见的异步编程方式，比如定时器： 123456789// 会先执行f1的代码，再将传入的f2作为回调函数执行。function f1(callback) { // f1 code setTimeout(() =&gt; { callback(); }, 0);}f1(f2); 除了 setTimeout 之外，还有 XMLHttpRequest 也使用了回调函数编写异步任务。 事件监听（EventListener）比如由f1运行一段任务，任务完成后触发一个事件。f2监听这个事件，监听到了就运行任务。 123456789101112// 给f1绑定事件和触发函数f2f1.on('event_name', f2);// 运行f1的任务，完成后触发事件function f1() { setTimeout(() =&gt; { // f1 code // 触发事件 f1.trigger('event_name'); }, 0);} 发布/订阅（publish/subscribe）有一个信号中心，生产者发布信号（publish）到信号中心，消费者订阅信号中心的信号（subscribe）。 消费者还可以取消订阅信号（unsubscribe）。 PromisePromise 可以将回调套娃的代码变为扁平的顺序结构。 Promise对象的状态只能从pending到resolve或者从pending到reject。 注意： then() 接受两个参数，第一个参数是resolve时调用的函数，第二个参数是reject时调用的函数。 比如： 12345678910111213141516171819202122232425262728// Promise的参数是一个函数，这个函数会被异步执行// Promise中的resolve()和reject()用于向then传递参数new Promise(function(resolve, reject) { setTimeout(function() { console.log(1); resolve(); }, 1000);}).then(function() { // then中可以使用return向后面的then传递参数 return new Promise(function(resolve, reject) { setTimeout(function() { console.log(2); resolve(); }, 4000); });}).then(function() { setTimeout(function() { console.log(3); }, 3000);}).catch(function() { // 捕获异常，前面的运行中有任何异常都会直接跳到这里}).finally(function() { // 最终运行的代码});// 1// 2// 3 jQuery异步编程API： 基于Promise的when, then, done, fail 参考我之前写的：jQuery的when, then, done, fail GeneratorGenerator 用于创建迭代器(iterator)。 关于iterator： iterator为不同的可迭代的对象提供统一的访问接口。 可以按照次序迭代可迭代对象。 可以用for…of语句迭代。 iterator内有next方法，next内有value（当前迭代的值）和done（是否迭代完成）属性。 创建迭代器： 123456let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();// 调用next方法iter.next(); 创建Generator并使用： 12345678910111213// 创建Generator,执行后返回一个iterator对象function* createGenerator() { yield 1; yield 2; yield 3;}// 返回值是一个iteratorlet iter = createGenerator();iter.next(); // {value: 1, done: false}iter.next(); // {value: 2, done: false}iter.next(); // {value: 3, done: false}iter.next(); // {value: undefined, done: true} Generator可以在运行过程中使用 yield 多次return，故而可以异步编程。 注意：Generator需要配合 yield 和 * 使用。 异步函数（async/await）async/await是JavaScript异步编程的终极解决方案。 异步函数的返回值是一个Promise对象。 在异步函数内部，可以使用 await 命令等待一个Promise对象处理的结果（await也可以等待其他数据类型的字面量），再顺序往下执行。 12345678910111213141516function asyncFunction() { return new Promise((resolve) =&gt; { setTimeout(function() { console.log(\"asyncFunction\"); resolve(); }, 1000); });}async function helloAsync() { let promiseData = await asyncFunction(); console.log(\"helloAsync\");}helloAsync();// asyncFunction// helloAsync e.g. 12345678910111213141516async function a() { console.log(\"1\"); console.log(\"2\");}a();console.log(\"3\");//打印： 1 2 3 async function a() { await 1; console.log(\"1\"); console.log(\"2\");}a();console.log(\"3\");//打印： 3 1 2 参考文档 https://www.runoob.com/w3cnote/es6-promise.html https://www.runoob.com/js/js-promise.html https://www.runoob.com/js/js-async.html https://www.runoob.com/w3cnote/es6-async.html https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html https://mp.weixin.qq.com/s/tGfC5XVuWXuSbG7wFLuaag","link":"/2022/05/05/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"title":"洗牌算法之Knuth-Shuffle算法","text":"看到好多公众号里写的洗牌算法有问题。 比如，最常见的一种是： 123Array.prototype.shuffle = function() { return this.sort(() =&gt; Math.random() - 0.5);} 这种算法的问题在于 Math.random() - 0.5 会导致左边的元素会堆积在左边，右边的元素会堆积在右边，尽管数组在被洗牌后看起来像是被打乱了。 洗牌算法的核心应该是找到一个映射方法，将数组中原来的元素value随机放置到数组中一个新的index上。 Knuth-Shuffle算法关于Knuth-Shuffle，CSDN等博客基本写的都有问题。 我的理解如下： 一个长度为n的数组，设置一个指针rightPos放在最右边。 随机选取包含该rightPos在内的前n个元素的其中一个元素，将rightPos元素与其交换，这样可以保证rightPos元素有几率留在原位置。 rightPos左移一位，重复第2步直到rightPos为0。 12345678910111213141516/* * 改变原数组并返回 */Array.prototype.shuffle = function() { for (let len = this.length, i = len - 1; i &gt;= 0; i--) { // 指针index let rightPos = i; // 随机选取前i+1个元素的index let randomPos = Math.floor(Math.random() * (i + 1)); // 交换两个元素 [this[randomPos], this[rightPos]] = [this[rightPos], this[randomPos]]; } return this;}[1, 2, 3, 4, 5].shuffle();","link":"/2022/05/12/Knuth-Shuffle/"},{"title":"Java并发编程","text":"在Java中可以通过创建多线程来达到并发编程的目的。 线程Java中的线程（Thread）的生命周期是这样的： 实例化一个线程对象后，线程处于新建状态，等待进入就绪状态。 调用start()后，线程进入就绪状态，等待被JVM的线程调度器调度进入运行状态。 调用run()后，线程进入运行状态，运行状态的线程可能进入阻塞状态、就绪状态、死亡状态。 运行状态的线程如果调用了sleep()或者suspend()后会失去所有资源，线程进入阻塞状态，阻塞状态的线程在睡眠时间到后或者获得资源后会重新进入就绪状态。 run()执行完毕、调用stop()、调用destroy()，线程会进入死亡状态。 线程进入阻塞状态有三种情况： 等待阻塞状态：运行状态的线程调用wait()进入等待阻塞状态。 同步阻塞状态：运行状态的线程获取synchronized同步锁失败（同步锁被其他线程占用）会进入同步阻塞状态。 其他阻塞状态：线程调用sleep()、join()IO请求，线程会进入阻塞状态，当sleep超时或者join终止或者超时，或者IO完毕，线程会重新进入就绪状态等待被JVM调度。 线程的优先级每个线程都有一个优先级，默认优先级 NORM_PRIORITY（5） 。 JVM根据线程优先级调度资源。 创建线程Java提供三种方法创建线程： 实现 Runnable 接口。 继承 Thread 类。 实现 Callable 和 Future 接口来创建线程。 实现Runnable接口来创建线程ThreadDemo.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class RunnableDemo implements Runnable { private Thread t; private String threadName; // 构造方法 RunnableDemo(String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } // 实现run，线程进入运行状态 public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i &gt; 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // sleep Thread.sleep(50); } } catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + \" interrupted.\"); } System.out.println(\"Thread \" + threadName + \" exiting.\"); } // 实现start，线程进入就绪状态 public void start () { System.out.println(\"Starting \" + threadName ); if (t == null) { t = new Thread (this, threadName); t.start (); } }}public class ThreadDemo { public static void main(String args[]) { RunnableDemo R1 = new RunnableDemo( \"Thread-1\"); R1.start(); RunnableDemo R2 = new RunnableDemo( \"Thread-2\"); R2.start(); } } 继承Thread类来创建线程继承Thread类，其他代码相同。 实现Callable和Future接口来创建线程略","link":"/2023/05/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"NUC8i7BEH Hackintosh","text":"前段时间我的MBP 2018 13inch（i5-8259u, 16G, 256G）在干活的时候各种卡顿，风扇无故狂转，所以打算搞个黑苹果写代码用。 于是在闲鱼上收了个 NUC8i7BEH ，配了两条光威的16G DDR4 3200的内存（镁光颗粒），买了一块1T的西数SN570。 然后将硬盘分了三个区，一个windows，一个esp分区，一个macOS分区，安装了最新的 Ventura 和最新的 windows 11 。 未来一两年这就是我的开发机器了。 配置MacBook Pro 2018 13inchwangwei@192.168.0.102 --------------------- OS: macOS 13.1 22C65 x86_64 Host: MacBookPro15,2 Kernel: 22.2.0 Uptime: 7 hours, 6 mins Packages: 41 (brew) Shell: zsh 5.8.1 Resolution: 2560x1440@2x DE: Aqua WM: Quartz Compositor WM Theme: Blue (Light) Terminal: HyperTerm Terminal Font: Menlo CPU: Intel i5-8259U (8) @ 2.30GHz GPU: Intel Iris Plus Graphics 655 Memory: 11553MiB / 16384MiB NUC8i7BEH 机器规格：https://ark.intel.com/content/www/cn/zh/ark/products/126140/intel-nuc-kit-nuc8i7beh.html wangwei@NUC8i7BEH.local ----------------------- OS: macOS 13.0.1 22A400 x86_64 Host: Hackintosh (SMBIOS: Macmini8,1) Kernel: 22.1.0 Uptime: 5 hours, 33 mins Packages: 17 (brew) Shell: zsh 5.8.1 Resolution: 2560x1440 DE: Aqua WM: Quartz Compositor WM Theme: Blue (Light) Terminal: HyperTerm Terminal Font: Menlo CPU: Intel i7-8559U (8) @ 2.70GHz GPU: Intel Iris Plus Graphics 655 Memory: 16556MiB / 32768MiB","link":"/2022/12/12/NUC8i7BEH-Hackintosh/"},{"title":"LaTeX安装和配置（mac平台）","text":"准备写人工智能领域的论文了，安装配置一下LaTeX。 主要是mactex的安装以及vscode的配置。 LaTeX（LATEX，音译“拉泰赫”）是一种基于TEX的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天、甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 下载mactex官网下载（使用迅雷）：https://www.tug.org/mactex/ 清华镜像站：https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/ 安装mactex安装完毕后launchpad会出现两个app，LaTeXiT是配置用的，TeXshop是编辑器。 不过自带的编辑器TeXshop过于简陋，故而使用VScode来配置LaTeX写作环境。 查看文档安装完成后就可以使用以下命令来查看中文的LaTeX简明文档了（一百多页）。 1texdoc lshort-china 然后另存到常用目录下。 使用vscode安装插件 LaTeX workshop LTex 配置settings.jsonvscode在settings.json文件中添加： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115{ \"latex-workshop.latex.tools\": [ { \"name\": \"latexmk\", \"command\": \"latexmk\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-pdf\", \"%DOC%\" ] }, { \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] } ],\"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] }, { \"name\": \"latexmk\", \"tools\": [ \"latexmk\" ] }, { \"name\": \"pdflatex -&gt; bibtex -&gt; pdflatex*2\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] }, { \"name\": \"xelatex-&gt;bibtex-&gt;xelatex-&gt;xelatex\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", ] } ], \"latex-workshop.view.pdf.viewer\": \"tab\", \"latex-workshop.latex.clean.fileTypes\": [ \"*.aux\", \"*.bbl\", \"*.blg\", \"*.idx\", \"*.ind\", \"*.lof\", \"*.lot\", \"*.out\", \"*.toc\", \"*.acn\", \"*.acr\", \"*.alg\", \"*.glg\", \"*.glo\", \"*.gls\", \"*.ist\", \"*.fls\", \"*.log\", \"*.fdb_latexmk\" ], //下面这段是语法检查模块//{\"ltex.enabled\": true, // 启用插件\"ltex.language\": \"en-US\",// 设置语言，这里是德语// 要英语就下载对应 English Support，然后这里填 en, 或者 en-US,en-GB 等*/ \"ltex.de.dictionary\": [\"Niubility\", \"Zhihu\"], //注意根据要对应语言，ltex.&lt;LANGUAGE&gt;.dictionary\"ltex.environments.ignore\": [ \"lstlisting\", \"verbatim\"],\"ltex.commands.ignore\": [ \"\\\\documentclass[]{}\", \"\\\\renewcommand*{}[]{}\"],//}语法检查功能在这里结束} 如果需要配置skim（在skim设置中的sync标签下，PDF-TeX Sync support下的preset选择vscode即可。），则settings.json添加如下配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133{ \"latex-workshop.latex.tools\": [ { \"name\": \"latexmk\", \"command\": \"latexmk\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-pdf\", \"%DOC%\" ] }, { \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] } ],\"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] }, { \"name\": \"latexmk\", \"tools\": [ \"latexmk\" ] }, { \"name\": \"pdflatex -&gt; bibtex -&gt; pdflatex*2\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] }, { \"name\": \"xelatex-&gt;bibtex-&gt;xelatex-&gt;xelatex\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", ] } ], \"latex-workshop.view.pdf.viewer\": \"tab\", \"latex-workshop.latex.clean.fileTypes\": [ \"*.aux\", \"*.bbl\", \"*.blg\", \"*.idx\", \"*.ind\", \"*.lof\", \"*.lot\", \"*.out\", \"*.toc\", \"*.acn\", \"*.acr\", \"*.alg\", \"*.glg\", \"*.glo\", \"*.gls\", \"*.ist\", \"*.fls\", \"*.log\", \"*.fdb_latexmk\" ], //下面这段是语法检查模块//{\"ltex.enabled\": true, // 启用插件\"ltex.language\": \"en-US\",// 设置语言，这里是德语// 要英语就下载对应 English Support，然后这里填 en, 或者 en-US,en-GB 等*/ \"ltex.de.dictionary\": [\"Niubility\", \"Zhihu\"], //注意根据要对应语言，ltex.&lt;LANGUAGE&gt;.dictionary\"ltex.environments.ignore\": [ \"lstlisting\", \"verbatim\"],\"ltex.commands.ignore\": [ \"\\\\documentclass[]{}\", \"\\\\renewcommand*{}[]{}\"],\"editor.fontSize\": 18,//}语法检查功能在这里结束\"latex-workshop.view.pdf.viewer\": \"external\",\"latex-workshop.view.pdf.external.synctex.command\": \"/Applications/Skim.app/Contents/SharedSupport/displayline\",\"latex-workshop.view.pdf.external.synctex.args\": [\"-r\",\"%LINE%\",\"%PDF%\",\"%TEX%\"],\"latex-workshop.view.pdf.external.viewer.command\": \"/Applications/Skim.app/Contents/MacOS/Skim\",\"latex-workshop.view.pdf.external.viewer.args\": [ \"%PDF%\"],} 使用sublime text安装插件安装插件：LaTeX Tools 设置skim支持在skim设置中的sync标签下，PDF-TeX Sync support下的preset选择sublime text即可。 开始写LaTeX新建扩展名为.tex的文档就可以开始写LaTeX了。 1touch article.tex 使用XeLaTeX编译为了解决pdfLaTeX无法支持中文的问题，需要在Tex文档头部加上： 12%!TEX program = xelatex\\usepackage[UTF8]{ctex} 编译的时候也要选择XeLaTeX。 sublime text使用cmd + B即可编译。 随机弹出pdf预览（需要完成设置skim）。 使用shift + cmd并点击skim中的内容可以跳至sublime text对应代码。 使用TexpadTexpad是一款mac平台的LaTeX编辑器，使用起来更为专注和方便。 关键在于不用配置，省心。 测试123456789101112%!TEX program = xelatex\\usepackage[UTF8]{ctex}\\documentclass{article}\\usepackage{fontspec, xunicode, xltxtra}\\setmainfont{Hiragino Sans GB}\\title{标题}\\author{}\\begin{document}\\maketitle{}\\section{段落}内容，内容，内容，内容，内容，内容，内容，内容，内容，内容，内容，内容。\\end{document} 效果： LaTeX辅助工具 LaTeX官方中文文档：https://gcore.jsdelivr.net/gh/herotiga/cdn/pdf/lshort-zh-cn.pdf 妈咪叔LaTeX帮助文档：https://latexlive.com/help mactex官网：https://www.tug.org/mactex/ LaTeX公式编辑器：https://latexlive.com/ xFormula（mac）：https://apps.apple.com/cn/app/id1477136751 LaTeX表格代码生成器：https://www.tablesgenerator.com/ 网页版LaTeX：https://www.overleaf.com/","link":"/2020/06/18/LaTeX-installation/"},{"title":"Next.js开发笔记","text":"Next.js是基于react的一个全栈框架，提供的功能和Nuxt.js基本一样。 Next.js主要是为了解决react的如下问题： js环境 首屏加载慢 安全问题 SEO Next.js通过将渲染这个过程移动到服务端（将生成DOM放在服务端完成）来解决以上问题，也就是SSR。 初始化项目bash1234npx create-next-app@latest project-name# 使用tsnpx create-next-app@latest --typescript project-name 目录结构 路由静态路由静态路由是指在编译时就确定了路由和其对应的页面文件。 pages下创建文件即可生成对应的路由配置。 动态路由可以在pages目录下创建文件名，文件名是变量的形式[param].ts。 比如，如果想获取一个article页面的参数id，可以在article下定义名为[id].ts的文件，然后在这个文件内可以使用useRouter来获取id。 API静态路由API路由允许我们再next.js项目章自定义服务端逻辑，可以处理客户端发起的http请求。 创建方法： 在pages/api下创建一个文件，文件名即为路由，这里创建了user.ts文件。 在user.ts中编写处理请求的代码。 user.ts1234567891011121314import type { NextApiRequest, NextApiResponse } from 'next'type Data = { code: number users: string[]}export default function handler(req: NextApiRequest, res: NextApiResponse&lt;Data&gt;) { const users: string[] = ['Alice', 'Bob', 'Charlie'] res.status(200).json({ code: 0, users, })} 最后访问地址为/api/user的API即可获取到数据。 API动态路由除了上面的静态路由，next.js还可以实现动态路由（也就是在路由中允许参数）。 创建方法： 在pages/api下创建一个文件，文件名形如[id].ts，文件名即为路由。 在[id].ts中编写处理请求的代码，在代码中可以获取到id。 [id].ts12345678910import type { NextApiRequest, NextApiResponse } from 'next'type Data = { message: string}export default function handler(req: NextApiRequest, res: NextApiResponse&lt;Data&gt;) { const { id } = req.query res.status(200).json({ message: Received request for ID: ${id} })} 最后访问地址为/api/:id的API即可获取到对应id的数据。 SSR &amp; SSG这里有3个重要的方法。 getServerSideProps：服务端渲染，在请求时运行 getStaticProps：服务端生成，生成静态页面时运行 getStaticPaths：服务端生成，生成静态页面时运行 声明SSR页面在页面组件内添加一个getServerSideProps函数。 jsx12345678910111213141516171819202122// 正常的页面组件const Post = ({data}) =&gt; { return &lt;div&gt;{ data }&lt;/div&gt;}export default Post// 将该页面声明为SSR页面，下方函数是在服务端执行的export async function getServerSideProps(context) { // 取出id const { id } = context.query // 根据id查询接口 const res = await fetch(`/article/${id}`).then(data =&gt; data.json()) return { // 这里的props会被传入到上方组件中 props: { data: res, }, }} 声明SSG页面如果将以上代码的getServerSideProps改为getStaticProps，那么代码会在build的时候运行，此时文件会变为在build时渲染出来。 但是我们不知道用户会访问哪个id，所以需要搭配getStaticPaths来使用，getStaticPaths就是用来枚举用户可能访问的id。 下面生成一些用户可能访问的id： jsx12345678910111213141516171819202122232425262728293031323334353637// 正常的页面组件const Post = ({data}) =&gt; { return &lt;div&gt;{ data }&lt;/div&gt;}export default Post// 将该页面声明为SSR页面，下方函数是在服务端执行的export async function getStaticProps(context) { // 取出id const { id } = context.query // 根据id查询接口 const res = await fetch(`/article/${id}`).then(data =&gt; data.json()) return { // 这里的props会被传入到上方组件中 props: { data: res, }, }}// 下面会在build阶段生成id从1到100的页面export async function getStaticPaths() { return { paths: _.range(1, 100).map((id) =&gt; { return { params: { id: id + '', }, } }) // id未命中时退化为SSR fallback: 'blocking', }} fallback的取值还有：false（404），true（退化到CSR）。 增量静态生成（ISR）自动重新生成添加revalidate参数，表示这个静态页面最多可存活的秒数，如果当用户请求页面时这个页面已经生成了超过10s则会重新生成该页面。可以用来保证静态页面是最新的。 jsx123456789101112131415161718192021222324252627282930313233343536373839// 正常的页面组件const Post = ({data}) =&gt; { return &lt;div&gt;{ data }&lt;/div&gt;}export default Post// 将该页面声明为SSR页面，下方函数是在服务端执行的export async function getStaticProps(context) { // 取出id const { id } = context.query // 根据id查询接口 const res = await fetch(`/article/${id}`).then(data =&gt; data.json()) return { // 这里的props会被传入到上方组件中 props: { data: res, }, // 最多存活10s revalidate: 10, }}// 下面会在build阶段生成id从1到100的页面export async function getStaticPaths() { return { paths: _.range(1, 100).map((id) =&gt; { return { params: { id: id + '', }, } }) // id未命中时退化为SSR fallback: 'blocking', }} 手动重新生成在pages/api目录下创建一个文件，文件名即路由，在文件中手动调用revalidate方法即可。 参考 https://nextjs.frontendx.cn/ https://www.nextjs.cn/","link":"/2024/04/26/Nextjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"title":"Nuxt.js开发笔记","text":"Nuxt.js是基于vue的一个全栈（这里全栈的意思是支持CSR和SSR）开发框架或者说开发套件，支持SSR（服务端渲染）、SSG（静态站点生成）、SPA（单页面应用），它提供了vue不提供的路由、缓存、接口服务、SSR，并对开发场景做了大量优化，开箱即用。 初始化项目bash1npx create-nuxt-app my-app FileBased（文件即路由）只需要在pages下创建vue文件，即可访问，Nuxt.js会自动根据文件名注册路由。还支持路由嵌套、路由参数。 SSRvue项目都是在客户端渲染的，导致我们的页面不能完整的被搜索引擎爬取收录，这个时候就可以搭建服务端渲染（SSR）来解决这个问题。 SEO在Nuxt.js中实现SEO只需要使用Nuxt.js提供的SEO接口： vue12345678910&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\" setup&gt;useSeoMeta({ title: '电商', description: '描述',})&lt;/script&gt; 服务端渲染接口数据$fetchNuxt.js内置了$fetch，可以代替axios。 useAsyncDatauseAsyncData是用于获取接口数据的方法，需要结合$fetch使用。 vue12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\" setup&gt;import { ref } from 'vue'useSeoMeta({ title: '电商', description: '描述',})const list = ref([])const { data } = await useAsyncData( 'id', // 需要给定唯一的id () =&gt; $fetch('https://xxx.xxx.com', { headers: { // ... } }), { pick: ['data'], // 选择返回对象中想要的属性 // lazy: false, // 这里默认为false 会阻塞路由渲染，（一定要等到数据请求回来后才会跳转路由） lazy: true // 不会阻塞路由跳转，但是会导致跳转后无数据，需要通过watch监听数据后赋值 })list.value = data.valuewatch(data, () =&gt; { list.value = data.value})&lt;/script&gt; 如果对于获取的数据不需要处理，则无需监听可以在获取到data后直接渲染到页面上。 这样就可以像CSR一样使用data来渲染页面了。 此时接口的数据是在服务端完成的渲染，这样对于SEO友好，并且可以解决首屏加载慢的问题，因为页面都已经在服务端渲染好了。 useFetchuseFetch是useAsyncData的语法糖，它不需要传入id。 vue123456789101112131415161718192021&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\" setup&gt;useSeoMeta({ title: '电商', description: '描述',})const { data } = await useFetch( 'https://a.com/xxx', { headers: { // ... }, transform: res =&gt; res.data.list, // 选择返回对象中想要的属性 lazy: true, },)&lt;/script&gt; useLazyFetchuseLazyFetch是lazy为true的useFetch。 服务端接口Nuxt.js还可以写自己的服务端接口。 比如在server目录下创建api目录，目录下创建接口文件，可以直接读取数据库。实现了一个真实的api接口。 组件自动导入Nuxt.js中如果要使用一个组件，不需要再导入这个组件了，可以直接使用。 中间件Nuxt.js可以使用中间件（middleware）来实现比如鉴权等功能。 创建中间件 在具体页面组件中使用中间件。 vue12345678910111213141516&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\" setup&gt;definePageMeta({ middleware: 'middlewareName',})useSeoMeta({ title: '电商', description: '描述',})const { data } = await useFetch('https://a.com/xxx')&lt;/script&gt; 除了这些之外，Nuxt.js还支持页面渲染配置、过渡动画、状态管理、单元测试等等，以及社区资源。","link":"/2024/04/25/Nuxtjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"title":"React开发笔记","text":"陆续记录React开发的基础知识以及开发模式。 开发环境create-react-app通过create-react-app工具快速创建React项目。 bash123456789# 安装create-react-appnpm install -g create-react-appcreate-react-app my-app# npx一次性调用create-react-appnpx create-react-app my-react-appcd my-react-appnpm start React框架 Next.js：是一个全栈的react框架 bash1npx create-next-app@latest 渲染React DOM和原生DOM是一一对应的。 列表渲染可以使用 map, filter 等方法来创建列表。 实例：创建列表并为每一个列表项绑定 key。 jsx123456789const list = [1, 2, 3, 4, 5]function List() { const listItems = list.map((number, index) =&gt; &lt;li key={number.toString()}&gt;{number}&lt;/li&gt;) return ( &lt;ul&gt;{ listItems }&lt;/ul&gt; )} 一般选择列表项中唯一的字段作为列表项的key。 如果列表项中没有唯一的字段，则可以选择 index 作为key。 JSXJSX基本语法JSX是React的模板语言。 JSX是JS的扩展。 JSX最外层只能有一个根节点，可以使用 &lt;Fragment&gt;&lt;/Fragment&gt; 包裹，也可以简写为 &lt;&gt;...&lt;/&gt;。 JSX中使用自定义属性需要再DOM中添加前缀 data-。 JSX中使用js变量或者表达式需要将其放在 {} 中。 JSX中不能使用 if...else 语法，但是可以使用三元运算符代替。 JSX中的 class 需要写成 className 。 JSX中的 for 要写成 htmlFor 。 JSX样式React中可以使用camelCase的格式来设置内联样式。 jsx123456789101112function Test() { const paragraphStyle = { color: 'red', fontSize: 14, } return ( &lt;&gt; &lt;p style={paragraphStyle}&gt;测试&lt;/p&gt; &lt;/&gt; )} JSX注释jsx12345678910111213function Test() { const paragraphStyle = { color: 'red', fontSize: 14, } return ( &lt;&gt; {/* 这是一个JSX注释 */} &lt;p style={paragraphStyle}&gt;测试&lt;/p&gt; &lt;/&gt; )} JSX处理数组JSX中可以插入数组，数组会被自动展开。 jsx123456789function List({list}) { const listHtml = list.map(item =&gt; &lt;li&gt;{ item }&lt;/li&gt;) return ( &lt;ul&gt; { listHtml } &lt;/ul&gt; )} 组件React的组件都需要首字母大写。 组件不要嵌套定义，永远将组件定义在顶层。 函数组件jsx123456789101112131415161718192021222324import React, { useState, useEffect } from 'react'// 接受propsfunction Hello(props) { useEffect(() =&gt; { // 组件已挂载 return () =&gt; { // 组件卸载前和更新前 } }, []) // 空数组表示只在组件挂载时执行一次 return ( &lt;h1&gt;Hello, { props.name }&lt;/h1&gt; )}// 解构propsfunction Hello({name}) { return ( &lt;h1&gt;Hello, { name }&lt;/h1&gt; )} useEffect允许组件在每次渲染后执行副作用，第二个参数设置为[]，可以确保组件只在挂载后执行一次。 类组件jsx12345678910111213141516171819202122import React from 'react'class Hello extends React.Component { // 构造方法不是必须的 constructor(props) { super(props) this.state = { name: props.name, } } componentDidMount() { // 组件已挂载 } // render方法是必须的 render() { return ( &lt;h1&gt;Hello, { this.state.name }&lt;/h1&gt; ) }} 函数组件和类组件的区别区别：函数组件开销小，类组件开销大（因为需要创建实例），对于有状态的组件可以采用函数组件+hooks的方式开发， 结论：只使用函数组件+hooks的方式，尽量不用类组件。 受控组件和非受控组件如果一个组件由props驱动则为受控组件。 如果一个组件由state驱动 则为非受控组件。 深层props传递Context可以用于向后代组件传递变量。 组件通信 父子组件通信使用props 兄弟组件通信发布订阅，redux 组件和后代组件通信发布订阅，redux，Context插件 状态管理stateReact把组件看成是一个状态机，用户通过与组件的交互来实现不同的状态，然后渲染不同的UI。 React中，只需要更新组件的 state，就可以重新渲染组件。 state用于保存渲染中的数据，类似一个快照，setState 的时候会触发页面的重新渲染。 注意：state的初始化是在构造函数中，不要直接更新state，更新state需要调用setState。 state实例： jsx123456789101112131415161718192021222324252627282930313233class Person extends React.Component { constructor(props) { super(props) this.state.name = props.name this.state.age = props.age } // 生命周期钩子函数：组件已挂载 componentDidMount() { // } // 生命周期钩子函数：组件即将卸载 componentWillUnmount() { // } // 类方法 updatePerson() { this.setState({ name: '', }) } render() { return ( &lt;&gt; &lt;p&gt;姓名：{ this.state.name}&lt;/p&gt; &lt;p&gt;年龄：{ this.state.age}&lt;/p&gt; &lt;/&gt; ) }} 状态只在该组件内可访问，其他组件不可访问。 React组件的数据自顶向下单向流动。 由于状态的更新是异步的，所以setState的时候需要接受一个函数来设置state。 jsx123this.setState((prevState, props) =&gt; ({ counter: prevState.counter + props.increment})) flushSync如果想要强制react刷新DOM以便在DOM更新后进行一些操作，可以使用 flushSync。 jsx12345678910import { useState, useRef } from 'react'import { flushSync } from 'react-dom'flushSync(() =&gt; { setTodos([ ...todos, newTodo]);})// 上面的todos在这里已经更新了listRef.current.lastChild.scrollIntoView() 组件传参propsReact父子组件之间可以通过 props 来传参（包括js的所有数据类型以及JSX，可以通过传递JSX来实现类似Vue的插槽的功能）。 props和state的区别是：props不可变，state可以变更。 props通过父组件更新props来更新。 state通过set来更新。 实例： jsx123456789101112131415// 方式1：function Hello(props) { return &lt;h1&gt;hello, { props.name }&lt;/h1&gt;}// 方式2：function Hello({ name }) { return &lt;h1&gt;hello, { name }&lt;/h1&gt;}// 调用组件function Home() { const myName = 'Mason' return &lt;Hello name={myName} /&gt;} props默认值如果组件的props需要默认值怎么设置呢？ 函数组件可以通过直接设置props中变量的默认值进行设置。 函数组件和类组件都可以通过设置 defaultProps 来设置默认值。 如果父组件没有传递子组件需要的变量或者传了undefined，则子组件会使用默认值。 一般使用第一种。 jsx123456789101112131415// 方法一function Person({ name = '', age = 0, gender = 'male' }) { //}// 方法二function Person({ name, age, gender }) { //}Person.defaultProps = { name: '', age: 0, gender: 'male',} props校验props的校验使用 prop-types 库。 安装prop-typesbash1npm i -S prop-types 使用prop-typesjsx123456789101112131415161718// 引入import PropTypes from 'prop-types'// 组件function Person( name, age ) { return ( &lt;&gt; &lt;p&gt;{ name }&lt;/p&gt; &lt;p&gt;{ age }&lt;/p&gt; &lt;/&gt; )}// 指定了props变量的类型和是否必须Person.propTypes = { name: PropTypes.string.isRequired, age: PropTypes.number.isRequired,} 内容分发 在父组件中调用子组件并将JSX传入内层，子组件中调用props.children获取JSX。 jsx123456789// ParentComponent.jsfunction ParentComponent(props) { return &lt;div&gt;{props.children}&lt;/div&gt;}// Usage&lt;ParentComponent&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/ParentComponent&gt; 父组件将一个函数（这个函数返回JSX）作为props传给子组件，子组件调用该函数获取到JSX。 jsx1234567// ParentComponent.jsfunction ParentComponent(props) { return &lt;div&gt;{props.render()}&lt;/div&gt;;}// Usage&lt;ParentComponent render={() =&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt;} /&gt; 事件React中的事件命名都采用的是camelCase的形式。 常用事件React中的常见事件： onClick：元素被点击时触发该事件。 onChange：输入框内容变化时触发该事件。 onSubmit：提交表单时触发该事件。 onMouseOver/onMouseOut：鼠标移入或移出时触发该事件。 onKeyDown/onKeyUp：键盘按下或弹起触发该事件。 onFocus/onBlur：获取焦点或失去焦点触发该事件。 onScroll：滚动时触发该事件。 onLoad/onError：图片加载成功或失败时触发该事件。 除了以上的常用事件之外还有很多其他事件。 事件分类 鼠标事件 onContextMenu onClick onDoubleClick onMouseDown onMouseUp onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver 键盘事件 onKeyPress onKeyDown onKeyUp 触摸事件 onTouchStart onTouchEnd onTouchMove onTouchCancel 拖拽事件 onDrop onDrag onDragStart onDragEnd onDragEnter onDragLeave onDragOver onDragExit 剪贴板事件 onCopy onCut onPaste 表单事件 onChange onInput onSubmit 焦点事件 onFocus onBlur UI事件 onScroll 窗口事件 onWheel 组成事件 onCompositionStart onCompositionEnd onCompositionUpdate 图片事件 onLoad onError 多媒体事件 onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting 实例绑定的事件后需要传入一个事件处理函数。 onClick事件实例： jsx123456789function submitHandler(e) { // 处理事件}function Button() { return ( &lt;button onClick={(e) =&gt; {submitHandler(e)}}&gt;提交&lt;/button&gt; )} 在类组件中需要注意 this 的指向问题，区别普通函数和箭头函数。 父组件通过props将事件处理函数传递给子组件处理可以直接将事件处理函数卸载组件中，也可以将事件处理函数作为 props 传递给子组件，在子组件中处理。 jsx12345678910111213141516// 子组件function Button({onClickHandler, buttonText}) { return ( &lt;button onClick={(e) =&gt; {onClickHandler(e)}}&gt;{ buttonText }&lt;/button&gt; )}// 父组件，调用子组件function Form() { function handler() { alert(123) } return ( &lt;Button onClickHandler={handler}&gt;&lt;/Button&gt; )} 事件传播如果父元素和子元素绑定了同一个事件，触发子元素的事件后会一层一层传播到外层元素并触发事件。 阻止事件冒泡方法：stopPropagation jsx123456789function Button() { function submit(e) { e.stopPropagation() } return ( &lt;button onClick={(e) =&gt; {submit(e)}}&gt;提交&lt;/button&gt; )} 阻止事件默认行为方法：preventDefault jsx12345678910function Link() { const url = 'https://www.google.com/' function clickLinkHandler(e) { e.preventDefault() } return ( &lt;a src={url} onClick={(e) =&gt; {clickLinkHandler(e)}}&gt;链接&lt;/a&gt; )} 捕获子元素事件可以在父元素上绑定 onClickCapture 事件来监听子元素的事件。 jsx1234567891011function Button() { function onClickCaptureHandler(e) { console.log(e) } return ( &lt;div onClickCapture={(e) =&gt; {onClickCaptureHandler(e)}}&gt; &lt;button onClick={e =&gt; e.stopPropagation()}&gt;提交&lt;/button&gt; &lt;/div&gt; )} 条件渲染使用if…else判断来返回不同的React DOMjsx1234567function Home(props) { if (props.isLogin) { return &lt;UserHome /&gt; } else { return &lt;GuestHome /&gt; }} jsx12345678910111213141516import React, { useState } from 'react'function Home(props) { const [isLogin, setIsLogin] = useState(false) function toggleLogin(e) { setIsLogin(!isLogin) } return ( &lt;div&gt; &lt;p&gt;{ toggleLogin ? '已登录' : '未登录' }&lt;/p&gt; &lt;button onClick={(e) =&gt; {toggleLogin(e)}}&gt;切换&lt;/button&gt; &lt;/div&gt; )} 使用&amp;&amp;运算符jsx123456789function MessageBox(props) { const msgList = props.messages return ( &lt;div&gt; { msgList.length &amp;&amp; &lt;p&gt;有{ msgList.length }条信息未读&lt;/p&gt; } &lt;/div&gt; )} JSX对于 &amp;&amp; 运算符的处理：如果左侧为 truthy，那么之间返回右侧的值。如果左侧为 falsy，那么直接返回false且不会被渲染。 三元运算符jsx1234567function Home(props) { return ( &lt;div&gt; { props.isLogin ? &lt;UserHome /&gt; : &lt;GuestHome /&gt; } &lt;/div&gt; )} 阻止组件被渲染让render函数返回null即可阻止组件被渲染。 组件API注意：以下的API中的callback都会在重新渲染后被调用。setState用法：setState(object nextState[, function callback]) setState会合并旧的state和新的state（以新的state为准）。 setState会重新渲染组件。 修改state只能通过setState。 replaceState用法：replaceState(object nextState[, function callback]) replaceState会替换state，只会保留新的state。 setProps用法：setProps(object nextProps[, function callback]) setProps会合并旧的props和新的props（以新的props为准）。 setProps会重新渲染组件。 replaceProps用法：replaceProps(object nextProps[, function callback]) replaceProps会替换props，只会保留新的props。 forceUpdate用法：forceUpdate([function callback]) forceUpdate会使组件重新渲染。 避免使用forceUpdate。 findDOMNode用法：DOMElement findDOMNode() 返回值：DOM元素DOMElement 避免使用findDOMNode 已废弃。 isMounted用法：bool isMounted() isMounted用于判断组件是否挂载。 已废弃。，现在采用组件生命周期钩子函数判断是否已经挂载。 jsx1234567componentDidMount() { this.mounted = true}componentWillUnmount() { this.mounted = false} 组件生命周期参考另一篇我的笔记。 Ajax组件内一般在 componentDidMount 中请求数据，获取到数据后存储在state中，再用setState重新渲染组件。 在组件卸载之前 componentWillUnmount 内取消未完成的请求。 实例： jsx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React, { Component } from 'react'import axios from 'axios'class MyComponent extends Component { constructor(props) { super(props) this.state = { data: null, error: null } this.source = axios.CancelToken.source() } componentDidMount() { this.fetchData() } componentWillUnmount() { // 取消未完成的请求 this.source.cancel('Component unmounted') } async fetchData() { try { const response = await axios.get('https://api.example.com/data', { cancelToken: this.source.token }) this.setState({ data: response.data }) } catch (error) { if (axios.isCancel(error)) { console.log('Request canceled', error.message) } else { this.setState({ error: error.message }) } } } render() { const { data, error } = this.state if (error) { return &lt;div&gt;Error: {error}&lt;/div&gt; } return ( &lt;div&gt; {data ? ( &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt; ) : ( &lt;div&gt;Loading...&lt;/div&gt; )} &lt;/div&gt; ) }}export default MyComponent 表单与事件input比如react处理input：value绑定state，输入时更新state。 组件内处理输入： jsx12345678910111213import { useState } from 'react'function Form() { const [inputValue, setInputValue] = useState('') function inputHandler(e) { setInputValue(e.target.value) } return ( &lt;input type=&quot;text&quot; value={inputValue} onChange={inputHandler} /&gt; )} 父组件处理输入：父组件通过props传递绑定的变量给子组件，父组件通过props传递处理函数给子组件。 jsx123456789101112131415import { useState } from 'react'function Input({ inputValue, inputHandler }) { return ( &lt;input type=&quot;text&quot; value={inputValue} onChange={inputHandler} /&gt; )}function Form() { const [v, setV] = useState('') return ( &lt;Input inputValue={v} inputHandler={setV} /&gt; )} selectjsx1234567891011121314151617181920212223import { useState } from 'react'function Form() { const [selectValue, setSelectValue] = useState('') function submitHandler(e) { e.preventDefault() } function changeSelectHandler(e) { setSelectValue(e.target.value) } return ( &lt;form onSubmit={submitHandler}&gt; &lt;select value={selectValue} onChange={changeSelectHandler}&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; )} 多个表单处理如果有多个input元素，可以给每一个元素添加一个name属性，并根据name进行处理。 jsx12345678910111213function Form() { function handleInputChange(e) { const name = event.target.name // 根据name处理 } return ( &lt;input name=&quot;name1&quot; type=&quot;text&quot; onChange={handleInputChange} /&gt; &lt;br /&gt; &lt;input name=&quot;name2&quot; type=&quot;text&quot; onChange={handleInputChange} /&gt; )} RefsReact提供了Refs（类似Vue的Refs），可以绑定到任何组件上，可以通过引用Refs拿到组件实例。 useRefjsx123456789101112131415161718192021222324import React, { useRef, useEffect } from 'react'const MyComponent = () =&gt; { const inputRef = useRef(null) useEffect(() =&gt; { // 组件挂载后或者更新前，将焦点设置到输入框 inputRef.current.focus() }, []) const handleClick = (e) =&gt; { // 在点击按钮时，获取输入框的值 alert(inputRef.current.value) } return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={inputRef} /&gt; &lt;button onClick={e =&gt; {handleClick(e)}}&gt;Get Value&lt;/button&gt; &lt;/div&gt; )}export default MyComponent 路由基本用法导航区链接： jsx123import Link from 'react-router-dom'&lt;Link to=&quot;/Home&quot;&gt;首页&lt;/Link&gt; 展示区Route： jsx12345// 引入需要展示的组件import Home from './components/Home'// 根据路由展示组件&lt;Route path=&quot;/Home&quot; component={Home} /&gt; 注意：普通组件存放在components下，路由组件存放在pages下。 SwitchSwitch组件用于在多个路由规则之间进行选择，并且在找到第一个匹配的路由后停止匹配。 定义路由：在Switch组件内部定义路由规则。确保将最通用的路由放在最后，以避免它被其他更具体的路由覆盖。 jsx1234567&lt;Router&gt; &lt;Switch&gt; &lt;Route path=&quot;/about&quot; component={About} /&gt; &lt;Route path=&quot;/contact&quot; component={Contact} /&gt; &lt;Route path=&quot;/&quot; component={Home} /&gt; &lt;/Switch&gt;&lt;/Router&gt; 在上面的示例中，如果URL匹配/about，则将渲染About组件。如果URL匹配/contact，则将渲染Contact组件。如果URL未匹配任何其他路由，则将渲染Home组件。 可选步骤：还可以在Switch组件的末尾添加一个没有path属性的Route组件，作为404页面。 jsx12345678&lt;Router&gt; &lt;Switch&gt; &lt;Route path=&quot;/about&quot; component={About} /&gt; &lt;Route path=&quot;/contact&quot; component={Contact} /&gt; &lt;Route path=&quot;/&quot; component={Home} /&gt; &lt;Route component={NotFound} /&gt; &lt;/Switch&gt;&lt;/Router&gt; Switch组件确保只有一个匹配的路由会被渲染。这对于避免多个路由同时匹配的情况非常有用，从而保证了预期的路由行为。 Redict可以使用Redict兜底，当所有路由都不匹配时跳转到Redict指定的路由。 jsx12345678&lt;Router&gt; &lt;Switch&gt; &lt;Route path=&quot;/about&quot; component={About} /&gt; &lt;Route path=&quot;/contact&quot; component={Contact} /&gt; &lt;Route path=&quot;/&quot; component={Home} /&gt; &lt;Redict to=&quot;/home&quot; /&gt; &lt;/Switch&gt;&lt;/Router&gt; 路由中携带参数jsx123456789101112131415161718// 路由链接中携带参数&lt;Link to=&quot;/detail/2832737&quot; /&gt;// 注册路由，定义路由中接受的参数&lt;Route path=&quot;/detail/:id&quot; component={Detail} /&gt;// 在路由对应组件内获取参数function Detail(props) { const { id } = props.match.params return ( &lt;div&gt; { id } &lt;/div&gt; )}export default Detail 路由中携带查询参数jsx12345678910111213141516171819// 路由链接中携带查询参数&lt;Link to=&quot;/detail?id=2832737&quot; /&gt;// 注册路由&lt;Route path=&quot;/detail&quot; component={Detail} /&gt;// 在路由对应组件内获取查询参数function Detail(props) { const { search } = props.location const searchQuery = qs.parse(search.slice(1)) return ( &lt;div&gt; { searchQuery } &lt;/div&gt; )}export default Detail 在组件内跳转路由调用push, replace, goBack, goForward, go方法。 完整实例 安装 bash1npm install -S react-router-dom 创建Home组件 jsx123456789101112// Home.jsimport React from 'react'const Home = () =&gt; { return ( &lt;div&gt; &lt;h2&gt;Welcome to Home&lt;/h2&gt; &lt;/div&gt; )}export default Home 定义路由 jsx1234567891011121314151617181920// App.jsimport React from 'react'import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'import Home from './Home'const App = () =&gt; { return ( &lt;Router&gt; &lt;div&gt; &lt;Switch&gt; {/* Define your routes here */} &lt;Route path=&quot;/home&quot; component={Home} /&gt; {/* Add more routes if needed */} &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; )}export default App 现在，当访问/home时将渲染 Home 组件。 HooksuseState用于组件状态管理。 如果需要依赖于老的状态来更新新的状态，则可以传入函数来作为setState的参数，其中函数的参数为老的值，返回值为新的值。 jsx1234567891011121314151617import { useState } from 'react'function Demo(props) { const [count, setCount] = useState(0) function incressCount() { // 直接传入值 setCount(count + 1) // 传入函数，函数的参数是原值，返回新的值 setCount(count =&gt; count + 1) } return ( &lt;button onClick={incressCount}&gt;加一&lt;/button&gt; )} 如果要用setState更新对象，则需要将新的state设置为旧的state的展开再加上更新的字段。可以使用immer库来简化代码。 useEffect用于模拟组件生命周期中的钩子函数，用于在组件渲染后执行副作用，接受一个回调函数（副作用）作为参数并在组件挂载、更新、卸载时执行，第二个参数是状态数组（state数组）。当状态数组发生变化时，react会重新渲染并执行副作用（回调函数）。 如果传入非空数组，则当数组中的这些state变化时会执行副作用。 如果传递一个空数组 []，则表示不检测任何state，只在组件挂载时执行一次副作用。 如果不传递第二个参数，则会监测所有的state，初始化的时候以及每个状态更新的时候都会执行副作用。 使用useEffect实现组件的三个钩子函数： componentDidMount jsx123456useEffect(() =&gt; { // componentDidMount 相关的操作 return () =&gt; { // componentWillUnmount 在组件卸载前或者重新渲染前执行相关的清理操作 }}, []) componentDidUpdate jsx123useEffect(() =&gt; { // componentDidUpdate 相关的操作}) componentWillUnmount jsx12345useEffect(() =&gt; { return () =&gt; { // componentWillUnmount 在组件卸载前或者重新渲染前执行相关的清理操作 }}, []) useContext使用useContext可以方便的在组件中访问全局的上下文数据。 创建上下文对象： jsx12345// 引入createContextimport React, { createContext } from 'react'// 创建上下文对象const MyContext = createContext() 向子组件提供上下文对象 jsx12345678910import ChildrenComponent from './ChildrenComponent'// 向子组件提供上下文对象function Demo(props) { const sharedData = 'shared data' &lt;MyContext.Provider value={sharedData}&gt; &lt;ChildrenComponent&gt;&lt;/ChildrenComponent&gt; &lt;MyContext.Provide/&gt;} 子组件中访问上下文对象 jsx123456789101112import React, { useContext } from 'react'function ChildrenComponent(props) { // 使用useContext获取上下文对象 const data = useContext(MyContext) return ( &lt;div&gt; { data } &lt;/div&gt; )} 当上下文数据发生变化时，使用了该数据的组件会自动重新渲染。 如果上下文发生了嵌套，则使用了上下文数据的组件会获取最接近的Provider提供的值。 如果上下文数据变化较大或者变化频繁，可以使用memo优化性能。 useReducer可以代替useState，用于在组件中使用复杂的状态逻辑，接受一个reducer函数和初始状态作为参数，并返新的状态和dispatch函数。 定义reducer函数 reducer函数接受当前状态和一个操作（action），并根据操作的类型来更新状态。返回更新后的状态和dispatch函数。 js1234567891011121314function reducer(state, action) { switch (action.type) { case 'INCREMENT': return { count: state.count + 1 } case 'DECREMENT': return { count: state.count - 1 } default: return state }} 定义初始状态 js 123const initialState = { count: 0,} 在组件中应用reducer jsx12345678910111213import React, { useReducer } from 'react'function Counter() { const [state, dispatch] = useReducer(reducer, initialState) return ( &lt;div&gt; {state.count} &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;increment&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;decrement&lt;/button&gt; &lt;/div&gt; )} 可以使用useImmerReducer简化代码。 useCallback可以用来优化函数的性能，接受一个回调函数和依赖项数组作为参数，并返回一个经过优化的回调函数。该函数只有在以来数组发生变化时才会重新创建。如果以来数字不变，useCallback会返回之前缓存的回调函数引用，避免了重新创建函数。 使用场景： 传递函数给子组件当将回调函数作为属性传递给子组件时，可以使用useCallback来缓存回调函数以避免不必要的子组件的重新渲染。 避免额外的开销如果回调函数依赖于组件的状态或者属性，但是不需要每次组件渲染时都创建新的函数实例，这个时候可以使用useCallback将相关依赖项添加到依赖数组中，可以避免不必要的重新创建函数实例的开销。 当useEffect或者useMemo的依赖项是回调函数当将回调函数作为useEffect或者useMemo的依赖项时，可以使用useCallback来缓存回调函数，可以确保依赖项变化时回调函数能更新。 避免重复创建回调函数如果需要频繁创建回调函数，使用useCallback可以减少不必要的创建开销。 useCallback实例： jsx123456789101112import React, { useCallback } from 'react'function Demo({ handler }) { // 使用useCallback缓存回调函数 const cb = useCallback(() =&gt; { // 自己的逻辑 // 执行handler handler() }, [handler])} 这里，Demo组件接收了一个handler函数，使用useCallback缓存了handler函数。当handler发生变化时cb才会被重新创建。 如果不使用useCallback，那么每次Demo组件渲染时cb都会被重新创建。 useMemo用于组件渲染过程中进行性能优化，避免不必要的计算和重复渲染。 useMemo 接受两个参数：一个计算函数和依赖数组，组件渲染时会执行计算函数并将计算结果缓存起来，当依赖数组发生变化时会重新执行计算函数。这样就可以避免每次渲染时重复计算。 使用场景： 缓存计算结果 避免不必要的重新渲染如果一个组件依赖一个状态或者属性，但是这个状态或者属性的变化不会影响组件的渲染时，可以使用useMemo缓存结果避免重新渲染。 优化子组件渲染当将一个计算结果作为属性传给子组件时，可以使用useMemo缓存计算结果避免每次父组件渲染时都重新计算并传给子组件触发子组件的重新渲染。 比较操作当需要进行比较操作时，比如数组或者对象，可以使用useMemo缓存比较结果，避免每次渲染时重新比较。 useMemo实例： jsx12345678910111213141516171819202122232425262728import React, { useMemo, useState } from 'react'function ExpensiveComponent() { // 计算函数 function calc() { return Math.random() } // 使用useMemo缓存计算结果 const expensiveValue = useMemo(() =&gt; calc(), []) return ( &lt;div&gt; { expensiveValue } &lt;/div&gt; )}function App() { const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;increment&lt;/button&gt; &lt;ExpensiveComponent /&gt; &lt;/div&gt; )} 这里为了避免每次渲染时都重新计算expensiveValue，使用了useMemo来缓存计算结果。 useMemo第二个参数传入空数组，确保了只在组件第一次渲染时执行一次计算函数，并将计算结果缓存起来。当父组件中的count变化时，ExpensiveComponent组件重新渲染但是不会重新计算expensiveValue。 useRef当我们希望组件记住某些数据，但不想让这些数据触发新的渲染时，可以使用ref，设置ref的值不会引发重新渲染。 可以使用ref来存储计数器id、DOM以及其他不影响组件渲染的数据。 比如ref可以存储组件实例。 jsx123456789101112131415import { useRef } from 'react'function Demo() { const myRef = useRef() function getRef() { console.log('myRef', myRef) } return ( &lt;button ref={myRef} onClick={getRef}&gt;按钮&lt;/button&gt; )}export default Demo 对于自定义组件，如果需要在自定义组件中绑定ref，需要将自定义组件暴露出来（组件函数使用forwardRef包裹）。 jsx12345678910111213141516171819202122import { forwardRef, useRef } from 'react'const MyInput = forwardRef((props, ref) =&gt; { return &lt;input {...props} ref={ref} /&gt;})export default function Form() { const inputRef = useRef(null) function handleClick() { inputRef.current.focus() } return ( &lt;&gt; &lt;MyInput ref={inputRef} /&gt; &lt;button onClick={handleClick}&gt; 聚焦输入框 &lt;/button&gt; &lt;/&gt; )} 以上的方式会暴露整个MyInput组件。 如果只想要暴露部分api可以使用useImperativeHandle实现。 jsx123456789101112131415161718192021222324252627282930313233import { useRef, forwardRef, useImperativeHandle,} from 'react'const MyInput = forwardRef((props, ref) =&gt; { const realInputRef = useRef(null) useImperativeHandle(ref, () =&gt; ({ // 只暴露focus，没有别的 focus() { realInputRef.current.focus(); }, })) return &lt;input {...props} ref={realInputRef} /&gt;})export default function Form() { const inputRef = useRef(null) function handleClick() { inputRef.current.focus() } return ( &lt;&gt; &lt;MyInput ref={inputRef} /&gt; &lt;button onClick={handleClick}&gt; 聚焦输入框 &lt;/button&gt; &lt;/&gt; )} useLayoutEffect和useEffect类似，但是它在DOM更新后，在浏览器重排重绘之前触发，可以在DOM更新后立刻执行副作用。 一般用于需要在DOM更新之后获取到最新的布局和DOM的场景。 实例： jsx123456789101112131415import React, { useLayoutEffect, useRef } from 'react'function Demo() { const myRef = useRef() useLayoutEffect(() =&gt; { // DOM已更新，进行一些获取、操作最新DOM的操作 const {width, height} = myRef.current.getBoundingClientRect() }, []) return ( &lt;div ref={myRef}&gt;demo&lt;/div&gt; )} 需要注意的是，useLayoutEffect会阻塞浏览器渲染，因此不要在useLayoutEffect中做非常耗时的操作，仅用于获取新布局或者DOM。 ReduxRedux是react状态管理的库，可以集中管理多个组件共享的状态。 安装bash1npm install -S redux react-redux 使用 创建redux store redux store包含了整个state，在使用之前需要先创建一个store，通常在根组件中创建并配置redux store。 定义actions actions是描述发生了什么的普通的js对象，需要定义action creators来创建actions。 定义reducers reducers指定了应用状态如何响应actions并更新状态的逻辑，每个reducer都负责管理全局state树中的一部分数据。 使用react-redux链接react组件和redux store react-redux库提供了一些API来连接react组件和redux store。可以通过&lt;Provider&gt;组件提供store并使用connect函数来连接react组件。 实例App.js： jsx1234567891011121314151617181920// App.jsimport React from 'react'import { Provider } from 'react-redux'import { createStore } from 'redux'import rootReducer from './reducers'import MyComponent from './MyComponent'// 创建redux storeconst store = createStore(rootReducer)const App = () =&gt; { return ( // 通过Provider组件向后代组件提供state &lt;Provider store={store}&gt; &lt;MyComponent /&gt; &lt;/Provider&gt; )}export default App MyComponent.js： jsx123456789101112131415161718192021222324// MyComponent.jsimport React from 'react'import { connect } from 'react-redux'import { incrementCounter } from './actions'const MyComponent = ({ counter, increment }) =&gt; { return ( &lt;div&gt; &lt;p&gt;Counter: {counter}&lt;/p&gt; &lt;button onClick={e =&gt; {increment(e)}}&gt;Increment&lt;/button&gt; &lt;/div&gt; )}const mapStateToProps = state =&gt; ({ counter: state.counter})const mapDispatchToProps = dispatch =&gt; ({ increment: () =&gt; dispatch(incrementCounter())})// 使connect连接到redux storeexport default connect(mapStateToProps, mapDispatchToProps)(MyComponent) actions.js: jsx123456// actions.jsexport const INCREMENT_COUNTER = 'INCREMENT_COUNTER'export const incrementCounter = () =&gt; ({ type: INCREMENT_COUNTER}) reducers.js： jsx123456789101112131415161718// reducers.jsimport { combineReducers } from 'redux'import { INCREMENT_COUNTER } from './actions'const counterReducer = (state = 0, action) =&gt; { switch (action.type) { case INCREMENT_COUNTER: return state + 1 default: return state }}const rootReducer = combineReducers({ counter: counterReducer})export default rootReducer 性能优化组件性能优化使用PureComponent优化组件渲染，PureComponent重写了shouldComponentUpdate，只有state或者props发生变化时才会返回true（浅比较）。 参考 https://www.runoob.com/react/react-tutorial.html https://zh-hans.react.dev/learn https://blog.csdn.net/NAMECZ/article/details/122854282 https://blog.csdn.net/qq_42696432/article/details/133943462 https://blog.csdn.net/study_way/article/details/131752538 https://www.jb51.net/article/272222.htm","link":"/2021/08/06/React%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"title":"React组件的生命周期","text":"本文基于React17版本开始的新的生命周期。 React组件的生命周期分为三个阶段：Mounting -&gt; Updating -&gt; Unmounting Mounting 调用组件的构造函数constructor()。 调用getDerivedStateFromProps()，在Mounting和Updating阶段都会被调用。 调用render()函数，组件初始化一定会调用的只有render函数。 组件挂载完毕。 触发componentDidMount()钩子函数。 Updating组件的 props 或者 state 发生变化，组件就会更新。 调用getDerivedStateFromProps()，根据shouldComponentUpdate()的返回值，判断组件的输出是否受当前state或props更改的影响。 调用shouldComponentUpdate()。 调用render()函数，唯一必须会被调用的函数。 调用getSnapshotBeforeUpdate()，在最近一次渲染输出之前调用。 组件更新完毕。 调用componentDidUpdate()，在组件更新后会被立即调用。 Unmounting 调用componentWillUnmount()钩子函数，在组件卸载及销毁之前直接调用。 组件被卸载或者销毁。 可以看出react组件生命周期与vue的组件生命周期有区别但是不大。","link":"/2022/06/17/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"RSA算法原理","text":"在量子计算机问世之前再复习一下RSA算法。 RSA算法是一种非对称加密算法，所谓非对称加密是相对于对称加密而言的。 下面了解一下对称加密、非对称加密以及RSA算法。 对称加密对称加密算法就是A想要发送一段明文msg给B，但是明文发送会被截获不安全怎么办？A就对明文进行了加密，这个加密算法我将它称之为$f()$，故而明文就被加密为$f(msg)$。B收到密文后使用$f()$的逆算法对$f(msg)$解密出明文。这样的加密算法$f()$就称之为对称加密。 对称加密的缺点是：A必须事先将加密算法$f()$告诉B，这个过程就可能被窃听导致加密算法$f()$泄漏，即使是加密算法没有泄漏，还有可以通过分析密文规律从而破解出明文的。 现在的量子保密通信可以实现密钥分发的保密性，可是量子通信技术还远远没有成熟，目前安全的方法还是非对称加密。 非对称加密B生成一把公钥和一把私钥，公钥可以公布，私钥要保存好。A需要获取B的公钥，A向B发送信息的时候就使用B提供的公钥加密。B收到密文后使用私钥对其进行解密且不能使用公钥而只能使用B所持有的密钥对密文解密，这就是非对称加密。即使别人窃听了密文和公钥也是无法得知明文。 这样只要B的私钥没有泄露，那么信息就是安全的。当然除非使用大算力暴力破解，不过这样做cost是极高的。 RSA算法就是一种典型的非对称加密算法，它的使用范围非常广并且非常安全。 至于为什么叫RSA？因为算法的三个发明者的名字首字母是这个。 RSA算法的密钥长度越长越难破解。 目前普遍使用的是RSA1024和RSA2048。 RSA算法欧拉函数欧拉函数基于一个数学概念“互质”，所谓互质就是两个数如果没有除了1之外的公约数那就称这两个数互质。 对于给定的整数n，有多少个从1到n的数和n互质(包含1)，这就是欧拉函数：$$\\Phi(n)$$比如：$\\Phi(1)=1$,$\\Phi(5)=4$,$\\Phi(8)=4$ 既然用到了欧拉函数，为了防止混淆，再回顾一下欧拉公式和欧拉方程是什么东西。 欧拉公式 欧拉方程 算法 找两个质数p和q n = p * q 构造欧拉函数：$\\Phi(n)=(p-1)(q-1)$ 找一个整数公钥e，满足1 &lt; e &lt; $\\Phi(n)$，并且e要满足与$\\Phi(n)$互质。 找一个私钥d，满足条件ed除以$\\Phi(n)$后余数为1 加密：$m^{e}/n$求出余数c，c就是加密后的密文。（m为明文） 解密：现在有密文c还有私钥d，$c^d/n$求出余数，这个求得的余数就是明文m。 安全性发送信息：公钥e，数字n，密文c 解密信息需要：私钥d，数字n，密文c 通过公钥e算出私钥d是否可行？ 需要知道$\\Phi(n)$,从而又转化为求p和q，n=pq，质因数分解，大数（比如1024位的二进制数或者2048位的二进制数）的质因数分解非常困难。 故而，我们分析出了RSA算法安全的原因，那就是大数的质因数分解非常困难！","link":"/2020/03/27/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"},{"title":"Tex&#x2F;LaTex公式书写","text":"学习一下Tex/LaTex语法 参考1. 简书：markdown中公式编辑教程","link":"/2020/03/21/Tex-LaTex%E5%85%AC%E5%BC%8F%E4%B9%A6%E5%86%99/"},{"title":"Vue2和Vue3数据绑定实现原理的变化","text":"Vue数据绑定的实现原理从Vue2的 Object.defineProperty() 对象属性劫持改为了Vue3的 Proxy 数据代理。 Object.defineProperty()Object.defineProperty() 可以对于对象的已有属性进行监听、劫持、修改。","link":"/2022/09/14/Vue2%E5%92%8CVue3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E5%8F%98%E5%8C%96/"},{"title":"Vue teleport to","text":"官网文档写的过于啰嗦。 一句话总结就是： teleport 组件用于包裹html代码或者组件，配合 to 可以指定包裹的内容被渲染到哪个标签之下（使用类似jQuery的选择器指定标签，使用id，class等选择器，不要使用标签选择器）。 teleport, to如果在父组件parent中使用了teleport包裹子组件child，那么在代码逻辑上child依然是parent的子组件，但是可以指定teleport的to属性为parent之外的位置，这样就改变了child渲染的位置。 在同一个目标上使用teleport，多个teleport可以将内容追加挂载到同一个标签之下 123456789101112&lt;teleport to=\"#modals\"&gt; &lt;div&gt;A&lt;/div&gt;&lt;/teleport&gt;&lt;teleport to=\"#modals\"&gt; &lt;div&gt;B&lt;/div&gt;&lt;/teleport&gt;&lt;!-- result--&gt;&lt;div id=\"modals\"&gt; &lt;div&gt;A&lt;/div&gt; &lt;div&gt;B&lt;/div&gt;&lt;/div&gt; 禁用teleport，给teleport添加 disabled 属性，值为Boolean。 ref docs: https://v3.cn.vuejs.org/guide/teleport.html API: https://v3.cn.vuejs.org/api/built-in-components.html#teleport","link":"/2022/06/05/Vue-teleport-to/"},{"title":"Vue.js学习笔记（实践篇）","text":"记录一下学习vue的过程。 vue核心数据驱动传统jquery： 1234567&lt;div&gt; &lt;span class=\"txt\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; $('.txt').text('填充span的内容');&lt;/script&gt; vue数据驱动：一旦改变data里txt变量的内容，则span里面绑定的txt也会跟着改变。 注意：data属性的值不可以被页面修改。 注意：在组件里面使用变量需要这样写： 123456789&lt;script&gt; export default { data: function() { return { msg: '填充span的内容' } } }&lt;/script&gt; 组件里面不能直接这样写，页面里面可以直接这样写： 1234567&lt;script&gt; export default { data: { msg: '填充span的内容' } }&lt;/script&gt; 下面是vue的写法： 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;span&gt;{{ txt }}&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function() { return { msg: '填充span的内容' } } }&lt;/script&gt; 现在用js的 setTimeout() 来改变span里面txt的内容，这样span里面的txt就会在组件加载完毕后的1000ms后改变msg的值。 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;span&gt;{{ msg }}&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function() { return { msg: '填充span的内容' } }, mounted: function() { var self = this; setTimeout(function() { self.msg = '改变了的数据' }, 1000) } }&lt;/script&gt; props属性，可以暴露出去让页面异化组件的文案。 指令一般形式 v-xxx v-text=&quot;msg&quot; 和 作用一样 v-html 用于更新元素的 innerHTML V-if ：根据表达式真假 渲染元素。 v-show ：根据表达式真假切换元素的display。 组件如何在父组件里面引入子组件？ 编辑父组件： 123456789101112131415161718&lt;template&gt; &lt;div id=\"parent\"&gt; &lt;!-- 在父组件中调用子组件 --&gt; &lt;son&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 首先import子组件，这里可以给子组件一个变量，我这里给的变量是son,引入的组件路径名可以不加.vue扩展名 import son from '@/components/son' // 再在components中声明使用子组件 export default { name: 'parent', components: { son } }&lt;/script&gt; 方法vue中定义方法： 123456789&lt;script&gt; export default { methods: { doSth: function() { alert('done'); } } }&lt;/script&gt; 使用方法： v-on:eventName 用于绑定事件，这里绑定click事件 12345678910111213&lt;button v-on:click=\"doSth\"&gt;{{ txt }}&lt;/button&gt;//缩写为&lt;button @click=\"doSth\"&gt;{{ txt }}&lt;/button&gt;&lt;script&gt; export default { methods: { doSth: function() { alert(txt); } } }&lt;/script&gt; 生命周期 beforeCreate：组件创建之前 created：组件创建完毕 beforeMount：组件挂载之前 mounted：组件挂载完毕 beforeDestory：组件销毁之前 destroyed：组件销毁后 vue中还有一些认为出发的回调函数： deactivated：组件未使用状态 activated：组件使用状态（只有在被keep-alive标签包含的时候才会activated和deactivated） beforeUpdate：组件变动之前 updated：组件变动之后（全局监听） watch可以监听data里面的数据。 watch的用法： 12345678910111213&lt;script&gt; export default { watch: { 'info.name': function(newV, oldV) { console.log(newV); console.log(oldV); }, sex: function(newV, oldV) { console.log(newV); } } }&lt;/script&gt; vue里面不能直接监听一个对象，只能监听对象的值或者变量。 下面的例子：watch监听 info.name ，一旦发生改变就执行后面的函数。 12345678910&lt;script&gt; export default { watch: { 'info.name': function(newV, oldV) { console.log(newV); console.log(oldV); } } }&lt;/script&gt; 上面的函数在 info.name 发生改变后就执行，紧接着 updated() 才执行。 如何监听一个对象，下面是监听一个info对象的写法： 12345678910&lt;script&gt; export default { watch: { info: { handler: function(n, o) {}, deep: true } } }&lt;/script&gt; computedv-modellazy懒加载 v-model.lazy=&quot;modelValue&quot; trim去掉空白 v-model可以做到双向绑定，下面是例子： 123456789101112&lt;div id=\"demo\"&gt; &lt;input v-model=\"msg\"&gt; &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; export default { data: { msg: '信息' } }&lt;/script&gt; 安装 方法一：在html中以script标签引入 1&lt;script src=\"https://lib.baomitu.com/vue/2.6.10/vue.js\"&gt;&lt;/script&gt; vue-cli方式引入（通常用这种方式引入） 安装cnpm 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 安装vue-cli 1$ cnpm install -g vue-cli 初始化初始化vue项目webpack参数表示用webpack打包，它可以把.vue打包成css html js文件。 1$ vue init webpack project_name 选项配置如下： 等待安装完毕： 123$ cd test$ cnpm install$ npm run dev 开发1$ npm run dev 开发过程中发现vue的视图有 padding: 8px 的样式。下面清除vue的默认样式。 清除vue默认样式App.vue文件style标签中添加 1234body { padding: 0; margin: 0;} 或者在main.js文件中引入一个reset.css文件: 1import '@/css/reset.css' reset.css： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,menu,nav,output,ruby,section,summary,time,mark,audio,video,input { margin: 0; padding: 0; border: 0; font-weight: normal; vertical-align: baseline;}article,aside,details,figcaption,figure,footer,header,menu,nav,section { display: block;}body { line-height: 1; font-family: \"Microsoft YaHei\"; font-size: 16px;}blockquote,q { quotes: none;}blockquote:before,blockquote:after,q:before,q:after { content: none;}table { border-collapse: collapse; border-spacing: 0;}a { color: #7e8c8d; text-decoration: none; -webkit-backface-visibility: hidden;}li { list-style: none;}::-webkit-scrollbar { width: 5px; height: 5px;}::-webkit-scrollbar-track-piece { background-color: rgba(0, 0, 0, 0.2); -webkit-border-radius: 6px;}::-webkit-scrollbar-thumb:vertical { height: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;}::-webkit-scrollbar-thumb:horizontal { width: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;}html,body { width: 100%;}body { -webkit-text-size-adjust: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);} 以上reset.css代码经过了压缩，用的时候在项目目录 @/css 下新建一个reset.css文件，将上面代码复制进去，再再main.js中import即可。 编译1$ npm run build 最终代码在 dist 目录中 目录init 完毕后项目目录下有这些文件： Package.json 保存依赖信息 config 保存项目初始化配置 build 保存webpack初始化配置 需要写的代码都在 src 中 src/main.js 是入口js文件 dist 是最终编译生成的代码 main.js文件1234567891011121314151617181920212223242526272829// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.// 引入vue，在vue中引入文件直接用importimport Vue from 'vue'// 引入App.vue文件，这个文件是一个视图容器，然后我们在视图中装载各种组件或者页面import App from './App'// 引入路由配置import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */// 新建vue实例。new Vue({ // 绑定#app元素，意思是将视图放在#app元素中 el: '#app', router, // 引入的组件 components: { App }, // 文件内容将以&lt;App/&gt;这样的标签写进#app中 // template里面的内容将被写进页面 template: '&lt;App/&gt;'})// 以上一段代码的意思是将App.vue放到#app中，然后用&lt;App/&gt;代指#app App.vue文件在vue中这种文件叫做 组件 ，单页面的意思是结构、样式、逻辑都写在一个 .vue 文件中，当我们引入这个文件后就相当于引入了对应的结构、样式和js，这就是前端组件化。 1234567891011121314151617181920212223&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'App' }&lt;/script&gt;&lt;style&gt; #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; }&lt;/style&gt; 对于 .vue 文件，webpack在编译的时候将 .vue 文件中的html、css、js分别抽离出来组成一个单独的文件。 .vue 组件文件组成： &lt;template&gt; 标签， &lt;script&gt; 标签以及 &lt;style&gt; 标签。这里注意在 .vue 文件的最后面总是要留一个空行。 &lt;template&gt; 标签下仅能有一个根标签， vue依靠锚点达到不需要刷新页面就切换内容的效果。 &lt;router-view&gt; 标签的作用是在页面中放入一个路由器视图容器，当我们访问 http://localhost:8080/#/about/ 的时候会将about的内容放进去，访问 http://localhost:8080/#/recruit 的时候会将recruit的内容放进去 也就是说除了 &lt;router-view&gt; 中的视图， App.vue 文件中的其他部分都是公用的，无所访问什么路由都会有这部分。 路由文件router/index.js1234567891011121314151617import Vue from 'vue'// 引入路由插件vue-routerimport Router from 'vue-router'// 引入页面组件import HelloWorld from '@/components/HelloWorld'// 声明使用路由Vue.use(Router)// 注册路由器并配置路由，给不同的页面或者组件分配不同的路径export default new Router({ routes: [{ path: '/', name: 'HelloWorld', component: HelloWorld }]}) 比如配置 http://localhost:8080/#/about/me ，其实只需要给/about加一个子路由既可。 1234567891011121314151617181920export default new Router({ routes: [{ path: '/', name: 'HelloWorld', component: HelloWorld }, { path: '/about', name: 'about', component: About, children: [{ path: '/', component: page1 }, { path: '/me', component: Me }] } ]}) 然后在 about.vue 中放路由既可 1234&lt;template&gt; &lt;div&gt;共用部分&lt;/div&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt; 页面一般放在 pages 或者 views 目录下，组件放在 components 目录下，但其实页面和组件都是组件。 如果我想让用户访问我配置之外的路由的时候跳转到根目录该怎么办？使用 path: /* 12345678910111213141516171819202122232425export default new Router({ routes: [{ path: '/', name: 'HelloWorld', component: HelloWorld }, { path: '/about', name: 'about', component: About, children: [{ path: '/', component: page1 }, { path: '/me', component: Me }] }, { path: '/*', name: 'HelloWorld', component: HelloWorld } ]}) &lt;router-link&gt; 标签是vue提供的用于路由跳转的： 12345&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-link :to=\"{name: HelloWorld}\"&gt;前往helloworld&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 也可以使用传统a标签写： 1&lt;a href=\"#/\"&gt;前往helloworld&lt;/a&gt; 小节 .vue 文件中有共用部分也有根据路径选择性装载的部分。这部分的vue文件写完后再在 router/index.js 中配置好了路由，然后在公共部分后面加上 &lt;router-view&gt;&lt;/router-view&gt; 既可。 组件将经常用的代码比如按钮、导航等等封装成组件以方便后续使用。调用只需要写 &lt;组件名&gt;&lt;/组件名&gt; 。 一个页面可以由很多组件组成。 开发组件库我们在日常开发中将一个按钮、导航、列表等元素封装成组件以后以后使用。调用只需要写上 &lt;component-name&gt;&lt;/component-name&gt; 即可。 现在要开发一个页面： 一个首页，包含三个字页面：按钮页面，列表页面，导航页面。 页面都放在 @/pages 中，组件都放在 @/components 中。 @/pages 中包含首页和三个子页面， @/components 中包含三个组件。 先进行路由配置：先import页面组件，再配置路由。 12345678910111213141516171819202122232425262728293031323334import Vue from 'vue'import Router from 'vue-router'// 引入首页和三个字页面import index from '@/pages/index.vue'import pageQuiButton from '@/pages/pageQuiButton.vue'import pageQuiList from '@/pages/pageQuiList.vue'import pageQuiNav from '@/pages/pageQuiNav.vue'Vue.use(Router)export default new Router({ routes: [{ path: '/', name: 'index', component: index }, { path: '/btn', name: 'btn', component: pageQuiButton }, { path: '/list', name: 'list', component: pageQuiList }, { path: '/nav', name: 'nav', component: pageQuiNav } ]}) 以上路由配置的意思是： 首页： http://localhost:8080/#/ 按钮页面： http://localhost:8080/#/btn 列表页面： http://localhost:8080/#/list 导航页面： http://localhost:8080/#/nav 注意根页面是： #/ ，比如： 123&lt;template&gt; &lt;a href=\"#/\"&gt;链接&lt;/a&gt;&lt;/template&gt; 再来看 App.vue 里面 123456&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1 class=\"page-title\"&gt;&lt;a href=\"#/\"&gt;开发组件库&lt;/a&gt;&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 上面的h1是一个公共元素，无论进入页面都有它。 tips：除了直接在 style 标签里写样式之外，还可以引入css文件，只要在 &lt;style&gt; 中添加 @import 'url'; ，比如： 123&lt;style scoped&gt; @import '@/assets/css/common.css';&lt;/style&gt; scoped 关键字代表样式是私有的。 下面写首页 index.vue ：这里用 @import 引入样式 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=\"mod-module mod-parallel\"&gt; &lt;div class=\"img-list type-full\"&gt; &lt;div class=\"img-box\"&gt; &lt;p class=\"img-item\"&gt; &lt;a class=\"page-link\" href=\"#/btn\"&gt;按钮&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=\"img-box\"&gt; &lt;p class=\"img-item\"&gt; &lt;a class=\"page-link\" href=\"#/list\"&gt;列表&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=\"img-box\"&gt; &lt;p class=\"img-item\"&gt; &lt;a class=\"page-link\" href=\"#/nav\"&gt;导航&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; @import '@/assets/css/index.css'&lt;/style&gt; &lt;template&gt; 中的内容和平时写html差不多，不过 &lt;template&gt; 标签下只能有一个根元素。 特别注意下a标签 href 属性的书写： 1&lt;a class=&quot;page-link&quot; href=&quot;#/btn&quot;&gt;按钮&lt;/a&gt; vue运行时将 &lt;template&gt; 中的内容都注入到App.vue页面的 router-view 中，从而可以实现无刷新路由跳转。 quiButton.vue组件下面编写按钮组件quiButton.vue 1234567891011121314151617181920&lt;template&gt; &lt;button class=\"qui-btn\"&gt; &lt;span&gt;{{ msg }}&lt;/span&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default { data: function() { return { msg: '下载' } } }&lt;/script&gt;&lt;style scoped&gt; @import '@/assets/css/reset.css'; @import '@/assets/css/qui-btn.css'&lt;/style&gt; 如果这不是组件的话，正常data的写法可以直接写一个对象 data: { msg: '下载' } , 但是由于组件会被在多个地方引用，故而这里用function来每次返回一个对象实例。 如果我希望每次调用按钮组件按钮里面的内容都不相同（如下），该怎么办。 1&lt;qui-btn msg=\"确定\" class=\"small\"&gt;&lt;/qui-btn&gt; 只需要将属性写在props里面。 123456789&lt;script&gt; export default { props: { msg: { default: '下载' } } }&lt;/script&gt; 把属性写在props里面就可以暴露给其他页面调用。props是专门用来暴露组件的属性接口的。这里定义了msg的默认值 下载 ，其他页面调用只需要： 1&lt;qui-btn msg=\"确定\"&gt;&lt;/qui-btn&gt; vue如何绑定事件？使用methods属性： 1234567891011121314151617181920&lt;template&gt; &lt;button class=\"qui-btn\" v-on:click=\"btnClickEvent\"&gt; &lt;span&gt;{{msg}}&lt;/span&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default { props: { msg: { default: '下载' } }, methods: { //绑定事件的关键代码 btnClickEvent: function() { alert(this.msg); } } }&lt;/script&gt; 写完事件函数后，给按钮绑定事件： 12&lt;button v-on:click=\"btnClickEvent\"&gt;&lt;/button&gt; 或者： 12&lt;button @click=\"btnClickEvent\"&gt;&lt;/button&gt; 现在我们已经做好了按钮组件了，来使用pageQuiButton.vue组件。 12345678910111213141516//pageQuiButton.vue&lt;template&gt; &lt;div id=\"pageQuiButton\"&gt; &lt;!--使用--&gt; &lt;qui-btn msg=\"确定\" class=\"small\"&gt;&lt;/qui-btn&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import quiBtn from '../components/quiButton.vue' /*引用*/ export default { name: 'pageQuiButton', components: { 'qui-btn': quiBtn /*注册自定义标签*/ } }&lt;/script&gt; 首先，script里面import了按钮组件复制给变量quiBtn，在components中给他自定义标签名，用msg给组件传值。 那么按钮的点击事件怎样异化呢： 1&lt;qui-btn v-on:btnClickEvent=\"doSth\" msg=\"我可以点击\"&gt;&lt;/qui-btn&gt; 上面的代码引用组件时注册了一个时间，btnClickEvent事件时组按钮组件中定义的，这里给这个btnClickEvent一个新的方法doSth。 同时，在script中声明这个自定义方法： 123456789101112131415//pageQuiButton.vue&lt;script&gt; import quiBtn from '@/components/quiButton.vue' export default { name: 'pageQuiButton', components: { 'qui-btn': quiBtn }, methods: { doSth: function() { alert('你点击了组件的click:btnClickEvent'); } } }&lt;/script&gt; 以上的方法叫做监听，组件引用房监听子组件的内置方法，同时在子组件中需要出发这个事件，一下时在子组件中的关键代码： 1234567891011121314151617//quiButton.vue//子组件中的代码&lt;script&gt; export default { props: { msg: { default: \"下载\" } }, methods: { btnClickEvent: function() { alert(\"先弹出默认的文案\"); this.$emit(\"btnClickEvent\"); //关键代码父组件触发自定义事件 } } };&lt;/script&gt; 父组件监听，子组件触发。 这样引用方（父组件）就可以给不同子组件调用不同的事件处理了。 123456789101112&lt;qui-btn v-on:btnClickEvent=\"doSth1\" msg=\"确定\"&gt;&lt;/qui-btn&gt;&lt;qui-btn v-on:btnClickEvent=\"doSth2\" msg=\"取消\"&gt;&lt;/qui-btn&gt;&lt;script&gt; methods: { doSth1: function() { alert('111'); }, doSth2: function() { alert('222'); } }&lt;/script&gt; 怎样给按钮加上图片：slot插槽 给按钮组件加上一段结构 12345678//quiButton.vue&lt;template&gt; &lt;button class=\"qui-btn\" v-on:click=\"btnClickEvent\"&gt; &lt;slot name=\"icon\"&gt;&lt;/slot&gt; &lt;!--重点在这里--&gt; &lt;span&gt;{{msg}}&lt;/span&gt; &lt;/button&gt;&lt;/template&gt; 引用： 123&lt;qui-btn msg=\"下载\" class=\"with-icon\"&gt; &lt;img slot=\"icon\" class=\"ico\" src=\"xxx.png\" /&gt;&lt;/qui-btn&gt; 渲染的时候，会将img整个替换掉组件中的对应name的slot标签。 quiNav.vue组件如下： 功能需求：点击导航tab可以给当前 tab加上一个active类，同时切换底部的黄色滑条，并且输出当前tab文案，同时支持自定义事件。 还得暴露一个属性支持导航tab个数。 关键代码： 1234567891011121314151617181920212223242526272829303132333435//quiNav.vue&lt;template&gt; &lt;div class=\"qui-nav nav-type-1\"&gt; &lt;a v-for=\"(item, index) in items\"&gt; &lt;!--关键代码v-for--&gt; &lt;span class=\"nav-txt\"&gt;{{item.text}}&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function() { return { items: [{ text: '首页', active: true }, { text: '列表', active: false; }, { text: '关于', active: false }, { text: '招聘', active: false } ] } } }&lt;/script&gt; 以上代码关键在于对a标签的 v-for 指令的使用，items是data里面定义的对象。 v-for=&quot;(item, index) in items&quot; 暴露了item和index两个接口，这是vue提供的，分别代表了items中每一项和该项的下表，接着就可以在标签中使用绑定 了。 动态添加class：首先每一个tab都有默认的class，点击tab后，为当前tab添加active类，其他tab删除active类。 动态类名： 1234567891011121314151617181920212223//quiNav.vue&lt;template&gt; &lt;div class=\"qui-nav nav-type-1\"&gt; &lt;a v-for=\"(item,index) in items\" :class=\"[commonClass,item.active ? activeClass : '']\"&gt; &lt;span class=\"nav-txt\"&gt;{{ item.text }}&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function() { return { commonClass: 'nav-item', activeClass: 'active', items: [ //数据 ] } } }&lt;/script&gt; 如何修改每一个item的active值？就是给每一个tab绑定一个点击事件，当点击事件触发时修改当前tab对应的item的active： 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=\"qui-nav nav-type-1\"&gt; &lt;a v-for=\"(item, index) in items\" :class=\"[commonClass,item.active ? activeClass : '']\" v-on:click=\"navClickEvent(items,index)\"&gt; &lt;span class=\"nav-txt\"&gt;{{item.text}}&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data: function() { return { commonClass: 'nav-item', activeClass: 'active', items: [{ text: '首页', active: true }, ...... ] } }, methods: { navClickEvent: function(items, index) { /*默认切换类的动作*/ items.forEach(function(el) { el.active = false; }); items[index].active = true; /*开放用户自定义的接口*/ this.$emit('navClickEvent', items, index); } } }&lt;/script&gt; 以上代码，利用 v-for 为每个a标签绑定了一个click事件，click事件为 navClickEvent ，事件接受两个参数。 点击的时候，把items中的每一个item.active设置为false，把当前tab的active设置为true，最后再出发一次自定义事件。 这样就完成了导航组件，使用了 v-for 循环输出每一个tab，为每一个tab绑定动态class类名，同时在点击事件的时候动态的切换类。 小节回顾下我们这一篇章都学了什么内容。 页面路由的配置 按钮组件自定义属性props 按钮组件自定义事件 $on $emit 按钮组件自定义子块slot for循环实现导航组件 动态类名 quiList.vue组件 quiList.vue: 1234567891011121314151617181920212223242526272829//quiList.vue&lt;template&gt; &lt;div class=\"qui-list\"&gt; &lt;span class=\"list-tips\"&gt;{{tipsText}}&lt;/span&gt; &lt;qui-btn v-on:btnClickEvent=\"btnClickEvent\" :msg=msg class=\"small\"&gt;&lt;/qui-btn&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import quiButton from '../components/quiButton.vue' export default { props: { msg: { default: '下载' }, tipsText: { default: '默认的文案' } }, components: { 'qui-btn': quiButton }， methods: { btnClickEvent: function() { alert('按钮点击事件') } } }&lt;/script&gt;","link":"/2020/03/28/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Vue中使用Lodash实现防抖和节流","text":"Lodash实现防抖和节流。 防抖为了实现lodash组件独立，需要在 created 中添加函数。 1234567891011121314151617181920app.component('save-button', { created() { // 使用 Lodash 实现防抖 this.debouncedClick = _.debounce(this.click, 500) }, unmounted() { // 移除组件时，取消定时器 this.debouncedClick.cancel() }, methods: { click() { // ... 响应点击 ... } }, template: ` &lt;button @click=\"debouncedClick\"&gt; Save &lt;/button&gt; `}) ref https://www.lodashjs.com/","link":"/2022/06/03/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8Lodash%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"},{"title":"Vue2和Vue3组件生命周期对比","text":"Vue的生命周期其实就是Vue从初始化到最终被销毁期间的一系列重要节点。 可以在生命周期钩子函数中写一写代码执行一些操作。 Vue3的组件生命周期相比于Vue2发生了以下变化。 Vue2组件生命周期 beforeCreate():实例在内存中被创建出来，还没有初始化好data和methods属性。 create():实例已经在内存中创建，已经初始化好data和method，此时还没有开始编译模板。 beforeMount():已经完成了模板的编译，还没有挂载到页面中。 mounted()：将编译好的模板挂载到页面指定的容器中显示。 beforeUpdate():状态更新之前执行函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为还没有开始重新渲染DOM节点。 updated():此时data中的状态值和界面上显示的数据都已经完成了跟新，界面已经被重新渲染好了！ beforeDestroy():实例被销毁之前。 destroyed():实例销毁后调用，Vue实例指示的所有东西都会解绑，所有的事件监听器都会被移除,所有的子实例也都会被销毁。组件已经被完全销毁，此时组建中所有data、methods、以及过滤器，指令等，都已经不可用了。 Vue3组件生命周期 setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method onBeforeMount() : 组件挂载到节点上之前执行的函数。 onMounted() : 组件挂载完成后执行的函数。 onBeforeUpdate(): 组件更新之前执行的函数。 onUpdated(): 组件更新完成之后执行的函数。 onBeforeUnmount(): 组件卸载之前执行的函数。 onUnmounted(): 组件卸载完成后执行的函数 onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行。 onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。 onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。 横向对比Vue2--------------vue3 beforeCreate -&gt; setup() created -&gt; setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted activated -&gt; onActivated deactivated -&gt; onDeactivated errorCaptured -&gt; onErrorCaptured","link":"/2022/06/02/Vue2%E5%92%8CVue3%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AF%B9%E6%AF%94/"},{"title":"Tree-Shaking是什么？","text":"Tree-Shaking是一种代码优化技术，其通过删除未使用的代码来减少最终打包出来的文件的大小，从而提高程序的加载速度和性能。 概念在webpack5的production环境中默认开启了Tree-Shaking功能，也就是build出来的代码会删除无用的代码。 无用的代码包括下面几类： 不可能执行的代码 定义了但是没有引用的变量 参考 https://www.webpackjs.com/guides/tree-shaking/#root","link":"/2024/08/26/Tree-Shaking/"},{"title":"Vue中的updated和$nextTick","text":"updated 和 $nextTick 的区别是什么？ 网上资料有限，等有时间详细阅读一下官网这部分的文档。 updated范围：全局 用途：数据变更导致虚拟dom被重新渲染，updated用于组件被重新渲染后调用。 $nextTick范围：局部 用途：传入一个回调函数，会在下次dom更新循环之后时执行，一般用于更新了数据之后要立刻获取的情况。 nextTick会将多个对于同一个变量的操作合并为一个，再执行回调函数。 区别两者都是在dom更新后用于操作dom或者获取数据。 不同的是，updated发生在dom渲染后，$nextTick发生在渲染前。","link":"/2022/06/02/Vue%E4%B8%AD%E7%9A%84updated%E5%92%8C$nextTick/"},{"title":"Vue异步组件以及配合suspense使用","text":"异步组件的使用场景是，当一个项目被分成很多歌组件的时候，当在一个组件中需要到另一个组件的时候，可以使用异步组件的方式异步请求一个服务器上的组件。 异步组件的核心是使用 Vue.defineAsyncComponent 方法，参数是一个Promise工厂函数。 具体代码如下： 12345678910111213141516// 引入Vue.defineAsyncComponent方法const { createApp, defineAsyncComponent} = Vueconst app = createApp({})app.component('async-example', defineAsyncComponent( () =&gt; new Promise((resolve, reject) =&gt; { resolve({ template: '&lt;div&gt;I am async!&lt;/div&gt;' }) }))) 或者如果使用webpack的话可以这样动态导入组件： 1234567import { defineAsyncComponent} from 'vue'app.component('async-component', defineAsyncComponent(() =&gt; import('./components/AsyncComponent.vue'))) 在局部注册的组件中使用动态组件： 12345678910111213import { createApp, defineAsyncComponent} from 'vue'createApp({ // ... components: { AsyncComponent: defineAsyncComponent(() =&gt; import('./components/AsyncComponent.vue') ) }}) suspense的作用：在异步组件渲染完毕之前展示一些内容用于提升用户体验。 示例： 1234567891011&lt;!-- 这里async-component是一个已经定义好的异步组件，代码省略 --&gt;&lt;suspense&gt; &lt;!-- 异步组件加载成功时展示 --&gt; &lt;template #default&gt; &lt;async-component&gt;&lt;/async-component&gt;&gt; &lt;/template&gt; &lt;!-- 异步组件加载失败时展示 --&gt; &lt;template #fallback&gt; &lt;p&gt;异步组件加载失败！&lt;/p&gt; &lt;/template&gt;&lt;/suspense&gt;","link":"/2022/06/04/Vue%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/"},{"title":"Vue动态组件及其缓存","text":"Vue可以使用 :is 来绑定动态组件。 动态组件实例： 12&lt;!-- 下面的组件绑定了一个activeComponent变量，activeComponent是一个组件名，改变activeComponent的值可以达到切换组件的作用 --&gt;&lt;component :is=\"activeComponent\"&gt;&lt;/component&gt; 上面component组件的每一次切换会导致其被一次次创建和销毁，在一些不需要重新渲染的场景比如tab的切换就无端增加了开销。 下面是缓存动态组件的方法。 缓存动态组件只需要用 &lt;keep-alive&gt;&lt;/keep-alive&gt; 将动态组件包裹起来即可缓存失活的组件，这样失活的组件就不会被销毁和再创建，减少了开销。 代码： 123&lt;keep-alive&gt; &lt;component :is=\"activeComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;","link":"/2022/06/04/Vue%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E7%BC%93%E5%AD%98/"},{"title":"Vue的作用域插槽(slot)","text":"父组件中向子组件的slot插入内容一般只能使用父组件本身的数据，如果想要在父组件中使用子组件中的数据作为内容插入子组件的slot该怎么办。 这个时候就要用到作用域插槽了。 procedure 子组件写好slot标签，父组件写好v-slot。 子组件slot标签绑定属性（属性名无所谓），属性值为子组件的data中的变量。 父组件以#slotname=&quot;childvalue&quot;的形式接收到子组件中的数据。 父组件在v-slot标签内使用的方式向子组件slot中插入数据。 codechild.vue: child.vue123456789101112&lt;template&gt; &lt;slot name=\"default\" :d=\"name\"&gt;备用内容&lt;/slot&gt;&lt;/template&gt;&lt;script&gt; data() { return { name: 'Mason', age: 22 } }&lt;/script&gt; parent.vue: parent.vue123456&lt;template&gt; &lt;child #default=\"childData\"&gt; {{ childData.name }} {{ chileData.age }} &lt;/child&gt;&lt;/template&gt;","link":"/2022/10/21/Vue%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD(slot)/"},{"title":"Vue模板的编译原理","text":"Vue的编译就是将 template 模板转化成 render 函数的过程。 再通过 render 函数生成最新的vnode，再用vnode去渲染页面。 模板编译过程： 将模板解析为AST（抽象语法树），可以看做是解析器。 遍历AST，标记静态节点，可以看做是优化器。 使用AST生成render函数，可以看做是代码生成器。","link":"/2022/05/26/Vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"title":"Vue是如何实现双向数据绑定的","text":"Vue的双向数据绑定是通过数据劫持和发布订阅模式实现的。 其核心是通过 Object.defineProperty() 中的get和set来实现数据的劫持、数据变化时的事件发布、事件触发回调。 Object.defineProperty语法： Object.defineProperty(obj, propertyName, descriptor) 其中，descriptor可以是配置对象（configurable，writable，enumerable，value），也可以是get和set（但是此时不能设置writable和configurable）。 双向绑定原理 步骤： 监听器Observer监听所有属性，有变动就通知订阅者Watcher。 订阅者Watcher绑定一个更新函数，Watcher接收通知然后执行函数改变视图。 订阅中心Dep收集订阅者Watcher，当监听器Observer发来通知时就再去通知订阅者Watcher。 编译器Compiler一开始要初始化视图View，以及给订阅者Watcher绑定更新函数。","link":"/2022/05/25/Vue%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84/"},{"title":"Vue模板表达式中所能访问的全局变量","text":"Vue的模板表达式是放在沙盒中的，只能访问一个受限的全局变量列表。 具体在模板表达式中可以访问到哪些全局变量，如下。 code: https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3 12345678import { makeMap } from './makeMap'const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'export const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED) 同时，使用模板时应该遵守一条原则：模板中的表达式不应该有副作用，比如更改数据或者触发异步进程。","link":"/2022/06/03/Vue%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E6%89%80%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"title":"Vue组件通信的几种方式","text":"组件的数据有三种形态：props，data，computed。 下面的方法要么是通过某种方法使得组件之间直接通信，要么是使用了第三方作为中转。 方法props/$emit可以实现父子组件之间的通信。 父组件通过 props 向子组件传递数据。 子组件通过 $emit 触发事件向父组件传递数据，父组件通过 v-on 监听这个事件从而获取子组件传递的数据。 代码省略。 事件中心可以实现任何组件之间的通信。 通过new一个空的Vue实例作为事件中心，相当于是一个发布订阅。 12345678var Event = new Vue();// 触发指定事件并携带数据Event.$emit(eventName, data);// 监听指定事件并获取数据Event.$on(eventName, (data) =&gt; { // get data}); 这里还可以使用一个发布订阅mudule叫pubsub，支持vue和react。 pubsub可以publish一个信息并携带一个payload，也可以subscribe一个信息并在回调函数的参数中获取payload。 vuex可以实现任何组件之间的通信。 state存储数据，不能直接操作state，需要通过vuex的方法集操作state。 组件通过mutations操作state中的数据。 actions用于异步操作，最终提交mutations操作。 vuex数据持久化到localStorage。 将vuex数据持久化到locaStorage前要先JSON.stringify()为字符串。 将localStorage中的数据取出时要JSON.parse()为数组。 attrs/listenershexo将标题两个 $ 包裹的部分渲染为了数学公式故而没写美元符号。 $attrs 对象：包含了父组件传递了但是子组件props中没有暴露的属性。$listeners 对象：存放的是父组件中绑定的非原生事件。 provide/inject祖父组件通过provide向后代组件传递变量，注意祖父组件的provide要写成工厂函数。后代组件通过inject来注入变量。祖父组件provide的变量是不会变动的。 使用 Vue.observable 可以实现祖父组件provide的变量改变后，后代组件inject的变量也能响应式的改变。 parent, children, ref$parent 和 $children 用于访问父子组件实例。 ref 用于普通元素就是指向该DOM，如果用于组件就是指向组件实例，可以直接获取组件实例的所有数据方法。 ref https://segmentfault.com/a/1190000019208626 https://vue3js.cn/interview/vue/communication.html https://www.jianshu.com/p/2e5973fe1223","link":"/2022/05/28/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"Vue获取页面元素","text":"Vue如何像jQuery一样获取页面DOM呢？ 尽量不要直接操作DOM。 Vue可以在元素或者组件上使用 ref=&quot;refname&quot; 来给元素或者组件一个锚点。 然后可以使用 this.$refs.refname 来获取元素。 在组件内部使用ref123456789101112131415const app = Vue.createApp({})app.component('base-input', { template: ` &lt;input ref=\"input\" /&gt; `, methods: { focusInput() { this.$refs.input.focus() } }, mounted() { this.focusInput() }}) 在父组件中使用ref比如在父组件中使用上面定义的子组件 base-input ： 12&lt;!-- 父组件中，在子组件上写ref --&gt;&lt;base-input ref=\"usernameInput\"&gt;&lt;/base-input&gt; 12// 父组件中获取子组件this.$refs.usernameInput.focusInput()","link":"/2022/06/04/Vue%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0/"},{"title":"Ajax原理及封装","text":"封装Ajax请求函数。 原生js的Ajax请求 创建xhr实例 1234567var xhr;if (window.XMLHttpRequest) { xhr = new XMLHttpRequest();} else { // IE6, IE5 xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");} 调用open(), send()方法 12xhr.open(method, url, async);xhr.send(string); // 用于POST请求 实例：GET 12345xhr.open('GET', 'a/b/data.php', true);xhr.send();xhr.open('GET', 'a/b/data.php?num=' + Math.random(), true);xhr.send(); 实例：POST 1234567xhr.open('POST', 'a/b/data.php', true);xhr.send();// 模拟form表单POSTxhr.open('POST', 'a/b/data.php', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 添加http请求头xhr.send(\"fname=Henry&amp;lname=Ford\"); 监听状态改变 1234567xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { alert(xhr.responseText); }}xhr.open(\"GET\", \"a/b/data.php\", true);xhr.send(); 如果 async 为 false ，则不能写 onreadystatechange() ，这时Ajax已经是同步执行了，故而只需要先 open() 再 send() ，最后使用 xhr.responseText 既可： 123xhr.open(\"GET\", \"a/b/data.php\", false);xhr.send();alert(xhr.responseText); 服务器响应 使用 responseText (字符串)和 responseXML (XML)来获取服务器响应数据。如果服务器响应的数据为XML则使用 responseXML ，否则使用 responseText 。 对于 responseXML ，获取到了之后使用DOM方法操作。 onreadystatechange事件 onreadystatechange 事件用于监听 readystate 的改变。 readyState属性值： 0：请求未初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，响应已就绪 常用的status属性值： 200：OK 404：找不到页面 更多http状态码：http状态码 基于原生js封装Ajax从上面可以看出，封装一个Ajax方法所需要的无非就是以下几点： 入参： url(string) method(string) async(boolean) param(json) success(function) error(function) complete(function) 出参： data(json) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ajax({ url: '/a/b/data.php', method: 'GET', param: { name: 'Mason', age: 22 }, async: true, success: function(data) { }, error: function(xhr) { }, complete: function(xhr) { }});/** * 传入options参数对象 * @param options 参数对象 */function ajax(options) { let xhr; if (window.XMLHttpRequest) { xhr = new XMLHttpRequest(); } else { xhr = new ActiveXObject('Microsoft.XMLHTTP'); } if (options.method === 'GET') { xhr.open(options.method, options.url + '?' + parseParam(options.param), options.async); xhr.send(); } else if (options.method === 'POST') { xhr.open(options.method, options.url, options.async); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(options.param); } xhr.onreadystatechange = function() { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { options.success(xhr.responseText); } else if (xhr.readyState === 4 &amp;&amp; xhr.status !== 200) { options.error(xhr); } options.complete(xhr); } function parseParam(params) { let params_arr = []; for (let name in params) { params_arr.push(name + '=' + params.name); } return params_arr.join('&amp;'); }} jQuery的Ajax1234567891011121314151617181920function getReturnData(_path, _param, _type, _fn, _errorFn, async) { if (async === undefined) { async = true; } var _url = getContextPath() + _path; $.ajax({ url: _url, type: _type, async: async, contentType: 'application/json;charset=utf-8', data: _param, success: function (data) { _fn.call(this, data, data); }, error: function (err) { _errorFn.call(this, err); removeModal(); } });}","link":"/2018/02/22/ajax%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B0%81%E8%A3%85/"},{"title":"YAML笔记","text":"YAML：YAML Ain’t a Markup Language YAML：YAML不是一种标记语言 YAML官网：YAML YAML发音是：/ˈjæməl/，类似于：鸭某。 如上所示，YAML是“YAML Ain’t a Markup Language”的递归缩写（YAML不是标记语言）。 YAML是专门用来写配置文件的语言。 在YAML语言开发的时候，实际上，YAML的意思是“Yet Another Markup Language”（仍然是另一种标记语言）。 YAML可以简单表示清单、散列表、标量等数据，使用空白来缩进和大量依赖外观的特色，适合用来表达或者编辑数据结构、配置文件、倾印调试内容、文件大纲等等。 YAML文件扩展名为.yml。 语法规则 大小写敏感 使用缩进表示层级结构，且不能用tab只能用空格space，缩进的空格数量不重要，只要相同层级左对齐即可 用#进行单行注释 数据类型 对象：键值对的集合，又称为映射、哈希、字典。 键值对写法： 12345678910111213141516171819# 冒号后面有一个空格key: value# 值还可以是对象key: {key1: value1, key2: value2, ...}# 层级，下面用的不是tab，是4个空格key: key1: value1 key2: value2# 较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value# 在复杂对象中的key和value都各为一个数组? - key1 - key2: - value1 - value2 数组：一组有次序的值，又称为序列、列表。 数组以-开头： 123- elem1- elem2- elem3 多维数组： 1key: [value1, value2, value3] 数组结构的子成员是一个数组： 1234- - a - b - c 复杂数组实例： 12345678910111213# microsoft是一个数组，每个元素又有三个属性microsoft: - id: 001 name: wong salary: 15w - id: 002 name: lee salary: 20w# 将以上复杂例子扁平化为flow式表示microsoft: [{id: 001,name: wong,salary: 15w},{id: 002,name: lee,salary: 20w}] 数组和对象的复杂结构 123456789101112# 数组languages: - Ruby - Perl - Python# 对象websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 对应的json： 123456789{ languages: [ 'Ruby', 'Perl', 'Python'], websites: { YAML: 'yaml.org', Ruby: 'ruby-lang.org', Python: 'python.org', Perl: 'use.perl.org' } } 纯量：原子值 字符串 布尔值 整数 浮点数 Null 时间 日期 实例： 123456789101112131415161718192021string: - 'Hello World' # 单引号、双引号均可，用来包裹含有特殊字符的字符串，单引号会转义，双引号不会转义 - HelloWorld # 字符串中不含有特殊字符 - line1 line2 # 多行字符串，从第二行开始要缩进一格，一个换行被转化为一个空格boolean: - true # true,True,TRUE三种均可 - false # false,False,FALSE三种均可int: - 4869 # 十进制表示 - 0b1001_1001_1110_1011 # 二进制表示float: - 3.1415 - 1.23e+2 # 科学计数法null: name: 'node' parent: ~ # ~表示null，注意是null不是Nulldatetime: - 2020-5-12T14:55:02+08:00 # ISO8601格式，时间和日期用T连接，最后+时区date: - 2020-5-12 # ISO8601格式 引用 锚点：&amp;用来建立锚点。 别名：*用来引用锚点。 合并：&lt;&lt;用来合并引用的锚点数据到当前数据。 实例1： 123456classA: &amp;classA student1: wong student2: leeclassB: student3: queen &lt;&lt;: *classA 以上代码相当于： 1234567classA: student1: wong student2: leeclassB: student3: queen student1: wong student2: lee 实例2： 12345names: - &amp;bruce bruce - lee - wong - *bruce 以上代码相当于： 12345names: - bruce - lee - wong - bruce 参考 阮一峰YAML语言教程","link":"/2020/05/10/YAML-notes/"},{"title":"用animation写轮播图","text":"代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;style&gt; * { padding: 0; margin: 0; } a { text-decoration: none; } body { min-width: 1080px; background-color: #f4f4f4; } .banner { width: 1000px; overflow: hidden; margin: 0 auto; } .box&gt;img { float: left; width: 1000px; } .box { width: 5000px; animation: banner 25s infinite 3s; } @keyframes banner { 20% { margin-left: -1000px; } 40% { margin-left: -2000px; } 60% { margin-left: -3000px; } 80% { margin-left: -4000px; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"banner\"&gt; &lt;div class=\"box\"&gt; &lt;img src=\"image/4.png\" alt=\"\"&gt; &lt;img src=\"image/5.png\" alt=\"\"&gt; &lt;img src=\"image/2.png\" alt=\"\"&gt; &lt;img src=\"image/3.png\" alt=\"\"&gt; &lt;img src=\"image/1.png\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 改进123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"banner\"&gt; &lt;div class=\"box\"&gt; &lt;img src=\"image/5e52a48c00012a6418720764.jpg\" alt=\"\"&gt; &lt;img src=\"image/5e52a74200016f6218720764.jpg\" alt=\"\"&gt; &lt;img src=\"image/5e59d4c600017cc318720764.jpg\" alt=\"\"&gt; &lt;img src=\"image/5e5f7aea0001a36618720764.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243* { padding: 0; margin: 0;}a { text-decoration: none;}body { min-width: 1080px; background-color: #f4f4f4;}.banner { width: 1000px; height: 408px; /* border: 1px red solid; */ overflow: hidden; margin: 0 auto;}.banner&gt;div&gt;img { width: 1000px; height: 408px; float: left;}.box { width: 4000px; animation: banner 16s 2s infinite;}@keyframes banner { 25% { margin-left: -1000px; } 50% { margin-left: -2000px; } 75% { margin-left: -3000px; }}","link":"/2018/06/07/animation-slideshow/"},{"title":"我的博客vi已经上线","text":"今天开始陆陆续续给我的博客设计在hexo-icarus中的vi，主要包括： 不同类型文章的固定用的banner 站点favicon、logo、以及头像。 装饰性gif sketch源文件下载（实时更新）：blog-vi.sketch post-thumbnail2020/3/22 用于不同分类文章front-matter中的thumbnail。 由于电脑上没装photoshop和illustrator，所以暂时使用sketch设计了一个初版thumbnail。 规格：566*242 总览","link":"/2020/03/22/blog-vi/"},{"title":"鉴权：cookie, session和token","text":"一切都来源于http是一个无状态的协议，故而浏览器对于服务器的每一次相同的请求都是相同的。正是由于这个原因，服务器无法判断用户的状态，故而有了cookie, session, token, sessionStorage, localStorage的出现。 cookie的作用是存储用户数据以用于给服务器端判断用户状态，这些数据存储在用户电脑上。浏览器在每一次向服务器发出请求的时候cookie都会被顺带着发送给服务器，服务器会拿到cookie并从中获取一些用户信息。这些信息可能是用户的身份识别信息、会员识别信息等等。 cookie是一个字符串，它的形式是： &quot;cookie_name1=cookie_value1; cookie_name2=cookie_value2; ...; expires=Thu, 18 Dec 2099 12:00:00 GMT; path=/&quot; cookie又分为内存cookie（非持久化存储）和磁盘cookie（持久化存储）。 cookie和sessioncookie和session的产生过程浏览器首次请求服务器时，服务器会在本地建立一个session并返回给浏览器一个 Set-Cookie 响应头（包含了sessionid），浏览器拿到这个响应头就会去设置cookie。随后浏览器再次请求这个服务器的时候，随着用户对于页面的操作，就会修改cookie的值，后面每次浏览器请求服务器cookie都会被发送给服务器。 故而，cookie就是用户的身份识别信息，session就是服务端用来识别客户端cookie的一条记录。 cookie是实现session方案之一，现在一般是cookie+session的方式记录。 创建cookie创建cookie（默认）1document.cookie = \"username=Mason\"; 默认情况下：cookie会在浏览器关闭时删除。 创建cookie（设置时效）1document.cookie = \"username=Mason;expires=Thu, 18 Dec 2099 12:00:00 GMT\"; 指定cookie路径默认情况下：cookie属于当前页面。 告诉浏览器cookie路径： 1document.cookie = \"username=Mason;expires=Thu, 18 Dec 2099 12:00:00 GMT;path=/\"; 读取cookie12var ck = document.cookie;// ck是一个字符串，其内容是cookie_name1=cookie_value1;cookie_name2=cookie_value2;cookie_name3=cookie_value3;... 想进一步查找一个 name/value 就必须采用字符串方法查找。 还有一点就是cookie只能被其所在的domain的服务器所读取，也就是说cookie的domain值需要和服务器的domain一样才会被浏览器发送给服务器。 修改cookie1document.cookie = \"username=Ryan;expires=Thu, 18 Dec 2099 12:00:00 GMT;path=/\"; 删除cookie12// 将cookie设置为历史日期既可，指定cookie的name既可document.cookie = \"new_cookie_name=;expires=Thu, 01 Jan 1970 00:00:00 GMT\"; 也可以先 new Date() 获取当前时间，然后在此基础上减去一定的时间，再将 expires 设置为这个时间既可。 如果使用修改cookie的方法给cookie赋空值则cookie的name依然存在。 使用devtools查看cookie除了使用代码之外，还可以打开浏览器devtools -&gt; application -&gt; storage -&gt; cookies查看到cookie。 cookie的寿命cookie默认的寿命是直到浏览器被关闭。 后端可以使用一些方法来设置cookie的寿命。 java为例： java1234567891011121314// new一个Cookie实例Cookie cookie = new Cookie(\"username\", \"Mason\"); // 设定cookie寿命为1年cookie.setMaxAge(60*60*24*365); // 设定cookie寿命为关闭浏览器之前cookie.setMaxAge(-1); // 设定cookie为已过期cookie.setMaxAge(0); // 将cookie写入浏览器response.addCookie(cookie); 实例：设置、获取、检测cookie123456789101112131415161718192021222324252627282930function setCookie(cname, cvalue, exdays) { var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = \"expires=\" + d.toGMTString(); document.cookie = cname + \"=\" + cvalue + \"; \" + expires;}function getCookie(cname) { var name = cname + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) { var c = ca[i].trim(); if (c.indexOf(name) == 0) { return c.substring(name.length, c.length); } } return \"\";}function checkCookie() { var user = getCookie(\"username\"); if (user != \"\") { alert(\"欢迎 \" + user + \" 再次访问\"); } else { user = prompt(\"请输入你的名字:\", \"\"); if (user != \"\" &amp;&amp; user != null) { setCookie(\"username\", user, 30); } }} cookie, sessionStorage和localStorage相同点他们都是用于存储用户数据的方式。 不同点 cookie每次都会被浏览器发送给服务器，sessionStorage和localStorage不会被浏览器主动发送给服务器。 cookie有寿命，sessionStorage只对当前页面有效且仅存在于页面关闭之前，localStorage可以被多个页面共享且会一直存在于用户电脑上。 cookie作用：验证用户登录如果在一个网站比如腾讯视频已经登陆过了账号，那么下次打开该网站的时候服务器是怎么知道我们已经登陆了会员的呢？ 服务器会在用户登陆了网站的时候返回一个 Set-Cookie 响应头，这个响应头标识了用户的登录凭证。浏览器将它存储在本地，在下一次浏览器再一次打开这个网站的时候这个凭证就会被一同发送给服务器。服务器通过读取之前存储在数据库中的用户凭证来和浏览器发送过来的作比对，相同则服务器会根据该用户的信息渲染对应的前端页面并返回给用户的浏览器。 tokentoken（令牌）是一种服务器端无状态（服务器端不存放用户身份信息）的认证方式。 组成格式：uid（用户身份标识） + time（时间戳） + sign（签名） + 固定参数 token认证过程 用户登录后服务器返回一个token给客户端。 客户端将token保存在本地。 客户端再次访问服务器的时候token会被携带在headers中。 服务器校验token。 token的组成： Header 头部信息：记录了使用的加密算法信息； Payload 净荷信息：记录了用户信息和过期时间等； Signature 签名信息：根据 header 中的加密算法和 payload 中的用户信息以及密钥key来生成，是服务端验证服务端的重要依据。 相比于cookie和session的优势 Token 可以跨站共享，实现单点登录； Token 机制无需太多存储空间。Token 包含了用户的信息，只需在客户端存储状态信息即可，对于服务端的扩展性很好； Token 机制的安全性依赖于服务端加密算法和密钥的安全性； Token 机制也不是万金油。 JWT(json web token)客户端获取了服务端的token之后将它保存在本地localStorage中。以后客户端每次访问服务端都传token到服务端，服务端通过解密token识别用户身份从而提供服务。而服务端本地不存储用户状态信息从而服务器时无状态的，这样服务端就可以做基于无状态的负载均衡，这就是JWT。","link":"/2018/02/19/auth/"},{"title":"bootstrap grid布局","text":"grid布局概念 grid原生布局写法1234567891011&lt;div class=\"container\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt;&lt;/div&gt; 12345678910.container { height: 500px; border: 1px red solid; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;}.container&gt;div { border: 1px green solid;} 简写112345.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;} 也可以写为： 1234567.container { height: 500px; border: 1px red solid; display: grid; grid-template-columns: repeat(3,100px); grid-template-rows: repeat(3,100px);} 简写21234.container { display: grid; grid-template-columns: 100px 200px 300px 100px 200px 300px;} 也可以写为： 1234.container { display: grid; grid-template-columns: repeat(2,100px 200px 300px);} auto-fill关键字auto-fill关键字可以使得.container容器内部columns以一定的宽度自动填充满。 1234.container { display: grid; grid-template-columns: repeat(auto-fill,100px);} fr关键字(fr:fraction片段)1234.container { display: grid; grid-template-columns: 1fr 2fr;} 如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。 fr可以与绝对长度的单位结合使用，这时会非常方便。 例如： 12345.container { display: grid; grid-template-columns: 100px 1fr 2fr; /*第一列的宽度为150像素，第二列的宽度是第三列的一半。*/} minmax()函数minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1234.container { display: grid; grid-template-columns: 1fr 2fr minmax(100px,1fr);} auto关键字1234.container { display: grid; grid-template-columns: 1fr 2fr auto;} 指定网格线名字12345.container { display: grid; grid-template-columns: [c1] 100px [c2] 200px [c3] 300px [c4] 400px [c5]; grid-template-rows: [r1] 100px [r2] 100px [r3] 100px [r4];} 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 布局实例两栏布局：1234.container { display: grid; grid-template-columns: 70% 30%;} 十二网格布局：1234.container { display: grid; grid-template-columns: repeat(12,1fr);} gap间隔旧属性名： grid-column-gap grid-row-gap grid-gap 新属性名： column-gap row-gap gap 行列单独设置： 12345.container { display: grid; grid-column-gap: 20px; grid-row-gap: 30px;} 一起设置： 1234.container { display: grid; grid-gap: 20px 30px;} 如果grid-gap只有一个值，则行列都为这个值。 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 grid-template-areas属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。 12345678.container { display: grid; grid-template-columns: repeat(3,100px); grid-template-rows: repeat(3,100px); grid-template-areas: 'a b c' 'd e f' 'g h i';} 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下。 12345.container { grid-template-areas: 'a a a' 'b b b' 'c c c';} 上面代码将9个单元格分成a、b、c三个区域。 布局实例： 12345.container { grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\";} 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用”点”（.）表示。 12345.container { grid-template-areas: 'a a a' 'b . b' 'c c c';} 上面代码中，中间为点，表示没有用到该单元格，或者该单元格不属于任何区域 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 grid-auto-flow属性默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。 grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。 使用bootstrap进行grid布局使用bootstrap基本模版： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=\"https://gcore.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://gcore.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://gcore.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=\"https://gcore.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=\"https://gcore.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; bootstrap布局（记忆） 容器需要将class设置为container（带宽度），或者container-fluid（100%宽度），bootstrap中一行最多12列。 参考文章1.阮一峰grid教程","link":"/2020/05/18/bootstrap-layout-grid/"},{"title":"C语言复习笔记（ongoing）","text":"C语言是面向过程的语言。 HelloWorld12345678910// 包含头文件#include &lt;stdio.h&gt;// 程序入口函数，int表示返回值类型int main() { // stdio.h提供的函数 printf(\"HelloWorld!\\n\"); // 返回值为0 return 0;} 所有c语言程序都要包含main()函数。 注释：//或者/*...*/ #include是预处理命令，用于引入头文件。 &lt;&gt;表示系统自带的库，也可以写成&quot; &quot;表示用户自定义的库如果写成&quot; &quot;并且自定义的库里面没有这个文件系统会自动查找自带的库, 如果还是没有就报错 return 0;表示退出程序。 123456#include &lt;stdio.h&gt;// argc为参数个数，argv为字符串数组，第一个存放的是可执行程序的文件名字，然后依次存放传入的参数int main(int argc, char *argv[]) { printf(\"可执行程序 %s ,参数个数为[%d], 运行输出：[%s]\\n\",argv[0],argc,argv[1]); } c语言程序文件扩展名为 .c 。 c11是最新的c语言标准。 环境配置 c语言编译器 文本编辑器 程序结构c语言程序包括以下部分： 预处理器指令 函数 变量 语句和表达式 注释 demo： 123456789// 预处理器指令：包含stdio.h头文件#include &lt;stdio.h&gt;// 程序执行入口int main() { printf(\"HelloWorld\\n\"); // 返回值为0 return 0;} 如何编译c语言程序： 12gcc hello.c./hello.out 编译多个文件： 12gcc test1.c test2.c -o main.out./main.out gcc 命令如果不指定目标文件名时默认生成的可执行文件名为 a.out(linux) 或 a.exe(windows)。 可用 gcc [源文件名] -o [目标文件名] 来指定目标文件路径及文件名。 因编译器的原因，生成的 .exe 文件打开时会一闪而过，从而观察不到其运行的结果，这是因为 main() 函数结束时，DOS窗口会自动关闭。为了避免这个问题可在 return 0; 前加入 system(&quot;pause&quot;); 语句。 12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() { printf(\"Hello, World! \\n\"); system(\"pause\"); return 0;} 基本语法 token 分号 注释 标识符：标识符以字母A-Z或a-z或下划线_开始，后跟零个或多个字母、下划线和数字0-9，区分大小写。 关键字 数据类型","link":"/2021/03/22/c-review/"},{"title":"汇编语言基础备忘","text":"陆陆续续记录一下常用的汇编指令，真的是非常基础。 寄存器分类通用寄存器主要有AX, BX, CX, DX等等 指令寄存器IR存储着现在正在执行的指令地址 指针寄存器有栈指针寄存器SP和栈基址指针寄存器BP 段寄存器标志端的开始，有CS, DS, SS, ES 特殊用途有些寄存器有特定用途，如： AX用于累加和终端 CX用于计数、循环 内存分段一个程序可以有数据段、代码段、堆栈段。 数据段：存放全局变量，段寄存器为DS 代码段：存放汇编指令，段寄存器为CS 堆栈段：存放程序运行期间产生的变量，分为堆和栈，栈用于存放函数局部变量，堆用于存放动态分配的变量。堆栈段寄存器为SS，SP寄存器指向栈顶。 扩展段用于保存其他信息，段寄存器为ES 常用汇编指令(8086为例)mov 传送指令 mov a,b 将b的值赋值给a add 加法指令 add a,b 等同于 a=a+b sub 减法指令 sub a,b 等同于a=a-b cmp 比较指令 cmp a,b 比较a和b的大小，结果存在编制寄存器中 jmp 无条件跳转指令 修改IP和CS是程序跳转到特定地址运行 jcc 条件转移指令 通过判断标志寄存器的状态决定是否跳转 call 调用函数指令 程序会调用函数入口执行 ret 函数返回指令","link":"/2018/12/28/assembly-basic/"},{"title":"跨域（cross domain）","text":"概念广义上的跨域是指一个域下的文档或者脚本请求另一个域下的资源。狭义上的跨域是指由于浏览器的同源策略限制，从一个域名请求另一个域名的资源。我们通常所说的跨域是指狭义上的跨域。 同源：域名、端口和协议三者一致即为同源。以上三者只要有一个不同即为跨域。 解决方案 jsonp document.domain + iframe location.hash + iframe window.name + iframe postMessage CORS nginx代理 nodejs中间件代理 websocket","link":"/2018/09/20/cross-domain/"},{"title":"什么是CR,LF,CRLF","text":"使用编辑器和IDE的时候经常看到CR、LF和CRLF。其实这三个是不同操作系统的不同换行符。 CR：表示回车，对应ASCII码中的\\r。 LF：表示换行，对应ASCII码中的\\n。 CRLF：表示回车并换行，对应的ASCII码为\\r\\n。 那么三个分别适用于哪些系统呢？ CR：用于远古mac系统。 LF：unix,linux和现在的macos。 CRLF：用于windows。 一般安装完编辑器或者IDE都会根据你的系统预置换行配置。","link":"/2020/06/29/cr-lf-crlf/"},{"title":"centos下删除以及重新安装ruby","text":"由于jekyll从要求ruby2.0提升到&gt;=2.1故有了这次ruby的删除与重新安装。 卸载旧版本centos或者RHEL安装了老版本ruby的可以直接 1$ yum remove ruby -y 来卸载ruby及其依赖包 安装新版本这里安装ruby2.3.7 下载： 1234$ yum install -y wget$ wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.7.tar.gz$ tar -zxvf https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.7.tar.gz$ cd ruby-2.3.7 编译安装： 123$ ./configure$ make$ make install 查看是否安装成功： 12$ ruby -vruby 2.3.7 安装成功！","link":"/2018/05/07/centos-remove-ruby/"},{"title":"call, apply和bind","text":"这三个方法都是用来改变 this 指向的对象的。 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() 用法语法call: function_name.call(new_target_object, param1, param2, ..., paramN) apply: function_name.apply(new_target_object, [param1, param2, ..., paramN]) bind: function_name.bind(new_target_object, param1, param2, ..., paramN) call和apply对于call和apply，第一个参数都是this绑定到的新对象，且如果第一个参数是 null ，this就会指向 window 。对于call：第二个参数开始可以传参给这个函数。对于apply：第二个参数是一个数组，数组中的每个元素作为这个函数的参数。 bindbind方法返回一个修改过的函数。bind第一个参数也是新对象，从第二个参数开始可以传给这个函数。 bind传参的方式有两种，第一种是在bind时就预先穿进去参数： function_name.bind(new_target_object, param1) 第二种是在调用是传参，bind时预先传的参数会排在前面，调用时传的参数在后面。 总结call和apply都是改变这个函数的this指向并立刻执行这个函数，两者的区别仅仅在于传参的不同。而bind返回的是函数，可以先将bind后的函数保存到变量，在需要调用这个函数的时候调用这个函数并且可以传参进去。 ref https://www.cnblogs.com/pssp/p/5215621.html https://www.runoob.com/w3cnote/js-call-apply-bind.html","link":"/2022/03/02/call-apply-bind/"},{"title":"用纯css判断鼠标进入元素的方向","text":"如何用纯css来判断鼠标进入元素的方向呢？ 这是一个面试问题。 给定结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { padding: 2em; text-align: center; } .block { position: relative; display: inline-block; width: 10em; height: 10em; vertical-align: middle; } .block_content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; text-align: center; line-height: 10em; background: #333; color: #FFF; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"text\"&gt;从不同方向使鼠标指针移过下面的内容&lt;/p&gt; &lt;p&gt;↓&lt;/p&gt; &lt;span&gt;→ &lt;/span&gt; &lt;div class=\"block\"&gt; &lt;div class=\"block_content\"&gt; Hover me! &lt;/div&gt; &lt;/div&gt; &lt;span&gt; ←&lt;/span&gt; &lt;p&gt;↑&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果： 思路： 我们在css中判断鼠标移入用的是:hover，关键是如何判断鼠标移入的方向。 我们用:hover只能知道鼠标移入了，而却无法得知鼠标移入方向的。 那么如何通过css来判断出鼠标移入的方向呢？ 一开始我想用border来实现，可是一想border不能各自被hover。于是只能制造能被hover的块来实现。 实现： 在四个方向上都加上可以被hover的块。 123456789&lt;div class=\"block\"&gt; &lt;div class=\"block_hoverer\"&gt;上&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;下&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;左&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;右&lt;/div&gt; &lt;div class=\"block_content\"&gt; Hover me! &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.block_hoverer { position: absolute; width: 100%; height: 100%; z-index: 1;}.block_hoverer:nth-child(1) { background: red;}.block_hoverer:nth-child(2) { background: lime;}.block_hoverer:nth-child(3) { background: orange;}.block_hoverer:nth-child(4) { background: blue;} 结果只有最后一块露了出来。 接下来让四个快在其容器中仅仅有一点点宽度。 1234567891011121314151617181920212223242526.block_hoverer { position: absolute; z-index: 1; width: 100%; height: 100%; transition: all 0.3s ease;}.block_hoverer:nth-child(1) { background: red; top: -90%;}.block_hoverer:nth-child(2) { background: lime; top: 90%;}.block_hoverer:nth-child(3) { background: orange; left: -90%;}.block_hoverer:nth-child(4) { background: blue; left: 90%;} 给每个块加上过渡 12345678.block_hoverer { transition: all 0.3s ease;}.block_hoverer:hover { opacity: 1; top: 0; left: 0;} 隐藏 1234567891011121314.block { position: relative; display: inline-block; overflow: hidden; width: 10em; height: 10em; vertical-align: middle;}.block_hoverer { opacity: 0;}.block_hoverer:hover { opacity: 1;} 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { padding: 2em; text-align: center; } .block { position: relative; display: inline-block; overflow: hidden; width: 10em; height: 10em; vertical-align: middle; transform: translateZ(0); } .block_hoverer { position: absolute; z-index: 1; width: 100%; height: 100%; opacity: 0; transition: all .3s ease; } .block_hoverer:nth-child(1) { background: red; top: -90%; } .block_hoverer:nth-child(2) { background: lime; top: 90%; } .block_hoverer:nth-child(3) { background: orange; left: -90%; } .block_hoverer:nth-child(4) { background: blue; left: 90%; } .block_hoverer:hover { opacity: 1; top: 0; left: 0; } .block_content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; text-align: center; line-height: 10em; background: #333; color: #FFF; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"text\"&gt;从不同方向使鼠标指针移过下面的内容&lt;/p&gt; &lt;p&gt;↓&lt;/p&gt; &lt;span&gt;→ &lt;/span&gt; &lt;div class=\"block\"&gt; &lt;div class=\"block_hoverer\"&gt;1&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;2&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;3&lt;/div&gt; &lt;div class=\"block_hoverer\"&gt;4&lt;/div&gt; &lt;div class=\"block_content\"&gt; Hover me! &lt;/div&gt; &lt;/div&gt; &lt;span&gt; ←&lt;/span&gt; &lt;p&gt;↑&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 最终效果： Gif由gifox制作而成","link":"/2020/05/09/css-judge-directions/"},{"title":"CSS权威指南（第三版）读书笔记","text":"《CSS权威指南（第三版）》覆盖了CSS2 + CSS2.1的内容。《CSS权威指南（第四版）》加入了CSS3的内容。 CSS和文档 CSS：层叠样式表 替换元素：img、input等等。 非替换元素：大多数都是非替换元素。 块元素、行内元素，html和xhtml中块元素不能继承行内元素，但是CSS没有限制块元素和行内元素的嵌套。行内元素可以继承块元素，块元素不能继承行内元素。可以自定义元素并赋予样式。 引入外部样式表： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"basic.css\" media=\"screen, print\" /&gt; 候选样式表：需要用户手动选择，下面是如何定义候选样式表。候选样式表的title属性定义了候选样式表的名称。 123&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"default.css\" title=\"default\" /&gt;&lt;link rel=\"alternate stylesheet\" type=\"text/css\" href=\"alt01.css\" title=\"alt01\" /&gt;&lt;link rel=\"alternate stylesheet\" type=\"text/css\" href=\"alt02.css\" title=\"alt02\" /&gt; style标签：type一定要设置为 text/css ，还可以给style指定media属性。 123&lt;style type=\"text/css\"&gt; /* css code */&lt;/style&gt; @import规则 必须要放在样式表中，而且在最前面。 123&lt;style type=\"text/css\"&gt; @import url(style.css);&lt;/style&gt; 指定应用的媒体： 12345&lt;style type=\"text/css\"&gt; @import url(style.css) all; @import url(screen.css) screen; @import url(printandprojection.css) print, projection;&lt;/style&gt; 向后可访问性，使不能识别style标签的浏览器忽略标签中的声明（几乎用不到了） 写法： 123456789&lt;style type=\"text/css\"&gt; &lt;!-- @import url(style.css) all; h1 { background: yellow; } --&gt;&lt;/style&gt; 注释，不能嵌套 12345/* 注释1 *//* 注释2*/ 内联样式，可用于body以及body中的任何标签，现在几乎不用这种写法。 123&lt;p style=\"color: red; font-size: 14px;\"&gt; this is a paragraph.&lt;/p&gt; 选择器规则结构 每条规则都由选择器和声明块组成。 选择器定义了声明块影响文档中内容的范围。 声明块由一个或者多个声明组成，每条声明是一个属性-值对。 如下： 1234h1 { color: red; background: yellow;} 一个属性的属性值可以有多个： 123p { font: red 14px bold;} 选择器 元素选择器 123p { color: red;} 选择器分组 1234567891011121314151617181920212223h1 { color: red;}h2 { color: red;}h3 { color: red;}h4 { color: red;}h5 { color: red;}h6 { color: red;} 可以用分组来压缩代码： 12345678h1,h2,h3,h4,h5,h6 { color: red;} 通配选择器 12345* { color: red;} 声明分组 1234567891011p { color: red;}p { font-size: 14px;}p { background: yellow;} 12345p { color: red; font-size: 14px; background: yellow;} 每条声明后面的分号不能少。 结合选择器和声明的分组 为h1-h6设置字体颜色、背景颜色和border 12345678910h1,h2,h3,h4,h5,h6 { color: red; background: yellow; border: 1px solid gray;} 类选择器，可以给多个元素设置同一个类名 123456789&lt;p class=\"warning\"&gt; WARNING!&lt;/p&gt;&lt;style&gt; .warning { font-weight: bold; }&lt;/style&gt; 也可以只让包含warning类的所有p元素字体变粗： 123456789&lt;p class=\"warning\"&gt; WARNING!&lt;/p&gt;&lt;style&gt; p.warning { font-weight: bold; }&lt;/style&gt; 这里的 p.warning 比 .warning 更特殊，故而前者的声明会覆盖后者。 多类选择器 比如要选中既有urgent类又含有warning类的元素： 1.urgent.warning {} id选择器，只能给一个元素设置id名，id选择器一般用于js而不是css 1234567&lt;p id=\"para\"&gt; this is a paragraph.&lt;/p&gt;&lt;style&gt; #para {}&lt;/style&gt; 使用类选择器还是ID选择器？ 属性选择器 简单属性选择器 选择含有class属性的所有h1元素： 1h1[class] {} 选择同时有href和title属性的a元素： 1a[href][title] {} 根据具体属性值选择（属性值必需完全匹配）： 12345/* 根据一个特定属性选择a元素 */a[href=\"https://www.google.com\"] {}/* 根据多个属性值选择a元素 */a[href=\"https://www.google.com\"][title=\"google\"] {} 根据部分属性值选择： 123&lt;p class=\"urgent warning\"&gt; qwertyuiop&lt;/p&gt; 1p[class~=\"warning\"] {} 以上选择器选择了class属性包含warning的元素。（以空格做隔断） 子串匹配属性选择器： 类型 描述 [foo^=”bar”] 选择foo属性值以“bar”开头的所有元素 [foo$=”bar”] 选择foo属性值以“bar”结尾的所有元素 [foo*=”bar”] 选择foo属性值包含子串“bar”的所有元素 [foo~=”bar”] 选择foo属性值包含以空格隔断的“bar”子串的所有元素 这里注意最后两条的区别。 特定属性选择器 1*[lang|=\"en\"] {} 这个规则会选择lang属性为en或者以en开头的所有元素，这种选择器最常用的用途是匹配语言。 也就是： 类型 描述 [foo|=”bar”] 选择foo属性值等于“bar”或者以其为开头的所有元素 后代选择器：也叫上下文选择器， 12/* 这个选择器会选择作为h1后代的所有em元素 */h1 em {} 上面选择器中的空格表示后代。 子元素选择器：选择元素的直接后代，也就是子元素。 1p&gt;a {} 相邻兄弟选择器 12&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt; 1p+h1 {} 以上选择器读作：选择作为p元素同级别的紧邻的下一个h1元素。 伪类选择器 静态伪类选择器 12345/* 未访问的链接 */a:link {}/* 访问过的链接 */a:visited {} 动态伪类选择器 12345678/* 获取了焦点的元素 */a:focus {}/* 鼠标悬停的元素 */a:hover {}/* 激活的元素 */a:active {} 以上伪类的书写顺序应该为：LVHA或者LVFHA。 比如： 12345678910111213141516171819a:link { color: navy;}a:visited { color: gray;}a:focus { color: red;}a:hover { color: blue;}a:active { color: yellow;} 伪类结合使用，不能把互斥的伪类一起使用 1234567a:link:hover { color: red;}a:visited:hover { color: maroon;} 选择第一个子元素： 12345678910&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;&lt;style&gt; p:first-child { color: red; }&lt;/style&gt; 以上选择器选择作为第一个子元素的p元素。 根据语言选择： 使用:lang()伪类 例子：选择所有语言为法语的元素 1*:lang(fr) {} 伪元素选择器 123p:first-letter {}p:first-line {} 伪元素 :before 和 :after 用于在元素前后插入内容并赋予其样式。 before实例： 1234p:before { content: 'new'; color: red;} 结构和层叠特殊性重要声明： !important例子： 123p { color: red !important;} 继承一个例外：body元素的属性会传递到html标签。 层叠LVHA或者VLHA 值和单位值值分为数字（整数和小数）和百分数。 颜色css2.1中的17个颜色：aquafuchsialimeoliveredwhiteblackgraymaroonorangesilveryellowbluegreennavypurpleteal 字体字体系列CSS定义的5种通用字体系列。 Serif：衬线体，Times、Georgia、New Century Schoolbook。 Sans-serif：非衬线体，Helvetica、Geneva、Verdana、Arial、Univers。 Monospace：等宽字体，Courier、Courier New、Andale Mono。 Cursive：手写体，Zapf Chancery、Author、Comic Sans。 Fantasy：Western、Woodblock、Klingon。 使用字体123p { font-family: Georgia, serif;} 有空格或者有特殊字符的字体需要用引号括起来。 正确地font属性书写方式： 1234h1 { /* 前三个font-style,font-weight,font-variant顺序随意，后面两个顺序一定要先写font-size再写font-family且必须要写不能省略 */ font: italic normal small-caps 16px Arial, sans-serif;} font-size和line-height的写法： 16px/1.2 。 font-face规则已经从css2.1删除。 12345/* 下载字体 */@font-face { font-family: 'new font name'; src: url(...);} 文本属性 text-indent 只能用于块元素缩进，如果行内元素想要缩进则可以设置padding-left或者margin-left。 text-align vertical-align 只能用于行内元素和替换元素，不影响块元素中内容的对齐。 line-height word-spacing letter-spacing text-transform text-decoration text-shadow white-space direction 基本视觉格式化水平格式化垂直格式化","link":"/2018/05/04/css-definitive-guide/"},{"title":"css变量","text":"2017年三月，微软宣布edge正式支持了css变量，至此市面上所有主流的浏览器都支持了css变量。 变量声明在变量名前面加上--即可 这里在body里面声明了color1 color2两个变量。它们实质上就是属性，但是没有默认含义。故而css变量又称之为css自定义属性。 1234body { --color1: #111; --color2: #222;} 注意：变量名大小写敏感。 1234:root { --font-color: #3a3a3a; --block-color: #333333;} 这里:root匹配DOM根元素，对于html而言就是匹配&lt;html&gt;元素 var()函数用于读取变量： 1234a { color: var(--font-color); background-color: var(--block-color);} 第二参数： 123a { color: var(--font-color,#333);} 如果第一个变量不存在则使用第二个参数。 注意：第一个参数逗号之后的部分都属于第二个参数整体。 var()还可以用在变量的声明： 1234a { --first-color: #333; --second-color: var(--first-color);} 注意：var()是一个属性值。 变量值类型字符串1234a { --foo: 'hello'; --bar: var(--foo)' world';} 结果： --bar = 'hello world'。 数值 变量值没有单位 需要使用到calc()函数，这里注意calc()函数内符号两边要留空格。 1234p { --gap: 20; margin-top: calc(var(--gap) * 1px);} 变量值有单位 1234p { --gap: 20px; margin-top: var(--gap);} 作用域同一个css变量可以在多个选择器中被声明，按照css层叠来选择优先级最高的声明。 总结：css变量的作用域就是声明其的选择器的范围，并且按照层叠，优先级越高的作用越优先。 一般将css全局变量放在:root中，以使得所有选择器都可读取。 12345:root { --font-color: #000; --block-color: blue; --border-color: red;} 响应式布局12345678910111213141516body { --primary: #7F583F; --secondary: #F7EFD2;}a { color: var(--primary); text-decoration-color: var(--secondary);}@media screen and (min-width: 768px) { body { --primary: #F7EFD2; --secondary: #7F583F; }} 这样，窗口宽度在大于等于768px的时候采用: 1234body { --primary: #F7EFD2; --secondary: #7F583F; } 其他情况采用： 1234body { --primary: #7F583F; --secondary: #F7EFD2;} 而a标签是公共样式： 1234a { color: var(--primary); text-decoration-color: var(--secondary);} 兼容如果浏览器不支持css变量，则： 12345a { --main-color: #333; color: #333; color: var(--main-color);} 或者使用@supports检测： 1234567@supports ( (--a: 0) ) { /*supported*/}@supports ( not (--a: 0) ) { /*not supported*/} js检测浏览器是否支持css变量1234567const isSupported = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports('--a', 0);if (isSupported) { /*支持，继续使用css变量*/} else { /*不支持，使用兼容写法*/} JavaScript 操作 CSS 变量的写法如下。 123456789// 设置变量document.body.style.setProperty('--primary', '#7F583F');// 读取变量document.body.style.getPropertyValue('--primary').trim();// '#7F583F'// 删除变量document.body.style.removeProperty('--primary'); css变量提供了一种css与js通信的方式： 123div { --msg: if (x === 1) { this.width = 10};} 这个--msg变量的值在css中是无效的，但是我们通过js可以读取到它，变相让css传值给了js。","link":"/2019/10/26/css-var/"},{"title":"position属性值详解","text":"position属性值有5个：static,relative,absolute,fixed,sticky static默认值 relative相对定位，不会对其他元素的位置产生影响，因此元素之间可能产生重叠，相对于元素的默认位置进行偏移，搭配top,right,bottom,left，left和top搭配，right和bottom搭配 fixed相对定位，不会对其他元素的位置产生影响，因此元素之间可能产生重叠，相对与浏览器进行偏移，定位基点为浏览器窗口。搭配left,right,bottom,top使用。 absolute相对定位，不会对其他元素的位置产生影响，因此元素之间可能产生重叠，相对于上级元素进行偏移，条件是上级元素不能为static，否则定位基点变成html这个dom，搭配top,right,bottom,left使用。 使用： 1234&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt; &lt;/div&gt;&lt;/div&gt; 12345678.father { position: relative;}.son { position: absolute; left: 66px; top: 66px;} 以上代码.son元素相对于father元素进行往右66px往下66px的偏移 重点：.son元素会被正常文档流忽略，不会占用空间。 sticky一般用于导航条，脑补京东详情页，搭配left等使用。它的具体规则是，当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛，relative定位自动切换为fixed定位；等到父元素完全脱离视口时（即完全不可见），fixed定位自动切换回relative定位。 使用：对于safari要添加-webkit-sticky- 12345.toolbar { position: -webkit-sticky; /* safari 浏览器 */ position: sticky; /* 其他浏览器 */ top: 20px;} 上面代码中，页面向下滚动时，.toolbar的父元素开始脱离视口，一旦视口的顶部与.toolbar的距离小于20px（门槛值），.toolbar就自动变为fixed定位，保持与视口顶部20px的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），.toolbar恢复成relative定位。 例子：动态堆叠照片 代码： 123&lt;div&gt;&lt;img src=\"pic1.jpg\"&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=\"pic2.jpg\"&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=\"pic3.jpg\"&gt;&lt;/div&gt; 1234div { position: sticky; top: 0;} 它的原理是页面向下滚动时，每张图片都会变成fixed定位，导致后一张图片重叠在前一张图片上面 例子：表格th固定，数据滚动 代码： 12345678910&lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;小明&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;小洪&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;小黑&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 1234th { position: sticky; top: 0;} 注意：sticky必须设置在th上 复习下table的结构： 12345678&lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;标题1&lt;/th&gt;&lt;th&gt;标题2&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;数据1&lt;/td&gt;&lt;td&gt;数据2&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; or： 12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;标题1&lt;/th&gt; &lt;th&gt;标题2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数据1&lt;/td&gt; &lt;td&gt;数据2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","link":"/2018/05/18/css-position-attributes/"},{"title":"一条属性让网站变成灰色","text":"昨天是国家哀悼日，我发现所有主流网站都变成了灰色，那么这是怎么做到的呢。 其实这里用到了css3的滤镜filter属性，以及属性值grayscale()。 只需要给html标签加个class即可。 123456html.gray { -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%);} IE不支持filter 就拿youtube来试试看。 before: after:","link":"/2020/04/05/css3-filter-grayscale/"},{"title":"CSS布局（长期更新）","text":"长期总结css布局相关内容。 居中布局水平居中布局 inline-block + text-align 通过设置内容元素为inline-block，并且给父元素设置text-align: center;使内容元素具有文本对齐居中的属性。 123456789101112131415161718192021&lt;style&gt; .container { width: 100%; height: 200px; background-color: blue; text-align: center; } .content { width: 200px; height: 200px; background-color: red; display: inline-block; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; absolute + transform 父元素设置relative，子元素设置absolute并left: 50%。这个时候再将自身transform: translateX(-50%);完成居中。 这里使用到transform属性，这个属性为CSS3属性。 1234567891011121314151617181920212223&lt;style&gt; .container { position: relative; width: 100%; height: 200px; background-color: blue; } .content { position: absolute; left: 50%; transform: translateX(-50%); width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; block + margin 对子元素设置display: block,margin: 0 auto;就可以水平居中。 table也可以。 123456789101112131415161718192021&lt;style&gt; .container { width: 100%; height: 200px; background-color: blue; } .content { width: 200px; height: 200px; background-color: red; display: table; margin: 0 auto; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 垂直居中布局 定位 + transform 容器设置position: relative;，内容设置position: absolute;并且top: 50%;再transform: translateY(-50%);完成垂直居中。 1234567891011121314151617181920212223&lt;style&gt; .container { position: relative; width: 200px; height: 600px; background-color: blue; } .content { position: absolute; top: 50%; transform: translateY(-50%); width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; display: table-cell + vertical-align table-cell的元素有td元素的行为，其子元素布局类似文本元素。 故而父元素display: table-cell;+vertical-align: middle;即可让其子元素垂直居中。 注意父元素的所有子元素都会继承居中显示。 12345678910111213141516171819&lt;style&gt; .container { display: table-cell; vertical-align: middle; width: 200px; height: 600px; background-color: blue; } .content { width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 水平垂直居中布局 定位 + transform 也就是上面两个的集合。 123456789101112131415161718192021222324&lt;style&gt; .container { position: relative; width: 1200px; height: 800px; background-color: blue; } .content { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 水平block + margin，垂直display: table-cell + vertical-align 1234567891011121314151617181920&lt;style&gt; .container { display: table-cell; vertical-align: middle; width: 1200px; height: 800px; background-color: blue; } .content { margin: 0 auto; width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 使用flex居中布局水平居中：justify-content: center; 垂直居中：align-items: center; 需要考虑浏览器兼容。 12345678910111213141516171819202122&lt;style&gt; .container { display: flex; align-items: center; justify-content: center; width: 1200px; height: 800px; background-color: blue; } .content { width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 多列布局两列布局这里是一列定宽，一列自适应。 左列左浮动，右列设置margin-left 12345678910111213141516171819202122&lt;style&gt; .left, .right { height: 600px; } .left { width: 400px; background-color: blue; float: left; } .right { background-color: red; margin-left: 400px; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;定宽元素&lt;/div&gt; &lt;div class=\"right\"&gt;自适应元素&lt;/div&gt;&lt;/body&gt; 左列左浮动，右列overflow: hidden 右列设置overflow: hidden;开启BFC，与外界隔离，所以能实现效果。 12345678910111213141516171819202122&lt;style&gt; .left, .right { height: 600px; } .left { width: 400px; background-color: blue; float: left; } .right { background-color: red; overflow: hidden; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;定宽元素&lt;/div&gt; &lt;div class=\"right\"&gt;自适应元素&lt;/div&gt;&lt;/body&gt; 父元素display: table，左右列display: table-cell 1234567891011121314151617181920212223242526272829&lt;style&gt; .container { display: table; table-layout: fixed; width: 100%; } .left, .right { display: table-cell; height: 600px; } .left { width: 400px; background-color: blue; } .right { background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;定宽元素&lt;/div&gt; &lt;div class=\"right\"&gt;自适应元素&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; flex两列布局 父元素设置为flex，左列定宽，右列flex: 1;。 1234567891011121314151617181920212223&lt;style&gt; .container { display: flex; height: 600px; } .left { background-color: blue; width: 400px; } .right { flex: 1; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;自适应&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 三列布局普通三列布局左中定宽，右边自适应。 定宽 + overflow: hidden 123456789101112131415161718192021222324252627282930&lt;style&gt; .left, .center, .right { height: 600px; } .left { width: 400px; background-color: blue; float: left; } .center { width: 400px; background-color: yellow; float: left; } .right { background-color: red; overflow: hidden; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"center\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;自适应&lt;/div&gt;&lt;/body&gt; flex三列布局 与两列flex相同。 1234567891011121314151617181920212223242526272829&lt;style&gt; .container { display: flex; height: 600px; } .left { width: 400px; background-color: blue; } .center { width: 400px; background-color: yellow; } .right { flex: 1; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"center\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;自适应&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 圣杯布局两侧定宽，中间自适应的三列布局。 左边定宽左浮动，右边定宽右浮动，中间设置margin 需要将右边元素放在中间元素的前面，否则右边元素会下沉。但是不利于中间元素的SEO。 12345678910111213141516171819202122232425262728293031&lt;style&gt; .left, .center, .right { height: 600px; } .left { width: 400px; background-color: blue; float: left; } .center { background-color: yellow; margin-left: 400px; margin-right: 400px; } .right { width: 400px; background-color: red; float: right; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;定宽&lt;/div&gt; &lt;div class=\"center\"&gt;自适应&lt;/div&gt;&lt;/body&gt; 父元素设置margin，左中右都浮动，利用定位和margin布局 center在最前面，有利于SEO。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; .container { /* margin-left对应左边元素left的宽度，margin-right对应右边元素right的宽度 */ margin-left: 400px; margin-right: 400px; } .left, .center, .right { height: 600px; float: left; } .left { width: 400px; background-color: blue; position: relative; /* 为了让left元素从当前行移动到第一行同一位置*/ margin-left: -100%; /* 移动到中间元素左侧正确位置 */ left: -400px; } .center { width: 100%; background-color: yellow; } .right { width: 400px; background-color: red; position: relative; /* 为了让left元素从当前行移动到上一行*/ margin-left: -400px; right: -400px; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"center\"&gt;自适应&lt;/div&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;定宽&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 双飞翼布局左右定宽，中间自适应。 中间元素增加子元素用来放置内容。 中间元素设置margin，左中右设置浮动，左右margin 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .left, .center, .right { height: 600px; float: left; } .left { width: 400px; background-color: aqua; /* 为了让l元素从当前行移动到第一行同一位置*/ margin-left: -100%; } .center { width: 100%; background-color: blue; } .i { height: 600px; background-color: blueviolet; margin-left: 400px; margin-right: 400px; } .right { width: 400px; background-color: brown; /* 为了让r元素移动到第一行*/ margin-left: -400px; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"center\"&gt; &lt;div class=\"i\"&gt;自适应&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;定宽&lt;/div&gt;&lt;/body&gt; flex三列布局 1234567891011121314151617181920212223242526272829&lt;style&gt; .container { display: flex; height: 600px; } .left { width: 400px; background-color: blue; } .center { flex: 1; background-color: red; } .right { width: 400px; background-color: yellow; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"center\"&gt;自适应&lt;/div&gt; &lt;div class=\"right\"&gt;定宽&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 多列等分布局 浮动 + 百分数进行多列等分布局 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .col { float: left; width: 20%; height: 300px; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;&lt;/div&gt; &lt;div class=\"col col2\"&gt;&lt;/div&gt; &lt;div class=\"col col3\"&gt;&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; table多列等分布局 父元素display: table;，设置布局行为table-layout: fixed，指定每个表格等宽。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .container { display: table; /* 列宽由表格宽度和列宽度设定 */ table-layout: fixed; width: 100%; } .col { display: table-cell; height: 300px; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;&lt;/div&gt; &lt;div class=\"col col2\"&gt;&lt;/div&gt; &lt;div class=\"col col3\"&gt;&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; column多列等分布局 指定内容区域为5列。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .container { /* 指定列数 */ column-count: 5; /* 指定列与列之间的间隙，默认1em */ column-gap: 0; } .col { height: 300px; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;&lt;/div&gt; &lt;div class=\"col col2\"&gt;&lt;/div&gt; &lt;div class=\"col col3\"&gt;&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; flex多列等分布局 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .container { display: flex; } .col { height: 300px; flex: 1; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;&lt;/div&gt; &lt;div class=\"col col2\"&gt;&lt;/div&gt; &lt;div class=\"col col3\"&gt;&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 多列等高布局意思是每一列高度相等。 table多列等高布局 父元素设置为table，子元素table-cell，这样就使得子元素等高。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .container { display: table; } .col { display: table-cell; width: 20%; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col2\"&gt;啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col3\"&gt; 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt; 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; flex多列等高布局 align-items设置为auto或者不设置。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .container { display: flex; } .col { flex: 1; } .col1 { background-color: #111; } .col2 { background-color: #222; } .col3 { background-color: #333; } .col4 { background-color: #444; } .col5 { background-color: #555; }&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col col1\"&gt;啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col2\"&gt;啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col3\"&gt; 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;/div&gt; &lt;div class=\"col col4\"&gt;&lt;/div&gt; &lt;div class=\"col col5\"&gt; 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 全屏布局全屏布局就是头部、内容区域、底部组成的。 这里采用头部底部fixed，中间内容区域两列布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;style&gt; html, body { margin: 0; overflow: hidden; } header { position: fixed; left: 0; top: 0; right: 0; height: 100px; background-color: salmon; } .container { position: fixed; left: 0; right: 0; top: 100px; bottom: 100px; overflow: auto; background-color: palevioletred; } .container .left { width: 400px; /* height: 100%; */ position: fixed; left: 0; top: 100px; bottom: 100px; background-color: greenyellow; } .container .right { position: fixed; left: 400px; right: 0; top: 100px; bottom: 100px; background-color: blueviolet; } footer { position: fixed; left: 0; right: 0; bottom: 0; height: 100px; background-color: goldenrod; }&lt;/style&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt; 持续挖掘中…","link":"/2020/05/12/css-layout/"},{"title":"css三角形","text":"虽然现在的带宽速度已经足够加载图片，但是使用css来生成三角形仍然可以压缩页面资源大小以及获得比粗暴插入图片更好的样式。 利用css盒模型的border创建三角形1234567891011&lt;div&gt;&lt;/div&gt;&lt;style&gt; /*div长宽设置为0，四周border设为同样的值，三个border颜色设置为transparent另一个border设置为想要的三角形的颜色便可得到一个直角三角形*/ div { width: 0; height: 0; border: 20px solid; border-color: transparent transparent red; } /*可以得到一个下边的红色三角形*/&lt;/style&gt; 不过这样得到的三角形其他三个部分仍然占用空间，只是我们把它设置为了透明。 再将border-top的width设置为0即可： 12345678910&lt;div&gt;&lt;/div&gt;&lt;style&gt; div { width: 0; height: 0; border-width: 0 20px 20px; border-style: solid; border-color: transparent transparent red; }&lt;/style&gt; 利用两个三角形重叠形成三角形环1234567891011121314151617181920212223&lt;div class=\"tri_big\"&gt;&lt;/div&gt;&lt;style&gt; div.tri_big { position: relative; width: 0; height: 0; border-width: 0 20px 20px; border-style: solid; border-color: transparent transparent red; } div.tri_big:after { content: ''; position: absolute; left: -16px; top: 3px; width: 0; height: 0; border-width: 0 16px 16px; border-style: solid; border-color: transparent transparent yellow; }&lt;/style&gt; 绘制左/右直角三角形右直角三角形将border-left设置为0 1234567891011&lt;div class=\"tri\"&gt;&lt;/div&gt;&lt;style&gt; div.tri { width: 0; height: 0; border-width: 0 20px 20px 0; border-style: solid; border-color: transparent transparent red; }&lt;/style&gt; 左直角三角形将border-right设置为0 1234567891011&lt;div class=\"tri\"&gt;&lt;/div&gt;&lt;style&gt; div.tri { width: 0; height: 0; border-width: 0 0 20px 20px; border-style: solid; border-color: transparent transparent red; }&lt;/style&gt;","link":"/2019/09/02/css-triangle/"},{"title":"css技巧（长期更新）","text":"总结一下css 的一些技巧。 文本水平居中 123p { text-align: center;} 容器水平居中 先给容器定宽，再margin: 0 auto 1234div { width: 100px; margin: 0 auto;} 文本垂直居中 直接将line-height设置为容器高度即可。 1234567&lt;div&gt;文本&lt;/div&gt;&lt;style&gt; div { height: 18px; line-height: 18px; }&lt;/style&gt; 如果容器内有n行文本，则设置line-height为height/n即可。 容器垂直居中 一个大容器包含一个小容器，让小容器垂直居中。 首先设置大容器高度以及将大容器position: relative，然后小容器定高度以及position: absolute，top设置为50%，margin-top设置为负值的小容器高度的一半。 下面使用calc()简化代码。 calc()函数写法如下，符号两边各空一个空格。 1234567891011121314151617181920212223&lt;div class=\"big\"&gt; &lt;div class=\"small\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .big { height: 100px; position: relative; } .small { height: 20px; position: absolute; top: calc(50% - 10px); } /*或者*/ .small { height: 20px; position: absolute; top: 50%; margin-top: -10px; }&lt;/style&gt; 图片自适应容器 12345678img { max-width: 100%;}/*ie-6写法*/img { width: 100%;} 3D按钮 设置左上为浅色，右下为深色。 1234button { border: 1px solid; border-color: #999 #777 #777 #999;} font简写,注意font-family属性值引号 分开写： 12345678p { font-family: Arial, Helvetica, sans-serif; font-size: 12px; font-weight: bold; font-variant: small-caps; font-style: italic; line-height: 150%;} 写一起： 123p { font: 12px/150% bold small-caps italic Arial, Helvetica, sans-serif;} a标签的伪类 1234a:link {}a:visited {}a:hover {}a:active {} IE条件注释 使用条件注释，引入只对IE生效的语句，比如这里引入只对IE生效的ie.css样式 123&lt;!--[if IE] &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"ie.css\"&gt;&lt; ![endif]--&gt; 区分IE版本： 12345 &lt;!--[if IE 6]&gt; - targets IE6 only --&gt; &lt;!--[if gt IE 6]&gt; - targets IE7 and above --&gt; &lt;!--[if lt IE 6]&gt; - targets IE5.5 and below --&gt; &lt;!--[if gte IE 6]&gt; - targets IE6 and above --&gt; &lt;!--[if lte IE 6]&gt; - targets IE6 and below --&gt; IE6专用语法 ie6视html为根元素，故而以下代码仅对ie6生效。 123* html {}* html body {}* html .class{} IE专用语法 只有ie6可以识别属性前面的下划线 只有ie7可以识别属性前面的通配符 12345.class { background: red; *background: green; _background: blue;} 然而并没有什么卵用。 选择器优先级 1行内样式 &gt; ID &gt; class &gt; 标签 IE6的min-height IE6不支持min-height 解决方法一： 顺序不能乱！ 12345.class { min-height: 100px; height: auto !important; height: 100px;} 解决方法二： 使用了IE6才能识别的_height属性 1234.class { min-height: 100px; _height: 100px;} font-size统一 浏览器默认16px。 可以先设置基准文字大小为10px： 1234body { font-size: 62.5%; /*基准字体大小设置为了10px*/} 后面一律使用em来设置字体： 2.4em就是24px 123h1 { font-size: 2.4em;} 改变字母大小写 123456789101112/*字母设置为大写*/p { text-transform: uppercase;}/*字母设置为小写*/p { text-transform: lowercase;}/*字母设置为首字母大写*/p { text-transform: capitalize;} 1234/*字母设置与小写字母等高的大写形式*/p { font-variant: small-caps;} reset.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;}/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block;}body { line-height: 1;}ol, ul { list-style: none;}blockquote, q { quotes: none;}blockquote:before, blockquote:after,q:before, q:after { content: ''; content: none;}table { border-collapse: collapse; border-spacing: 0;} 修改list图标样式 默认： 123ul { list-style-type: disc;} 自定义图标： 123ul { list-style: url('triangle.png');} 或者： 123456ul { list-style: none;}ul li { background: url('pic.png') no-repeat 0 0.5em;} css中的透明 123div { opacity: 0.5;} css三角形 原理：容器长宽设为0，设置border-width后，对四个border分别着色，可以看到四个不同颜色的等腰直角三角形组成了一个正方形（由border构成）。 容器长宽设置为0，设置border-width border-style: solid,将需要的三角形着色，其他三角形设为透明border-color: transparent。 1234567891011&lt;div class=\"triangle\"&gt;&lt;/div&gt;&lt;style&gt; .triangle { width: 0; height: 0; border-style: solid; border-width: 4px; border-color: transparent transparent red transparent; }&lt;/style&gt; 以上就得到了一个底边长8px红色的相左的等腰直角三角形。 详细css三角形见博客单独文章。 禁止文本自动换行 让文本在一行显示 123p { white-space: nowrap;} 给标题设置图标 不想使用文本，想使用图标替换h1达到更好的视觉效果。但是又不能丧失SEO。 方法： 为容器设置宽高。 设置一个负的大的文本缩进将h1移出视野。 background设置替换的图片。 123456h1 { width: 200px; height: 50px; text-indent: -9999px; background: url('icon.jpg') no-repeat;} :focus 为可以获取焦点的元素设置获取焦点后的样式。 123input:focus { border: 1px yellow solid;} !important 1234p { color: red !important; color: green;} 规则color: red胜出。 值得一提的是IE不支持!important规则，故而可以用来区分IE和非IE浏览器。 提示框 1&lt;a class=\"tips\" href=\"#\"&gt;https://google.com/&lt;span&gt;提示文本&lt;/span&gt;&lt;/a&gt; 123456789101112131415a.tips { position: relative;}a.tips span { display: none; padding: 5px; width: 200px;}a:hover { background: #fff;}a.tips:hover span { display: inline; position: absolute;} 固定header位置 将header标签固定在页面顶部 1234567891011121314151617body{ margin:0;padding:100px 0 0 0;}div#header{ position:absolute; top:0; left:0; width:100%; height:&lt;length&gt;;}@media screen{ body&gt;div#header{position: fixed;}}* html body{overflow:hidden;}* html div#content{height:100%;overflow:auto;} 浏览器兼容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* IE6 and below */ * html #uno { color: red } /* IE7 */ *:first-child+html #dos { color: red } /* IE7, FF, Saf, Opera */ html&gt;body #tres { color: red } /* IE8, FF, Saf, Opera (Everything but IE 6,7) */ html&gt;/**/body #cuatro { color: red } /* Opera 9.27 and below, safari 2 */ html:first-child #cinco { color: red } /* Safari 2-3 */ html[xmlns*=\"\"] body:last-child #seis { color: red } /* safari 3+, chrome 1+, opera9+, ff 3.5+ */ body:nth-of-type(1) #siete { color: red } /* safari 3+, chrome 1+, opera9+, ff 3.5+ */ body:first-of-type #ocho { color: red } /* saf3+, chrome1+ */ @media screen and (-webkit-min-device-pixel-ratio:0) { #diez { color: red } } /* iPhone / mobile webkit */ @media screen and (max-device-width: 480px) { #veintiseis { color: red } } /* Safari 2 - 3.1 */ html[xmlns*=\"\"]:root #trece { color: red } /* Safari 2 - 3.1, Opera 9.25 */ *|html[xmlns*=\"\"] #catorce { color: red } /* Everything but IE6-8 */ :root *&gt; #quince { color: red } /* IE7 */ *+html #dieciocho { color: red } /* Firefox only. 1+ */ #veinticuatro, x:-moz-any-link { color: red } /* Firefox 3.0+ */ #veinticinco, x:-moz-any-link, x:default { color: red } /***** Attribute Hacks ******/ /* IE6 */ #once { _color: blue } /* IE6, IE7 */ #doce { *color: blue; /* or #color: blue */ } /* Everything but IE6 */ #diecisiete { color/**/: blue } /* IE6, IE7, IE8 */ #diecinueve { color: blue\\9; } /* IE7, IE8 */ #veinte { color/*\\**/: blue\\9; } /* IE6, IE7 -- acts as an !important */ #veintesiete { color: blue !ie; } /* string after ! can be anything */ 容器水平和垂直居中 1234&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;img&gt;&lt;/div&gt; 123456789101112131415161718div { width: 100px; height: 200px; display: block; text-align: center; vertical-align: middle;}div * { display: inline-block; height: 100%; vertical-align: middle;}div img { width: auto; height: auto; max-width: 100%; max-height: 100%;} 阴影 text-shadow box-shadow 外阴影： 123456div { -moz-box-shadow: 5px 5px 5px #ccc; -webkit-box-shadow: 5px 5px 5px #ccc; box-shadow: 5px 5px 5px #ccc; /*不带厂商前缀的放在最后*/} 内阴影： 12345div { -moz-box-shadow: inset 0 0 10px #000; -webkit-box-shadow: inset 0 0 10px #000; box-shadow: inset 0 0 10px #000;} 取消IE文本框滚动条 1textarea { overflow: auto; } 图片预加载 纯css预加载： 12345678body:after { content: \"\"; display: block; position: absolute; background: url(\"../image/manage/help/help_item2_01.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_02.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_03.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_04.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_05.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_06.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_07.png?v=201707241359\") no-repeat -10000px -1000px,url(\"../image/manage/help/help_item2_01.png?v=201707241359\") no-repeat -10000px -1000px; width: 0; height: 0}","link":"/2020/03/24/css%E6%8A%80%E5%B7%A7/"},{"title":"Deno试水","text":"Deno: A secure runtime for JavaScript and TypeScript. 安装bash12345# curlcurl -fsSL https://deno.land/x/install/install.sh | sh# brewbrew install deno 开始bash12# exampledeno run https://deno.land/std/examples/welcome.ts","link":"/2020/07/01/deno-install/"},{"title":"防抖(debounce)和节流(throttle)","text":"防抖和节流的目的都是希望一段时间内不要密集调用callback。 应用场景：滚动（防抖），搜索（节流） 防抖所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 有些事件比如 resize, scroll, mousemove 等会被持续的触发，导致 callback 被高频调用，这就要用到防抖。 1234567891011121314151617181920212223242526272829/** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */function debounce(func, wait, immediate) { let timeout; return function() { let context = this; let args = arguments; if (timeout) clearTimeout(timeout); if (immediate) { var callNow = !timeout; timeout = setTimeout(() =&gt; { timeout = null; }, wait); if (callNow) func.apply(context, args); } else { timeout = setTimeout(function() { func.apply(context, args); }, wait); } };} 节流所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 时间戳版和定时器版的节流函数的区别是：时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 123456789101112131415161718192021222324252627282930313233/** * @desc 函数节流 * @param func 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */function throttle(func, wait, type) { if (type === 1) { let previous = 0; } else if (type === 2) { let timeout; } return function() { let context = this; let args = arguments; if (type === 1) { let now = Date.now(); if (now - previous &gt; wait) { func.apply(context, args); previous = now; } } else if (type === 2) { if (!timeout) { timeout = setTimeout(() =&gt; { timeout = null; func.apply(context, args); }, wait); } } };} 总结防抖是控制次数，节流是控制频率。 ref 简版 debounce 和 throttle","link":"/2021/12/18/debounce-and-throttle/"},{"title":"使用curl代替postman","text":"curl是一个命令行工具，功能是发出请求并得到应答，最后输出到终端。 使用 查看源码 12345678# 打印在终端中curl www.baidu.com# 将输出保存为文件curl -o &lt;filename&gt; www.baidu.com# 自动跳转curl -L www.baidu.com 显示头信息 12345# 显示代码和头信息curl -i www.baidu.com# 只显示头信息curl -I www.baidu.com 显示通信过程 12345curl -v www.baidu.com# 查看详细信息curl --trace &lt;filename&gt; www.baidu.comcurl --trace-ascii &lt;filename&gt; www.baidu.com GET/POST GET: 1curl baidu.com/form.cgi?data=xxx POST: 1curl -X POST --data \"data=xxx\" baidu.com/form.cgi 表单编码： 1curl -X POST--data-urlencode \"date=April 1\" baidu.com/form.cgi http动词 默认GET -X参数用来指定动词。 12curl -X POST www.baidu.comcurl -X DELETE www.baidu.com 上传文件 1curl --form upload=@filename --form press=OK [URL] referer 该字段用于指示从哪个url跳转而来 1curl --referer http://www.baidu.com http://www.baidu.com User Agent 该字段表示客户端的代理信息。 模拟用户代理： 1curl --user-agent \"[User Agent]\" [URL] cookie 发送cookie： 1curl --cookie \"name=xxx\" www.baidu.com 增加头信息 1curl --header \"Content-Type:application/json\" http://example.com HTTP认证 1curl --user name:password baidu.com 参考 http://www.ruanyifeng.com/blog/2011/09/curl.html http://www.ruanyifeng.com/blog/2019/09/curl-reference.html","link":"/2020/07/26/curl-postman/"},{"title":"DNS详解","text":"DNS（Domain Name System）：域名解析系统。 DNS的作用是根据域名查找ip，也就是输入一个域名输出一个ip。 域名的层级根域名：.root或者.。 顶级域名：.com、.cn、还有我的.icu都是顶级域名。 次级域名：比如我的域名ownpress.icu。 主机域名：比如proxy.ownpress.icu，主机域名由域名持有者自行分配。 proxy.ownpress.icu.root主机域名.次级域名.顶级域名.根域名 DNS解析过程比如在浏览器中输入了www.ownpress.icu，会发生什么？ 浏览器会查找本地dns缓存，有则返回结果，没有则继续下一步。 查看本地hosts文件有没有记录，有则返回，没有则继续下一步。 Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 需要注意的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。 浏览器向本地dns服务器（运营商提供的）发送查询请求，本地dns服务器收到请求后会查询本地缓存，有则返回，没有则向dns根域名服务器发出查询请求。 根域名服务器收到请求后就返回.icu这个顶级域名的服务器。 本地dns服务器收到返回的.icu顶级域名服务器地址后就给.icu顶级域名服务器发出查询请求。 .icu顶级域名服务器收到查询请求后返回ownopress.icu的地址。 本地dns服务器收到后，向.ownpress.icu这个域名服务器请求查询www.ownpress.icu。 .ownpress.icu域名服务器收到请求后，查询www.ownpress.icu的ip并返回给本地dns服务器。 本地dns收到最终查询结果后将其返回给了用户，不过本地dns服务器不会每次都傻傻的去一层层查询，它会缓存一部分在本地dns服务器中。 DNS缓存时间dns服务器会配置有一个参数TTL(time to live)，也就是dns记录的存活时间。 设置TTL的原因是一个域名对应的ip可能会发生变动导致dns服务器缓存记录失效，另外就是让访问量不是那么大的域名的解析不要一直占用dns服务器的缓存。 超过TTL的记录都会被删除，下次再有用户查询则重新获取。 DNS记录类型 A：地址记录（address），返回域名指向的ip。 NS：域名服务器记录（name server），返回保存下一级域名信息的服务器地址，要设置为域名。 MX：邮件记录（mail exchange），返回接受电子邮件的服务器地址。 CNAME：规范名称记录（canonical name），返回另一个域名，也就是跳转到另一个域名。 PTR：逆向查询记录（pointer record），只用于从ip地址查询域名。 DNS报文结构DNS报文： 同一个dns解析的请求报文和应答报文具有相同的事务ID。 DNS劫持和http劫持dns劫持：中国互联网早期经常出现dns劫持，dns劫持就是dns返回的ip与你要访问的域名的真实ip不符。dns劫持的方法有好几种，第一种是流氓软件或者恶意程序修改了用户本地的hosts文件，第二种是路由劫持，第三种是dns服务器查询并返回了错误的ip，这可能是dns服务器被攻陷了亦或者是dns服务器故意如此。 http劫持： 在用户的客户端与其要访问的服务器经过网络协议协调后，二者之间建立了一条专用的数据通道，用户端程序在系统中开放指定网络端口用于接收数据报文，服务器端将全部数据按指定网络协议规则进行分解打包，形成连续数据报文。 用户端接收到全部报文后，按照协议标准来解包组合获得完整的网络数据。其中传输过程中的每一个数据包都有特定的标签，表示其来源、携带的数据属性以及要到何处，所有的数据包经过网络路径中ISP的路由器传输接力后，最终到达目的地，也就是客户端。 HTTP劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文，目的是让用户端程序解释“错误”的数据，并以弹出新窗口的形式在使用者界面展示宣传性广告或者直接显示某网站的内容。 使用工具管理DNS dig dig可以查询dns记录以及dns解析的过程。 使用：dig +trace www.ownpress.icu查询详细信息。 使用：dig +short www.ownpress.icu查询结果。 使用：dig @8.8.8.8 www.ownpress.icu指定dns服务器。 使用：dig cname www.ownpress.icu查询指定类型的记录。 host host是dig的简化版，返回当前请求域名的各种记录。 用法：host www.ownpress.icu whois 查看域名的注册信息。 用法：whois ownpress.icu nslookup 1nslookup [待查询域名] [指定DNS服务器] 清理本地dns缓存 macos 12sudo dscacheutil -flushcachesudo killall -HUP mDNSResponder linux 使用NSCD的dns缓存： 1sudo /etc/init.d/nscd restart 使用DNSMASQ： 1sudo dnsmasq restart windows 1ipconfig /flushdns 根域名请参考：http://www.ruanyifeng.com/blog/2018/05/root-domain.html","link":"/2020/06/02/dns/"},{"title":"docsify使用方式","text":"docsify是什么？看官网怎么说： A magical documentation site generator. 一个神奇的文档站点生成器。 docsify官网 安装npm全局安装 1npm i docsify-cli -g Mac使用npm安装docsify的时候遇到了错误： 1gyp: No Xcode or CLT version detected! 解决办法： 12sudo rm -rf $(xcode-select -print-path)xcode-select --install 初始化创建目录并初始化： 1docsify init docsify_folder 在已有的目录中初始化： 1docsify init index.html：入口文件 README.md：主页内容 .nojekyll：用于阻止 GitHub Pages忽略掉下划线开头的文件 预览1docsify serve docsify_folder 路由页面路由和文件夹的对应关系如下： 1234docsify_folder/README.md =&gt; http://domain.comdocsify_folder/guide.md =&gt; http://domain.com/guidedocsify_folder/zh-cn/README.md =&gt; http://domain.com/zh-cn/docsify_folder/zh-cn/guide.md =&gt; http://domain.com/zh-cn/guide 导航栏与侧边栏导航栏简单导航条 在index.html中： 1234567&lt;body&gt; &lt;nav&gt; &lt;a href=\"#/\"&gt;LeetCode题解&lt;/a&gt; &lt;a href=\"https://herotiga.github.io\" target=\"_blank\"&gt;我的博客&lt;/a&gt; &lt;/nav&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt; 复杂导航条 通过md文件配置 配置 loadNavbar 为 true： 123456&lt;script&gt; window.$docsify = { loadNavbar: true }&lt;/script&gt;&lt;script src=\"//unpkg.com/docsify\"&gt;&lt;/script&gt; 在 ./docs 下创建一个 _navbar.md 文件，在该文件中使用 Markdown 格式书写导航： 123* 导航1 * [子导航](nav1/child/)* [导航2](nav2/) 侧边栏默认情况下，侧边栏会根据当前文章的标题生成目录。但也可以通过 Markdown 文档生成。 首先配置 loadSidebar 选项为 true： 123456&lt;script&gt; window.$docsify = { loadSidebar: true }&lt;/script&gt;&lt;script src=\"//unpkg.com/docsify\"&gt;&lt;/script&gt; 然后在 ./docs 下创建 _sidebar.md 文件： 12345678910111213141516171819202122232425262728293031323334353637383940* [简介](/)* 数据结构 * [数组](data-structure/array/) * [字符串](data-structure/string/) * [链表](data-structure/linked_list/) * 树 * [递归](data-structure/tree/recursion/) * [层次遍历（BFS）](data-structure/tree/bfs/) * [前中后序遍历（DFS）](data-structure/tree/dfs/) * [其他](data-structure/tree/other/) * [堆](data-structure/heap/) * [栈](data-structure/stack/) * [哈希表](data-structure/hash/)* 算法思想 * 排序 * [堆排序](algorithm/sort/heap/) * [快速排序](algorithm/sort/quick/) * [冒泡排序](algorithm/sort/bubble/) * [其他](algorithm/sort/other/) * 搜索 * [深度优先](algorithm/research/dfs/) * [广度优先](algorithm/research/bfs/) * [二分查找](algorithm/research/binary-search/) * [动态规划](algorithm/dynamic/) * [贪心](algorithm/greedy/) * [位运算](algorithm/bit/) * [数学题](algorithm/math/) * [其他](algorithm/other/)* 周赛 * [第 121 场周赛](weekly/121/) * [第 122 场周赛](weekly/122/) * [第 124 场周赛](weekly/124/) * [第 129 场周赛](weekly/129/) * [第 130 场周赛](weekly/130/) * [第 131 场周赛](weekly/131/) * [第 133 场周赛](weekly/133/) * [第 134 场周赛](weekly/134/) * [第 136 场周赛](weekly/136/) * [第 137 场周赛](weekly/137/) * [第 138 场周赛](weekly/138/) 插件代码高亮使用 Prism 作为代码高亮插件，可以在 index.html 中这样配置： 123&lt;script src=\"//unpkg.com/docsify\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/prismjs/components/prism-bash.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/prismjs/components/prism-php.js\"&gt;&lt;/script&gt; 注意这里引入的文件，如果你要高亮 Python 代码，那么就要引入： 1&lt;script src=\"//unpkg.com/prismjs/components/prism-python.js\"&gt;&lt;/script&gt; 对不同语言的高亮支持可见 Prism 仓库。 部署我的 Github Pages 读取的是 gh-pages 分支下的代码，因此我要把 ./docs 下的文件上传到 gh-pages 分支上，完整的代码则上传的到 master 分支。 为了方便更新，我在项目根目录下放置了一个用于推送代码的脚本 push.sh： 12345678910111213141516message=$1# 复制 README.mdcp README.md docs/README.md# 更新 mastergit add .git commit -m \"$message\"git push -f git@github.com:JalanJiang/leetcode-notebook.git master# 更新 gh-pagescd docs/git initgit add -Agit commit -m \"$message\"git push -f git@github.com:JalanJiang/leetcode-notebook.git master:gh-pages","link":"/2019/05/14/docsify-usage/"},{"title":"Emmet常用写法","text":"整理一下Emmet常用写法。 Emmet一般IDE都支持，tab即可生成dom树，非常快捷，再tab既可依次输入内容。 编辑器需要安装插件。 选择器生成 p p{content} p.class p#id a[href=&quot;https://baidu.com&quot;] div&gt;span h1+p div&gt;ul&gt;li^span 123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 这里 ^ 是代表上级节点，这里就是让 span 成为 li 的上级节点，也就是成为 ul 的兄弟节点。 然后tab生成结构。 连写 li*3&gt;a 效果： 123&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; 自动编号 div#id_name$.class_name$$*3 其中 $ 表示位数为一的序号， $$ 表示拥有两位的序号。 效果： 123&lt;div id=\"id_name1\" class=\"class_name01\"&gt;&lt;/div&gt;&lt;div id=\"id_name2\" class=\"class_name02\"&gt;&lt;/div&gt;&lt;div id=\"id_name3\" class=\"class_name03\"&gt;&lt;/div&gt; 从指定序号开始生成： div#id_name$@3*5 倒序生成： div#id_name$@-*5 倒序并指定序号： div#id_name$@-10*5 综合方式 header+nav+article 效果： 123&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;article&gt;&lt;/article&gt; nav&gt;ul&gt;(li&gt;a[href=#]{Link})*5 效果： 123456789&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; table&gt;(thead&gt;tr&gt;th*5)(tbody&gt;tr&gt;td*5) 这里 () 里为一个代码块。 {} 里面写内容 效果： 1234567891011121314151617181920&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 生成html基本结构 ! 效果： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 隐式标签:未指定标签 .class_name 效果： 1&lt;div class=\"class_name\"&gt;&lt;/div&gt; ul&gt;.item$*3 效果： 12345&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt;&lt;/ul&gt; 生成属性 标签:属性 form form: form:get form:post input:input:b or input:button input select: select&gt;option*3 select&gt;[value=&quot;item$&quot;]*3 XML的生成 root&gt;player*3 root&gt;player#$*3 root[match=&quot;nba&quot; title=&quot;1nba&quot;]&gt;player#$$*4 name+age+sex+address root&gt;player#$*3&gt;name+age+sex+address css的生成 margin: m m10 m10p m10r m10-20-10-20 m10p20p mt10 mr10 mb10 ml10 m-10 m-10--20 padding: p color: c c#f c#f0 color:rgb color:rgba 常用生成写法：pore : position: relative; posa : position: absolute; d:n : display: none; d:b : display: block d:i : display: inline ov:h : overflow: hidden; cur:p : cursor: pointer; ta:c : text-align: center; 以此类推。 cheatsheet 发掘更多：https://docs.emmet.io/cheat-sheet/","link":"/2020/03/25/emmet/"},{"title":"ES6学习笔记——简介","text":"es6笔记 ECMAScript和JavaScript的关系ECMAScript是JavaScript的规格，JavaScript是ECMAScript的一种实现（还有JScript和ActionScript）。日常场合，这两个词是可以互换的。 ES6与ECMAScript2015的关系ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。本书中提到ES6的地方，一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言”。 ECMAScript的历史Node.js是JavaScript的服务器运行环境（runtime）。它对ES6的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看Node.js默认没有打开的ES6实验性语法。 12345# Linux &amp; Mac$ node --v8-options | grep harmony# Windows$ node --v8-options | findstr harmony Babel转码器Babel是一个es6转码器，可以将es6转为es5代码以提高es6代码的向下兼容。 实例比如： 1234567// 转码前, es6的肩头函数input.map(item =&gt; item + 1);// 转码后, es5的普通函数input.map(function(item) { return item + 1;}); 安装在项目目录中使用Babel： 1cnpm install --save-dev @babel/core 配置文件安装完了第一步就是要配置 .babelrc 文件。 配置文件存在于项目根目录下，用于配置转码规则和插件： 1234567{ // 用于设定转码规则 &quot;presets&quot;: [], // 用于设定插件 &quot;plugins&quot;: []} 安装转码规则： 12345# 最新转码规则$ npm install --save-dev @babel/preset-env# react转码规则$ npm install --save-dev @babel/preset-react 添加到 .babelrc : 1234567{ &quot;presets&quot;: [ &quot;@babel/env&quot;, &quot;@babel/preset-react&quot; ], &quot;plugins&quot;: [] } 命令行转码安装命令行转码器： 1cnpm install --save-dev @babel/cli 使用： 1234567891011121314151617# 转码结果输出到标准输出$ npx babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ npx babel example.js --out-file compiled.js# 或者$ npx babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ npx babel src --out-dir lib# 或者$ npx babel src -d lib# -s 参数生成source map文件$ npx babel src -d lib -s 参考 阮一峰ES6教程：https://es6.ruanyifeng.com/","link":"/2021/09/08/es6-note-01-%E7%AE%80%E4%BB%8B/"},{"title":"使用es6简化代码","text":"es6简化代码。 块作用域使用 var : 123456for (var i = 0; i &lt; 5; i++) { setTimeout(() =&gt; { console.log(i) }, 1000)}// 5 5 5 5 5 使用 let : 123456for (let i = 0; i &lt; 5; i++) { setTimeout(() =&gt; { console.log(i) }, 1000)}// 0 1 2 3 4 es5使用闭包可以实现块作用域的效果。 解构使用解构简化变量声明和赋值1234567// es5let a = 1;let b = 2;let c = 3;// es6let [a, b, c] = [1, 2, 3]; 使用解构交换变量123456789101112// es5let a = 1;let b = 2;let tmp;tmp = a;a = b;b = tmp;// es6let a = 1;let b = 2;[a, b] = [b, a] 使用对象解构给对象赋值123456789let obj = { x: 1, y: 2, c: 1}let { x, y} = obj; 字符串解构1let [a, b, c, d, e] = 'hello'; 函数参数解构12345678910111213const PERSON = { name: 'Mason', age: 22,}function getAge({ name, age}) { return `${name}今年${age}岁`}getAge(PERSON); 箭头函数箭头函数内部 this 指向定义时所在对象且固定不变。 12345678910111213// es5var func(param) { return ret;}// es6, 没参数var func = () =&gt; ret// es6, 单个参数var func = param =&gt; ret// es6, 多个参数var func = (param1, param2) =&gt; ret 模板字符串用于在字符串中嵌入变量。 123const NAME = 'Mason';const AGE = 22;const SELF_STATEMENT = `My name is ${NAME}, 今年${AGE}岁`; 展开符... 变量名 用于获取函数的多余参数可以代替 arguments 对象。... 变量名 可以将一个数组转化为用逗号隔开的参数序列 param1, param2, ...paramN 用展开符合并数组： 123let arr1 = [1, 2, 3];let arr2 = [4, 5, 6];let arr = [...arr1, ...arr2]; 用展开符取得对象中的属性和方法并拷贝到新对象中，只能对基本数据类型拷贝，如果成员含有引用类型则为浅拷贝。 12345678let obj1 = { name: 'Mason', age: 22};let obj2 = { ...obj1}; 对象字面量简写12345678910let name = 'Mason';let age = 22;let person = { name, age, printName() { console.log(this.name); }}; 数组的 includes() 判断数组中是否存在给定值可以判断是否含有 NaN 1234567891011[1, 2, 3].includes(2);// true[1, 2, 3].includes(4);// false[1, 2, 3, NaN].includes(NaN);// true[1, 2, 3].includes(NaN);// false async/await 异步语法1234567async function getData(url) { let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([sS]+)&lt;/title &gt; /i)[1] }getData(url).then(res) =&gt; console.log('success!'); 上面代码的执行顺序是：先执行 getData() 里面的三个操作，等待三个操作全部执行完毕再执行 then() 中的语句。","link":"/2021/09/08/es6%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/"},{"title":"ES6学习笔记——let和const","text":"let 和 const 是es6新增的用于声明变量的命令 。let 用于可以代替 var ，用于声明作用域为该代码块的变量。const 用于声明作用域为该代码块的常量。 es5和es6声明变量的几种方式es5 var function es6 var function let const import class let作用域ES6新增了 let 命令用于声明变量，只在所在代码块内有效。 实例： 123456{ let a = 1; var b = 2;}a // ReferenceError: a is not defined.b // 2 实例： 1234567// 这里的i的作用域仅仅在循环体内for (let i = 0; i &lt; 10; i++) {}i// ReferenceError: i is not defined 实例： 123456789var a = [];// 这里var声明的i为全局变量for (var i = 0; i &lt; 10; i++) { a[i] = function() { console.log(i); };}a[6](); // 10 1234567var a = [];for (let i = 0; i &lt; 10; i++) { a[i] = function() { console.log(i); };}a[6](); // 6 for 循环中： () 内和 {} 内不是同一个作用域， () 位于 {} 的父作用域，孤儿 {} 内部可以再次声明已经在 () 中声明过的变量。 12345678for (let i = 0; i &lt; 3; i++) { // 这里重新声明了i覆盖了上面的声明 let i = 123; console.log(i);}// 123// 123// 123 另外：在同一个作用域内不可以使用 let 重复声明同一个变量。 没有变量提升var 有变量提升。let 没有变量提升。 故而， let 需要先声明后使用。 实例： 1234567// var，这里使用var声明的foo会被提升到顶部，但是对于foo的赋值没有被提升到顶部，故而可以获取到foo但是为undefinedconsole.log(foo); // 输出undefinedvar foo = 2;// let，这里使用let声明的bar不会被提升到顶部，会报引用错误console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区(TDZ)只要块级作用域内存在 let ，那么它所声明的变量就绑定了这个作用域且不受外部影响。 实例： 123456var tmp = 123;if (true) { tmp = 'abc'; // ReferenceError let tmp;} 这里很奇怪的一点就是：js代码是自上往下顺序执行的，代码块内如何提前知道下面有let声明了某个在let之前就被操作了的变量并在let之前就抛出错误呢？ 找到了stackoverflow的说法：let和const也是存在变量提升的，只是不像var变量提升的时候会被初始化为undefined，let和const会一直保持未初始化的状态。 实例： 123456789101112if (true) { // TDZ开始 temp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123} 正因为 let 的TDZ特性，使得很多在 let 声明一个变量之前对于这个变量做的操作失效。 故而，在一个代码块内，对于一个变量，一定要先使用 let 声明后使用。 实例：隐蔽的死区 12345function bar(x = y, y = 2) { return [x, y];}bar(); // ReferenceError 这里y还没声明就赋值给了x，也就是y还没被声明就被使用了，此时为TDZ故而报错。 实例： 12345// 不报错var x = x;// 报错let x = x; 软神的这句话可能有误： ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总而言之：需要先let声明后使用，否则就报错。不允许重复声明不允许使用 let 在同一作用域内多次声明一个变量，否则报错。 块作用域es5作用域es5的作用域：只有全局作用域和函数内作用域。 实例：函数体内部的声明覆盖了全局声明 1234567891011var tmp = new Date();function f() { console.log(tmp); if (0) { var tmp = 'abc'; }}f();// undefined 这里编写代码的本意是在 console.log 这行使用外部 tmp ，在 if 循环体内部重新声明变量 tmp ，但是结果却是 undefined 。原因是循环体内部对于 tmp 的声明被提升到了函数的顶部，故而 console.log 打印的是已经被在函数内声明的 tmp 。 实例：计数变量泄露为全局变量 1234567891011121314var s = 'hello';for (var i = 0; i &lt; s.length; i++) { console.log(s[i]);}// h// e// l// l// o// undefinedconsole.log(i);// 5 这里的 i 最终被计算成了5，并且是一个全局变量，造成了变量泄露。 es6作用域es6的作用域： let 为js提供了块作用域， let 声明的变量作用域仅在其所处的代码块内，并且外层代码块不受内层代码块的影响。 实例： 123456789function f1() { // 这里声明的n的作用域在函数内部 let n = 5; if (true) { let n = 10; // 这里声明的n的作用域仅在if内部 } console.log(n); // 5} 实例：es6允许块作用域任意层嵌套， 内层可以访问外层，外层无法访问内层。 1234567{ let num = 1; { let num = 2; { let num = 3; } }} 块作用域可以替代IIFE： 123456789101112131415// IIFE写法(function() { var tmp = 123; console.log(tmp); // 123})();// 外部不可访问// 块作用域替代{ let tmp = 123; console.log(tmp); // 123}// 外部不可访问 块作用域和函数声明那么函数可以在块作用域内声明吗？ es5：只能在全局声明或者函数内作用域声明，但是浏览器不会报错。 es6：允许在块作用域内声明函数。 实例：下面的代码在es5中运行会得到 I am inside! ，因为if内部的重新声明会被提升到函数顶部从而覆盖了外部的声明。而如果在es6中运行理论上会得到 I am outside! 但是实际上在浏览器中运行都会报错，原因是这段代码在es5和在es6中的运行结果截然相反，故而会导致严重的问题，为了保证对es5的兼容会在es6中报错。 1234567891011121314function f() { console.log('I am outside!');}(function() { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f();}()); 故而不要在块作用域内部声明函数或者如果要声明也要携程函数表达式。 123456789// 不建议{ function f() {}}// 如果要在块内部声明函数则用表达式{ let f = function() {}} es6的块作用域必须有大括号 {} ，否则js不认为其是块作用域。实例： 1234567// 没有写大括号，报错if (1) let x = 1;// 正确写法if (1) { let x = 1;} 123456'use strict';// 这个函数作用域仅在if内部if (1) { function f() {}} const基本用法const 声明一个只读的常量，其指向一个内存空间，内存空间内容不可改变。故而 const 声明时就要赋值，因为一旦声明之后就无法改变。 const 的作用域和 let 一样：只在其所声明的块作用域内有效。const 也存在TDZ，也需要先声明并赋值后使用。const 也不可以重复声明。 const的本质const 实质上是保证 const 变量指向的内存空间的内容不变。对于基本数据类型而言：指向的内存空间就是保存了基本类型的数据（布尔，字符串，数字），故而一旦使用 const 声明了基本数据类型就无法改变。对于符合数据类型而言：指向的内存空间保存了这个复杂类型的指针，而指针又指向了另外一个或者多个内存空间，这里的内存空间才是真正保存了复杂类型下的基本类型的值。 实例： 123456789const person = {};person.name = 'mason';person.age = 22;// 修改person对象的属性均成功person = {};// 报错// 这里给person赋了一个新的值{}，这里的{}内存地址和原来的不一样故报错 实例： 1234567const arr = [];arr.push('a');// 成功arr = ['b'];// 报错// 这里给arr赋值了新的内存空间故而报错 顶层对象的属性浏览器中的顶层对象是 window 对象。node环境中的顶层对象是 global 对象。 在es5中：顶层对象的属性和全局变量等价。 12345window.person = 'mason';person // 'mason'person // 'mason'window.person // 'mason' 在es6中： var 和 function 声明的仍然是顶层对象的属性（或者说全局变量），而 let , const , class 声明的全局变量不属于顶层对象的属性。 12345678// 这两种写法等价var name = 'mason';window.name = 'mason';// \blet声明的变量不属于顶层对象的属性let name = 'mason';window.name// undefined globalThis对象上面说了js在浏览器环境和在node环境中的顶层对象不同，或者说“在各个js的实现里面，顶层对象不统一。” 为了能让代码能适应多个实现的环境，在es2020里面引入了 globalThis 对象，该对象存在于所有环境，可以通过其拿到顶层对象。 浏览器环境1234// 全局作用域下，以下均为truewindow === thiswindow === globalThisthis === globalThis node1234// 全局作用域下，以下均为trueglobal === thisglobal === globalThisthis === globalThis","link":"/2021/09/08/es6-note-02-let-const/"},{"title":"ES6学习笔记——字符串的扩展","text":"字符的unicode表示法 123456// 单字节表示，只能表示\\u000-\\uFFFF之间的字符'\\u0061' // 'a'// 双字节表示'\\uD842\\uDFB7''𠮷' 字符串的遍历器接口es6为字符串添加了遍历器接口，所以可以使用 for...of 遍历字符串。 123for (let ch of 'asdfgh') { console.log(ch);} for...of 可以遍历unicode的字符串， for 不可以。 123456789101112let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) { console.log(text[i]);}// \" \"// \" \"for (let i of text) { console.log(i);}// \"𠮷\" JSON.stringify()的扩展es2019对于 JSON.stringify() 的心行为是保留unicode供开发者自己决定。 12JSON.stringify('\\u{D834}') // \"\"\\\\uD834\"\"JSON.stringify('\\uDF06\\uD834') // \"\"\\\\udf06\\\\ud834\"\" 模板字符串jQuery插入html： 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); es6模板字符串插入html：使用反引号包裹html字符串，使用 ${var_name} 来引用变量，可以作为普通字符串使用，直接回车多行。 12345$('#result').append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale!`); 括号内部可以是任意js表达式包括调用函数。大括号中最后都会转化为字符串( toString() )。 模板字符串可以嵌套。 模板可以写成函数，需要的时候调用这个函数。","link":"/2021/09/15/es6-note-04-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"ES6学习笔记——变量的解构赋值","text":"数组的解构赋值基本用法对称解构只要等号两边的模式相同，左边的变量就会被赋予对应的值。 一次性给三个变量赋值： 12let [a, b, c] = [1, 2, 3];let [x, , y] = [1, 2, 3]; 给多维数组赋值： 1let [a, b, [c, d]] = [1, 2, [3, 4]]; rest: 123let [head, ...tail] = [1, 2, 3, 4];tail// [2, 3, 4] 如果解构不成功则被赋值为 undefined 。 非对称解构12let [x, y] = [1, 2, 3];// 也成功 如果等号的右边是不可比遍历的解构则报错。 Set12let [x, y, z] = new Set([1, 2, 3]);// 成功 只要数据类型具有Iterator接口就可以使用数组结构。 默认值指定默认值： 12345let [name = 'mason'] = [];name // 'mason'let [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' es6内部判断一个位置是否有值： 严格等于 undefined 才会赋予默认值，也就是说除了 undefined 不能作为默认值其他都可以。 12345let [x = 1] = [undefined];// x = 1let [x = 1] = [null];// x = null 如果默认值是一个表达式，那么这个表达式不会执行并返回值，因为表达式是惰性求值的。 123456function f() { return 1;}let [a = f()] = [2];// a为2 对象的解构赋值123let {a, b} = {a:'a', b: 'b'};// a: 'a'// b: 'b' 对象的解构没有次序限制，变量名需要和属性名相同。 123let {a, b} = {b: 'b', a: 'a'};// a: 'a'// b: 'b' 如果解构失败，变量的值为undefined。 使用对象解构赋值可以动态的给变量赋值： 12345678910111213141516let Math = { log: function() { }, sin: function() { }, cos: function() { }, tan: function() { }, ...};let {log, sin, cos} = Math; 如果变量名和属性名不一致，则要写成这样： 1234// 这里的aa和bb相当于a和b的别名let {a: aa, b: bb} = {b: 'b', a: 'a'};// aa: 'a'// bb: 'b' 也就是说对象的解构赋值是如下机制：先找到同名属性然后赋值给对应的变量。 1let {foo: foo, bar: bar} = {foo: 'a', bar: 'b'}; 对象的解构也可以嵌套： 12345678910let obj = { p: [ 'Hello', { y: 'World' } ]};let { p: [x, { y }] } = obj;x // \"Hello\"y // \"World\" 默认值对象的解构也可以指定默认值，具体同数组的解构一样。 默认值生效的条件是对象的属性值=== undefined。 1234567// 生效let {x = 3} = {x: undefined};// x = 3// 不生效let {x = 3} = {x: 1};// x 1 注意点 如何解构一个已经声明了的变量： 12let x;({x} = {x: 1}); 对于类似数组的对象也可以与数组结构 12let arr = [1, 2, 3];let {0: 'a', 1: 'b', 2: 'c'} = arr; 字符串的解构赋值对于非对象和数组的类型在被解构时会先被转为包装对象： 1234let [a, b, c] = 'why';let {length: len} = 'hello';// len = 5 数值和布尔值的解构赋值对于非对象和数组的类型在被解构时会先被转为包装对象： 12345let {toString: s} = 123;s === Number.prototype.toString // truelet {toString: s} = true;s === Boolean.prototype.toString // true undefined和nullundefined和null无法转为对象故而在结构时会报错。 函数参数的解构赋值12345678910111213141516171819202122function add([x, y]) { return x + y;}add([1, 2]);function move(x = 0, y = 0) { return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3}); // [3, 0]move({}); // [0, 0]move(); // [0, 0]function move({x, y} = { x: 0, y: 0 }) { return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3}); // [3, undefined]move({}); // [undefined, undefined]move(); // [0, 0] 圆括号问题不能使用圆括号的情况 变量声明 参数函数 赋值语句模式 可以使用圆括号的情况 赋值语句的非模式部分 123[(a)] = [1];({p: (d)} = {});[{parseInt.prop}] = [3]; 变量解构的用途 交换变量 1[x, y] = [y, x]; 从函数返回多个值 函数只能return一个值，想要返回多个值就要把他们放到数组或者对象里面。 12345678// 以返回对象为例function f() { return { foo: 1, bar: 2 };}let {foo, bar} = f(); 函数参数的定义 1234567// 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1}); 提取JSON 1234567let data = { name: 'wang', age: 22, isMarried: false};let {name, age, isMarried} = data; 函数参数的默认值 1234567let f = function({ name = '', age = 0, isMarried = false,} = {}) { // 操作参数 } 遍历Map 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) { console.log(key + \" is \" + value);}// first is hello// second is world 123456789// 获取键名for (let [key] of map) { // ...}// 获取键值for (let [,value] of map) { // ...} 输入模块的指定方法 1const { SourceMapConsumer, SourceNode } = require(\"source-map\");","link":"/2021/09/10/es6-note-03-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"前端面试系列（一）","text":"var和let的区别var声明在函数中则作用域就是该函数，声明在函数外则作用于为全局，js引擎执行代码时会提升变量到顶部。 let作用域为当前所处的代码块，没有变量提升故而要先声明后使用，且不允许在相同作用域中重复声明同一个变量。 实例1：作用域对比 123456{ let a = 123; var b = 321;}a // 引用错误b // 321 实例2：let在for循环中的使用 12345for (let i = 0; i &lt; 5; i++) { console.log(i); // 0 1 2 3 4}console.log(i); // 引用错误 实例3：常见面试题 12345for (var i = 0; i &lt; 10; i++) { setTimeout(function() { console.log(i); // 执行的时候同步代码for已经执行完毕 },0);} 1234567891010101010101010101010 12345for (let i = 0; i &lt; 10; i++) { setTimeout(function() { console.log(i); // 这里的i的作用域是循环体内，不受外界影响 },0);} 123456789100123456789 实例4：for循环特点，()中的是父作用域，{}中是子作用域。 1234for (let i = 0; i &lt; 3; i++) { let i = 'love'; console.log(i);} 123lovelovelove == 和 === 有什么区别==允许自动类型转换 ===不允许自动类型转换 this 在对象方法中，this指向调用它所在方法的对象。 在全局环境中，this指向全局对象。 在函数中，this指向函数的所有者。 在函数中，严格模式，this指向undefined。 在事件中，this指向接收事件的元素。 call()和apply()可以指定函数执行的上下文环境，即this绑定的对象，可以将this引用到任何对象。 以下实例均在浏览器环境中运行。 实例1：方法中的this指向调用该方法的对象。 123456789var person = { firstName: \"mason\", lastName: \"wong\", fullName: function() { return this.firstName + ' ' + this.lastName; }};person.fullName();// 'mason wong' 实例2：单独使用this，指向全局对象（严格模式也是）。 12console.log(this);// window 实例3：函数中使用this，指向函数所有者，也就是全局对象。 12345function func() { return this;}func();// window 实例4：严格模式下，函数中使用this，指向undefined。 123456\"use strict\";function func() { return this;}func();// undefined 实例5：事件中的this，指向接收事件的html元素。 1&lt;button onclick=\"this.style.display='none'\"&gt;点击我消失&lt;/button&gt; 实例6：对象方法中绑定，这里对象是函数的所有者。 12345678var person = { firstName : \"John\", lastName : \"Doe\", id : 5566, myFunction : function() { return this; }}; 实例7：显式函数绑定 使用call和apply切换函数执行上下文环境（context），也就是指定this指向的对象。 1234567891011var person1 = { fullName: function() { return this.firstName + \" \" + this.lastName; }}var person2 = { firstName:\"John\", lastName: \"Doe\",}person1.fullName.call(person2); // \"John Doe\" 上面这个例子中调用person1.fullName()方法，使用call()指定了this指向的对象为person2，故而取得了person2中的firstName和lastName。 什么是构造函数使用new关键字调用的函数为构造函数，通常构造函数的函数名首字母大写。 构造函数的样子如下： 12345function Person(name, gender, hobby) { this.name = name; this.gender = gender; this.hobby = hobby;} 这样就可以通过new来调用，也就是通过new构造函数传入参数并快速创建对象： 1var p1 = new Person('小明', '男', '足球'); 这样就达到了代码复用。 确定一个函数是构造函数的方法是看是否使用new调用了它。 构造函数执行过程 使用new调用后会创建一个新的内存空间分配给实例。 函数题内部的this指向该内存空间。 执行函数题内代码 默认返回this。 如何将基于回调的函数转换为基于Promise的函数实例：将getData回调函数转换为Promise 12345678910111213141516171819202122232425262728293031// the function itselffunction getData(callback, errorCallback) { try { // Do some network/api stuff... callback(result) } catch (e) { errorCallback(e); }}// Here is how you would use it:getData(result =&gt; console.log(result), error =&gt; console.error(error));// Here is how to create a Promise-based function from it:function getDataAsync() { return new Promise((resolve, reject) =&gt; { getData(resolve, reject); });}getDataAsync() .then(result =&gt; console.log(result)) .catch(error =&gt; console.error(error));// ORasync functoin main() { const result = await getDataAsync(); console.log(result);} Promise构造函数接受一个回调，该回调接收两个函数：resolve和reject。在回调内部，你可以执行耗时的任务，并根据结果调用resolve或reject。 NaN === NaN ?结果：false NaN不===于任何值 0.1 + 0.2 === 0.3 ?结果：false 事实上：0.1 + 0.2 = 0.30000000000000004 原因：js中的数字以IEEE 754的双精度标准存储。无法精确表示0.1和0.2，故而结果对不对就看运气。 解决方法：将浮点数转化为整数运算。 10.1 + 0.2 1(1 + 2) / 1e1 输出： 10.3 js中的原始数据类型是什么Boolean Number String 什么是严格模式1'use strict'; 以下省略一千字。 以下代码的输出是什么12345678function func() { return { a: 'b'; }}console.log(func()); 输出： 1undefined 原因： js会在第二行的return后面自动添加分号;，将后面的{}代码块视为作用域而不是对象定义。","link":"/2020/04/15/fed-interview-01/"},{"title":"转载：前端高频面试题整理","text":"作者：Big shark@LX原文链接：https://juejin.im/post/5eb250f3f265da7bf6742594备用链接：https://mp.weixin.qq.com/s/Jyc_OHmHiTyuIjaVf02F9w","link":"/2020/05/23/fed-interview-reship-01/"},{"title":"备案小记","text":"昨天下午给这个网站提交了备案，今天早上就完全备案完了，也在footer悬挂了ICP备案信息，就来记录一下备案的过程以及备案的痛点。 首先，备案有两种：ICP备案和公安备案。ICP备案是在中国大陆运行的所有网站都需要备案的，当然，我的网站由github page托管，服务器不在国内所以其实不用备案。 但是迫于前几天收件撸了一个阿里云的dcdn（全站加速）。dcdn和cdn的区别？dcdn就是对网站的所有资源进行加速而不是cdn仅对静态资源进行加速。但是你懂的，像大陆IDC提供的其他服务一样，使用dcdn也是需要以网站备案为前提的，故而没办法只能进行备案。 公安备案是你的网站在大陆境内进行业务的话会需要这个备案，我作为一个个人博客是不需要备案的。当然还有很多其他各种专项备案，大家看大型网站底部总是能发现一堆的备案信息，其实都是各种专项的东西，个人使用的博客站只需要ICP备案即可。 软硬环境服务器使用了github提供的github page服务，这个服务提供了免费的静态页面的托管服务以及一个github.io的次级域名。 网站使用了hexo这个静态博客生成器，hexo可以再本地编辑修改配置文件来给网站一定的信息以及本地编写文章，再编译为静态文件后部署到github page上面。就我以前用wordpress的经验来看，越接近服务器的博客方案维护成本越高，我使用服务器搭建wordpress的时候需要自己购买服务器域名，自己维护服务器的web服务器环境比如LAMP或者LNMP，自己搞SSL证书，自己搞重定向以及配置端口。这还不是全部，wordpress一周一个小版本一个月一次大版本的更新实在受不了，还有各种插件的更新以及兼容的问题。所以自建服务器以及自建站点实在是太费心费力了。 域名ownpress.icu是在阿里云购买的，dns解析也没改也是阿里云的dns。 开始备案我的域名是购于阿里云但是我的服务器实际是位于海外的，点进阿里云的备案系统后到了第二步发现需要填写服务器的一个id，但是我并没有在阿里云购买。这个时候其实上只要去淘宝购买一个备案服务号就可以填写进去从而不用提供主机信息了。 填写信息接下来就是在阿里云填写各种个人信息以及身份证和摄像头人脸识别等等。这个过程真的让我感觉我就是一颗韭菜，嗯，这里省略一万字。最后提交 提交审核写完了就可以提交了，提交了以后会先送到阿里云进行初审，阿里云初审通过后会提交到管局（管局就是工信部下面管理网站的一个部门）进行审核。 备案完成没什么问题的话管局就会给你发一个短信和一封邮件告诉你成功了，并提醒你悬挂ICP备案信息在网站footer，不然可能会罚款5000-10000元。 悬挂ICP在主题layout目录下找到footer.*文件，我的主题是footer.ejs模板文件，在对应位置添加a链接即可。","link":"/2020/06/08/filing/"},{"title":"获取url参数","text":"获取url参数。 12345678910const getUrlParam = function(param_name) { var reg = new RegExp(\"(^|&amp;)\" + param_name + \"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if (null != r) return unescape(r[2]); return null;}// url: https://www.baidu.com/s?wd=%E5%AD%97%E6%AE%B5&amp;rsv_spt=1&amp;rsv_iqid=0xd0b8cedf0003ddd6&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_btype=t&amp;inputT=1124&amp;rsv_t=5d5fy7IgBRPdzAzH14Trm1rHQHMc7tyfekRowuJWwzCd44xNsWtYNcwkvDVBRPAttnsv&amp;rsv_sug3=11&amp;rsv_sug1=7&amp;rsv_sug7=100&amp;oq=get&amp;rsv_pq=f54d93940005c478&amp;rsv_sug2=0&amp;rsv_sug4=5075getUrlParam('wd');// \"字段\"","link":"/2018/02/20/getUrlParam/"},{"title":"前端面试系列（二）","text":"如何理解执行上下文 每一段js代码的执行之前都会创建一个上下文环境 JavaScript执行上下文是指代码运行环境。 执行上下文有三种： 全局执行上下文 函数执行上下文 eval执行上下文 如何理解作用域链 JavaScript代码执行前会创建上下文环境（包含变量、作用域链、this） 也就是从当前环境向父级一层层的查找变量的过程，这个链就是作用域链。 实例： 12345var name = 'wang'function hello() { console.log(name);} 以上代码：执行 hello() 的时候，会先在hello()的作用域内查找变量 name ，如果没有找到则去hello()的父级作用域查找。 如何理解原型链每个函数都有一个 prototype 属性，每个函数实例对象都有一个 __proto__ 属性，这个属性指向函数的 prototype 。 当我们访问实例对象的属性或者方法的时候，会先从自身构造函数中查找，如果找不到就通过 __proto__ 去原型中查找，这个查找过程所访问的链就是原型链。 实例： 123456789101112131415161718192021222324// parent classfunction Human() { this.age = 30; this.say = function() { return 'hello'; }}// son classfunction Man() { this.name = 'Adam';}// son class inherits parent class via prototype chainMan.prototype = new Human();// create a Man() examplevar lee = new Man();// compare,return truelee.__proto__ === Man.prototype;// print \"age\",return 30console.log(lee.age); 上面会先查找 lee 再查找 Human ，找不到再往上找。 闭包闭包就是定义在一个函数内部的函数，这样就可以使用内部函数访问到外部函数中的局部变量。 实例： 正常情况下无法访问到函数内部的局部变量： 1234function f1() { var name = 'mason';}console.log(name); 输出： 1undefined 使用闭包： 12345678function f1() { var name = 'mason'; return function f2() { console.log(name); }}var f = f1();f(); 输出： 1mason 总结： 由于在 JavaScript 中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如 f2 记住了它诞生的环境 f1 ，所以从 f2 可以得到 f1 的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 继承有哪些方法 原型继承 构造继承 实例继承 call(),apply() ES6的class extends 深拷贝、浅拷贝javascript的数据类型总体分为基本类型和引用类型。 基本类型保存值，引用类型保存指针。 浅拷贝：共用一个引用地址，方法有直接对象复制、 Object.assign 。 深拷贝：创建新的内存地址，方法有：先 JSON.stringify 转化为字符串再 JSON.parse ，还有深度递归遍历。 如何判断一个对象是数组方法： 1Object.prototype.toString.call([]) 输出： 1\"[object Array]\" 数组有哪些方法 push() pop() shift() unshift() concat() join() reverse() sort() map() forEach() filter() indexOf() includes() slice() splice() slice()和splice()的区别： slice()：截取数组，参数有起始点和结束点，不改变原数组，返回新数组。 splice()：删除，参数有起始点、长度、待插入的元素。 DOM常用操作创建节点： createElement createTextNode createDocumentFragment 修改节点： appendChild insertBefore replaceChild CSS清除浮动的方法有哪些 父元素设置高度，手动撑开 浮动元素结尾添加空标签，设置空标签clear: both 父元素设置overflow: hidden 父元素添加伪类:after和zoom CSS选择器优先级!important &gt; 内联样式 &gt; id选择器 &gt; 类选择器/属性选择器/伪类 &gt; 元素选择器 CSS三列布局 浮动布局 左边区域 float: left; ，右边区域 float: right; ，中间区域设置 margin-left 和 margin-right 。 12345&lt;div class=\"layout\"&gt; &lt;div class=\"layout_left\"&gt;&lt;/div&gt; &lt;div class=\"layout_center\"&gt;&lt;/div&gt; &lt;div class=\"layout_right\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.layout { width: 1200px; overflow: hidden;}.layout_left { width: 20%; float: left;}.layout_right { width: 20%; float: right;}.layout_center { margin-left: 5%; margin-right: 5%;} 定位布局 三列布局的父元素设置 position: relative; ，左边区域 position: absolute; 并同时设置 left ，右边区域 position: absolute; 并同时设置 right 。 中间部分设置 position: absolute; 并设置 margin-left 和 margin-right 。 flex布局 1234567891011.layout_left { flex: 0 0 200px;}.layout_right { flex: 0 0 200px;}.layout_center { flex: 1;} 谈一下flex布局flex是弹性布局。 包含flex-container和flex-item。 常用属性：flex-direction、flex-wrap、justify-content、align-items。 水平居中 justify-content:center 水平两头居中 justify-content:space-between 垂直居中 align-items:center。 什么是盒模型内容区、 padding 、 border 、 margin 分为IE盒模型和w3c盒模型 box-sizing: border-box; box-sizing: content-box IE盒模型的 width 包含了content、 border 、 padding 。 transition动画和animation的区别transition用于做简单的过渡效果。 animation可以做复杂的效果。 h5自适应方案使用 rem ，rem是根据 html 的 font-size 来设置的。 call(), apply(), bind()作用都是改变函数的作用域。 call() , apple() 可以直接执行， bind() 不会立刻执行。 call() 单个传参， apply() 用数组传参。 观察者和发布订阅的区别发布订阅有调度中心， 浏览器解析渲染页面的过程 浏览器解析html文档并生成DOM树。 浏览器解析CSS生成CSSOM树。 DOM和CSSOM关联，生成渲染树。 根据渲染树进行布局。 根据渲染树进行绘制。 将图像信息发送给GPU，最终显示在显示器上。 谈一谈EventLoop事件循环 JavaScript本身是单线程，也就是同一时刻只能干一件事，JS任务包含了同步任务和异步任务，遇到执行函数会将其放入调用栈(先进后出)中，遇到setTimeout/setInterval等异步任务时，会把它放入到消息队列中，等主线程的任务执行完成以后，再回过头执行消息队列中的异步任务，如果异步任务中仍然有异步任务，会继续放入消息队列，以此类推，便形成了一个事件循环。 GET和POST的区别 GET传输大小2K-8K，POST无限制 都不安全，GET通过url明文传输，POST通过body传输 浏览器会记录GET请求，不会记录POST GET对浏览器后退无影响，POST会再次提交 浏览器收藏：GET可以，POST不可以 GET可缓存，POST不会 GET用的url编码，POST支持多种编码 GET产生一个TCP数据包，POST产生2个TCP数据包 GET主要是拉取数据，POST主要是提交数据 防抖和节流两者目的都是希望一段时间内不要重复请求。 应用场景：搜索，滚动。 区别：防抖是规定时间内只触发一次，再次调用时间重新计算。节流是在固定时间内只触发一次。 数组去重 ES6 set去重 Object key去重 两层循环遍历生成新的不重的数组 indexOf() sort()排序后依次对比 数组排序 sort()排序 冒泡排序 选择排序 插入排序 常用设计模式 单例模式 工厂模式 观察者模式 适配器模式 for…ofes2015的语法 可以用来遍历数组、类数组、map/set/字符串等等。 数组遍历 1for (const number of [1, 2, 3]) {} 类数组遍历 1for (const number of arguments) {} 字符串遍历 12const msg = 'hello';for (const character of msg) {} Map遍历 123456const map = new Map();map.set(\"name\", '前端未来');map.set(\"author\", '河畔一角');for (const item of map) {}// 或者for (const [key, val] of map) {} Set遍历 12const names = new Set(['Tom', 'Jack', 'Lily']);for (let name of names) {} 前端常见攻击方式 XSS CSRF sql注入 html脚本注入 常见跨域方案跨域源于浏览器的同源政策：必须同协议、同域名、同端口。 JSONP（js调用） CORS（后台设置） Nginx反向代理（运维） 网站常用优化方案思路： 减少请求次数 压缩资源大小 提高响应速度和加载速度 优化资源加载时机 优化加载方式 方法： 合并、压缩、混淆前端代码 服务器nginx开启gzip压缩 静态资源使用CDN 图标做base64处理以减小大小 css放head，js放body中的最后面 设置缓存 css和js的rel属性设置prefetch或preload可预加载资源 按需加载组件库 按需import和require 服务端渲染SSR，加快首屏渲染，利于SEO 页面使用骨架屏提高首页加载速度 尽量少使用jpeg和png，转而使用JPEG 2000, JPEG XR, WebP 图片懒加载","link":"/2020/05/12/fed-interview-02/"},{"title":"从删库到恢复","text":"讨论一下程序员从删库到跑路恢复的问题。 误删库后该怎么办如果真的不幸在生产环境服务器直接或者间接地执行了rm -rf /*那么该怎么办呢？ 首先，当你错误执行了rm -rf /*那么当终端开始滚动删除文件信息的时候你应该知道大事不妙了。这时你应该眼疾手快地赶紧ctrl+ c来中断命令，这非常重要，这可以极大减少数据损失。 到这个时候千万不要重启服务器或者断开ssh连接，然后就是对比查看到底是哪些文件和目录被删除了，使用ls来确定被删除的文件和目录。如果不幸ls已经被删除了（linux中一切皆文件），那么可以使用cd和 tab来查看当前目录的文件和目录（如下）。 回顾一下linux系统目录有哪些以及其功能（参考自：http://www.92csz.com/study/linux/）： /binbin是Binary的缩写。这个目录存放着最经常使用的命令。 /boot这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /devdev是Device(设备)的缩写。该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /medialinux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root该目录为系统管理员，也称作超级权限者的用户主目录。 /sbins就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv该目录存放一些服务启动之后需要提取的数据。 /sys这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs ，sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统种被创建。 /tmp这个目录是用来存放一些临时文件的。 /usr这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /usr/bin系统用户使用的应用程序。 /usr/sbin超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src内核源代码默认的放置目录。 /var这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 恢复/bin目录，找一台拥有正常/bin目录的服务器，通过wget先下载tar命令并赋予执行权限，再用tar打包/bin为一个文件后wget下载至本机。并给予/bin下的命令以执行权限。如果chmod也被删除了，可以用perl给予权限。 1perl -e \"chmod 777, 'ls'\" 预防再一次误删 首先要多加小心，在执行rm之前要停顿对目标文件或目录确定确定再确定。如果在脚本中执行rm命令，则需要判断目标文件或目录是否可能为空，判断如果不为空再执行rm。 针对遇到目标变量不存在导致rm删库的情况，使用set -u使得脚本遇到不存在的变量报错并停止执行。 比如： 12345#!/bin/bashset -urm -rf $a/*echo finished 结果： 1test.sh: line 4: a: unbound variable 使用safe-rm代替rm，safe-rm是一个开源项目，用来安全删除文件。通过配置/etc/safe-rm.conf文件来排除一些目录来防止这些目录被删除。 创建回收站机制。大家都知道命令行下的linux是没有回收站机制的，通过在命令行下创建回收机制就可以有后悔的机会。 那么我们先回忆一下windows下的回收站是如何工作的：我们在windows下删除一个文件或目录的时候，这个文件或目录被移除了本来所属的目录并且被移动到了回收站，等待用户手动清空回收站这些文件才会被真正删除。 具体方法：https://www.cnblogs.com/xiaoyuxixi/p/11608198.html 根目录挂载为只读。 在/etc/fstab中将/挂载为只读： 12# &lt;file system&gt; &lt;mount pt&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;/dev/root / ext4 remount,ro,noatime 0 1 ​","link":"/2020/06/04/from-delete-to-restore/"},{"title":"git学习笔记","text":"系统的学习了一下廖雪峰老师的git教程。 参考 廖雪峰git教程 简介git是世界上最先进的分布式版本控制系统。 git是linux之父linus大神花了两个星期用c写的。。。 安装1git --version #查看机器上是否有git以及版本号 windows: 直接下载gitbash：https://git-scm.com/downloads linux/macos 1234sudo apt-get install git #debian/ubuntu安装sudo apt-get install git-core #老版本debian/ubuntu安装yum install git #centos/RHEL安装brew install git #macos安装，需要先安装homebrew包管理工具 使用配置名称和邮件12git config --global user.name \"Your Name\"git config --global user.email \"email@example.com\" 创建版本库1234#linux和macos没问题，提醒一下windows不要使用cmd/powershell，使用gitbashmkdir gitDircd gitDirgit init #在gitDir目录下初始化git仓库 仓库中.git目录用来跟踪管理版本库，不要修改！ 1ls -lha #查看.git目录，-lha三个参数分别为列表显示、人性化显示、全部显示(显示以.开头的文件) 在非空目录下 git init 也可 把文件添加到版本库git仅可以跟踪文本文件的变动，对于二进制文件仅可以知道其改动了。 ps：二进制文件非常多，包括office三兄弟 文本文件使用utf-8编码 切勿使用新建记事本文件，记事本为utf-8 with BOM编码，若使用notepad++则改为utf-8 without BOM编码 命令 git仓库中新建一个readme.txt文件： 12Git is a version control system.Git is free software. git add 命令把文件添加到仓库 12345git add readme.txt#执行完无显示则表示成功git add .git add *git add -u # 自动追踪更新的文件 git commit 把文件提交到仓库 1git commit -m 'wrote a readme.txt file' # -m后面为本次commit的说明 为什么Git添加文件需要 add ， commit 一共两步呢？因为 commit 可以一次提交很多文件，所以你可以多次 add 不同的文件，比如： 123git add file1.txtgit add file2.txt file3.txtgit commit -m 'add 3 files' 即add一次可以add一个或者多个文件，而commit则一次性把add的文件提交 重命名文件名 1git mv file_old_name file_new_name 小结初始化一个Git仓库，使用 git init 命令。 添加文件到Git仓库，分两步： 使用命令 git add ，注意，可反复多次使用，添加多个文件； 使用命令 git commit -m ，完成。 回滚修改readme.txt文件为： 12Git is a distributed version control system.Git is free software. 运行 git status 可以看到仓库状态和哪些文件被修改了。 1git status 运行 git diff 查看修改了什么内容 1git diff readme.txt 再提交 12git add readme.txtgit commit -m 'readme.txt has been modified' 看状态 12git status# 提示没有需要提交的修改，工作目录干净 版本回退git log 查看历史记录 1git log # 从上到下是从近期到以前的commit 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 --pretty=oneline 参数： 1git log --pretty=online 或者 1git log --oneline 最近4次的记录 1git log -n4 --oneline 图形化显示 1git log --oneline --graph commit id是SHA1计算出来的16进制大数（为防止冲突） 版本回退： 当前版本为 HEAD ，上一个版本为 HEAD^ , 上100个版本为 HEAD~100回退上一个版本： 1git reset --hard HEAD^ 退回特定版本： 1git reset --hard commit-id #版本号可以只写前几位 版本回退仅仅是吧HEAD指针指向当前版本 git reflog 用来记录每一条git命令，可以用来找以前的commit id 1git reflog 小结： HEAD 指向当前版本 版本回退命令： git reset --hard commit-id git log 查看提交历史，以便决定回退到哪个版本 git reflog 查看历史命令，以便决定回退到哪个版本 工作区和暂存区123mkdir gitDircd gitDir #gitDir就是工作区ls -lha #可以看到.git目录，.git就是版本库 版本库中有一个叫stage的暂存区、master分支和HEAD指针 git add 就是把文件添加进暂存区 git add 是把暂存区文件提交到当前分支 若之后未对工作区做任何修改，则工作区clean 123git status#On branch master#nothing to commit, working tree clean 此时版本库变为： 总结： Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库) 工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库 git add 把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库， git diff 查看工作区和暂存区差异， git diff --cached 查看暂存区和仓库差异， git diff HEAD 查看工作区和仓库的差异， git add 的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区， git commit 的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。 修改管理git跟踪的是修改而不是文件。 第一次修改完一个文件后 git add ，再第二次修改这个文件，然后再 git commit ，只会提交第一次修改，故而git跟踪的是修改而不是文件。现在要提交第二次修改只需要： git add 这个文件，再 git commit 就行了，或者第一次修改完了不要急着 git add ，等着两次修改完了一起 git add git commit 。 撤销修改git checkout -- filename ：将文件咋工作区的修改完全撤销 作用是让这个文件回到最近一次 git commit 或者 git add 时候的状态： 一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git reset HEAD filename 可以把暂存区修改撤销 git reset 既可以回退版本也可以吧暂存区修改回退到工作区 小结情况一：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- file 。 情况二：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 git reset HEAD ，就回到了场景1，第二步按场景1操作。 情况三：已经提交了不合适的修改到版本库时，想要撤销本次提交，使用版本回退。 情况四：如果已经push到了远程仓库，完蛋。 简而言之： 没有 git add 时，用 git checkout -- file 回退到与版本库最新版一致 已经 git add 时，先 git reset HEAD 回退到1.，再按1. 操作 已经 git commit 时，用 git reset 回退版本 推送到远程库，GG 删除文件 先直接删除文件 使用 git rm 从版本库中删除该文件 git commit 提交更改 若误删文件，则用 git checkout -- filename 从版本库中恢复到工作区 远程仓库我一般使用github 本地git仓库和github仓库的传输通过ssh加密，故而本地要创建ssh key： 1ssh-keygen -t -C \"youremail@example.com\" 一路回车既可，无需设置密码 ~/.ssh/ 下面有有 id_rsa 和 id_rsa.pub 两个文件 登录github-setting-add ssh key，填写title，粘贴pub里的内容到上面，点击add key。 GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 github仓库为公开，不要提交敏感信息 可以搭建git服务器保护代码 搭建git服务器以ubuntu/debian为例： 1234567891011121314sudo apt-get install git # 服务器安装gitsudo adduser git # 创建一个用户git，用来运行git服务 sudo git init --bare sample.git # 创建证书登录，收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。sudo git init --bare sample.git # 初始化git仓库，选择一个目录用作git仓库，--bare创建了一个裸仓库，没有工作区sudo chown -R git:git sample.git # 将owner改为git# 禁用ssh登录：# 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash# 改为git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell# 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。git clone git@server:/srv/sample.git # 克隆远程仓库 管理公钥： 小团队管理：把团队中每个人的公钥收集起来放到服务器的 /home/git/.ssh/authorized_keys 文件里就可以。 大团队管理：使用gittosis。 git不支持权限管理！！！ 添加远程仓库 先在github上创建一个新的仓库 本地仓库 git remote add origin git@github.com:herotiga/Python-100-Days.git 第一次推送本地文件到远程仓库： git push -u origin master 以后只需要 git push origin master ssh警告第一次使用git clone or git push连接github会有警告 小结 关联远程仓库： git remote add origin git@github.com:herotiga/learngit.git 关联后，使用 git push -u origin master 第一次推送master分支 之后每次只需要 git push origin master 从远程仓库克隆1git clone git@github.com:herotiga/asd.git 注意：克隆下来的是一个目录 一般使用ssh，添加了ssh key之后无需输入密码。而https需要输入密码。 小结git clone 将项目克隆下来，一般使用ssh（除非公司内部只能使用https）。 分支管理创建分支1git checkout -b dev # 创建分支dev并切换到dev分支，-b表示创建完了切换上去 以上命令等同于： 12git branch devgit checkout dev 查看当前分支 1git branch 当前分支前面会有* 或者 1git status 合并分支1git merge dev # 将dev分支合并到当前分支上 删除分支1git branch -d dev 切换分支123git switch -c dev # 创建并切换到新的dev分支git switch master # 切换到已经有的分支，比如master分支 小结12345git branch # 查看分支git branch branchName # 创建分支git checkout branchName / git switch branchName #切换分支git merge branchName # 合并分支到当前分支git branch -d branchName # 删除分支 不完整，仍需补充","link":"/2018/01/30/git-notes/"},{"title":"解决github.io子域名dns污染","text":"上个月月末开始就发现本博客的herotiga.github.io域名无法访问了，于是我试着打开了各个大佬的github.io的博客果然都一样，当时就发觉这是一场有组织有纪律的dns污染行为。 解决方法从v2ex反应的情况来看，默认自动从ISP获取的dns都被污染了，所以手动更换一个公共dns服务器即可。 我选择了 114.114.114.114 。","link":"/2020/08/07/github-dns%E6%B1%A1%E6%9F%93/"},{"title":"gitbook使用方式","text":"gitbook可以用来管理知识。 搭建gitbook并托管到github pages 安装需要node.js 1cnpm install gitbook-cli -g 命令1234567891011# 初始化gitbookgitbook init# 预览gitbook serve# 生成静态页面gitbook build# 初始化安装插件gitbook install 目录结构12345678910.├── book.json├── README.md├── SUMMARY.md├── chapter-1/| ├── README.md| └── something.md└── chapter-2/ ├── README.md └── something.md book.json:配置文件数据 README.md:简介-书籍的简单介绍 SUMMARY.md:目录 以子目录的方式与项目集成 对于软件项目，可以使用子目录(如docs/)来存储项目的文档。您可以在book.json中通过配置选项告诉GitBook在那里找到根目录： 12345.├── book.json└── docs/ ├── README.md └── SUMMARY.md book.json配置如下： 123{ \"root\": \"./docs\"} 菜单与页面GitBook使用一个SUMMARY.md文件来定义文档的菜单。 SUMMARY.md中[]内的内容是标题，()内是文档的路径，章节和子章节用四个空格或者tab键来分级。 菜单示例： 123456789101112# 概述### 服务介绍* [服务介绍](README.md)### 服务接入流程* [服务开通](serviceOpen.md)* [应用配置](appConfig.md)### 企业实名认证服务端API* [API服务规范](apiStandard.md)* [营业执照OCR接口](apiOCR.md) 配置GitBook允许您使用灵活的配置自定义书籍和文档。这些选项在book.json文件中指定。 常用的配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041{ \"root\": \"./docs\", \"language\" : \"zh-hans\", \"styles\": { \"website\": \"./styles/website.css\" }, \"plugins\": [ \"hide-element\", \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"custom-favicon\", \"insert-logo\", \"tbfed-pagefooter\", \"-sharing\", \"sharing-plus\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [ \".gitbook-link\" ] }, \"insert-logo\": { \"url\": \"./images/logo.png\", \"style\": \"background: none; max-height: 60px; min-height: 50px\" }, \"favicon\": \"./images/favicon.ico\", \"sharing\": { \"twitter\": false, \"facebook\": false, \"google\": false }, \"tbfed-pagefooter\": { \"copyright\":\"北京科技XXX公司版权所有\", \"modify_label\":\"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } }} 也可以使用gitbook editor编辑markdown文件。 待阅读 简书GitBook 使用教程 简书gitbook入门 csdn GitBook 从懵逼到入门","link":"/2019/05/01/gitbook-usage/"},{"title":"git知识点和常用操作总结","text":"工作原理 工作目录（workspace）：持有实际文件。 暂存区（index/stage）：缓存区，临时保存你改动了的文件索引。 本地仓库（repository）：保存本地仓库commit。 远程仓库（remote）：用于团队协作或者作为个人备份。 我们写代码就是修改工作区文件，add之后会暂存到index/stage暂存区（修改了的文件的索引）中，多次add到index后，commit提交到本地仓库完成一次提交，或者说是一次快照。 HEAD^ 指 HEAD 的父节点，或者 HEAD~1 。同理： HEAD^^ == HEAD~2 配置查看配置使用 git config --list 。 或者直接查看 .gitconfig 文件： 1bat ~/.gitconfig 下面是我的配置： 123456789101112131415161718192021222324252627282930[user] email = herotiga@vip.qq.com name = wangwei[http] proxy = socks5://127.0.0.1:1086[https] proxy = socks5://127.0.0.1:1086[core] excludesfile = /Users/wangwei/.gitignore_global[difftool &quot;sourcetree&quot;] cmd = opendiff \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; path =[mergetool &quot;sourcetree&quot;] cmd = /Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; -ancestor \\&quot;$BASE\\&quot; -merge \\&quot;$MERGED\\&quot; trustExitCode = true[commit] template = /Users/wangwei/.stCommitMsg[filter &quot;lfs&quot;] clean = git-lfs clean -- %f smudge = git-lfs smudge -- %f process = git-lfs filter-process required = true[alias] dog = log --all --decorate --oneline --graph st = status co = checkout ci = commit br = branch unstage = reset HEAD -- last = log -1 HEAD 查看某个仓库的配置： 1bat .git/config 配置全局用户名和邮件git用户名和邮箱的用途是标识git操作的用户。 12git config --global user.name \"user name\"git config --global user.email \"email@example.com\" 配置命令别名（git alias）配置： 12345678# 常用的aliasgit config --global alias.co checkoutgit config --global alias.st statusgit config --global alias.ci commitgit config --global alias.br branch# 美化git log输出，实际使用时可以在 git lg 后面加命令参数，如： git lg -10 显示最近10条提交git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\" 取消配置： 12git config --global --unset alias.cogit config --global --unset user.name 除了使用命令配置之外，还可以直接编辑 ~/.gitconfig 的 [alias] 字段来给git命令起别名。 123456789101112[alias] st = status ci = commit co = checkout br = branch cf = config fc = fetch pl = pull ps = push unstage = reset HEAD -- last = log -1 HEAD visual = !gitk 除了git alias之外，像oh my zsh的 ~/.zshrc 文件还从linux alias层面提供了一堆git的别名。 配置代理迫于 git clone 实在是太慢了，学习了一下怎样配置使其走代理。 [http] 和 [https] 字段用来配置本地代理，1081端口。 方法一：使用命令配置 1234567# 配置socks5代理git config --global http.proxy socks5://127.0.0.1:1081git config --global https.proxy socks5://127.0.0.1:1081# 配置http/https代理git config --global https.proxy http://127.0.0.1:1081git config --global https.proxy https://127.0.0.1:1081 方法二：编辑 ~/.gitconfig 文件 1234567891011# 配置socks5代理[http] socks5://127.0.0.1:1081[https] socks5://127.0.0.1:1081 # 配置http/https代理[http] proxy = http://127.0.0.1:1081[https] proxy = https://127.0.0.1:1081 查看代理 12git config --global --get http.proxygit config --global --get https.proxy 取消代理 12git config --global --unset http.proxygit config --global --unset https.proxy 速度飞起～ 初始化仓库123456# 初始化已存在的目录为git仓库cd &lt;repository&gt;git init# 创建目录并初始化为git仓库git init &lt;repository&gt; 查看仓库状态1git status 克隆仓库12345678# 克隆本地仓库git clone /path/to/repository# 克隆远程仓库git clone username@host:/path/to/repository# 克隆到指定目录git clone /path/to/repository path/to/newFolder 添加和提交从工作区添加文件到暂存区： 1234567891011121314# 添加单个文件git add &lt;filename&gt;# 添加所有文件git add *# 添加本目录，监控工作区，会add所有改动，包括修改和新文件，不包括被删除的文件git add .# 是git add --all的缩写，提交所有变化git add -A# 仅监控已经被add的文件的改动，不提交新文件git add -u 撤回git add： 1git rm --cached &lt;file name&gt; 提交到 HEAD 并附上提交信息： 1234567891011121314# 不附加提交信息git commit# 附加提交信息git commit -m 'commit infomation'# add并commit，不推荐使用git commit -am 'commit infomation'# 修改最近一次的commit附加信息git commit --amend# 修改commit附加信息git rebase -i &lt;需要修改附加信息的commit的父节点的commit-id&gt; commitizen还可以使用commitizen，可以规范化 git commit 信息以便回溯。 1234567891011# 安装cnpm install -g commitizen# 先add文件git add &lt;filename&gt;# 使用j和k上下选择类型，输入影响范围，输入短描述和长描述git cz# 查看commit信息git log ref: http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html https://www.jianshu.com/p/36d970a2b4da 推送到远程仓库12345# 指定远程仓库名origin和分支名master，参数-u的作用是，以后直接git push即可，不用加origin &lt;branch&gt;git push -u origin master# 不指定远程仓库名和分支名，只关联了一个远程仓库且只有一个分支则可以使用该命令git push 添加远程服务器 12345# 下面的origin为远程仓库的默认别名，用以区分不同的远程仓库（一个本地仓库关联多个远程仓库）。git remote add origin &lt;remote-repository&gt;# 查看remotegit remote -v 如果没有克隆远程仓库，将仓库连接到远程服务器。 这里需要做ssh免密校验。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候， master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个“feature_x”的分支，并切换过去 12345678# 创建分支feature_x并切换到feature_x分支，-b参数表示新建分支，checkout表示切换分支git checkout -b feature_x# 上面的代码相当于# 新建分支git branch feature_x# 切换到新建的分支git checkout feature_x 基于某个分支产生新的分支： 1git checkout -b new_branch base_branch 切换回主分支 1git checkout master 再把新分支删除 12345# 删除分支git branch -d feature_x# 强制删除分支git branch -D feature_x 除非将新分支推送到远程仓库，否则该分支就不对他人所见 1234git push origin &lt;branch&gt;# 推送到remote并重命名远端分支名git push origin local_branch_name:remote_branch_name 删除远程仓库分支： 1git push origin :&lt;branch_name&gt; 将工作区恢复为暂存区内容： 1git checkout -- &lt;filename&gt; 将master回退到上一次commit： 12git reset master^git reset master~5 将master回退到指定commit id： 1git reset &lt;commit_id&gt; 将暂存区内容恢复为HEAD内容： 1git reset HEAD -- &lt;filename&gt; 查看所有分支信息 12345# 查看本地分支git branch# 查看本地和远程所有分支git branch -av 更新与合并更新你的本地仓库至最新改动 1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行： 12345# 默认ffgit merge &lt;branch&gt;# 推荐使用这种merge方式，保留了合并时的commitgit merge &lt;branch&gt; --no-ff 在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功： 1git add &lt;filename&gt; 在合并改动之前，你可以使用如下命令预览差异： 1git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签： 1git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID： 1git log 你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。 替换本地改动假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动： 1git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它： 12git fetch origingit reset --hard origin/master 重命名和删除文件123git mv old_name new_namegit rm filename 更新本地仓库到最新改动（拉取最新）12git pullgit pull origin master 合并多个连续的分支 1git rebase -i 然后再pick多个分支中的一个分支作为base，其他的分支squash(s)既可。 合并分支到当前分支 1git merge &lt;branch&gt; 如若合并失败，则手动修改文件解决冲突，改完之后，你需要执行如下命令以将它们标记为合并成功： 1git add &lt;filename&gt; 预览分支差异： 1git diff source_branch target_branch 对比暂存区和HEAD的差异： 1git diff --cached 对比工作区和暂存区的差异： 12345# 对比所有文件git diff# 对于指定文件git diff -- readme.md css/style.css git标签id通过 git log 查看，只需要写前几位并具有唯一指向性即可。 1git tag 1.0.0 &lt;commit_id&gt; 查看日志1234567891011121314151617181920# 查看当前分支的历史git log# 查看所有分支历史git log --all# 查看所有分支历史（图形化）git log --all --graph# 简明显示git log --oneline# 输出最近3次的commitgit log -n3# 查看某个commit的详细信息git show &lt;commit_id&gt;# 查看引用日志git reflog 我最常用的git log是这条： 1git log --all --decorate --oneline --graph 替换本地改动假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动： 1git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它： 1git fetch origin 1git reset --hard origin/master 12# 将工作区和暂存区恢复到指定commit，丢弃这个commit之后所有的commitgit reset --hard &lt;commit-id&gt; git垃圾回收机制随着cdn仓库commit次数的变多，本地的cdn仓库会越来越占空间。可是我本地cdn仓库的目的只是用来push静态文件到github的cdn仓库，目的不是用来做版本管理，那么怎么释放这些成倍于静态文件大小的本地仓库占用空间呢？ git有gc机制（garbage collection），git会不定时的自动auto gc，它可以将松散的文件压缩。 下面是命令： 1git gc 搭配参数使用： 12345# 对git仓库进行彻底的清理和优化git gc --aggressive# 如果有7000个松散的对象或者50个以上的packfile，git才会进行gcgit gc --auto 还有另一个简单粗暴的方法：删除.git目录，重新 git init 仓库，然后重新 commit 1234rm -rf .gitgit initgit add .git commit -m 'info' 上面的方法都试过了发现 git gc --aggressive 比较靠谱。 暂存工作区变动到临时空间有一种场景是：我们已经add了一些文件到暂存区，而我们的工作区又修改了，这个时候测试提交了一个代码错误需要我们在原来的环境下fix，那么该怎么办呢？ 1git stash 这个时候工作区就被清空了，开始做bug fix。 完成修复后再pop就可以恢复之前的工作区： 12# apply会保留stash list，而pop不会保留git stash apply 查看stash： 1git stash list .gitignore文件编写便携 .gitignore 文件用于使得git仓库忽略某些文件。 在git仓库目录下touch一个 .gitignore 既可，然后编写规则。 .gitignore 文件生成：https://www.toptal.com/developers/gitignore tips内建的图形化 git： 1gitk 彩色的 git 输出： 1git config color.ui true 显示历史记录时，每个提交的信息只显示一行： 1git config format.pretty oneline 交互式添加文件到暂存区： 1git add -i rebaserebase用于将当前分支移动到目标分支的最后一次commit。 rebase黄金法则：不要在公共分支上面使用rebase，比如master。 使用merge还是rebase看团队而定。 revert在公共分支使用git revert以保留commit以便回溯，在特性分支使用git reset既可。 将fork的仓库与上游仓库保持一致 先clone已经fork的仓库到本地。 git remote -av查看分支。 添加上游仓库git remote add upstream git fetch upstream git rebase upstream/，这里如果是做contribution那就用merge。 pull（拉取并合并） = fetch（拉取） + merge（合并） 工作流https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md GUI工具 sourcetree：支持git和svn。 vscode jetbrains ide 扩展阅读 https://juejin.im/post/6844904191203213326","link":"/2019/08/02/git-summary/"},{"title":"哈希碰撞","text":"哈希函数（hash function）就是将不同的输入映射为独一无二的固定长度的哈希值。 哈希是对输入信息的一种summarize，故而存在输出相同的情况，这种情况就称之为哈希碰撞。 由于hash是压缩映射，故而必然会导致哈希碰撞。 那么如何降低哈希碰撞的概率呢？ 最简单粗暴的方法就是增加哈希值的取值范围，或者说增加哈希值的长度。但是更长的哈希值也意味着占用的存储空间和消耗的cpu时间也会随之增长。 我们在实际开发中要做的就是在消耗资源的量和安全性之间找到balance使得我们能在有很高安全性的同时尽可能使用较少的资源消耗。 生日攻击假设哈希值是均匀分布的，那么影响哈希碰撞的因素有以下两点： 哈希值取值范围 哈希值生命周期中的计算次数 在数学中有一个生日问题，就是说假设全班有n个同学，一年365天（简化模型），那么班上有同学生日为同一天的概率有多大。 答案很出人意料。如果至少两个同学生日相同的概率不超过5%，那么这个班只能有7个人。事实上，一个23人的班级有50%的概率，至少两个同学生日相同；50人班级有97%的概率，70人的班级则是99.9%的概率。 这意味着，如果哈希值的取值空间是365，只要计算23个哈希值，就有50%的可能产生碰撞。也就是说，哈希碰撞的可能性，远比想象的高。实际上，有一个近似的公式。 $$\\sqrt{\\frac{\\pi}{2} N}$$ 50%的哈希碰撞概率所需要的计算次数，N表示哈希的取值空间。生日问题的 N 就是365，算出来是 23.9。 这个公式告诉我们，哈希碰撞所需耗费的计算次数，跟取值空间的平方根是一个数量级。 这种利用哈希空间不足够大，而制造碰撞的攻击方法，就被称为生日攻击（birthday attack）。 哈希碰撞概率公式这里省略了计算过程。 $$p(n, d) \\approx 1-e^{\\frac{-n(n-1)}{2 d}}$$ 封装为函数1234const calculate = (d, n) =&gt; { const exponent = (-n * (n - 1)) / (2 * d) return 1 - Math.E ** exponent;} 参考 https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8 http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html","link":"/2020/07/20/hash-collision/"},{"title":"icarus主题魔改","text":"将分类大写改为原字符将node_modules/_hexo-component-inferno@0.4.0@hexo-component-inferno/lib/view/common/article_media.js文件中的is-uppercase类删掉，也可以添加后缀让它失效。 参考 https://www.imaegoo.com/2020/icarus-with-bulma/ https://www.imaegoo.com/2020/icarus-3-guide/ https://removeif.github.io/theme/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html https://www.v2ex.com/t/504000 https://blog.zhangruipeng.me/hexo-theme-icarus/tags/Icarus用户指南/ https://blog.zhangruipeng.me/hexo-theme-icarus/","link":"/2020/03/28/hexo-icarus-modify/"},{"title":"堆(heap)和栈(stack)","text":"复习一下堆和栈的概念和区别。 堆和栈都是一种数据结构，存储在内存之中。 堆堆是运行时动态变化的，在运行时确定，速度慢。 进程内堆的数据共享。 数据量不确定用堆，大数据量用堆。 栈栈是静态的，在编译时确定，速度快。 每个函数维护一个自己的调用栈，不同函数的栈不能共享，每个线程之间的栈也不能共享。 数据量确定用栈。 释放堆栈 对于手动管理内存的语言，手动free堆栈的空间。 对于有GC的语言，将堆栈的引用设置为null。 ref https://cloud.tencent.com/developer/article/1688327","link":"/2020/06/10/heap-and-stack/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/01/30/hello-world/"},{"title":"hexo插入图片","text":"总结一下hexo中插入图片的几种方法。 图床插入图片使用sm.ms或者新浪图床之类的图床，也可以是七牛云oss等。 插入语法： 1![pic_title](url) 优点是在任何联网的场景都可以查看，而且可以缓解服务器的带宽压力，明显提高网站性能。 缺点是图床毕竟不是自己的服务器，之前一直用的微博图床就出现了防盗链导致我的原博客所有图片失效，第二个缺点就是使用图床的话只能在联网的环境下才能查看到图片。 本地插入图片就是将图片防止在markdown文件所在的目录中。 优点是图片永远不会丢失。 缺点是图片会占用服务器存储空间、带宽。以及在hexo中本地插入图片有些不方便。 流行的方式： 首先在hexo根目录下打开_config文件，查找到post_asset_folder，修改为post_asset_folder: true。 该配置会使得hexo new 'post_title'的时候在_posts目录中自动生成一个与文章同名的文件夹用来存放资源。 安装hexo-asset-image插件 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 将文章图片拷贝至同名文件夹下，记住图片文件名，现在只需要插入到markdown中，直接![pic_title](pic_name.jpg)即可。如下： 1![pic_title](pic.jpg) 完成 网上流行这种方式，hexo的确可以正常显示图片。不过在markdown中就无法显示图片了，因为这种路径是相对于public目录中图片的目录的，在markdown编辑的时候路径错误故而无法正确显示图片。 我的方法：最后还是上传到了图床sm.ms。","link":"/2020/03/22/hexo-insert-picture/"},{"title":"hexo在控制台打印自定义信息","text":"在控制台输出一些信息。 修改布局文件我使用的是icarus主题。 修改/themes/icarus/layout/layout.ejs文件，在&lt;/body&gt;上面添加console.log()即可： 12345&lt;script type=\"text/javascript\"&gt; console.log('[]~(￣▽￣)~*没啥可看的'); console.log('[]~(￣▽￣)~*没啥可看的'); console.log('[]~(￣▽￣)~*没啥可看的');&lt;/script&gt; 图片转字符画https://www.jianshu.com/p/fca56d635091 其他参考 https://www.cnblogs.com/Wayou/p/chrome_dev_tool_style_console.html","link":"/2020/05/30/hexo-console-log/"},{"title":"hexo不渲染指定文件或目录","text":"给hexo添加gitbook以及自己写的前端代码的时候hexo都会自动渲染这些代码从而达不到我们需要的效果。 如果不需要hexo渲染自己的文件但又想要文件出现在hexo中，那么怎么办呢。 单个文件对于单个文件（md）的不渲染需求，只要在文件中添加如下配置： 123---layout: false--- 多个文件对于多个文件的不渲染需求，需要配置博客根目录下的_config.yml文件： 12345678910111213141516171819# 跳过单个文件skip_render: test.html# 跳过所有的html的文件skip_render: '*.html'# 跳过目录下的所有文件skip_render: test/*# 跳过某一目录下的所有文件和子目录的渲染skip_render: test/**# 跳过多个目录，或者多个文件的渲染skip_render: ['*.html', demos/**, test/*]skip_render: - test.html - '*.html' - test/** - test/* 上面的路径只能为相对路径。 编写html代码在hexo的post或者page中插入html代码需要用以下代码包裹 123{% raw %}&lt;!-- html code --&gt;{% endraw %} 测试 测试 * { margin: 0; padding: 0; border-radius: 0; } div.box { background: green; font-size: 2em; color: #fff; } 成功 测试外链文件点我测试 参考 https://github.com/hexojs/hexo/issues/1146","link":"/2020/06/18/hexo-skip-render/"},{"title":"hexo详细使用方式","text":"前提是已经安装了nodejs和git 安装并初始化安装hexo123456789101112# 本地全局安装hexo$ npm install hexo-cli -g# 初始化博客目录$ hexo init blog_dir# 进入初始化好的博客目录并安装依赖包$ cd blog_dir$ npm install# 本地启动server查看效果$ hexo server cnpm若npm速度慢，可以使用cnpm代替。 cnpm安装： 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 使用cnpm： 1$ cnpm install [package_name] 目录结构12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的配置信息 package.json安装了的应用 scaffolds模板文件夹（hexo new的时候，hexo根据scaffolds文件夹中的模板来建立文件） Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 配置在_config.yml文件中 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 keywords 网站的关键词。使用半角逗号 , 分隔多个关键词。 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。 url 网址 默认值 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 pretty_urls 改写 permalink 的值来美化 URL pretty_urls.trailing_index 是否在永久链接中保留尾部的 index.html，设置为 false 时去除 true pretty_urls.trailing_html 是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效) true 其他配置一般不需要改动 命令123456789# init$ hexo init [folder]# new post#若没有指定layout，则默认使用_config.yml中的default_layout参数代替$ hexo new [layout] &lt;title&gt;# 如果标题包含空格，则使用引号包裹$ hexo new \"new post\" 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 自定义文章路径： 1$ hexo new page -p about/me \"About me\" 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot; 1234# 生成静态文件$ hexo generate# or$ hexo n 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 简写为： 1$ hexo g 12# publish发表草稿$ hexo publish [layout] &lt;filename&gt; 很少使用 12# server$ hexo server 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 简写为： 1$ hexo s 12# deploy部署$ hexo deploy 参数 描述 -g, --generate 部署之前预先生成静态文件 简写为： 1$ hexo d 1# clean清除缓存文件db.json和已经生成的静态文件public 12# 列出网站资料$ hexo list &lt;type&gt; 12# 显示hexo版本$ hexo version 12# 安全模式$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 12# 调试模式$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 12# 显示草稿$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 迁移从wordpress迁移到hexo先安装hexo-migrator-wordpress插件 1$ npm install hexo-migrator-wordpress --save 在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考WP支持页面）。 插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。 1$ hexo migrate wordpress &lt;source&gt; 插件不完美，迁移完毕后手动审核文件。 开始写作12# 创建新文章或者新页面$ hexo new [layout] &lt;title&gt; layout默认为post 布局layoutpost路径：source/_posts page路径：source draft路径：source/_drafts 将Front-Matter中的layout: false，可以使得文章不被处理 draft草稿(一般用不到)draft布局被创建的时候在source/_drafts中 使用publish命令后，草稿将被移动到source/_posts 文件夹 1$ hexo publish [layout] &lt;title&gt; 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo \"my photo\" 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matterFront-matter格式： 1234---title: Hello Worlddate: 2012/4/5 12:32:54--- 参数： 参数 描述 默认值 layout 布局 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） categories/tags只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 12345categories:- csstags:- float- position 将一个文章加入一个多层级分类（前端 - css）： 12345---categories:- 前端- css--- 将一个文章加入多个分类（前端,css,布局）： 123456---categories:- [前端]- [CSS]- [布局]--- 将一个文章加入多个深层分类（前端 - css,前端 - 布局,技术）： 123456---categories:- [前端,css]- [前端,布局]- [技术]--- 组合自己所需的front-matter参数,形成post模版123456789101112131415161718---title: article_titledate: 2018-07-08 16:11:13updated:toc: truecategories: - [前端,html] - [前端,css]tags: - css - 前端thumbnail:permalink:comments:---summary paragraph.&lt;!-- more --&gt;main paragraph.(this paragraph cannot be seen) 写完front-matter后，写一段summary，紧接着加一行&lt;!-- more --&gt;用来隐藏正文。 标签插件标签插件是用于在文章中快速插入特定内容的插件。 引用块（在文章中插入引言，可以包含作者，来源，标题）：123{% blockquote [author[,source]] [link] [source_link_title] %}content{% endblockquote %} 示例1：纯粹引用内容，没有作者信息 123{% blockquote %}content{&amp; endblockquote &amp;} 示例2: 引用内容并给出作者和书名 123{% blockquote David Levithan,Wide Awake %}nothing but just example.{% endblockquote %} 示例3:引用twitter 123{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}content{% endblockquote %} 示例4: 引用网络内容 123{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}content{% endblockquote %} 代码块hexo提供的插入代码块的语法： 123{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %} Specify additional options in option:value format, e.g. line_number:false first_line:5. Extra Options Description Default line_number Show line number true highlight Enable code highlighting true first_line Specify the first line number 1 mark Line highlight specific line(s), each value separated by a comma. Specify number range using a dash Example: mark:1,4-7,10 will mark line 1, 4 to 7 and 10. wrap Wrap the code block in `` true 示例（codeblock仅能在hexo渲染器中看到效果，markdown没效果） codeblock代码段： [grid布局] [lang: css]1234567.container {​ display: grid;} 渲染结果，貌似hexo不能高亮代码 markdown代码段： 123.container { display: grid;} 可以高亮代码 示例：普通代码块 代码： 123{% codeblock %}alert('done!');{% endcodeblock %} 效果（仅可在hexo渲染器中查看效果）： 123alert('done!'); 示例：指定语言 代码： 123{% codeblock lang:objc %}[rectangle setX: 10 y: 10 width: 20 height: 20];{% endcodeblock %} 效果： 1[rectangle setX: 10 y: 10 width: 20 height: 20]; 示例：附加说明 代码： 123{% codeblock Array.map %}array.map(callback[, thisArg]){% endcodeblock %} 效果： Array.map123array.map(callback[, thisArg]) 反引号代码块代码： 1​```[language] [title] [url] [link text] this is code snippet 1234效果：```[language] [title] [url] [link text] this is code snippet markdown代码块代码： 123​```csscode snippet​ 1234567效果：```css.div { background-color: blue;} markdown小段代码代码； 1`code snippet` 效果： code snippet 插入pull quote代码： 123{% pullquote [class] %}content{% endpullquote %} 效果： content 插入jsFiddle代码： 1{% jsfiddle shorttag [tabs] [skin] [width] [height] %} 效果： 插入gist代码： 1{% gist gist_id [filename] %} 效果： 插入iframe代码： 1{% iframe url [width] [height] %} 效果： 插入图片代码： 1{% img [class names] /path [width] [height] '\"title text\" \"alt text\"' %} 效果： 插入链接代码： 1{% link text url [external] [title] %} 效果： 百度 插入include code插入 source/downloads/code 文件夹内的代码文件。source/downloads/code 不是固定的，取决于你在配置文件中 code_dir 的配置。 代码： 1{% include_code [title] [lang:language] [from:line] [to:line] path/file %} 示例： 嵌入 test.js 文件全文 1{% include_code lang:javascript test.js %} 只嵌入第 3 行 1{% include_code lang:javascript from:3 to:3 test.js %} 嵌入第 5 行至第 8 行 1{% include_code lang:javascript from:5 to:8 test.js %} 嵌入第 5 行至文件结束 1{% include_code lang:javascript from:5 test.js %} 嵌入第 1 行至第 8 行 1{% include_code lang:javascript to:8 test.js %} 插入youtube视频代码： 1{% youtube video_id %} 效果（需科学上网环境）： 插入vimeo视频代码： 1{% vimeo video_id %} 引用文章链接12{% post_path filename %}{% post_link filename [title] [escape] %} 详细使用方法查看hexo文档 引用资源123{% asset_path filename %}{% asset_img filename [title] %}{% asset_link filename [title] [escape] %} raw如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。 123{% raw %}content{% endraw %} 文章摘要代码： 1&lt;!-- more --&gt; 摘要可能会被 Front Matter 中的 excerpt 覆盖。 资源文件夹asset代表source文件夹中除了文章之外的所有文件：图片,css,js文件etc 简单引用图片的方法：如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 代码： 绝对路径： 1234![test image size](/images/1.jpg)![test image size](/images/1.jpg){:class=\"img-responsive\"}![test image size](/images/1.jpg){:height=\"50%\" width=\"50%\"}![test image size](/images/1.jpg){:height=\"100px\" width=\"400px\"} 效果：在编辑时没有效果，hexo中有效果 相对路径： 1![test image size](../images/1.jpg) 效果：在编辑时有效果，hexo中有效果 assets文件夹config.yml文件中的post_asset_folder选项设置为true，则每次new新文章会自动生成一个同名文件夹用来存储资源文件。再通过相对路径引用。 ###相对路径引用的标签插件 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。 hexo中引用方式： 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} 示例 代码： 1{% asset_img example.jpg this is an example image %} 效果： 数据文件(一般用不到)在主题中使用一些不在文章内部的资料，并且要复用这些资料，使用数据文件功能。 此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。 举例来说，在 source/_data 文件夹中新建 menu.yml 文件： 123Home: /Gallery: /gallery/Archives: /archives/ 您就能在模板中使用这些资料： 123&lt;% for (var link in site.data.menu) { %&gt; &lt;a href=&quot;&lt;%= site.data.menu[link] %&gt;&quot;&gt; &lt;%= link %&gt; &lt;/a&gt;&lt;% } %&gt; 渲染结果如下 : 123&lt;a href=\"/\"&gt; Home &lt;/a&gt;&lt;a href=\"/gallery/\"&gt; Gallery &lt;/a&gt;&lt;a href=\"/archives/\"&gt; Archives &lt;/a&gt; 服务器hexo将server独立成一个单独的模块 安装1$ npm install hexo-server --save 启动服务器运行期间会见空文件变动，自动更新 123$ hexo server# or$ hexo s 修改端口端口默认4000，若被占用，可以修改端口号 1$ hexo server -p 5000 静默模式服务器之处理public文件夹内文件，不处理文件变动。 此时需要hexo g更新文件变动。 静默模式通常用于生产环境下。 1$ hexo server -s 自定义ip服务器默认运行在0.0.0.0。 自定义ip： 1$ hexo server -i 192.168.1.1 pow(用不到)pow时macos上面的rack服务器，可以作为建议静态文件服务器使用。 安装1$ curl get.pow.cx | sh 设置在~/.pow文件夹建立链接(symlink) 12$ cd ~/.pow$ ln -s /path/to/myapp 网站就将在http://myapp.dev下运行。 生成器一次生成123$ hexo generate# or$ hexo g 持续监控监控文件SHA1 checksum变动并生成新静态文件 123$ hexo generate --watch# or$ hexo g -w 部署12345$ hexo generate --deploy$hexo g -d# or$ hexo deploy --generate$ hexo d -g 以上两条命令可以分别简写为： 123$ hexo g -d# or$ hexo d -g 我的简写方法： 1$ hexo g &amp;&amp; hexo d 模版 模板 用途 回退 index 首页 post 文章 index page 分页 index archive 归档 index category 分类归档 archive tag 标签归档 archive icarus主题参数banner大小：566px*242px 参考1.hexo中文文档 2.淘宝cnpm","link":"/2018/03/08/hexo%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"title":"hexo常用命令以及配置","text":"整理以下hexo常用的命令和配置 hexo初始化12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server hexo常用命令1234567891011121314151617181920212223242526272829# 新建文章hexo n &lt;title&gt;# 新建草稿hexo n draft &lt;title&gt;# 新建页面hexo n page &lt;title&gt;# 新建指定layouthexo n [layout] &lt;title&gt;# 将一个草稿发布，hexo会将其从_drafts目录中移动到_posts目录hexo publish &lt;draft_title&gt;# 清除静态文件hexo clean# 生成静态文件hexo g# 运行本地服务器hexo s# 部署代码到远程服务器hexo d# 清除静态文件、生成静态文件并部署hexo clean &amp;&amp; hexo d -g tips折叠文章在文章的summary和article之间插入如下代码 1&lt;!-- more --&gt; 开启RSS安装插件 1npm install hexo-generator-feed --save 配置hexo根目录下的_config.yml文件，添加 1rss: /atom.xml #rss地址 默认即可","link":"/2018/03/10/hexo-using/"},{"title":"变量提升(hoisting)","text":"var 和 function 的声明毫无疑问是会被提升到其所在的全局作用域顶部或者函数作用域顶部的。故而，对于 var 和 function 可以先使用后声明。 但是对于 let 和 const ，各种文章教程都说不会被js提升。但是我从暂时性死区(TDZ)中发现其实他们俩也是存在变量提升的，只是他们被提升的时候不会在js内部被初始化。 let对于 let ，具有块级作用域，会被提升到其所在代码块顶部，不能重复声明，存在TDZ。 const对于 const ，具有块级作用域，会被提升到其所在代码块顶部，一旦声明就无法改变其值，不能重复声明，存在TDZ。故而，需要在声明的时候同时初始化。 我们可以看到 let 和 const 的唯一区别就是 const 需要申明时初始化否则报错，而且不能改变其值。其他都相同，包括两者都存在TDZ。 因此造成了 let 和 const 由于TDZ的存在而不能在声明前使用。","link":"/2021/09/23/hoisting/"},{"title":"浅谈hooks","text":"Vue3和React16.8都已经支持了 hooks 作为组件编写的方式。 什么是hooks？ 钩子编程是通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为钩子(hooks)。 React中的hooksReact只能在函数组件中使用hooks。 React中的hooks指的是以 use 开头的一系列方法，可以让我们避开class component写法，在函数式组件中完成全部的开发。 hooks函数以 use 开头是计算机中对于hooks约定俗成的写法。 Vue中的hooksVue只能在 setup 中使用hooks。 Vue中的hooks指的是以 use 开头的方法，他们提供了组件复用状态管理等能力，除此之外，Vue的组合式API也是一种hooks。 hooks的优点 hooks可以将业务逻辑清晰划分解耦。 hooks可复用性高、状态逻辑复用清晰，可以替代 mixin。 避免了class组件需要频繁使用 bind 的麻烦。 React hooks实例jsx123456789101112131415161718192021222324import { useState, useEffect } from 'react'const Demo = () =&gt; { // 创建name状态和set方法 const [name, setName] = useState('') // 处理副作用 useEffect(() =&gt; { console.log(name) }, [name] ) // 依赖name动态计算message const message = useMemo(() =&gt; { return `my name is ${name}` }, [name]) return ( &lt;div&gt; {message} &lt;/div&gt; )}export default Demo Vue hooks实例vue12345678910111213&lt;template&gt; &lt;div&gt;{{ message }}&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import { computed, ref } from 'vue'const name = ref('')const message = computed(() =&gt; { return `my name is ${name.value}`})&lt;/script&gt; 自定义hook自定义hook是一种重用状态逻辑的方法。 下面以react hook为例，如何自定义一个hook： 给hook命名：以use开头。 编写函数：写一个普通的函数，函数内可以使用其他的hook。 使用写好的hook：在其他组件中可以使用编写好的hook，在组件中可以使用它返回的任何状态和函数。 自定义react hook实例： jsx12345678910111213141516171819202122232425262728293031import { useState } from 'react'// 自定义Hook：用于追踪和更新计数function useCounter(initialCount) { const [count, setCount] = useState(initialCount) const increment = () =&gt; { setCount(prevCount =&gt; prevCount + 1) } const decrement = () =&gt; { setCount(prevCount =&gt; prevCount - 1) } return { count, increment, decrement }}// 在组件中使用自定义Hookfunction CounterComponent() { const { count, increment, decrement } = useCounter(0) return ( &lt;div&gt; &lt;p&gt;Count: {count}&lt;/p&gt; &lt;button onClick={increment}&gt;Increment&lt;/button&gt; &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt; &lt;/div&gt; )}export default CounterComponent 扩展阅读 https://mp.weixin.qq.com/s/a1A7b6nzqNpZuv8KkN8nug","link":"/2023/08/02/hooks/"},{"title":"html5小技巧","text":"声明文档类型 1&lt;!DOCTYPE html&gt; 善用figure标签 123456&lt;figure&gt; &lt;img src=”” alt=\"\" /&gt; &lt;figcaption&gt; &lt;p&gt;img title&lt;/p&gt; &lt;/figcaption&gt;&lt;/figure&gt; 引入css和js无需写类型 如下： 12&lt;link rel=”stylesheet” href=”” /&gt;&lt;script src=””&gt;&lt;/script&gt; contenteditable属性 contenteditable属性允许用户编辑元素内容 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=”en”&gt;&lt;head&gt; &lt;meta charset=”utf-8″&gt; &lt;title&gt;untitled&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;ul contenteditable=”true”&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; placeholder 1&lt;input name=”email” type=”email” placeholder=”example@email.host” /&gt; local storage html5的local storage可以让浏览器记住输入的内容，就算后来浏览器关闭或者重新刷新也不受影响。 语义标签 有header和footer等等 123456&lt;header&gt; &lt;!-- header --&gt;&lt;/header&gt;&lt;footer&gt; &lt;!-- footer --&gt;&lt;/footer&gt; 群组标题标签 1234&lt;hgroup&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;h2&gt;h2&lt;/h2&gt;&lt;/hgroup&gt; 低版本IE兼容html5 123header, footer, article, section, nav, menu, hgroup { display: block;} 123456document.createElement(“article”);document.createElement(“footer”);document.createElement(“header”);document.createElement(“hgroup”);document.createElement(“nav”);document.createElement(“menu”); required属性 某个表单必须要输入，则使用required属性 1&lt;input type=”text” name=”someInput” required&gt; 例子： 12345&lt;form method=”post” action=\"\"&gt; &lt;label for=”someInput”&gt; Your Name: &lt;/label&gt; &lt;input type=”text” id=”someInput” name=”someInput” placeholder=”Douglas Quaid” required&gt; &lt;button type=”submit”&gt;Go&lt;/button&gt;&lt;/form&gt; autofocus属性 1&lt;input type=”text” name=”someInput” placeholder=”Douglas Quaid” required autofocus&gt; audio标签 12345&lt;audio autoplay=”autoplay” controls=”controls”&gt; &lt;source src=”file.ogg” /&gt; &lt;source src=”file.mp3″ /&gt; &lt;a href=”file.mp3″&gt;Download&lt;/a&gt;&lt;/audio&gt; video标签 12345&lt;video width=\"320\" height=\"240\" controls preload&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; 您的浏览器不支持 video 标签。&lt;/video&gt; 检测浏览器对属性的支持 原生js实现 1alert( ’pattern’ in document.createElement(‘input’) ) // boolean; jquery实现 12if (!’pattern’ in document.createElement(‘input’)) {} mark标签 用于高亮显示文本。 1&lt;p&gt;这是一段&lt;mark&gt;高亮&lt;/mark&gt;文本&lt;/p&gt;","link":"/2018/06/21/html-tips/"},{"title":"html学习笔记","text":"HTML(HyperText Markup Language)是超文本标记语言，是用来描述网页的一种标记语言。html文档也叫web页面，由浏览器解析。 简介实例解析这是一个标准的html实例： 1234567891011121314151617181920212223242526&lt;!-- 声明为html5文档 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- html是根元素 --&gt;&lt;html lang=\"en\"&gt;&lt;!-- head元素包含了文档的元数据 --&gt;&lt;head&gt; &lt;!-- 这个meta定义了文档编码格式 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- title定义了文档标题 --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;!-- body定义了页面的可见内容 --&gt;&lt;body&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;h3&gt;三级标题&lt;/h3&gt; &lt;p&gt;段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 将上面的代码保存为 .html 或者 .htm 文件即可在浏览器运行， .htm 扩展名和前者没有区别。 基本概念 标签 一个html标签的基本结构是这样的： &lt;tagName&gt;content&lt;/tagName&gt; 元素 html元素和标签是一个概念。 web浏览器 web浏览器是用于读取html/css/js等静态文件的，用于web页面展示。 文档结构这是一个基本的html页面结构： 文档声明12345678&lt;!-- html5 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- html4.01 --&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;!-- xhtml1.0 --&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; 文档编码统一使用utf-8既可： 12&lt;meta charset=\"UTF-8\"&gt;&lt;meta charset=\"utf-8\"&gt; 编辑器 vscode（免费） sublime text（收费，按年付费） vi/vim emacs 可以使用emmet插件提高编码速度。 基础标题html标题有h1到h6 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这是一个标题&lt;/h2&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt; 段落1&lt;p&gt;这是一个段落。&lt;/p&gt; 链接1&lt;a href=\"https://herotiga.github.io/\"&gt;我的博客&lt;/a&gt; 图像1&lt;img loading=\"lazy\" src=\"/images/logo.png\" width=\"640\" height=\"320\" /&gt; 元素html文档由html元素定义。 元素由起始标签和闭合标签组成，他们之间有内容。 有一些html元素内容为空。 空元素在开始标签中关闭： &lt;br /&gt; 。 大多数元素可以有属性。 嵌套html元素可以互相嵌套，html文档本身也是由互相嵌套的html标签组成。 空元素没有内容的元素称之为空元素，空元素在开始标签中进行关闭。在xhtml、xml和未来版本的html中，所有元素都必须要被关闭。建议关闭空标签。 关闭空元素的正确方法：比如 &lt;br /&gt; ，先敲一个空格再敲一个斜杠。 大小写标签html大小写不敏感，不过推荐全小写。在未来的xhtml和html中都强制使用小写。 属性html属性是元素的附加信息。 html元素可以设置属性。 属性可以给元素附加信息。 属性描述于开始标签。 属性和属性值以name=”value”的形式出现。 属性和属性值也要采用小写。 属性实例href 就是a标签的一个属性， https://herotiga.github.io/ 就是这个属性的值。 1&lt;a href=\"https://herotiga.github.io/\"&gt;我的博客&lt;/a&gt; 属性值要放在引号中，单引号双引号都可以，如果属性值含有引号则属性值要用另一个引号，比如： 1name=&quot;here's my blog&quot; 其他属性class，id，style，title这几个是几乎所有的标签都拥有的属性。 标题html标题从大到小依次是h1-h6，这个次序也是最重要到最不重要。标题元素是块元素，浏览器会自动在标题的前后加上空行。 标题元素只能用于标题，不能为了生成大号字体而使用，因为搜索引擎使用标题来索引网页内容。 水平线123&lt;p&gt;1&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;2&lt;/p&gt; 注释12345&lt;!-- 注释 --&gt;&lt;!-- 注释--&gt; 查看源码右击网页，点击查看源文件、源代码既可。 段落html将文档分为若干个段落。 p标签： 1&lt;p&gt;段落&lt;/p&gt; 换行1&lt;p&gt;第一行&lt;br&gt;第二行&lt;br&gt;第三行&lt;/p&gt; 空行和空格浏览器解析html代码的时候，会将连续的空格或者空行压缩为一个空格。 文本格式化12345678910111213141516171819202122232425262728293031&lt;b&gt;加粗&lt;/b&gt;&lt;strong&gt;突出显示&lt;/strong&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;em&gt;强调&lt;/em&gt;&lt;code&gt;电脑输出&lt;/code&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;big&gt;大字体&lt;/big&gt;&lt;small&gt;小字体&lt;/small&gt;&lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;code&gt;计算机输出&lt;/code&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt;&lt;tt&gt;打字机文本&lt;/tt&gt;&lt;samp&gt;计算机代码样本&lt;/samp&gt;&lt;var&gt;计算机变量&lt;/var&gt;&lt;address&gt; Written by &lt;a href=\"mailto:webmaster@example.com\"&gt;Mason&lt;/a&gt;.&lt;br&gt; Visit us at:&lt;br&gt; Example.com&lt;br&gt; Box 564, Disneyland&lt;br&gt; USA&lt;/address&gt;&lt;abbr title=\"全写\"&gt;缩写&lt;/abbr&gt;&lt;acronym title=\"World Wide Web\"&gt;WWW&lt;/acronym&gt;&lt;bdo dir=\"rtl\"&gt;文字从右到左显示。&lt;/bdo&gt;&lt;q&gt;短引用&lt;/q&gt;&lt;blockquote&gt;长引用&lt;/blockquote&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;ins&gt;插入文本&lt;/ins&gt;&lt;cite&gt;引用源&lt;/cite&gt;&lt;dfn&gt;定义一个定义项目&lt;/dfn&gt; 为了将语义和样式分离开，b和i现在不用了，使用strong代替b，使用em代替i。strong和em的样式交由css。 链接链接的作用是从一个页面跳转到另一个页面或者本页面的一个锚点。 代码： 1&lt;a href=\"https://baidu.com/\"&gt;百度&lt;/a&gt; target属性可以定义连接的打开方式： 1&lt;a href=\"https://baidu.com/\" target=\"_blank\"&gt;百度&lt;/a&gt; id属性可以在文档中创建锚点： 123456789&lt;!-- 创建锚点 --&gt;&lt;a id=\"tips\"&gt;锚点&lt;/a&gt;&lt;!-- 创建链接，指向锚点 --&gt;&lt;a href=\"#tips\"&gt;指向锚点的连接&lt;/a&gt;&lt;!-- 创建连接，指向另一个页面的一个锚点 --&gt;&lt;a href=\"https://www.runoob.com/html/html-links.html#tips\"&gt; 指向另一个页面的锚点&lt;/a&gt; tips:始终将 / 加入到url目录的后面： 123&lt;a href=\"https://herotiga.github.io/\"&gt;&lt;/a&gt;&lt;a href=\"https://herotiga.github.io/categories/\"&gt;&lt;/a&gt;&lt;a href=\"https://herotiga.github.io/tags/\"&gt;&lt;/a&gt; 如果不加斜杠就会向服务器产生两次http请求，加上斜杠则只会产生一次http请求。 图片连接： 123&lt;a href=\"#\"&gt; &lt;img src=\"example.jpg\"&gt;&lt;/a&gt; 创建邮件链接： 1234&lt;!-- example 1 --&gt;&lt;a href=\"mailto:someone@example.com?Subject=Hello%20again\" target=\"_top\"&gt;点击发送邮件&lt;/a&gt;&lt;!-- example 2 --&gt;&lt;a href=\"mailto:someone@example.com?cc=someoneelse@example.com&amp;bcc=andsomeoneelse@example.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!\" target=\"_top\"&gt;发送邮件!&lt;/a&gt; 头部头部head元素包含了一些元素，比如style，script，meta，title等等。除此之外还有link，noscript，base元素。 title title元素定义了文档的标题，它会出现在浏览器的标签上。 title元素在html/xhtml文档中是必须的。 title还可以在左边显示logo等等。 1234&lt;head&gt; &lt;link rel=\"shortcut icon\" href=\"url\"&gt; &lt;title&gt;这是一个带图片的标签&lt;/title&gt;&lt;/head&gt; basebase元素定义了基地址，它会作为文档中所有链接的默认链接地址。 1&lt;base href=\"https://herotiga.github.io/\" target=\"_blank\"&gt; linklink元素定义了文档和外部资源的关系。常用于css引入： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt; style定义了文档的样式 123456789&lt;style type=\"text/css\"&gt; body { background-color: yellow; } p { color: blue; }&lt;/style&gt; metameta定义了一些基本的元数据，通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。 meta放置在head中。 1234567891011&lt;!-- 定义关键词 --&gt;&lt;meta name=\"keywords\" content=\"HTML, CSS, XML, XHTML, JavaScript\"&gt;&lt;!-- 定义描述 --&gt;&lt;meta name=\"description\" content=\"免费 Web &amp; 编程 教程\"&gt;&lt;!-- 定义作者 --&gt;&lt;meta name=\"author\" content=\"Runoob\"&gt;&lt;!-- 定时刷新 --&gt;&lt;meta http-equiv=\"refresh\" content=\"30\"&gt; scriptscript标签用于加载js脚本。 样式css（层叠样式表）用于渲染html的样式。 如何使用css 内联样式：在标签中使用style属性。 内部样式表：在head中用style标签包含css代码。 外部引用：在head中使用link引入外部样式表。 tips：最好使用外部引入css。 内联样式实例1： 1&lt;p style=\"color: red;padding: 2px 4px;\"&gt;红色字体，带有内边距&lt;/p&gt; 实例2: 123456&lt;!-- 早期html使用bgcolor来定义背景颜色 --&gt;&lt;body style=\"background-color:yellow;\"&gt; &lt;h2 style=\"background-color:red;\"&gt;这是一个标题&lt;/h2&gt; &lt;p style=\"background-color:green;\"&gt;这是一个段落。&lt;/p&gt;&lt;/body&gt; 内部样式表1234567891011&lt;head&gt; &lt;style type=\"text/css\"&gt; body { background-color: yellow; } p { color: blue; } &lt;/style&gt;&lt;/head&gt; 外部样式表123&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt;&lt;/head&gt; 已经弃用的标签和属性不建议使用的标签： font center strike 不建议使用的属性： bgcolor 图像基本用法图像由img标签定义，url由src定义。 map标签用于定义图像地图 area标签用于定义图像地图中的可点击区域 1&lt;img src=\"\" alt=\"替换文本\"&gt; 指定图像的高和宽是哥好习惯，页面会在加载的时候预留指定尺寸的空间。 1&lt;img src=\"\" alt=\"替换文本\" width=\"480\" height=\"360\"&gt; 提示加载图片需要时间，谨慎使用图片。 表格表格组成表格由table标签定义，tr（表格行）定义表格的一个行，每一行分为若干个单元格，单元格有th（表格表头单元）和td（表格数据单元）组成，单元格里面可以有文本、图片、列表、段落、表单、水平线、表格等等。 实例： 12345678910&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格边框给表格一个边框： 123456&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;Row 1, cell 1&lt;/td&gt; &lt;td&gt;Row 1, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格表头使用th标签定义表头。 1234567891011121314&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 实例 没有边框的表格 123456789101112131415161718192021222324252627&lt;h4&gt;这个表格没有边框:&lt;/h4&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;600&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;这个表格没有边框:&lt;/h4&gt;&lt;table border=\"0\"&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;600&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 带标题（caption）的表格 123456789101112131415&lt;table border=\"1\"&gt; &lt;caption&gt;Monthly savings&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;$50&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 跨行、列的表格 123456789101112131415161718192021222324252627&lt;h4&gt;单元格跨两列:&lt;/h4&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th colspan=\"2\"&gt;Telephone&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;td&gt;555 77 855&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;单元格跨两行:&lt;/h4&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;First Name:&lt;/th&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th rowspan=\"2\"&gt;Telephone:&lt;/th&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;555 77 855&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 单元格边距 1234567891011&lt;h4&gt;有单元格边距:&lt;/h4&gt;&lt;table border=\"1\" cellpadding=\"10\"&gt; &lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Second&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 单元格间距 1234567891011&lt;h4&gt;单元格间距=\"10\":&lt;/h4&gt;&lt;table border=\"1\" cellspacing=\"10\"&gt; &lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Second&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 一个漂亮的表格 https://c.runoob.com/codedemo/3187 标签 Tag Description table 定义表格 th 定义表头单元 td 定义表格数据单元 tr 定义表格行 caption 定义表格标题 colgroup 定义表格列的组 col 定义用于表格列的属性 thead 定义表格的主体 tbody 定义表格的主体 tfoot 定义表格的页脚 列表列表有有序列表（ol）、无序列表（ul）以及自定义列表（dl）。 无序列表ul定义无序列表，列表项会以黑圆点显示。 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表ol定义有序列表，列表项前面会有有序的符号标识。 12345&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 自定义列表自定义列表dl也是列表，不过还是项目和注释的组合。 dl以dt开始，后面是dd。 123456&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 实例 不同类型的有序列表 123456789101112131415161718192021222324252627282930313233343536373839&lt;h4&gt;编号列表：&lt;/h4&gt;&lt;ol&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;大写字母列表：&lt;/h4&gt;&lt;ol type=\"A\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;小写字母列表：&lt;/h4&gt;&lt;ol type=\"a\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;罗马数字列表：&lt;/h4&gt;&lt;ol type=\"I\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;小写罗马数字列表：&lt;/h4&gt;&lt;ol type=\"i\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ol&gt; 不同类型的无序列表 12345678910111213141516171819202122232425&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt; 在 HTML 4中 ul 属性已废弃，HTML5 已不支持该属性，因此我们使用 CSS 代替来定义不同类型的无序列表如下：&lt;/p&gt;&lt;h4&gt;圆点列表：&lt;/h4&gt;&lt;ul style=\"list-style-type:disc\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;圆圈列表：&lt;/h4&gt;&lt;ul style=\"list-style-type:circle\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;正方形列表：&lt;/h4&gt;&lt;ul style=\"list-style-type:square\"&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ul&gt; 嵌套列表 1234567891011&lt;h4&gt;嵌套列表：&lt;/h4&gt;&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea &lt;ul&gt; &lt;li&gt;Black tea&lt;/li&gt; &lt;li&gt;Green tea&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 复杂嵌套列表 12345678910111213141516&lt;h4&gt;嵌套列表：&lt;/h4&gt;&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea &lt;ul&gt; &lt;li&gt;Black tea&lt;/li&gt; &lt;li&gt;Green tea &lt;ul&gt; &lt;li&gt;China&lt;/li&gt; &lt;li&gt;Africa&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 自定义列表 1234567&lt;h4&gt;一个自定义列表：&lt;/h4&gt;&lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt; 区块html可以使用div和span将元素包裹起来。 块元素html元素大致分为块元素和内联元素。 块元素独占一行。 内联元素内联元素不会以新的一行开始。 常见的有：b, td, a, img divdiv是无语义的块容器。 spanspan是无语义的内联容器，用于组合行内元素。 布局布局对网站的外观非常重要。 大多数网站可以使用div和table创建多列布局，用css对元素定位和增添其他样式。不建议使用table布局。 div布局div是用于分组html元素的无语义块容器。 实例：使用5个div创建多列布局 12345678910111213141516&lt;body&gt; &lt;div id=\"container\" style=\"width:500px\"&gt; &lt;div id=\"header\" style=\"background-color:#FFA500;\"&gt; &lt;h1 style=\"margin-bottom:0;\"&gt;主要的网页标题&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"menu\" style=\"background-color:#FFD700;height:200px;width:100px;float:left;\"&gt; &lt;b&gt;菜单&lt;/b&gt;&lt;br&gt; HTML&lt;br&gt; CSS&lt;br&gt; JavaScript&lt;/div&gt; &lt;div id=\"content\" style=\"background-color:#EEEEEE;height:200px;width:400px;float:left;\"&gt; 内容在这里&lt;/div&gt; &lt;div id=\"footer\" style=\"background-color:#FFA500;clear:both;text-align:center;\"&gt; 版权 © runoob.com&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果： table布局table的用途是将数据表格化呈现，table并不是布局工具！ 下面的例子使用三行两列的表格 - 第一和最后一行使用 colspan 属性来横跨两列： 1234567891011121314151617181920212223242526&lt;body&gt; &lt;table width=\"500\" border=\"0\"&gt; &lt;tr&gt; &lt;td colspan=\"2\" style=\"background-color:#FFA500;\"&gt; &lt;h1&gt;主要的网页标题&lt;/h1&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"background-color:#FFD700;width:100px;\"&gt; &lt;b&gt;菜单&lt;/b&gt;&lt;br&gt; HTML&lt;br&gt; CSS&lt;br&gt; JavaScript &lt;/td&gt; &lt;td style=\"background-color:#eeeeee;height:200px;width:400px;\"&gt; 内容在这里&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" style=\"background-color:#FFA500;text-align:center;\"&gt; 版权 © runoob.com&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 效果： 提示 使用外部样式表的好处是，css都在单独的文件中，利于维护。 使用模板可以快速创建布局，通过百度搜索。 消除默认样式： 1234body { padding: 0; margin: 0;} 表单和输入表单用于手机不同类型的用户输入。 表单表单（form）是一个包含表单元素的元素。 表单元素允许用户输入各种内容：文本域textarea，下拉列表select，单选框radio，复选框checkbox。 实例： 123&lt;form&gt; &lt;!-- 表单元素 --&gt;&lt;/form&gt; 输入元素多数情况下输入标签是input，由type属性定义输入类型。 type有以下几类： text 1234&lt;form&gt; First name: &lt;input type=\"text\" name=\"firstname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lastname\"&gt;&lt;/form&gt; password 123&lt;form&gt; Password: &lt;input type=\"password\" name=\"pwd\"&gt;&lt;/form&gt; password会以圆点显示。 radio 单选按钮，name需要一致。 1234&lt;form&gt; &lt;input type=\"radio\" name=\"sex\" value=\"male\" checked=\"checked\"&gt;Male&lt;br&gt; &lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt;Female&lt;/form&gt; 复选框 name需要一致。 1234&lt;form&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\" checked=\"checked\"&gt;I have a bike&lt;br&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\"&gt;I have a car&lt;/form&gt; submit 1234&lt;form name=\"input\" action=\"html_form_action.php\" method=\"get\"&gt; Username: &lt;input type=\"text\" name=\"user\"&gt; &lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt; 点击submit，表单的内容会被提交到action的url。 其他实例 简单下拉列表 12345678&lt;form action=\"\"&gt; &lt;select name=\"cars\"&gt; &lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value=\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"fiat\"&gt;Fiat&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 预选下拉列表 12345678&lt;form action=\"\"&gt; &lt;select name=\"cars\"&gt; &lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value=\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"fiat\" selected&gt;Fiat&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 文本域 123&lt;textarea rows=\"10\" cols=\"30\"&gt;我是一个文本框。&lt;/textarea&gt; 按钮 123&lt;form action=\"\"&gt; &lt;input type=\"button\" value=\"Hello world!\"&gt;&lt;/form&gt; 重置 1&lt;input type=\"reset\" name=\"button\" id=\"button\" value=\"重置\"&gt; 表单实例 带边框的表单 12345678&lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;Personal information:&lt;/legend&gt; Name: &lt;input type=\"text\" size=\"30\"&gt;&lt;br&gt; E-mail: &lt;input type=\"text\" size=\"30\"&gt;&lt;br&gt; Date of birth: &lt;input type=\"text\" size=\"10\"&gt; &lt;/fieldset&gt;&lt;/form&gt; 带输入框和确认按钮的表单 12345&lt;form action=\"demo-form.php\"&gt; First name: &lt;input type=\"text\" name=\"FirstName\" value=\"Mickey\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"LastName\" value=\"Mouse\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 带电子邮件的表单 12345678910&lt;form action=\"MAILTO:someone@example.com\" method=\"post\" enctype=\"text/plain\"&gt; Name:&lt;br&gt; &lt;input type=\"text\" name=\"name\" value=\"your name\"&gt;&lt;br&gt; E-mail:&lt;br&gt; &lt;input type=\"text\" name=\"mail\" value=\"your email\"&gt;&lt;br&gt; Comment:&lt;br&gt; &lt;input type=\"text\" name=\"comment\" value=\"your comment\" size=\"50\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"发送\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt;&lt;/form&gt; 其他表单元素label：定义了input的标签，并使用外框包含起来。fieldset：定义了一组相关的表单元素并使用边框包含起来。legend：定义了fieldset的标题。button：定义了按钮。datalist：指定一个预先定义的输入控件选项列表。output：定义了一个计算结果。 框架使用框架可以在页面中显示另一个页面。 1&lt;iframe src=\"demo_iframe.htm\" width=\"200\" height=\"200\"&gt;&lt;/iframe&gt; width和height默认使用px作为单位，还可以使用百分比。 移除边框： 1&lt;iframe src=\"demo_iframe.htm\" frameborder=\"0\"&gt;&lt;/iframe&gt; 使用iframe显示目标连接页面12&lt;iframe src=\"demo_iframe.htm\" name=\"iframe_a\"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href=\"http://www.runoob.com\" target=\"iframe_a\"&gt;RUNOOB.COM&lt;/a&gt;&lt;/p&gt; 颜色html使用的颜色由RGB构成。 颜色值几种写法： #ff0000，可以简写为#f00 rgb(255, 0, 0) rgba(255, 0, 0, .5)，最后一个参数为透明度 颜色名： 一般不用颜色名。 脚本script标签script标签用于定义脚本。script标签可以直接在中间写代码也可以链接外部脚本文件。JavaScript 最常用于图片操作、表单验证以及内容动态更新。 实例： 123&lt;script&gt; document.write(\"Hello World!\");&lt;/script&gt; noscript标签noscript标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。noscript元素可包含普通HTML页面的body元素中能够找到的所有元素。 只有在浏览器不支持脚本或者禁用脚本时，才会显示noscript元素中的内容： 1234&lt;script&gt; document.write(\"Hello World!\")&lt;/script&gt;&lt;noscript&gt;抱歉，你的浏览器不支持 JavaScript!&lt;/noscript&gt; 字符实体html中的预留字符必须被替换为字符实体。一些在键盘上找不到的字符也可以使用字符实体来替换。 urlurl（统一资源定位符）是一个网页地址。 浏览器通过url从浏览器请求资源。 url规则： 12scheme://host.domain:port/path/filename协议://主机.域名:端口/路径/文件名 常见的协议： http：超文本传输协议，不加密。 https：安全超文本传输协议，加密。 ftp：文件传输协议，上传或下载文件。 file：本机文件。 url编码 url只能采用ascii字符集。 url经常含有ascii之外的字符，所以url必须转化为有效的ascii格式。 url编码使用“%”加后面的两个16进制数字来替换非ascii字符。 url不能包含空格，通常使用“+”替换空格。 速查列表基本文档123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 可见文本...&lt;/body&gt;&lt;/html&gt; 基本标签1234567891011&lt;h1&gt;最大的标题&lt;/h1&gt;&lt;h2&gt; . . . &lt;/h2&gt;&lt;h3&gt; . . . &lt;/h3&gt;&lt;h4&gt; . . . &lt;/h4&gt;&lt;h5&gt; . . . &lt;/h5&gt;&lt;h6&gt;最小的标题&lt;/h6&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化1234567891011121314151617&lt;b&gt;粗体文本&lt;/b&gt;&lt;code&gt;计算机代码&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt;&lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt;&lt;abbr&gt; （缩写） &lt;address&gt; （联系信息） &lt;bdo&gt; （文字方向） &lt;blockquote&gt; （从另一个源引用的部分） &lt;cite&gt; （工作的名称） &lt;del&gt; （删除的文本） &lt;ins&gt; （插入的文本） &lt;sub&gt; （下标文本） &lt;sup&gt; （上标文本） 链接123456普通的链接：&lt;a href=\"http://www.example.com/\"&gt;链接文本&lt;/a&gt;图像链接： &lt;a href=\"http://www.example.com/\"&gt;&lt;img src=\"URL\" alt=\"替换文本\"&gt;&lt;/a&gt;邮件链接： &lt;a href=\"mailto:webmaster@example.com\"&gt;发送e-mail&lt;/a&gt;书签：&lt;a id=\"tips\"&gt;提示部分&lt;/a&gt;&lt;a href=\"#tips\"&gt;跳到提示部分&lt;/a&gt; 图片1&lt;img loading=\"lazy\" src=\"URL\" alt=\"替换文本\" height=\"42\" width=\"42\"&gt; 内部样式1234567891011&lt;style type=\"text/css\"&gt; h1 { color: red; } p { color: blue; }&lt;/style&gt;&lt;div&gt;文档中的块级元素&lt;/div&gt;&lt;span&gt;文档中的内联元素&lt;/span&gt; 无序列表1234&lt;ul&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; 定义列表123456&lt;dl&gt; &lt;dt&gt;项目 1&lt;/dt&gt; &lt;dd&gt;描述项目 1&lt;/dd&gt; &lt;dt&gt;项目 2&lt;/dt&gt; &lt;dd&gt;描述项目 2&lt;/dd&gt;&lt;/dl&gt; 表格12345678910&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 框架1&lt;iframe src=\"demo_iframe.htm\"&gt;&lt;/iframe&gt; 表单123456789101112131415&lt;form action=\"demo_form.php\" method=\"post/get\"&gt; &lt;input type=\"text\" name=\"email\" size=\"40\" maxlength=\"50\"&gt; &lt;input type=\"password\"&gt; &lt;input type=\"checkbox\" checked=\"checked\"&gt; &lt;input type=\"radio\" checked=\"checked\"&gt; &lt;input type=\"submit\" value=\"Send\"&gt; &lt;input type=\"reset\"&gt; &lt;input type=\"hidden\"&gt; &lt;select&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option selected=\"selected\"&gt;香蕉&lt;/option&gt; &lt;option&gt;樱桃&lt;/option&gt; &lt;/select&gt; &lt;textarea name=\"comment\" rows=\"60\" cols=\"20\"&gt;&lt;/textarea&gt;&lt;/form&gt; 实体123&lt; 等同于 &lt;&gt; 等同于 &gt;&amp;#169; 等同于 © 标签速查https://www.runoob.com/html/html-tag-name.html","link":"/2018/02/07/html-tutorial/"},{"title":"html5语义标签用法","text":"html5语义标签就是拥有语义的标签。 语义标签能清楚的向浏览器和开发者描述标签内容。 语义标签 1234567891011121314151617&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;main&gt; &lt;summary&gt;&lt;/summary&gt; &lt;article&gt; &lt;section&gt; &lt;mark&gt;&lt;/mark&gt; &lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;/article&gt; &lt;aside&gt; &lt;details&gt;&lt;/details&gt; &lt;/aside&gt;&lt;/main&gt;&lt;footer&gt;&lt;/footer&gt; 常用布局","link":"/2019/05/18/html5-semantic-tags/"},{"title":"http状态码","text":"XMLHttpRequest.status属性返回一个整数表示服务器响应的http状态码。 XMLHttpRequest.statusText属性返回一个字符串，包含整个状态信息。 状态码 状态信息 意义 200 OK 访问正常 301 Moved Permanently 永久移动 302 Moved temporarily 暂时移动 304 Not Modified 未修改 307 Temporary Redirect 暂时重定向 401 Unauthorized 未授权 403 Forbidden 禁止访问 404 Not Found 未发现指定网址 500 Internal Server Error 服务器发生错误 也就是说：只有2XX和304表示服务器返回是正常状态。 完整状态码： https://www.runoob.com/http/http-status-codes.html 判断服务器返回是否正常： 12345678if (xhr.readyState === 4) { if ( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || (xhr.status === 304) ) { // 处理服务器的返回数据 } else { // 出错 }}","link":"/2018/09/16/http-status-code/"},{"title":"import和export","text":"import 和 export 都要使用 {} 来包裹变量。 import1234567// 逐个引入import {year, month, day} from \"../components/date\";import {year as y, month as m, day as d} from \"../components/date\";// 整体引入赋值给dateimport * as date from \"../components/date\";// 引用：date.year, date.month, date.day import()使用 import() 函数可以实现动态加载（按需加载），返回一个 promise 对象。 import()1234567891011import(url) .then(function () { // ... }) .catch(function () { // ... }); export1234567// 写法一export var year = 2012;export function fn() {}// 写法二export { year, month, day };export { year as y, month as m, day as d }; export defaultimport 一个模块时需要知道模块 export 的变量名。如果不想看 export 的变量名而直接使用的话，可以使用 export default 。 export1export default ...; 这种写法不需要给date加{}： import1import date from \"../components/date\";","link":"/2021/09/17/import-export/"},{"title":"常用meta总结","text":"summary 常用meta整理&lt;meta&gt;标签定义了文档的元数据，对于浏览器可读。 SEO相关12345678910111213141516&lt;!-- 页面关键字 --&gt;&lt;meta name=\"keywords\" content=\"html,css,js,node,java,python\" /&gt;&lt;!-- 页面描述，不超过150个字符 --&gt;&lt;meta name=\"description\" content=\"about computer science.\" /&gt;&lt;!-- 搜索引擎索引方式，常用值none，noindex，nofollow，all，index和follow --&gt;&lt;!-- all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。 --&gt;&lt;meta name=\"robots\" content=\"index,follow\"&gt;","link":"/2018/06/22/html-meta/"},{"title":"慕课网js入门","text":"最近刷了一下慕课网的js入门课程，做了一点笔记。 document对象 12document.write(\"hello\");document.getElementById(\"p1\").style.color = \"blue\"; html中插入js代码 123&lt;script type=\"text/javascript\"&gt; document.write(\"开启JS之旅!\"); //js语句&lt;/script&gt; js代码外链 在html文件中写： 1&lt;script src=\"script.js\"&gt;&lt;/script&gt; 在script.js文件中直接写js代码 js代码位置 我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。放在head部分最常用的方式是在页面中head部分放置 &lt;script&gt; 元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。放在body部分JavaScript代码在网页读取到该语句的时候就会执行。 注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。 每一句JavaScript代码格式: 语句;先来看看下面代码 123&lt;script type=\"text/javascript\"&gt; alert(\"hello!\");&lt;/script&gt; 例子中的 alert(&quot;hello!&quot;); 就是一个JavaScript语句。 一行的结束就被认定为语句的结束，通常在结尾加上一个分号 &quot;;&quot; 来表示语句的结束。 单行注释，在注释内容前加符号 “//”。 123&lt;script type=\"text/javascript\"&gt; document.write(\"单行注释使用'//'\"); // 我是注释，该语句功能在网页中输出内容&lt;/script&gt; 多行注释以”/*“开始，以”*/“结束。 1234567&lt;script type=\"text/javascript\"&gt; document.write(\"多行注释使用/*注释内容*/\"); /* 多行注释 养成书写注释的良好习惯 */&lt;/script&gt; 变量名可以任意取名，但要遵循命名规则: 变量必须使用字母、下划线(_)或者美元符($)开始。 然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。 不能使用JavaScript关键词与JavaScript保留字。 语法 12345if (条件) { 条件成立时执行的代码;} else { 条件不成立时执行的代码;} 假设我们通过年龄来判断是否为成年人，如年龄大于等于18岁，是成年人，否则不是成年人。代码表示如下**:** 12345678910&lt;script type=\"text/javascript\"&gt; var myage = 18; if (myage &gt;= 18) //myage&gt;=18是判断条件 { document.write(\"你是成年人。\"); } else //否则年龄小于18 { document.write(\"未满18岁，你不是成年人。\"); }&lt;/script&gt; 函数 函数是完成某个特定功能的一组语句。如没有函数，完成任务可能需要五行、十行、甚至更多的代码。这时我们就可以把完成特定功能的代码块放到一个函数里，直接调用这个函数，就省重复输入大量代码的麻烦。 如何定义一个函数呢？基本语法如下: 123function 函数名() { 函数代码;} 说明: function定义函数的关键字。 “函数名”你为函数取的名字。 “函数代码”替换为完成特定功能的代码。 我们来编写一个实现两数相加的简单函数, 并给函数起个有意义的名字：“add2”，代码如下： 1234function add2() { var sum = 3 + 2; alert(sum);} 函数调用: 函数定义好后，是不能自动执行的，所以需调用它, 只需直接在需要的位置写函数就ok了, 代码如下: document.write() 12345&lt;script type=\"text/javascript\"&gt; var a = 'hello'; document.write(a + \"&lt;br&gt;\"); document.write('world');&lt;/script&gt; 警告弹窗 12alert(\"字符串\");alert(变量名); 例如 1234&lt;script type=\"text/javascript\"&gt; alert(\"警告\"); alert(\"第二条警告\");&lt;/script&gt; confirm消息对话框 confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。 语法: 1confirm(\"str\"); 参数说明: 12str：在消息对话框中要显示的文本返回值: Boolean值 返回值: 12当用户点击&quot;确定&quot;按钮时，返回true当用户点击&quot;取消&quot;按钮时，返回false 注: 通过返回值可以判断用户点击了什么按钮 看下面的代码: 12345678&lt;script type=\"text/javascript\"&gt; var mymessage = confirm(\"你喜欢JavaScript吗?\"); if (mymessage == true) { document.write(\"很好,加油!\"); } else { document.write(\"JS功能强大，要学习噢!\"); }&lt;/script&gt; prompt消息对话框 弹出消息对话框, 通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。 1prompt(str1, str2); 12str1: 要显示在消息对话框中的文本， 不可修改str2： 文本框中的内容， 可以修改 返回值: 1231. 点击确定按钮，文本框中的内容将作为函数返回值2. 点击取消按钮，将返回null 123456var myname = prompt(\"请输入姓名:\");if (myname != null) { alert(\"你好\" + myname);} else { alert(\"你好我的朋友\");} 打开新窗口 1window.open('URL', '窗口名称', '参数字符串'); 123456789窗口名称：可选参数，被打开窗口的名称。 1.该名称由字母、数字和下划线字符组成。 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。 例如: 打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口： 123&lt;script type=\"text/javascript\"&gt; window.open('http://www.imooc.com', '_blank', 'width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')&lt;/script&gt; 关闭窗口 1234567window.close(); //关闭本窗口窗口对象.close();//关闭指定窗口例如&lt;script style=\"text/javascript\"&gt; var newWindow = window.open('http://www.imooc.com'); newWindow.close();&lt;/script&gt; 注意: 上面代码在打开新窗口的同时，关闭该窗口，看不到被打开的窗口。 DOM 获取id 123document.getElementById(\"这里是id\");var myId = document.getElementById(\"这里是id\");document.write(\"id的标签是\" + myId); innerHTML属性 innerHTML 属性用于获取或替换 HTML 元素的内容。 语法: 1[Object].innerHTML = 'asd' 使用js改变html的样式 12[Object].style.属性 = [new style];Object是通过document.getElementById(\"id\") 获取的元素对象 display属性 123[Object].stytle.display = [value];value: none（ 不显示该元素）block（ 以块元素显示） 控制类名 1[Object].className = \"类名\";","link":"/2018/02/25/imooc-js-junior/"},{"title":"html5学习笔记","text":"html5是html的最新版本，2014年由W3C指定。 html5指定的目的是在移动设备上提供多媒体支持。 html5html5简介html5是下一代html标准。html4.01诞生于1999年。 html5新特性： canvas video，audio 更好的支持本地离线存储。 新的语义容器：article，footer，header，nav，section等等。 新的表单控件：calendar，date，time，email，url，search等等。 html5的声明必须使用： 1&lt;!DOCTYPE html&gt; html5文档实例： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; html5的改进 新元素 新属性 完全支持css3 video，audio 2D、3D制图 本地存储 本地sql数据 web应用 html5多媒体video和audio元素。 html5应用 本地数据存储 访问本地文件 本地sql数据 缓存引用 js worker XHTMLHttpRequest2 html5图形 canvas 内联svg css3 2D转换，3D转换 html5使用css3 新选择器 新属性 动画 2D、3D转换 圆角 阴影 可下载字体 语义元素html5添加了很多语义元素： html5表单新表单元素，新属性，新输入类型，自动验证。 已删除的元素以下的4.01中的元素在html5已经被删除。 acronym applet basefont big center dir font frame frameset noframes strike html5浏览器支持IE9以下的版本兼容html5的方法，使用html5shiv包： 123&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 载入后，初始化新标签的css： 1234567891011article,aside,dialog,footer,header,section,nav,figure,menu { display: block;} html5浏览器支持可以让一些老旧的浏览器支持html5。 现代浏览器都支持html5.浏览器对于无法识别的元素都会作为内联元素处理。 将html5元素定义为块元素html5定义了8个语义元素，这些元素都是块级元素。 为了让旧的浏览器正确显示，可以设置css： 12345678910header,section,footer,aside,nav,main,article,figure { display: block;} 自定义新元素1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;为 HTML 添加新元素&lt;/title&gt; &lt;script&gt; document.createElement(\"myHero\") &lt;/script&gt; &lt;style&gt; myHero { display: block; background-color: #ddd; padding: 50px; font-size: 30px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;myHero&gt;我的第一个新元素&lt;/myHero&gt;&lt;/body&gt;&lt;/html&gt; IE浏览器问题以上的方法可以为IE浏览器添加html5元素，但是不支持IE8及更早的版本。 我们可以使用 Sjoerd Visscher 创建的 “HTML5 Enabling JavaScript”, “ shiv” 来解决该问题: 123&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://html5shiv.googlecode.com/svn/trunk/html5.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 上面的作用是对于IE9以下的版本读取html5.js文件并解析。 123&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 针对IE浏览器html5shiv 是比较好的解决方案。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。 完美的shiv解决方案12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;渲染 HTML5&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一篇文章&lt;/h1&gt; &lt;article&gt; 菜鸟教程 —— 学的不仅是技术，更是梦想！！！ &lt;/article&gt;&lt;/body&gt;&lt;/html&gt; html5新元素和移除的元素html5新元素新的多媒体元素： canvas：定义图形，基于js的绘图API。 video：定义视频。 audio：定义音频。 source：定义video和audio的文件源。 embed：定义嵌入的内容，比如插件。 track：为video和audio之类的元素的媒介规定外部文本轨道。 新的表单元素： datalist：定义选项列表，与input配合使用。 keygen：规定用于表单的秘钥的生成器字段。 output：定义不同类型的输出，比如脚本的输出。 新的语义容器和结构元素： article：定义页面独立的内容区域。 aside：定义页面的侧边栏内容。 bdi：设置文本方向。 command：定义命令按钮，比如单选按钮、复选框、按钮。 details：用于描述文档的细节。 dialog：对话框。 summary：包含details元素的标题。 figure：图像、图标、照片、代码。 fugcaption：定义figure元素的标题。 footer：定义全局或局部的页脚。 header：定义文档头部。 mark：定义标记文本。 meter：定义度量。 nav：定义导航链接部分。 progress：定义任务进度。 ruby：定义ruby注释（中文注音或字符）。 rt：定义字符的解释或者发音。 rp：在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 section：定义文档中的节。 time：定义日期或者时间。 wbr：在文本合适的地方添加换行符。 html5已经移除的元素 acronym applet basefont big center dir font frame frameset noframes strike tt canvas详细教程：https://www.runoob.com/w3cnote/html5-canvas-intro.html canvas标签定义图形，canvas标签只是图形容器，图形需要靠js脚本绘制。 可以使用js在canvas中绘制路径、盒、圆、字符、图像。 创建画布canvas画布是一个矩形框，默认没有边框和内容。需要制定一个id，width和height。一个页面可以有多个canvas。 1&lt;canvas id=\"mycanvas\" width=\"200\" height=\"100\" style=\"border: 1px red solid;\"&gt;&lt;/canvas&gt; 使用js开始绘图12345678// 首先获得画布var c = document.getElementById(\"mycanvas\");// 获得画布的context对象var ctx = c.getContext(\"2d\");// 填充样式，可以有颜色、渐变、图案ctx.fillStyle = \"#f00\";// 填充一个矩形，x,y,width,heightctx.fillRect(0, 0, 150, 75); canvas坐标canvas是一个二维网络，左上角为(0, 0)。 canvas路径使用以下方法画线： moveTo(x, y)定义线条开始坐标 lineTo(x, y)定义线条结束坐标 stroke()绘制线条 实例：绘制直线 12345var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.moveTo(0, 0);ctx.lineTo(200, 100);ctx.stroke(); 实例：绘制圆形 12345var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.beginPath();ctx.arc(95, 50, 40, 0, 2 * Math.PI);ctx.stroke(); canvas绘制文本使用canvas绘制文本的属性和方法如下： font，定义字体 fillText(text, x, y)，绘制实心文本 strokeText(text, x, y)，在canvas上绘制空心文本 实例：绘制实心文本 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.font = \"30px Arial\";ctx.fillText(\"Hello World\", 10, 50); 实例：绘制空心文本 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");ctx.font = \"30px Arial\";ctx.strokeText(\"Hello World\", 10, 50); canvas渐变渐变可以用于填充矩形、圆形、线条、文本等等。 canvas渐变的方法： createLinearGradient(x, y, x1, y1)，创建线性渐变。 createRadialGradient(x, y, r, x1, y1, r1)，创建径向渐变。 使用渐变必须使用两种及以上的颜色。。addColorStop()方法指定颜色停止，参数用坐标描述，0-1。再设置fillStyle()或者strokeStyle()的值为渐变，然后绘制形状。 实例：createLinearGradient() 1234567891011var c = document.getElementById(\"mycanvas\");var ctx = c.getContext(\"2d\");// 创建渐变var grd = ctx.createLinearGradient(0, 0, 200, 0);grd.addColorStop(0, \"red\");grd.addColorStop(1, \"white\");// 填充ctx.fillStyle = grd;ctx.fillRect(10, 10, 150, 80); 实例：createRadialGradient() 1234567891011var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");// 创建渐变var grd = ctx.createRadialGradient(75, 50, 5, 90, 60, 100);grd.addColorStop(0, \"red\");grd.addColorStop(1, \"white\");// 填充渐变ctx.fillStyle = grd;ctx.fillRect(10, 10, 150, 80); canvas绘制图片把一张图片放到canvas中，使用drawImage(image, x, y) 1234var c = document.getElementById(\"myCanvas\");var ctx = c.getContext(\"2d\");var img = document.getElementById(\"scream\");ctx.drawImage(img, 10, 10); 内联svghtml5支持内联svg。 svg是可伸缩矢量图形。svg的特点是： svg用于网络 svg使用XML格式定义图形 svg放大缩小图形质量都不会损失 svg是万维网联盟的标准 svg的优势： svg可以通过编辑器创建和修改 svg可以被搜索、索引、脚本化、压缩 svg可伸缩 svg可以在任何分辨率下打印 svg可以再质量不损失的情况下放大 将svg嵌入html页面123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" height=\"190\"&gt; &lt;polygon points=\"100,10 40,180 190,60 10,60 160,180\" style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\"&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; svg和canvas的区别svg是使用xml描述2d图形的语言，svg基于xml故而可以使用js处理svg事件，适合有大型渲染区域的应用（地图），不适合游戏。canvas是一个画布，通过使用js绘制2d图形，是逐像素渲染的，不支持事件处理，文本渲染能力弱，能够直接保存图像，适合图像密集型游戏。 MathMLMathML的标签是 &lt;math&gt;&lt;/math&gt; 。 MathML基于xml，是用来在网络上书写数学符号和公式的语言。 MathML代码生成：https://latexlive.com/ 拖放（Drag、Drop）拖放是html5标准的一部分，任何元素都能拖放。 拖放：抓取一个对象后拖到另一个位置。 实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1 { width: 350px; height: 70px; padding: 10px; border: 1px solid #aaaaaa; } &lt;/style&gt; &lt;script&gt; function allowDrop(ev) { ev.preventDefault(); } function drag(ev) { ev.dataTransfer.setData(\"Text\", ev.target.id); } function drop(ev) { ev.preventDefault(); var data = ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data)); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt; &lt;div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"&gt;&lt;/div&gt; &lt;br&gt; &lt;img loading=\"lazy\" id=\"drag1\" src=\"/images/logo.png\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"336\" height=\"69\"&gt;&lt;/body&gt;&lt;/html&gt; 解析： 首先，设置元素为可拖动 1&lt;img draggable=\"true\"&gt; 拖动时的行为，ondragstart和setData() drag(): 123function drag(ev) { ev.dataTransfer.setData(\"Text\", ev.target.id);} 放到哪里ondragover ondragover 事件规定在何处放置被拖动的数据。 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用 ondragover 事件的 event.preventDefault() 方法： 1event.preventDefault() 放置ondrop 当放置的时候回发声drop事件。 12345function drop(ev) { ev.preventDefault(); var data = ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data));} 调用preventDefault()来避免浏览器对数据的默认处理（drop事件的默认行为是以链接形式打开） 通过 dataTransfer.getData(“Text”)方法获得被拖的数据。该方法将返回在setData()方法中设置为相同类型的任何数据。 被拖数据是被拖元素的id(“drag1”) 把被拖元素追加到放置元素（目标元素中 实例：来回拖动12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1, #div2 { float: left; width: 100px; height: 35px; margin: 10px; padding: 10px; border: 1px solid #aaaaaa; } &lt;/style&gt; &lt;script&gt; function allowDrop(ev) { ev.preventDefault(); } function drag(ev) { ev.dataTransfer.setData(\"Text\", ev.target.id); } function drop(ev) { ev.preventDefault(); var data = ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data)); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"&gt; &lt;img src=\"img_w3slogo.gif\" draggable=\"true\" ondragstart=\"drag(event)\" id=\"drag1\" width=\"88\" height=\"31\"&gt;&lt;/div&gt; &lt;div id=\"div2\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Geolocation（地理定位）Geolocation（地理定位）用于定位用户的位置（需要获得用户同意）。 获得地理位置使用getCurrentPosition()方法获得用户位置。 实例：获取用户经纬度 1234567891011121314151617var x = document.getElementById(\"demo\");function getLocation() { // 检查是否支持定位 if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(showPosition); } else { // 不支持定位的处理 x.innerHTML = \"该浏览器不支持获取地理位置。\"; }}// 点击按钮的事件function showPosition(position) { x.innerHTML = \"纬度: \" + position.coords.latitude + \"&lt;br&gt;经度: \" + position.coords.longitude;} 实例：在以上的代码中加入错误处理 12345678910111213141516function showError(error) { switch (error.code) { case error.PERMISSION_DENIED: x.innerHTML = \"用户拒绝对获取地理位置的请求。\" break; case error.POSITION_UNAVAILABLE: x.innerHTML = \"位置信息是不可用的。\" break; case error.TIMEOUT: x.innerHTML = \"请求用户地理位置超时。\" break; case error.UNKNOWN_ERROR: x.innerHTML = \"未知错误。\" break; }} 在地图中显示结果需要使用可以使用经纬度的地图服务，谷歌地图或者百度地图： 1234567function showPosition(position) { var latlon = position.coords.latitude + \",\" + position.coords.longitude; var img_url = \"http://maps.googleapis.com/maps/api/staticmap?center=\" + latlon + \"&amp;zoom=14&amp;size=400x300&amp;sensor=false\"; document.getElementById(\"mapholder\").innerHTML = \"&lt;img src='\" + img_url + \"'&gt;\";} 给定位置的信息 更新本地信息 显示用户周围的信息 GPS getCurrentPosition()getCurrentPosition()返回对象： coords.latitude：维度 coords.longitude：经度 coords.accuracy：精度 coords.altitude：海拔 coords.altitudeAccuracy：海拔精度 coords.heading：方向 coords.speed：速度 timestamp：相应日期、时间 其他方法watchPosition()：持续返回用户位置。clearWatch()：停止watchPosition() 实例： 1234567891011121314var x = document.getElementById(\"demo\");function getLocation() { if (navigator.geolocation) { navigator.geolocation.watchPosition(showPosition); } else { x.innerHTML = \"该浏览器不支持获取地理位置。\"; }}function showPosition(position) { x.innerHTML = \"纬度: \" + position.coords.latitude + \"&lt;br&gt;经度: \" + position.coords.longitude;} 实例：百度地图获取经纬度 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入百度 API，\"ak=\" 后面一串码是密钥，最好自己申请--&gt; &lt;script type=\"text/javascript\" src=\"https://api.map.baidu.com/api?v=2.0&amp;ak=7a6QKaIilZftIMmKGAFLG7QT1GLfIncg\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" onclick=\"getLocation()\" value=\"确认\" /&gt; &lt;div id=\"position\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var x = document.getElementById('position'); function getLocation() { // 创建百度地理位置实例，代替 navigator.geolocation var geolocation = new BMap.Geolocation(); geolocation.getCurrentPosition(function(e) { if (this.getStatus() == BMAP_STATUS_SUCCESS) { // 百度 geolocation 的经纬度属性不同，此处是 point.lat 而不是 coords.latitude x.innerHTML = '纬度：' + e.point.lat + '&lt;br/&gt;经度：' + e.point.lng; } else { x.innerHTML = 'failed' + this.getStatus(); } }); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; videohtml5提供了显示视频的标准。 使用12345&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; 您的浏览器不支持Video标签。&lt;/video&gt; 标签详解： 控件controls width、height属性 source元素用于提供多个视频文件，src属性用于指定视频路径。 track元素定义文本轨迹 浏览器对于视频格式的支持 IE：mp4 chrome：mp4、webm、ogg firefox：mp4、webm、ogg safari：mp4 opera：mp4、webm、ogg 视频格式的MIME类型：mp4：video/mp4webm：video/webmogg：video/ogg 使用DOM控制video和audio元素拥有相同的方法、属性和事件，并且可以使用js控制。 方法用于播放、暂停、加载。属性（时长、音量等等）可以被读取和设置。DOM事件通知我视频开始播放、暂停、停止等等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div style=\"text-align:center\"&gt; &lt;button onclick=\"playPause()\"&gt;播放/暂停&lt;/button&gt; &lt;button onclick=\"makeBig()\"&gt;放大&lt;/button&gt; &lt;button onclick=\"makeSmall()\"&gt;缩小&lt;/button&gt; &lt;button onclick=\"makeNormal()\"&gt;普通&lt;/button&gt; &lt;br&gt; &lt;video id=\"video1\" width=\"420\"&gt; &lt;source src=\"mov_bbb.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"mov_bbb.ogg\" type=\"video/ogg\"&gt; 您的浏览器不支持 HTML5 video 标签。 &lt;/video&gt; &lt;/div&gt; &lt;script&gt; var myVideo = document.getElementById(\"video1\"); function playPause() { if (myVideo.paused) myVideo.play(); else myVideo.pause(); } function makeBig() { myVideo.width = 560; } function makeSmall() { myVideo.width = 320; } function makeNormal() { myVideo.width = 420; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; audiohtml5提供了播放音频的标准audio元素。 使用12345&lt;audio controls&gt; &lt;source src=\"horse.ogg\" type=\"audio/ogg\"&gt; &lt;source src=\"horse.mp3\" type=\"audio/mpeg\"&gt; 您的浏览器不支持 audio 元素。&lt;/audio&gt; controls属性提供了播放、暂停、音量控件。 可以使用多个source元素提供多个格式。 浏览器对于音频格式的支持IE：mp3chrome：mp3、wav、oggfirefox：mp3、wav、oggsafari：mp3、wavopera：mp3、wav、ogg 三种音频格式的MIME类型：mp3：audio/mpegogg：audio/oggwav：audio/wav 新的input类型 color date datetime datetime-local email month number 1数量 ( 1 到 5 之间 ): &lt;input type=\"number\" name=\"quantity\" min=\"1\" max=\"5\"&gt; number类型有以下几种属性可以用：disabled, max, maxlength, min, pattern, readonly, required, size, step, value range 1&lt;input type=\"range\" name=\"points\" min=\"1\" max=\"10\"&gt; 可用的属性：max, min, step, value search tel time url week 新表单元素 datalist keygen output datalistdatalist元素规定输入域的选项列表。 datalist属性规定form或者input域应该拥有自动完成功能，当用户开始输入的时候，浏览器在该域下显示填写的选项。实例： 123456789&lt;input list=\"browsers\"&gt;&lt;datalist id=\"browsers\"&gt; &lt;option value=\"Internet Explorer\"&gt; &lt;option value=\"Firefox\"&gt; &lt;option value=\"Chrome\"&gt; &lt;option value=\"Opera\"&gt; &lt;option value=\"Safari\"&gt;&lt;/datalist&gt; keygenkeygen元素的作用是提供一种验证用户的可靠方法，它规定了用于表单的秘钥对生成器字段。 当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书。 实例： 12345&lt;form action=\"demo_keygen.asp\" method=\"get\"&gt; 用户名: &lt;input type=\"text\" name=\"usr_name\"&gt; 加密: &lt;keygen name=\"security\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; outputoutput元素用于不同类型的输出（计算、脚本输出等等）： 12345&lt;form oninput=\"x.value=parseInt(a.value)+parseInt(b.value)\"&gt;0 &lt;input type=\"range\" id=\"a\" value=\"50\"&gt;100 + &lt;input type=\"number\" id=\"b\" value=\"50\"&gt;= &lt;output name=\"x\" for=\"a b\"&gt;&lt;/output&gt;&lt;/form&gt; 新表单属性form元素新属性： autocomplete novalidate input元素新属性： autocomplete autofocus form formaction formenctype formmethod formnovalidate formtarget height, width list min, max multiple pattern (regexp) placeholder required step autocompleteautocomplete属性规定了form和input元素的自动完成功能。当用户开始在元素中输入的时候，浏览器会在域中显示选项。 实例： 123456&lt;form action=\"demo-form.php\" autocomplete=\"on\"&gt; First name:&lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; E-mail: &lt;input type=\"email\" name=\"email\" autocomplete=\"off\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; novalidatenovalidate属性是布尔型，规定了提交表单的时候不应该验证form或者input。 实例：这个表单无需验证 1234&lt;form action=\"demo-form.php\" novalidate&gt; E-mail: &lt;input type=\"email\" name=\"user_email\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; autofocusautofocus属性是一个布尔型，规定了在页面加载的时候某个域自动获取焦点。 实例：页面加载的时候，这个input元素会自动获取焦点 1First name:&lt;input type=\"text\" name=\"fname\" autofocus&gt; input元素的form属性form属性规定了输入域所属的一个或者多个表单。 123456&lt;form action=\"demo-form.php\" id=\"form1\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;Last name: &lt;input type=\"text\" name=\"lname\" form=\"form1\"&gt; input元素的formaction属性formaction属性用于描述表单提交的url地址，该属性会覆盖form元素的action属性。 实例：两个表单提交地址 123456&lt;form action=\"demo-form.php\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt; &lt;input type=\"submit\" formaction=\"demo-admin.php\" value=\"提交\"&gt;&lt;/form&gt; input元素的formenctype属性formenctype属性描述了表单提交到服务器的数据编码，会覆盖form元素的enctype属性。该属性与 type=”submit” 和 type=”image” 配合使用。 实例： 12345&lt;form action=\"demo-post_enctype.php\" method=\"post\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;input type=\"submit\" formenctype=\"multipart/form-data\" value=\"以 Multipart/form-data 提交\"&gt;&lt;/form&gt; formmethod属性formmethod属性定义了表单的提交方式，会覆盖form元素的method属性。该属性可以与 type=”submit” 和 type=”image” 配合使用。 实例： 123456&lt;form action=\"demo-form.php\" method=\"get\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;input type=\"submit\" formmethod=\"post\" formaction=\"demo-post.php\" value=\"使用 POST 提交\"&gt;&lt;/form&gt; formnovalidate属性formnovalidate属性会覆盖form元素的novalidate属性，与submit一起使用。 实例： 12345&lt;form action=\"demo-form.php\"&gt; E-mail: &lt;input type=\"email\" name=\"userid\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt; &lt;input type=\"submit\" formnovalidate value=\"不验证提交\"&gt;&lt;/form&gt; formtarget属性formtarget属性指定一个名称或者一个关键字来指明表单提交数据后的展示。formtarget属性会覆盖form元素的target属性。与submit和image配合使用。 实例： 123456&lt;form action=\"demo-form.php\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"正常提交\"&gt; &lt;input type=\"submit\" formtarget=\"_blank\" value=\"提交到一个新的页面上\"&gt;&lt;/form&gt; width和height属性用于指定image类型input的高度和宽度。 只能用于image类型的input元素 实例： 1&lt;input type=\"image\" src=\"img_submit.gif\" alt=\"Submit\" width=\"48\" height=\"48\"&gt; list属性list属性规定了输入域的datalist，datalist是输入域的选项列表。 实例： 123456789&lt;input list=\"browsers\"&gt;&lt;datalist id=\"browsers\"&gt; &lt;option value=\"Internet Explorer\"&gt; &lt;option value=\"Firefox\"&gt; &lt;option value=\"Chrome\"&gt; &lt;option value=\"Opera\"&gt; &lt;option value=\"Safari\"&gt;&lt;/datalist&gt; min和max属性min、max和step属性用于包含数字的input类型，比如date pickers、number 以及 range。 实例： 12345678Enter a date before 1980-01-01:&lt;input type=\"date\" name=\"bday\" max=\"1979-12-31\"&gt;Enter a date after 2000-01-01:&lt;input type=\"date\" name=\"bday\" min=\"2000-01-02\"&gt;Quantity (between 1 and 5):&lt;input type=\"number\" name=\"quantity\" min=\"1\" max=\"5\" step=\"1\"&gt; multiple属性multiple属性是布尔型属性。 multiple属性规定了input元素可选择多个值，用于email和file类型。 实例：上传多个文件 1Select images: &lt;input type=\"file\" name=\"img\" multiple&gt; pattern属性描述了一个正则表达式用于验证input的value，适用类型有text、search、url、tel、email、password。 实例： 1Country code: &lt;input type=\"text\" name=\"country_code\" pattern=\"[A-Za-z]{3}\" title=\"Three letter country code\"&gt; placeholder属性placeholder属性在输入域提供了提示信息。适用于text, search, url, telephone, email 以及 password。 1&lt;input type=\"text\" name=\"fname\" placeholder=\"First name\"&gt; required属性required属性是一个布尔型属性。带有required属性的输入域必须要填写。使用类型：ext, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。 1Username: &lt;input type=\"text\" name=\"usrname\" required&gt; 语义元素语义元素：有意义的元素，能够清楚地描述其意义以及给浏览器和开发者提示。 新的语义容器 header nav article section aside figcaption figure footer section元素section元素定义了文档中的节，比如章节、页眉或者其他部分。 实例： 1234&lt;section&gt; &lt;h1&gt;WWF&lt;/h1&gt; &lt;p&gt;The World Wide Fund for Nature (WWF) is....&lt;/p&gt;&lt;/section&gt; article元素article元素定义独立的内容。 实例： 1234&lt;article&gt; &lt;h1&gt;Internet Explorer 9&lt;/h1&gt; &lt;p&gt;Windows Internet Explorer 9(缩写为 IE9 )在2011年3月14日21:00 发布。&lt;/p&gt;&lt;/article&gt; nav元素nav元素定义了导航链接部分，不是所有的连接都包含在nav元素中。 实例： 123456&lt;nav&gt; &lt;a href=\"/html/\"&gt;HTML&lt;/a&gt; | &lt;a href=\"/css/\"&gt;CSS&lt;/a&gt; | &lt;a href=\"/js/\"&gt;JavaScript&lt;/a&gt; | &lt;a href=\"/jquery/\"&gt;jQuery&lt;/a&gt;&lt;/nav&gt; aside元素aside元素定义了主内容区域之外的内容（侧边栏），且与主内容相关。 实例： 123456&lt;p&gt;My family and I visited The Epcot center this summer.&lt;/p&gt;&lt;aside&gt; &lt;h4&gt;Epcot Center&lt;/h4&gt; &lt;p&gt;The Epcot Center is a theme park in Disney World, Florida.&lt;/p&gt;&lt;/aside&gt; header元素header定义了文档头部区域，一个文档里可以有多个header。 实例： 1234567&lt;article&gt; &lt;header&gt; &lt;h1&gt;Internet Explorer 9&lt;/h1&gt; &lt;p&gt;&lt;time pubdate datetime=\"2011-03-15\"&gt;&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;Windows Internet Explorer 9(缩写为 IE9 )是在2011年3月14日21:00发布的&lt;/p&gt;&lt;/article&gt; footer元素footer定义了文档的底部区域，通常有连接、作者信息、版权等信息。 1234&lt;footer&gt; &lt;p&gt;Posted by: Hege Refsnes&lt;/p&gt; &lt;p&gt;&lt;time pubdate datetime=\"2012-03-01\"&gt;&lt;/time&gt;&lt;/p&gt;&lt;/footer&gt; figure和figcaption元素figure元素规定了一个独立的内容区域（图片，表格，代码等）。figure元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。figcaption元素规定了figure元素的标题，一般放在figure元素中的最后面。 实例： 1234&lt;figure&gt; &lt;img loading=\"lazy\" src=\"img_pulpit.jpg\" alt=\"The Pulpit Rock\" width=\"304\" height=\"228\"&gt; &lt;figcaption&gt;Fig1. - The Pulpit Pock, Norway.&lt;/figcaption&gt;&lt;/figure&gt; 旧版本浏览器兼容对于不支持html5新元素的浏览器： 123456789header,section,footer,aside,nav,article,figure { display: block;} 对于IE8以及更早的版本： 使用HTML5 Shiv Javascript脚本，放入html中： 123&lt;!--[if lt IE 9]&gt;&lt;script src=\"html5shiv.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 上面的代码需要放在head元素中。 html5 web存储html5 web存储是比cookie更好的本地存储方式。html5 web存储可以在本地存储用户的浏览数据。数据以key/value的形式存在，只对该网页开放使用。 localStorage和sessionStorage对象客户端存储数据的两个对象是： localStorage：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。 sessionStorage：用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。 检查浏览器是否支持这两个对象： 123456if (typeof(Storage) !== \"undefined\") { // 是的! 支持 localStorage sessionStorage 对象! // 一些代码.....} else { // 抱歉! 不支持 web 存储。} localStorage对象localStorage对象存储的数据没有时间限制。 实例： 123456// 存储一组键值对localStorage.sitename = \"菜鸟教程\";// 查找一组键值对并写入一个元素中document.getElementById(\"result\").innerHTML = \"网站名：\" + localStorage.sitename;// 删除一组键值对localStorage.removeItem(\"sitename\"); localStorage对象中的数据都是键值对，sitename是一个key，菜鸟教程是一个值。 localStorage和sessionStorage可使用的API都是一样的，常用的： localStorage.setItem(key, value)，保存一组键值对。 localStorage.getItem(key)，读取一个key的value。 localStorage.removeItem(key)，删除一组键值对。 localStorage.clear()，删除所有数据。 localStorage.key(index)，查询某个index的key。 键值对通常是以字符串存储。 实例：点击转化字符串为数字 1234567if (localStorage.clickcount) { // 类型转换 localStorage.clickcount = Number(localStorage.clickcount) + 1;} else { localStorage.clickcount = 1;}document.getElementById(\"result\").innerHTML = \" 你已经点击了按钮 \" + localStorage.clickcount + \" 次 \"; sessionStorage对象sessionStorage仅用于session会话，关闭标签后数据删除。 实例： 123456if (sessionStorage.clickcount) { sessionStorage.clickcount = Number(sessionStorage.clickcount) + 1;} else { sessionStorage.clickcount = 1;}document.getElementById(\"result\").innerHTML = \"在这个会话中你已经点击了该按钮 \" + sessionStorage.clickcount + \" 次 \"; html5 web sql数据库web sql是一个独立的规范，引入了一组使用sql操作客户端数据库的API。web sql数据库可以再safari、chrome和opera中运行。 核心方法 openDatabase：使用现有的数据库或者新建的数据库创建一个数据库对象。 transaction：用于控制一个事务以及基于这种情况执行提交或者回滚。 executeSql：执行sql查询。 打开数据库使用openDatabase()打开已存在的数据库，若不存在则会创建一个新的数据库： 12var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);参数依次是： 数据库名称、 版本号、 描述文本、 数据库大小、 创建回调 执行查询执行操作使用 database.transaction() 函数： 12345var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function(tx) { // 创建了一个名为LOGS的表 tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');}); 插入数据在上面的基础上插入数据： 123456var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');}); 动态值插入数据： 123456var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function(tx) { // e_id 和 e_log 是外部变量，executeSql 会映射数组参数中的每个条目给 \"?\"。 tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id,log) VALUES (?, ?)', [e_id, e_log]);}); 读取数据123456789101112131415161718192021var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');});db.transaction(function(tx) { tx.executeSql('SELECT * FROM LOGS', [], function(tx, results) { var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++) { alert(results.rows.item(i).log); } }, null);}); 完整实例123456789101112131415161718192021222324var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);var msg;db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")'); msg = '&lt;p&gt;数据表已创建，且插入了两条数据。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg;});db.transaction(function(tx) { tx.executeSql('SELECT * FROM LOGS', [], function(tx, results) { var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++) { msg = \"&lt;p&gt;&lt;b&gt;\" + results.rows.item(i).log + \"&lt;/b&gt;&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; } }, null);}); 删除记录123db.transaction(function(tx) { tx.executeSql('DELETE FROM LOGS WHERE id=1');}); 删除动态id的数据： 123db.transaction(function(tx) { tx.executeSql('DELETE FROM LOGS WHERE id=?', [id]);}); 更新记录123db.transaction(function(tx) { tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=2');}); 更新动态id的数据： 123db.transaction(function(tx) { tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=?', [id]);}); 完整实例123456789101112131415161718192021222324252627282930313233343536var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);var msg;db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")'); msg = '&lt;p&gt;数据表已创建，且插入了两条数据。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg;});db.transaction(function(tx) { tx.executeSql('DELETE FROM LOGS WHERE id=1'); msg = '&lt;p&gt;删除 id 为 1 的记录。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg;});db.transaction(function(tx) { tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=2'); msg = '&lt;p&gt;更新 id 为 2 的记录。&lt;/p&gt;'; document.querySelector('#status').innerHTML = msg;});db.transaction(function(tx) { tx.executeSql('SELECT * FROM LOGS', [], function(tx, results) { var len = results.rows.length, i; msg = \"&lt;p&gt;查询记录条数: \" + len + \"&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++) { msg = \"&lt;p&gt;&lt;b&gt;\" + results.rows.item(i).log + \"&lt;/b&gt;&lt;/p&gt;\"; document.querySelector('#status').innerHTML += msg; } }, null);}); html5应用程序缓存（Application Cache）通过创建cache manifest 文件，可以创建离线web应用。 应用程序缓存的优势： 可以离线浏览 已缓存的资源加载更快 减少服务器负载 cache manifest实例12345678&lt;!DOCTYPE HTML&gt;&lt;html manifest=\"demo.appcache\"&gt;&lt;body&gt; 文档内容......&lt;/body&gt;&lt;/html&gt; cache manifest基础为html标签添加manifest属性即可启用应用程序缓存： 12345&lt;!DOCTYPE HTML&gt;&lt;html manifest=\"demo.appcache\"&gt;...&lt;/html&gt; 指定了manifest的页面都会被缓存。 manifest文件的扩展名为： .appcache 。 manifest文件的MIME类型为： text/cache-manifest ，要在web服务器上配置。 manifest文件manifest文件是简单的文本文件，它告诉浏览器被缓存的内容。 manifest文件的三部分： CACHE MANIFEST：在此标题下列出的文件将在首次下载后进行缓存 NETWORK：在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK：此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 这是一个manifest文件： 1234567891011121314151617# 第一行，CACHE MANIFEST，必需CACHE MANIFEST/theme.css/logo.gif/main.js# 联网时下载NETWORK:login.php# 其他所有文件都在联网时下载NETWORK:*# 如果无法联网，则使用文件替换FALLBACK:/html/ /offline.html 更新缓存一旦应用被缓存，它就会保持缓存直到发生下列情况： 用户清空浏览器缓存 manifest 文件被修改（参阅下面的提示） 由程序来更新应用缓存 完整的manifest文件以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 1234567891011CACHE MANIFEST# 2012-02-21 v1.0.0/theme.css/logo.gif/main.jsNETWORK:login.phpFALLBACK:/html/ /offline.html web workersref: http://www.ruanyifeng.com/blog/2018/07/web-worker.html web workers独立于其他脚本，是运行在后台的js，不影响页面性能。 实例index.html: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;计数： &lt;output id=\"result\"&gt;&lt;/output&gt;&lt;/p&gt; &lt;button onclick=\"startWorker()\"&gt;开始工作&lt;/button&gt; &lt;button onclick=\"stopWorker()\"&gt;停止工作&lt;/button&gt; &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.&lt;/p&gt; &lt;script&gt; var w; function startWorker() { if (typeof(Worker) !== \"undefined\") { if (typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\"); } w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data; }; } else { document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\"; } } function stopWorker() { w.terminate(); w = undefined; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; demo_workers.js: 123456789var i = 0;function timedCount() { i = i + 1; postMessage(i); setTimeout(\"timedCount()\", 500);}timedCount(); 检测浏览器是否支持web worker123456if (typeof(Worker) !== \"undefined\") { // 是的! Web worker 支持! // 一些代码.....} else { //抱歉! Web Worker 不支持} 创建web worker文件demo_workers.js： 123456789var i = 0;function timedCount() { i = i + 1; postMessage(i); setTimeout(\"timedCount()\", 500);}timedCount(); 创建web worker对象在html页面中调用上面写的demo_workers.js文件： 123if (typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\");} 给worker添加一个onmessage事件监听器： 123w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data;}; 终止web worker1w.terminate(); 完整代码html: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;计数： &lt;output id=\"result\"&gt;&lt;/output&gt;&lt;/p&gt; &lt;button onclick=\"startWorker()\"&gt;开始工作&lt;/button&gt; &lt;button onclick=\"stopWorker()\"&gt;停止工作&lt;/button&gt; &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.&lt;/p&gt; &lt;script&gt; var w; function startWorker() { if (typeof(Worker) !== \"undefined\") { if (typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\"); } w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data; }; } else { document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\"; } } function stopWorker() { w.terminate(); w = undefined; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; web worker: 123456789var i = 0;function timedCount() { i = i + 1; postMessage(i); setTimeout(\"timedCount()\", 500);}timedCount(); 关于DOMweb worker文件位于外部，故而web worker无法访问window、document、parent这几个对象。 服务器发送事件（Server-Sent Events）html5服务器发送事件允许网页获得服务器的更新，用途：sns更新、新闻更新等等。 Server-Sent 事件指的是网页自动获取来自服务器的更新。 接收Server-Sent事件通知123456// 创建一个新的EventSource对象，参数是服务器端处理文件路径var source = new EventSource(\"demo_sse.php\");// 出发onmessage事件时更新页面内容source.onmessage = function(event) { document.getElementById(\"result\").innerHTML += event.data + \"&lt;br&gt;\";}; 检测Server-Sent事件支持123456if (typeof(EventSource) !== \"undefined\") { // 浏览器支持 Server-Sent // 一些代码.....} else { // 浏览器不支持 Server-Sent..} 服务器端代码12345678&lt;?phpheader('Content-Type: text/event-stream');header('Cache-Control: no-cache');$time = date('r');echo \"data: The server time is: {$time}\\n\\n\";flush();?&gt; EventSource对象除了onmessage事件，还有onopen，onerror。 websocketwebsocket（ws）是html5提供的一种在单个tcp连接上进行全双工通信的协议。 websocket使得服务器可以主动向客户端推送数据，客户端和服务器只要完成一次握手就可以一直保持连接，并且可以双向传输数据。 在websocket之前要想实现服务器向客户端推送数据需要客户端使用ajax轮询，带宽资源消耗较高。 websocket连接建立后，使用send()向服务器发送数据，使用onmessage事件接受服务器返回的数据。 1var Socket = new webSocket(url, [protocol]); 下面的Socket对象都是这里new的。 websocket属性属性： Socket.readyState：只读，表示连接状态，0 - 表示连接尚未建立，1 - 表示连接已建立，可以进行通信，2 - 表示连接正在进行关闭，3 - 表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount：只读，缓冲区中的字节数。 websocket事件 事件open：Socket.onopen，建立连接时触发。 事件message：Socket.onmessage，客户端接收服务端数据时触发。 事件error：Socket.onerror，通信错误时触发。 事件close：Socket.onclose，连接关闭时触发。 websocket方法 Socket.send()：发送数据。 Socket.close()：关闭连接。 websocket实例websocket通信过程： 首先，客户端要向服务器发起一个http请求，附加头信息： Upgrade: WebSocket 表明这是这是websocket。 然后服务器解析头信息后应答。 这样连接就建立了。 直到客户端、服务端中一方主动关闭连接。 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; function WebSocketTest() { if (\"WebSocket\" in window) { alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:9998/echo\"); ws.onopen = function() { // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); }; ws.onmessage = function(evt) { var received_msg = evt.data; alert(\"数据已接收...\"); }; ws.onclose = function() { // 关闭 websocket alert(\"连接已关闭...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); } } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"sse\"&gt; &lt;a href=\"javascript:WebSocketTest()\"&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; pywebsocket客户端代码已经写好了，还差一个服务器端脚本用来处理websocket（需要python环境运行）。 下载pywebsocket： 1git clone https://github.com/google/pywebsocket.git 执行： 12345python setup.py buildsudo python setup.py install# 查看文档pydoc mod_pywebsocket 开启服务： 12# pywebsocket/mod_pywebsocket下sudo python standalone.py -p 9998 -w ../example/ html5代码规范 使用正确的文档声明 1&lt;!DOCTYPE html&gt; 使用小写元素名 关闭所有标签 关闭空标签 1&lt;meta charset=\"utf-8\" /&gt; 使用小写属性名 属性值 用引号括起来，单引号双引号均可不过风格要统一。 图片属性 图片使用alt和长宽。 空格和等号 等号前后少用空格。 避免一行代码过长 空行和缩进 不要无故添加空行。为每一个逻辑功能块添加空行，便于阅读。缩进使用两个空格，不使用tab。短代码之间不使用不必要的空行和缩进。 html和body标签 html5中可以省略这两个标签，不过不推荐。 head标签 html5中head可以省略，不过不推荐。 元数据 title元素必须。charset必须。 注释 123456&lt;!-- 这是注释 --&gt;&lt;!-- 这是一个较长评论。 这是 一个较长评论。这是一个较长评论。 这是 一个较长评论 这是一个较长评论。 这是 一个较长评论。--&gt; 样式表 1&lt;link rel=\"stylesheet\" href=\"styles.css\"&gt; 外部js 1&lt;script src=\"myscript.js\"&gt; 使用小写文件名 文件扩展名 html: .htmlcss: .cssjs: .js.htm 也可以，原因是早起DOS系统扩展名只能支持三个字符。","link":"/2018/02/10/html5-tutorial/"},{"title":"慕课网js进阶","text":"接上面的js进阶部分课程笔记。 基本语法变量命名变量名字可以任意取，只不过取名字要遵循一些规则: 必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字。如下: 12345678正确: mysum _mychar $numa1 错误: 6num //开头不能用数字 %sum //开头不能用除(_ $)外特殊符号,如(% + /等) sum+num //开头中间不能使用除(_ $)外特殊符号，如(% + /等) 变量声明 123var 变量名;var n1, n2; 1b &gt; a &amp;&amp; b &lt; c //“&amp;&amp;”是并且的意思, 读法\"b大于a\"并且\" b小于c \" &amp;&amp; 是逻辑与操作符，只有 &amp;&amp; 两边值同时为真的时候，整个表达式值才为真。 操作符之间的优先级（高到低）: 算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号 如果同级的运算是按从左到右次序进行, 多层括号由里向外。 数组 创建数组语法： 1var myarray = new Array(); 我们创建数组的同时，还可以为数组指定长度，长度可任意指定。 1var myarray = new Array(8); //创建数组，存储8个数据。 创建数组并赋值 123var arr = new Array();arr[0] = 1;arr[1] = 2; 123var arr = new Array(1, 2, 3, 4);或者var arr = [1, 2, 3, 4]; 数组存储的数据可以是任何类型（数字、字符、布尔值等） 调用数组元素 123arr[i];// 或者调用的同时赋值给变量var temp = arr[i]; 数组长度 12var arr = new Array(1, 2, 3, 4);arr.length; // 4 改变数组长度 1arr.length = 10; 二维数组 一维数组，我们看成一组盒子，每个盒子只能放一个内容。 1一维数组的表示: myarray[]; 二维数组，我们看成一组盒子，不过每个盒子里还可以放多个盒子。 1二维数组的表示: myarray[][]; 注意: 二维数组的两个维度的索引值也是从0开始，两个维度的最后一个索引值为(长度-1)。 二维数组的定义 定义方法1 1234567var myarr = new Array(); //先声明一维 for (var i = 0; i &lt; 2; i++) { //一维长度为2 myarr[i] = new Array(); //再声明二维 for (var j = 0; j &lt; 3; j++) { //二维长度为3 myarr[i][j] = i + j; // 赋值，每个数组元素的值为i+j }} 定义方法2 1234var arr = [ [0, 1], [0, 1, 2]]; 编程练习 使用js，把下面数组 var arr = [‘‘, ‘##’, “*”, “&amp;&amp;”, “**“, “##“]; arr[7] = “**”; 在页面显示如下图所示的图案： * ** 第一步：定义一个数组，存储要展示的图形。 123提示: var arr = ['*', '##', \"***\", \"&amp;&amp;\", \"****\", \"##*\"];arr[7] = \"**\"; 第二步：预想一下arr 数组的长度是多少？ 1提示: 使用alert弹出数组的长度，看看是否跟自己的答案一样。 第三步：将数组内容输出，完成达到的效果。 1提示: 想在不同行显示不同数组内容，别忘记&lt;br/&gt;换行标签。 1234var arr = ['*', '##', \"***\", \"&amp;&amp;\", \"****\", \"##*\"];arr[7] = \"**\";alert(arr.length); //8document.write(arr[0] + \"&lt;br&gt;\" + arr[7] + \"&lt;br&gt;\" + arr[2] + \"&lt;br&gt;\" + arr[4]); if语句 123if (condition) { code} if…else 12345if (condition) { // code} else { // code} if…else嵌套 1234567if () {} else if {} else {} switch语句 1234567891011switch (表达式) { case value1: // code1 break; case value2: // code2 break; ... default: // codeLAST} for 123456789for (初始化变量; 循环条件; 循环迭代) { // code}// 例如var a = [1, 2, 3, 4, 5];for (var i = 0; i &lt; a.length; i++) { document.write(a[i] + \"&lt;br&gt;\");} while 123while (condition) { // code} do…while 1234do { // code}while (condition) 好处：至少执行一次代码 break 在while、for、do…while、while循环中使用break语句退出当前循环，直接执行后面的代码。 123456for (初始条件; 判断条件; 循环后条件值更新) { if (特殊情况) { break; } 循环代码} continue 作用：仅仅跳出本次循环，整个循环继续执行 123456for (初始条件; 判断条件; 循环后条件值更新) { if (特殊情况) { continue; } 循环代码} 编程练习 在一个大学的编程选修课班里，我们得到了一组参加该班级的学生数据，分别是姓名、性别、年龄和年级，接下来呢，我们要利用JavaScript的知识挑出其中所有是大一的女生的的名字哦。 学生信息如下： ​ (‘小A’, ‘女’, 21, ‘大一’), (‘小B’, ‘男’, 23, ‘大三’), ​ (‘小C’, ‘男’, 24, ‘大四’), (‘小D’, ‘女’, 21, ‘大一’), ​ (‘小E’, ‘女’, 22, ‘大四’), (‘小F’, ‘男’, 21, ‘大一’), ​ (‘小G’, ‘女’, 22, ‘大二’), (‘小H’, ‘女’, 20, ‘大三’), ​ (‘小I’, ‘女’, 20, ‘大一’), (‘小J’, ‘男’, 20, ‘大三’) 第一步： 把这些数据组成一个数组，方便我们之后操作哦。 1提示: 使用二维数组。 第二步： 筛选数据吧，首先找出都是大一的所有信息 ; 第三步： 最后再一次筛选上一步得到的数据，打印出都是女生的姓名 ; 1提示: 可以用switch 或 if 语句进行筛选。 123456789101112131415161718var infos = [ ['小A', '女', 21, '大一'], ['小B', '男', 23, '大三'], ['小C', '男', 24, '大四'], ['小C', '男', 24, '大四'], ['小D', '女', 21, '大一'], ['小E', '女', 22, '大四'], ['小F', '男', 21, '大一'], ['小G', '女', 22, '大二'], ['小H', '女', 20, '大三'], ['小I', '女', 20, '大一'], ['小J', '男', 20, '大三']];for (var i = 0; i &lt; infos.length; i++) { if (infos[i][3] === \"大一\" &amp;&amp; infos[i][1] === \"女\") { document.write(infos[i][0] + \"&lt;br /&gt;\"); }} 函数 1234function add(a, b) { sum = a + b; alert(sum);} add()调用 函数的定义 123function 函数名() { // 函数体} 函数调用 1.script标签内调用 12345678&lt;script type=\"text/javascript\"&gt; //定义 function func() { alert(\"调用成功\"); } //调用 func();&lt;/script&gt; 2.onclick调用 12&lt;buttun onclick=\"func()\"&gt;&lt;/buttun&gt; 有参数的函数 123function func(参数1， 参数2， 参数3，......) { // code} 有返回值的函数 1234function add(x, y) { sum = x + y; return sum;} 练习 使用javascript代码写出一个函数：实现传入两个整数后弹出较大的整数。 第一步： 编写代码完成一个函数的定义吧。 第二步： 我们来补充函数体中的控制语句，完成函数功能吧。 1提示:再想一想，两个整数比较有三种情况，大于，等于或小于，所以我们需要控制语句判断(if...else if)。 第三步： 写好的函数，我们就可以任意调用函数了。通过函数调用实现两组数值中，返回较大值吧。 1234567function com(a, b) { if (a &gt;= b) { return a; } else { return b; }} 事件 JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。 比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。 主要事件表: onclick事件 1234567891011&lt;script type=\"text/javascript\"&gt; function shuchu123() { document.write('123'); }&lt;/script&gt;&lt;body&gt; &lt;form&gt; &lt;input name=\"buttun\" type=\"buttun\" value=\"提交\" onclick=\"shuchu123()\" /&gt; &lt;/form&gt;&lt;/body&gt; onmouseover事件 onmouseout事件 onfocus事件 当网页中的对象获得聚点时，执行onfocus调用的程序就会被执行。 onblur失去焦点事件 onselect事件 onchange文本框内容改动事件 onload加载事件 事件会在页面加载完成后，立即发生，同时执行被调用的程序。注意： 加载页面时，触发 onload 事件，事件写在 &lt;body&gt; 标签内。 此节的加载页面，可理解为打开一个新页面时。 如下代码, 当加载一个新页面时，弹出对话框“加载中，请稍等…”。 onunload卸载事件 当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。 练习 使用JS完成一个简单的计算器功能。实现2个输入框中输入整数后，点击第三个输入框能给出2个整数的加减乘除。 提示：获取元素的值设置和获取方法为：例：赋值：document.getElementById(“id”）.value = 1； 取值：var = document.getElementById(“id”）.value； 任务 第一步： 创建构建运算函数count()。 第二步： 获取两个输入框中的值和获取选择框的值。 1提示：document.getElementById( id名 ).value 获取或设置 id名的值。 第三步： 获取通过下拉框来选择的值来改变加减乘除的运算法则。 1提示：使用switch判断运算法则。 第四步： 通过 = 按钮来调用创建的函数，得到结果。 注意: 使用parseInt()函数可解析一个字符串, 并返回一个整数。 对象 访问对象属性的语法: 1[objectName]. [propertyName] 访问对象的方法： 1[objectName]. [methodName]() 日期对象 123var time_now = new Date(); //获取当前电脑系统时间var d = new Date(2012, 10, 1); //2012.10.1var d = new Date('Oct 1,2012'); //2012.10.1 我们最好使用下面介绍的“方法”来严格定义时间。 访问方法语法： [日期对象].[方法]Date对象中处理时间和日期的常用方法： getDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下: 实例： 12345678910var d = new Date(); // Wed Apr 01 2020 22:41:15 GMT+0800 (中国标准时间)d.getDate(); // 1d.getFullYear(); // 2020d.getYear(); // 120d.getMonth(); // 3d.getDay(); // 3d.getHours(); // 22d.getMinutes(); // 41d.getSeconds(); // 15d.getTime(); // 1585752075892 String对象toUpperCase(), toLowerCase()123var str = 'sssssssssss';str.toUpperCase(); //输出大写str.toLowerCase(); //输出小写 charAt()charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。 12var str = 'abcd';str.charAt(index); 作用同 str[index]还可以使用它取字符串最后一个字符： 12var str = 'abcd';str.charAt(str.length - 1); indexOf()用于返回指定子串首次出现的位置 1stringObject.indexOf('subString', startPosition); 123456var str = 'abcdaddb'str.indexOf('da', 0);//startPosition若省略则从0开始检索/*返回指定字符首次出现的index*/ 若找不到符合条件的子串则返回-1 split()字符串分割12stringObject.split(separator, howmany)//将字符串分割为字符串数组，并返回该数组 参数 描述 separator 必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。 howmany 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 使用指定符号分割字符串，代码如下: 123var str = 'www.imooc.com'console.log(str.split(\".\"));console.log(str.split(\".\", 2)); 输出： 12[\"www\", \"imooc\", \"com\"][\"www\", \"imooc\"] substring()提取俩下标之间的字符串12stringObject.substring(startPosition, endPosition);//从0开始 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 123var str = 'www.imooc.com'str.substring(3, 6);str.substring(6, 3); 输出： 12\".im\"\".im\" substr()提取指定数目的字符1stringObject.substr(startPos, length); Math()对象123//直接调用，无需创建Math.PI;Math.abs(); Math 对象是一个固有的对象，无需创建实例，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date, String对象的区别。 Math对象的属性（都是大写） Math对象的方法（都是小写） 编写一个随机数生成器：随机生成一个0-100的随机整数。 123function random_int() { return Math.round(Math.random() * 100);} 12345678910111213141516random_int()53random_int()75random_int()20random_int()73random_int()62random_int()15random_int()7random_int()64 ceil()向上取整1Math.ceil(x) //x必须是一个数值,它返回的是大于或等于x，并且与x最接近的整数。 floor()向下取整1Math.floor(x) //返回的是小于或等于x，并且与 x 最接近的整数。 四舍五入round()1Math.round(x) //round() 方法可把一个数字四舍五入为最接近的整数。 random()随机数1Math.random() //random() 方法可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。 Array数组对象1234567//定义var arr = new Array();var arr = new Array(n);var arr = [a, b, c, d];//调用arr[index]; 数组方法： concat()数组连接concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。 1arrayObject.concat(array1, array2, ..., arrayN); 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 12var arr = [1, 2, 3, 4];arr.concat(5, 6); 1[1, 2, 3, 4, 5, 6] 12var arr = [1, 2, 3, 4]arr.concat([5, 6], [7]); 1[1, 2, 3, 4, 5, 6, 7] join()指定分隔符链接数组元素join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。 1arrayObject.join('分隔符') //若省略则默认使用逗号 12var arr = [1, 2, 3, 4];var str = arr.join('-'); 1'1-2-3-4' reverse()翻转数组元素12arrayObject.reverse()//该方法会改变原来的数组，而不会创建新的数组。 12var arr = [1, 2, 3, 4];arr.reverse(); 1[4, 3, 2, 1] slice()选定元素12//slice() 方法可从已有的数组中返回选定的元素。arrayObject.slice(start, end) 该方法并不会修改数组，而是返回一个子数组。 注意： 可使用负值从数组的尾部选取元素。 如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 String.slice() 与 Array.slice() 相似。 数组排序sort()sort() 会变改原数组，包括const数组。 1arrayObject.sort(函数方法) 如果不指定&lt;方法函数&gt;，则按数组元素的unicode码顺序排列。 12var arr = [1, 23, 4, 14];arr.sort(); 1[1, 14, 23, 4] window对象window对象是BOM的核心，window对象指当前的浏览器窗口。 window对象方法: js计时器1234在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。计时器类型：一次性计时器：仅在指定的延迟时间之后触发一次。间隔性触发计时器：每隔一定的时间间隔就触发一次。 计时器方法： setInterval()计时器每隔一段时间执行代码 1setInterval(code, time); //time以毫秒计时 setInterval() 和 setTimeout() 会返回一个id用于clear。 参数说明： 代码：要调用的函数或要执行的代码串。 交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。 返回值: 一个可以传递给 clearInterval() 从而取消对”代码”的周期性执行的值。 调用函数格式(假设有一个clock()函数): 123setInterval(\"clock()\", 1000);或setInterval(clock, 1000); 我们设置一个计时器，每隔100毫秒调用clock()函数，并将时间显示出来，代码如下: 1234567891011121314151617181920212223&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;计时器&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var clock_id = setInterval(clock, 100) function clock() { var time = new Date(); document.getElementById(\"clock\").value = time; } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type=\"text\" id=\"clock\" size=\"50\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; clearInterval()取消计时器1clearInterval(idOfSetInterval); setTimeout()在页面载入后一次性计时 1setTimeout(code, time); clearTimeout()1clearTimeout(id_of_setTimeout); history对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 12window.history. [属性 / 方法] //window可以不写history.length //history中的url数量 History 对象属性 History 对象方法 使用length属性，当前窗口的浏览历史总长度，代码如下： 1234&lt;script type=\"text/javascript\"&gt; var HL = window.history.length; console.write(HL);&lt;/script&gt; 1234//后退window.history.back();//上面相当于下面window.history.go(-1); 1234//前进window.history.forward();//相当于window.history.go(1); 12//指定打开一个历史页面window.history.go(number); location对象1location. [属性 / 方法] location用于获取或设置窗体的URL，并且可以用于解析URL。 location对象属性图示: location 对象属性： location 对象方法: navigator对象Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 对象属性: 查看浏览器的名称和版本，代码如下: 1234567&lt;script type=\"text/javascript\"&gt; var browser = navigator.appName; var b_version = navigator.appVersion; document.write(\"Browser name\" + browser); document.write(\"&lt;br&gt;\"); document.write(\"Browser version\" + b_version);&lt;/script&gt; userAgent返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) 1navigator.userAgent 使用userAgent判断使用的是什么浏览器(假设使用的是IE8浏览器), 代码如下: 123456789101112131415function judgeBrowser() { var u_agent = navigator.userAgent; var B_name = \"Failed to identify the browser\"; if (u_agent.indexOf(\"Firefox\") &gt; -1) { B_name = \"Firefox\"; } else if (u_agent.indexOf(\"Chrome\") &gt; -1) { B_name = \"Chrome\"; } else if (u_agent.indexOf(\"MSIE\") &gt; -1 &amp;&amp; u_agent.indexOf(\"Trident\") &gt; -1) { B_name = \"IE(8-10)\"; } document.write(\"B_name:\" + B_name + \"&lt;br&gt;\"); document.write(\"u_agent:\" + u_agent + \"&lt;br&gt;\");}judgeBrowser(); 运行结果: screen对象1window.screen.属性; 对象属性: 1234567891011screen.availHeight// 1417screen.colorDepth// 24screen.pixDepth// 24screen.height// 1440 DOM(文档对象模型)文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 先来看看下面代码: 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 1. 元素节点：上图中 &lt;html&gt; 、 &lt;body&gt; 、 &lt;p&gt; 等都是元素节点，即标签。 2. 文本节点: 向用户展示的内容，如 &lt;li&gt;...&lt;/li&gt; 中的JavaScript、DOM、CSS等文本。 3. 属性节点: 元素属性，如 &lt;a&gt; 标签的链接属性 href=&quot;http://www.imooc.com&quot; 。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body, 它的子节点3个li, 它的兄弟结点h2、P。 DOM操作: 注意:前两个是document方法。 getElementsByName()方法返回带有指定名称的节点对象的集合。 12document.getElementsByName(name);//通过元素的name属性查找元素 name属性不唯一，可能返回多个元素组成的数组而不是一个元素 getElementsByTagName()方法返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。 1document.getElementsByTagName(tagname) 说明: Tagname是标签的名称，如p、a、img等标签名。 和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。 看看下面代码，通过getElementsByTagName()获取节点。 getElementById, getElementsByName和getElementsByTagName的区别以人来举例说明，人有能标识身份的身份证，有姓名，有类别(大人、小孩、老人)等。 ID 是一个人的身份证号码，是唯一的。所以通过getElementById获取的是指定的一个人。 Name 是他的名字，可以重复。所以通过getElementsByName获取名字相同的人集合。 TagName可看似某类，getElementsByTagName获取相同类的人集合。如获取小孩这类人，getElementsByTagName(“小孩”)。 把上面的例子转换到HTML中，如下: 1&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby1\"&gt; 音乐 input标签就像人的类别。 name属性就像人的姓名。 id属性就像人的身份证。 方法总结如下: 注意：方法区分大小写 通过下面的例子(6个name=”hobby”的复选项，两个按钮)来区分三种方法的不同: 12345678&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby1\"&gt; 音乐&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby2\"&gt; 登山&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby3\"&gt; 游泳&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby4\"&gt; 阅读&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby5\"&gt; 打球&lt;input type=\"checkbox\" name=\"hobby\" id=\"hobby6\"&gt; 跑步&lt;input type=\"button\" value=\"全选\" id=\"button1\"&gt;&lt;input type=\"button\" value=\"全不选\" id=\"button1\"&gt; document.getElementsByTagName(“input”)，结果为获取所有标签为input的元素，共8个。 document.getElementsByName(“hobby”)，结果为获取属性name=”hobby”的元素，共6个。 document.getElementById(“hobby6”)，结果为获取属性id=”hobby6”的元素，只有一个，”跑步”这个复选项。 getAttribute()方法1elementNode.getAttribute(name); 说明: elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点。 name：要想查询的元素节点的属性名字 看看下面的代码，获取h1标签的属性值： 运行结果: h1标签的ID ：alinkh1标签的title ：getAttribute()获取标签的属值 setArrribute()方法setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。 语法： 1elementNode.setAttribute(name,value) 说明： 1.name: 要设置的属性名。 2.value: 要设置的属性值。 注意： 把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。 类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。 节点属性在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称 nodeValue ：节点的值 nodeType ：节点的类型 一、nodeName 属性: 节点的名称，是只读的。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document 二、nodeValue 属性：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 访问子节点childNodes访问旋顶元素节点下的所有子节点的列表，返回值为一个数组 1elementNode.childNodes 访问子节点的第一项和最后一项1234//访问第一个子节点node.firstChild//等于node.childNodes[0] 1234//访问最后一个子节点node.lastChild//等于node.childNodes[node.length - 1] 访问父节点parentNode1elementNode.parentNode 访问兄弟节点12nodeObject.nextSibling //右兄弟nodeObject.previousSibling //左兄弟 插入节点appendChild()12appendChild(newNode)//在指定节点的最后一个子节点列表之后添加一个新的子节点。 插入节点insertBefore()12insertBefore(newnode, node)//insertBefore() 方法可在已有的子节点前插入一个新的子节点。 删除节点removeChild()12nodeObject.removeChild(node)//removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。 替换元素节点replaceChild()12node.replaceChild(newnode, oldnew)//replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 创建元素节点createElement12document.creatElement(tagName)//要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。 创建文本节点createTextNode1document.createTextNode(data) 浏览器窗口可视区域大小获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法: 一、对于IE9+、Chrome、Firefox、Opera 以及 Safari： • window.innerHeight - 浏览器窗口的内部高度 • window.innerWidth - 浏览器窗口的内部宽度 二、对于 Internet Explorer 8、7、6、5： • document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。 • document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。 或者 Document对象的body属性对应HTML文档的 &lt;body&gt; 标签 • document.body.clientHeight • document.body.clientWidth 在不同浏览器都实用的 JavaScript 方案： 1234var w = document.documentElement.clientWidth || document.body.clientWidth;var h = document.documentElement.clientHeight || document.body.clientHeight; 网页尺寸scrollHeight和scrollWidth获取网页内容高度和宽度 一、针对IE、Opera: scrollHeight 是网页内容实际高度，可以小于 clientHeight。 二、针对NS、FF: scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 三、浏览器兼容性 1234var w=document.documentElement.scrollWidth || document.body.scrollWidth;var h=document.documentElement.scrollHeight || document.body.scrollHeight; 注意: 区分大小写 scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。 网页尺寸offsetHeightoffsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。 一、值 offsetHeight = clientHeight + 滚动条 + 边框。 二、浏览器兼容性 1234var w = document.documentElement.offsetWidth || document.body.offsetWidth;var h = document.documentElement.offsetHeight || document.body.offsetHeight; 网页卷去的距离与偏移量我们先来看看下面的图： scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。 scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。 offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。 offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。 注意: 1. 区分大小写 2. offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。 编程挑战现在利用之前我们学过的JavaScript知识，实现选项卡切换的效果。 效果图: 文字素材: 房产： ​ 275万购昌平邻铁三居 总价20万买一居​ 200万内购五环三居 140万安家东三环​ 北京首现零首付楼盘 53万购东5环50平​ 京楼盘直降5000 中信府 公园楼王现房 家居: ​ 40平出租屋大改造 美少女的混搭小窝​ 经典清新简欧爱家 90平老房焕发新生​ 新中式的酷色温情 66平撞色活泼家居​ 瓷砖就像选好老婆 卫生间烟道的设计 二手房： ​ 通州豪华3居260万 二环稀缺2居250w甩​ 西3环通透2居290万 130万2居限量抢购​ 黄城根小学学区仅260万 121平70万抛!​ 独家别墅280万 苏州桥2居优惠价248万 任务大家先思考和分析实现思路，然后在动手实现 一、HTML页面布局 123提示:选项卡标题使用ul..li选项卡内容使用div 二、CSS样式制作 12345提示:整个选项卡的样式设置选项卡标题的样式设置选项卡内容的样式设置一开始只显示一个选项卡内容，其它选项卡内容隐藏。 三、JS实现选项卡切换 1234提示:获取选项卡标题和选项卡内容选项卡内容多个，需要循环遍历来操作，得知哪个选项卡和哪个选项内容匹配通过改变DOM的css类名称,当前点击的选项卡显示，其它隐藏。","link":"/2018/02/26/imooc-js-senior/"},{"title":"Java复习笔记（二）","text":"Day02: 2020.09.05 变量类型java中的所有变量使用之前都必须要声明。 声明实例： 123456int a, b, c;int d = 3, e = 4;byte z = 2;String str = \"this is a line of string\";double pi = 2.14;char x = 'a'; java支持的变量类型有：类变量：独立于方法之外的变量，用static修饰。实例变量：独立于方法之外的变量，没有static修饰。局部变量：类的方法中的变量。 123456789101112public class Variable{ // 类变量 static int count = 0; // 实例变量 String str = 'asd'; public void method(){ // 局部变量 int a = 1; }} 局部变量 局部变量声明在方法、构造方法或者语句块中。 局部变量在方法、构造方法、或者语句块被执行的时候创建，执行完毕就会被销毁。 访问修饰符不能用于局部变量。 局部变量只在声明它的方法、构造方法或者语句块中可见。 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后必须要初始化才能使用。 实例1：age是一个局部变量，定义在pupAge()中，age的作用域就限制在该方法中。Test.java: 12345678910111213141516public class Test{ // pupAge()方法 public void pupAge(){ int age = 0; age = age + 7; System.out.println(\"小狗的年龄是：\" + age); } // 主函数，调用pupAge() public static void main(String[] args){ // new一个Test类的实例 Test test = new Test(); // 调用Test类的pupAge()方法，如果成功的话则第一次会输出7，而且再次运行也会是输出7 test.pupAge(); }} 第一次运行输出： 1小狗的年龄是：7 第二次运行输出： 1小狗的年龄是：7 可以看到age并没有再次+7，也就是说age变量仅限于执行中，执行完毕age就被销毁了。 实例2：下面的局部变量age变量没有初始化，故而javac的时候会报错。 12345678910111213public class Test{ public void pupAge(){ // 局部变量age没有初始化 int age; age = age + 7; System.out.println(\"小狗的年龄是 : \" + age); } public static void main(String[] args){ Test test = new Test(); test.pupAge(); }} 编译出错：variable number might not have been initialized。变量还没有被初始化。 实例变量 声明在一个类中，但是在方法、构造方法和语句块之外。 当一个对象被实例化后，每个实例变量的值就跟着确定。 实例变量在对象创建的时候创建，在对象被销毁的时候销毁。 实例变量的值至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方法获取实例变量信息。 实例变量可以声明在使用前或者使用后。 访问修饰符可以修饰实例变量。 实例变量对于类中的方法、构造方法或者语句块是可见的，一般情况下应该吧实例变量设为私有，通过使用访问修饰符可以使实例变量对子类可见。 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 实例：Employee.java 123456789101112131415161718192021222324252627import java.io.*;public class Employee{ // 这个实例变量对子类可见 public String name; // 私有变量，仅在该类可见 private double salary; //在构造器中对name赋值 public Employee (String empName){ name = empName; } //设定salary的值 public void setSalary(double empSal){ salary = empSal; } // 打印信息 public void printEmp(){ System.out.println(\"名字 : \" + name ); System.out.println(\"薪水 : \" + salary); } public static void main(String[] args){ Employee empOne = new Employee(\"RUNOOB\"); empOne.setSalary(1000.0); empOne.printEmp(); }} 编译并运行： 12名字 : RUNOOB薪水 : 1000.0 类变量（静态变量） 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 实例：Employee.java 123456789101112import java.io.*; public class Employee { //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = \"开发人员\"; public static void main(String[] args){ salary = 10000; System.out.println(DEPARTMENT+\"平均工资:\"+salary); }} 输出： 1开发人员平均工资:10000.0 如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT。 修饰符修饰符的分类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。 一共有4中访问控制修饰符： default（即不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private: 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 public: 对所有类可见。使用对象：类、接口、变量、方法。 protected: 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 默认访问修饰符：不使用任何关键字。 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 Day02: 2020.09.05","link":"/2020/09/05/java-review-02/"},{"title":"面试会问到的linux命令","text":"总结一下面试中会问到的linux命令。 ls 常用命令： 12ls -lls --color=auto 输出信息： 第一列：第一个字为文件类型，后面三组分别是所属用户权限、所属组权限和其他用户所属权限，r (2)、w (4)、e (1)分别是读、写、执行。若为-则表示没有权限。 第二列：硬连接数量，硬连接就是允许一个文件有多个有效路径名。 第三列：为文件所属用户。 第四列：为文件所属组。 第五列：为文件大小。 第六列：为文件被修改的时间。 最后一列：为文件名。 可以使用chown改变所属用户，用chgrp改变所属组。 nohup 不要挂起命令 1nohup &lt;command&gt; &gt;file.name 2 &gt;&amp;1 &amp; 1表示标准输出，2表示标准错误输出。2&gt;1&amp;表示将两者合并。 ps 查看当前正在运行的程序使用ps -ef 1ps -ef | grep &lt;progress&gt; awk 下面的命令作用是将.csv文件按照“,”分割并打印第一列和第二列。 1awk -F \",\" '{print 2}' filename.csv 下面的命令作用是获取第三列的最大值。 1awk 'BEGIN{max=0}{if(3&gt;max)max=3}END{print max}' tar 解压缩命令。 参数： -c: 压缩。 -x: 解压缩。 -t: 列出tar文件包含的文件信息。 -r: 附加新的文件到包中。 常用写法： 1234567891011# 压缩、实时显示、强制打包为tartar -cvf &lt;filename&gt;.tar &lt;filename&gt;# 解压缩、实时显示、强制解包tartar -xvf &lt;filename&gt;.tar# 用gzip压缩、实时显示、强制打包为tar.gztar -zcvf &lt;filename&gt;.tar.gz &lt;filename&gt;# 用gzip解压缩、实时显示、强制解包tar.gztar -zxvf &lt;filename&gt;.tar.gz scp scp可以再多个服务器中相互复制传输文件。 常用写法： 将文件A复制到位于网络上的B位置。 1scp -r A B rm 慎用rm。 linux没有回收站机制，将rm命令alias为mv并将要删除文件移入一个目录既可创建回收站机制。 watch 动态监控命令执行结果。 mac没有watch命令，brew安装： 1brew install watch 例子1：每隔一秒高亮显示http连接数变化。 1watch -n 1 -d 'pstree | grep http' 例子2：每隔十秒输出系统的平均负载。 1watch -n 10 'cat /proc/loadavg' df 查看磁盘使用情况。 常用命令： 1df -h tcpdump 和它类似的工具在windows中是wireshark，其采用底层库winpcap/libpcap实现。采用了bpf过滤机制。下面我们看看提供的不同参数的含义。 参数名 含义 -n 使用IP地址表示主机。使用数字表示端口 -i 指定要监听的端口。如果为”-i any”表示住区所有网卡数据包 -v 输出诸如ip数据包中的TTL更加详细的信息 -t 不打印时间戳 -e 显示以太网帧头部信息 -c 仅仅抓取指定数量的数据包 -x 按照十六进制显示数据包内容 -X 不仅仅输出-x结果还输出十六进制对应的ASCII字符 -s 设置抓包时的抓包长度 -w 将输出结果定向到某个文件，一般为pcap后缀 -r 从文件读取数据包并显示数字表示端口 -i 指定要监听的端口。如果为”-i any”表示住区所有网卡数据包 -v 输出诸如ip数据包中的TTL更加详细的信息 -t 不打印时间戳 -e 显示以太网帧头部信息 -c 仅仅抓取指定数量的数据包 -x 按照十六进制显示数据包内容 -X 不仅仅输出-x结果还输出十六进制对应的ASCII字符 -s 设置抓包时的抓包长度 -w 将输出结果定向到某个文件，一般为pcap后缀 -r 从文件读取数据包并显示 知道了相关参数，下面看几个案例 执行任务 执行命令 捕获特定网口数据包 tcpdump -i eth0 捕获特定个数(1000)的包 tcpdump -c 1000 -i eth0 将捕获的包保存到文件 tcpdump -w a.pcap -i eth0 读取pcap格式的包 tcpdump -r a.pcap 增加捕获包的时间戳 tcpdump -n -ttt -i eth0 指定捕获包的协议类型 tcpdump -i eth0 arp 捕获指定端口 tcpdump -i eth0 post 22 捕获特定目标ip+port的包 tcpdump -i eth0 dst address and port 22 捕获DNS请求和响应 tcpdump -i eth0 -s0 port 53 匹配Http请求头 tcpdump -s 0 -v -n -l | egrep -i “POST /|GET /|Host:” 将捕获的包保存到文件 tcpdump -w a.pcap -i eth0 读取pcap格式的包 tcpdump -r a.pcap 增加捕获包的时间戳 tcpdump -n -ttt -i eth0 指定捕获包的协议类型 tcpdump -i eth0 arp 捕获指定端口 tcpdump -i eth0 post 22 捕获特定目标ip+port的包 tcpdump -i eth0 dst address and port 22 捕获DNS请求和响应 tcpdump -i eth0 -s0 port 53 匹配Http请求头 tcpdump -s 0 -v -n -l | egrep -i “POST /|GET /|Host:” lsof 列出当前打开的文件描述符工具，可以得知描述符被声明进程使用。 参数 描述 -i 显示sokcet文件描述符 -c 显示指定的命令打开的所有文件描述符 -t 仅显示打开了目标文件描述符的进程pid 例子： 执行任务 命令 列出所有的网络链接 lsof -i 列出所有udp的网络链接 lsof -i udp 列出谁在使用某个端口 lsof -i :3306 列出谁在使用特定的tcp端口 lsof -i tcp:80 根据文件描述范围列出文件信息 lsof -d 2-3 nc 瑞士军刀，它用来快速构建网络链接。常用来调试客户端程序。 参数 描述 -i 设置数据包传送的时间间隔 -l 以服务器方式运行。默认为客户端运行 -k 重复接受并处理某个端口上的所有链接 -p 以客户端运行时强制其使用指定端口 -C 将CR和LF两个字符作为结束符 -u 使用udp协议。默认tcp协议 -X nc客户端余代理服务器通信时默认为socks5协议。 -z 扫描目标机器某个范围服务是否开启 例子： 执行任务 执行命令 扫描机器A端口号在30-40的服务 nc -z A 30-40 连接服务器A 端口号为5000 nc -C A 5000 传送文件 MachineA:nc -v -n ip portE:\\a.exe netstat 网络信息统计。 可以查看网卡接口、路由表。 参数 描述 -n 使用IP地址表示主机 -a 显示结果中包含监听的socket -t 仅显示TCP连接 -r 显示路由信息 -i 显示网卡接口数据流量 -c 每隔1s输出一次 -o 显示socket定时器的信息 -p 显示socket所属的进程的PID和名字 例子： 执行任务 执行命令 列出所有连接 netstat -a 只列出TCP或者UDP netstat -at/netstat -au 列出监听中的连接 netstat -tnl 获取进程名、进程号以及用户 ID nestat -nlpt 打印统计信息 netstat -s netstat持续输出 netstat -ct 打印active状态的连接 netstat -atnp | grep ESTA 查看服务是否运行(npt) netstat -aple| grep ntp vmstat 实时输出系统进程信息和内存信息以及cpu占用。 参数 描述 -f 显示系统自启动以来执行的fork次数 -s 显示内存相关统计信息 -d 显示磁盘相关统计信息 -p 显示指定磁盘分区统计信息 count 采样次数。 vmstat输出信息字段： 字段名 描述 procs r表示等待运行的而进程数目。b表示处于不可中断睡眠状态的进程数目 memory swpd：使用的虚拟内存量。free：空闲内存量。buff：用作缓冲区的内存量。cache：用作缓存的内存量。 swap si：从磁盘换入的内存量（/s）。so：交换到磁盘的内存量（/s）。 io bi：从块设备接收的块（blocks/s）。bo：发送到块设备的块（blocks/s）。 system in：每秒中断的次数，包括时钟。cs：每秒上下文切换的次数。 mpstat 用于实时监测多个处理器系统中的每个cpu的状态，需要先安装sysstat。 输出信息字段： 字段 描述 cpu 表示当前条信息属于哪个cpu的数据 %usr 进程运行在用户空间所占cpu运行时间的比例 %nice nice值为负的进程运行在用户空间的时间占cpu总运行时间的比例 %iowait cpu等待磁盘操作的时间占cpu总运行时间的比例 %irq cpu用于处理硬件中断时间占cpu总运行时间的比例 %soft cpu用于处理软件中断的时间占cpu用运行时间的比例 %steal 一对虚拟cpu。当超级管理员在处理某个虚拟cpu时，另一个等待它处理完才能运行。这段等待时间表示为steal时间占总运行时间的比例 %guest 运行虚拟cpu时间占cpu总运行时间的比例 %idle 系统空闲时间占cpu总运行时间的比例 split 将文件分割为多个文件。 例子：将README.md文件每隔3行分割为一个文件。 1split -3 README.md wc wc命令的作用是统计文件的字节数、字数、列数。若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。 -c或–bytes或——chars：只显示Bytes数；-l或——lines：只显示行数；-w或——words：只显示字数。 more/less head/tail diff 其他linux命令查询：man","link":"/2020/05/04/interview-linux-commands/"},{"title":"jQuery学习笔记（一）","text":"学习一下jquery jquery入门 jquery 是一个js库，它简化了js编程。 jquery实例： jquery入口函数1234567891011$(document).ready(function() { $(\"div\").click(function() { $(this).hide(); });});$(function() { $(\"div\").click(function() { $(this).hide(); });}); jquery前置知识： html css javascript jquery的功能有： html元素抓取 html元素操作 css操作 html事件函数 js特效和动画 html DOM的遍历和修改 ajax utilities 使用jquery主要因为用jquery的企业多。 关于jquery对IE的支持： jquery2以上不支持IE6.，7，8。 如果要支持IE6.，7，8，选择jquery1.9. 一般使用jquery1.x就可以了。 条件注释，判断IE版本自动选择jquery版本： 123456&lt;!--[if lt IE 9]&gt; &lt;script src=\"jquery-1.9.0.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;!--[if gte IE 9]&gt;&lt;!--&gt;&lt;script src=\"jquery-2.0.0.js\"&gt;&lt;/script&gt;&lt;!--&lt;![endif]--&gt; jquery安装下载jquery分为开发环境版本（未压缩）和生产环境版本（已压缩），从jquery官网下载：https://jquery.com/download/ 。 引入方法一： 将下载的 jquery.js 文件放到项目目录下。 html中引入： 1&lt;script src=\"jquery.js\"&gt;&lt;/script&gt; html5中引入js不需要加上 type=&quot;text/javascript&quot; 。 方法二： 使用静态资源cdn，比如75cdn。 使用cdn的好处是如果用户之前访问了某些网站加载过jquery文件则无需再次加载。 1&lt;script src=\"https://lib.baomitu.com/jquery/1.12.4/jquery.js\"&gt;&lt;/script&gt; 控制台查看页面使用的jquery版本： 1$.fn.jquery jquery语法基本语法通过jquery，我们可以选取（query）页面元素，并对元素进行操作（actions）。 jquery基础语法： 1234$(selector).action();// 美元符号定义了jquery// selector使用css选择器语法选取html元素// action()对选取的元素执行一些操作 实例： 12$(this).hide();$(\"p.test\").hide(); 文档就绪事件所有的jquery代码都要写在文档就绪事件函数中（或者说jquery入口函数）。 jquery入口函数是在DOM全都加载完毕后执行。 12345678910111213141516&lt;!--引入jquery--&gt;&lt;script src=\"js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;!--写法一--&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function() { // jquery code });&lt;/script&gt;&lt;!--写法二--&gt;&lt;script type=\"text/javascript\"&gt; $(function() { // jquery code });&lt;/script&gt; js入口函数：在DOM以及所有外部资源都加载完毕后执行 123window.onload = function() { // js code} jquery选择器jquery选择器可以对单个元素或者多个元素进行操作。 jquery除了支持css选择器之外，还有自己的选择器。 下面是常用的jquery选择器： 123456789101112131415161718192021222324252627282930$(\"*\")$(this)$(\"tag\")$(\"#id\")$(\".class\")$(\"tag.class\")$(\"tag#id\")$(\"p:first\") // 选取第一个p元素$(\"ul li:first\") // 选取第一个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素$(\"ul li:first-child\") // 选取每个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素$(\"[href]\")$(\"a[target='_blank']\")$(\"a[target!='_blank']\")$(\":button\") // 选取所有 type=\"button\" 的 &lt;input&gt; 元素 和 &lt;button&gt; 元素$(\"tr:even\") // 选取偶数位置的 &lt;tr&gt; 元素$(\"tr:odd\") // 选取奇数位置的 &lt;tr&gt; 元素$(\"#id, .class\") // 复合选择器$(\"div p span\") // 层级选择器 //div下的p元素中的span元素$(\"div&gt;p\") // 父子选择器div下的所有p元素$(\"div+p\") // 相邻元素选择器div后面的p元素(仅一个p)$(\"div~p\") // 兄弟选择器div后面的所有p元素(同级别)$(\".p:last\") // 类选择器加过滤选择器 第一个和最后一个（first 或者 last）$(\"div p:eq(2)\") // 索引选择器div下的第三个p元素（索引是从0开始）$(\"p:contains(test)\") // 内容过滤选择器，包含text内容的p元素$(\":empty\") // 内容过滤选择器，所有空标签（不包含子标签和内容的标签）parent相反$(\":hidden\") // 所有隐藏元素$(\"input:enabled\") // 选取所有启用的表单元素$(\":disabled\") // 所有不可用的元素$(\"input:checked\") // 获取所有选中的复选框单选按钮等$(\"select option:selected\") // 获取选中的选项元素 tips： 最好将jquery代码放入一个单独的js文件中。 比如： 1234&lt;head&gt; &lt;script src=\"jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"js/my_jquery_code.js\"&gt;&lt;/script&gt;&lt;/head&gt; jquery事件常用的jquery事件常用的jquery事件： 鼠标事件： click dblclick mouseenter mouseleave hover 键盘事件： keypress：按下触发，返回ascii代码，对于修饰键无效。 keydown：只要按着就不停地触发，返回按键代码。 keyup：松开按键触发，返回按键代码。 表单事件： submit change focus blur 窗口事件： load resize scroll unload jquery事件方法语句123$(\"input\").click(function() { // actions}); jquery常用事件方法 $(document).ready() jquery入口函数。 click() 元素被点击时触发函数。 123$(\"p\").click(function() { $(this).hide();}); dblclick() 双击元素触发函数。 123$(\"p\").dblclick(function() { $(this).hide();}); mouseenter() 鼠标指针进入元素时触发。 123$(\"#p1\").mouseenter(function() { alert('您的鼠标移到了 id=\"p1\" 的元素上!');}); mouseleave() 鼠标指针离开元素的时候触发。 123$(\"#p1\").mouseleave(function() { alert(\"再见，您的鼠标离开了该段落。\");}); 除此之外还有： mousedown()：按下鼠标时触发 mouseup()：松开鼠标时触发 hover()：悬停时触发 focus()：获取焦点时触发 blur()：失去焦点时触发 tips keypress, keydown, keyup的区别:1.keydown：在键盘上按下某键时发生, 一直按着则会不断触发（opera浏览器除外）, 它返回的是键盘代码;2.keypress：在键盘上按下一个按键，并产生一个字符时发生, 返回ASCII码。注意: shift、alt、ctrl等键按下并不会产生字符，所以监听无效 , 换句话说, 只有按下能在屏幕上输出字符的按键时keypress事件才会触发。若一直按着某按键则会不断触发。3.keyup：用户松开某一个按键时触发, 与keydown相对, 返回键盘代码. 实例：拿到按下的键的按键代码 123$(window).keydown(function() { var val = event.which;}); 实例：给事件处理函数传递参数，语法： jQueryObject.keypress( [[ data ,] handler ] ); 123456789var validKeys = { start: 65, end: 90};$(\"#keys\").keypress(validKeys, function(event) { var keys = event.data; //拿到validKeys对象. return event.which &gt;= keys.start &amp;&amp; event.which &lt;= keys.end;});","link":"/2018/06/09/jquery-tutorial-1/"},{"title":"jQuery学习笔记（四）","text":"jquery遍历 jquery遍历就是查找元素，从一个元素开始沿着这个元素移动并到达期望请选择的元素。 遍历 在DOM中存在这几种关系： 父子元素 兄弟元素 祖先元素，后代元素 祖先 parent()：返回被选元素的父元素。 parents()：返回被选元素的所有祖先元素直到根元素。 parentsUntil()：返回两个给定元素之间的所有祖先元素。 使用过滤器： 123456789// parents()过滤器$(document).ready(function(){ $(\"span\").parents(\"ul\");});// parentsUntil()$(document).ready(function(){ $(\"span\").parentsUntil(\"div\");}); 后代 children()：返回被选元素的所有直接子元素。 find()：返回被选元素的所有后代元素。 也可以使用过滤器。 兄弟兄弟节点拥有相同的父元素。 siblings()：返回被选元素的所有兄弟元素。 next()：返回被选元素的下一个兄弟元素。 nextAll()：返回被选元素的后面的所有兄弟元素。 nextUntil()：返回介于两个给定参数之间的所有兄弟元素。 prev()：返回被选元素的上一个兄弟元素。 prevAll()：返回被选元素的前面的所有兄弟元素。 prevUnitl()：返回介于两个给定参数之间的所有兄弟元素。 过滤过滤是为了缩小搜索的范围。 first()：返回被选元素的第一个元素。 last()：返回被选元素的最后一个元素。 eq()：选择指定index的元素。 filter()：返回被选元素中匹配的元素。 not()：返回被选元素中不匹配的元素。 filter()和not()相反。","link":"/2018/06/11/jquery-tutorial-4/"},{"title":"Java复习笔记（一）","text":"Day01: 2020.09.04 今天开始复习java，一天复习一点。 参考 菜鸟教程：Java C语言中文网：Java 概述背景Java是Sun Microsystems在1995年发布的高级程序设计语言。 Sun Microsystems是IT及互联网技术服务公司（已被甲骨文收购）Sun Microsystems 创建于1982年。主要产品是工作站及服务器。 Java可以运行在ARM和x86多个平台上，比如windows、macos、linux、unix等等。 Java有什么： Java语言 JVM Java API Javac等工具 jdk：1，2，3，4jre（Java运行时环境）：2，3 从底层到顶层：JVM -&gt; JRE -&gt; JDK HelloWorld老规矩，现在写第一个java程序：HelloWorld.java 下面创建java文件，文件名要和类名相同。 创建HelloWorld.java文件： 1touch HelloWorld.java HelloWorld.java： 12345public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World\"); }} 上面代码中的 String args[] 和 String[] args 都可以，但是还是推荐使用 String[] args 以避免歧义。 编译并运行12345678# 使用编译器javac将java文件编译为class字节码文件javac HelloWorld.java# 运行，无需加.class扩展名java HelloWorld# outputHello World 简介java体系java有三个体系：Java EE（企业版）, Java SE（标准版）, Java ME（微型版）。我使用了Java SE的jdk。 java特性 简单 面向对象 分布式 健壮性 安全 体系结构中立 可移植 解释型 高性能 多线程 动态 java历史1995年5月23日，Java语言诞生 java开发工具硬件要求：内存1G以上。系统要求：linux、macos、windows。JDK：7、8…编辑器：notepad、sublime text（收费）、vscode（开源且免费）等等。IDE：eclipse（开源且免费）、idea（收费）等等。 编辑器/IDE这里我主要使用vscode和idea。 开发环境配置开发java需要在机器上安装oracle jdk（java开发工具包）或者OpenJDK。 我这里使用Java SE 8。 查看是否安装成功： 安装成功！ 基础语法一个Java程序可以认为是一系列对象的集合，而这些对象通过彼此的方法来协同。 几个基本概念下面十几个重要的概念： 对象：对象是类的一个实例，有状态和行为。 类：是一个模板，描述一类对象的状态和行为。 方法：方法就是行为，逻辑运算、数据修改等所有动作都是在方法中修改的。 实例变量：每个对象都有独特的实例变量，对象的状态由实例变量的值决定。 第一个java程序实例： 12345678public class HelloWorld { /* 第一个Java程序 * 它将打印字符串 Hello World */ public static void main(String[] args) { System.out.println(\"Hello World\"); // 打印 Hello World }} 保存、编译和运行： 创建文件：HelloWorld.java 编写代码 编译：javac HelloWorld.java 运行：java HelloWorld 基本语法几条tips： java大小写敏感。 类名首字母大写，并且如果类名是由多个单词组成，那么每个单词首字母都要大写。 方法名以小写开头，采用驼峰式命名。 java文件名和类名要相同。 主方法入口：public static void main(String[] args){}，在最后的{}中编写代码。 String[] args表示传入一个String类型的数组args，可以在内部通过arg[i]获取参数，传参可以通过命令java file_name param1 param2 ...。 标识符类名、变量名、方法名都叫做标识符。 标识符规则： 只能以A-Z,a-z,$,_开始。 第一个字符之后可以用A-Z,a-z,$,_以及数字。 关键字不能作为标识符。 标识符大小写敏感。 标识符命名习惯 标识符包含语义信息。 包名、项目名全小写。 类名每个单词首字母大写。 变量名和方法名，驼峰式。 常量名全大写，采用下划线_连接。 修饰符java中的修饰符用来修饰类中的属性和方法。 修饰符种类： 访问控制修饰符：default, public, protected, private 非访问控制修饰符：final, abstract, static, synchronized 变量java变量类型： 局部变量 类变量（静态变量） 成员变量（非静态变量） 数组数组是存储在堆上的对象，可以保存多个同类型的变量。 枚举所谓枚举就是：限制了变量只能是预先设定好的值。 实例： 1234567891011class FreshJuice { enum FreshJuiceSize{ SMALL, MEDIUM, LARGE } FreshJuiceSize size;}public class FreshJuiceTest { public static void main(String[] args){ FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.medium; }} 关键字java关键字有这些： 访问控制 类、方法、变量修饰符 程序控制语句 错误处理 包相关 基本类型 变量引用 保留关键字 注释注释语法支持单行、多行注释，编译器会忽略注释。编译器还会忽略空白行。 12345678910111213141516public class HelloWorld { public static void main(String[] args) { // 单行注释方法一 /* 单行注释方法二 */ /* 多行注释 * 多行注释 */ /** * 多行注释 */ System.out.println(\"Hello World\"); }} 注释规范 类注释 每个类前面必须加类注释，模板： 123456789/*** Copyright (C), 2006-2010, ChengDu Lovo info. Co., Ltd.* FileName: Test.java* 类的详细说明** @author 类创建者姓名* @Date 创建日期* @version 1.00*/ 属性注释 每个属性前面必须加属性注释，模板： 12/** 提示信息 */private String strMsg = null; 方法注释 每个方法前面必须加方法注释，模板： 1234567/*** 类方法的详细使用说明** @param 参数1 参数1的使用说明* @return 返回结果的说明* @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明*/ 构造方法注释 每个构造方法前面必须加构造方法注释，模板： 123456/*** 构造方法的详细使用说明** @param 参数1 参数1的使用说明* @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明*/ 方法内部注释 在方法内部可以根据实际情况注释，模板： 12//背景颜色Color bgColor = Color.RED 继承java可以使用继承来重用已存在的类，被继承的类称之为超类，派生出来的类称之为子类。 接口java中的接口可以理解我对象之间相互通信的协议。 关于Java的编译运行 由图可见， .java 源文件经过编译后生成 .class 字节码文件，然后交由JVM解释运行。故而从性能而言，java还是不如c/cpp这些编译型语言。 对象和类java的基本概念： 封装 继承 多态 抽象 类 对象 实例 方法 重载 对象：对象是类的一个实例，有状态和行为。类：类是一个模板，描述一类对象的状态和行为。 对象对象就是类的实例，有自己的属性和方法。 类类就是对象的模板，是对对象的抽象。 实例： 12345678910111213public class Dog{ String breed; int age; String color; void barking(){ } void hungry(){ } void sleeping(){ }} 一个类可以包含这几种变量：局部变量，成员变量，类变量。局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。 构造方法每个类都有构造方法，如果没有定义则编译器会自动提供一个默认的构造方法。 在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 实例： 12345678public class Puppy{ public Puppy(){ } public Puppy(String name){ // 这个构造器仅有一个参数：name }} 创建对象对象是由类创建的。 如何创建对象？使用关键字 new 创建新对象： 首先声明一个对象。 使用new创建对象。 初始化对象。 12345678910public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); }} 访问对象变量和方法123456/* 实例化对象 */Puppy myPuppy = new Puppy( \"tommy\" );/* 访问类中的变量 */myPuppy.age;/* 访问类中的方法 */myPuppy.barking(); 实例123456789101112131415161718192021222324252627public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge(){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge(); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); }} 运行： 源文件声明规则 一个源文件只能有一个public类。 一个源文件可以有多个非public类。 源文件名要和public类名相同。 如果一个类定义在某个包中，那么package语句要在源文件首行。 如果源文件包含import语句，import应该放在package语句和类定义之间。如果没有package语句则import要放在源文件最前面。 import和package对源文件中定义的所有类都有效，在同一源文件中，不能给不同的类不同的包声明。 类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。还有特殊的类比如内部类和匿名类。 java包包用来对类和接口分类。 import实例：下面代码将会使编译器载入 java_installation/java/io 路径下的所有类。 1import java.io.*; 实例现在创建两个类：Employee和EmployeeTest，Employee类没有主函数，EmployeeTest有主函数。这里EmployeeTest调用了Employee的属性和方法。 Employee.java: 12345678910111213141516171819202122232425262728293031import java.io.*; public class Employee{ String name; int age; String designation; double salary; // Employee 类的构造器 public Employee(String name){ this.name = name; } // 设置age的值 public void empAge(int empAge){ age = empAge; } /* 设置designation的值*/ public void empDesignation(String empDesig){ designation = empDesig; } /* 设置salary的值*/ public void empSalary(double empSalary){ salary = empSalary; } /* 打印信息 */ public void printEmployee(){ System.out.println(\"名字:\"+ name ); System.out.println(\"年龄:\" + age ); System.out.println(\"职位:\" + designation ); System.out.println(\"薪水:\" + salary); }} EmployeeTest.java: 1234567891011121314151617181920import java.io.*;public class EmployeeTest { public static void main(String[] args){ /* 使用构造器创建两个对象 */ Employee empOne = new Employee(\"RUNOOB1\"); Employee empTwo = new Employee(\"RUNOOB2\"); // 调用这两个对象的成员方法 empOne.empAge(26); empOne.empDesignation(\"高级程序员\"); empOne.empSalary(1000); empOne.printEmployee(); empTwo.empAge(21); empTwo.empDesignation(\"菜鸟程序员\"); empTwo.empSalary(500); empTwo.printEmployee(); }} 编译运行： 12javac EmployeeTest.javajava EmployeeTest 运行结果： 名字:RUNOOB1 年龄:26 职位:高级程序员 薪水:1000.0 名字:RUNOOB2 年龄:21 职位:菜鸟程序员 薪水:500.0基本数据类型变量就是用来存储数据的，java创建变量的时候会向内存申请空间。内存管理系统根据变量的类型为其分配内存空间，改内存空间仅能用于存储改类型的数据。 实例： 12// 申请一个内存空间，类型为int，并将数字7存入int x = 7; java两大数据类型： 内置数据类型 引用数据类型 内置数据类型java内置了8中基本数据类型，其中有6种数字数据类型（4个整型+2个浮点型），一个字符数据类型，一个布尔型。 byte byte类型是8位、有符号、二进制补码表示的整数。最小值是-128（-2^7），最大值是127（2^7-1），默认值为0。byte类型的用处是节约空间，因为byte类型的空间占用只有int类型的1/4，主要是代替整数。 实例： 1byte a = 3; short short类型是16位、有符号、二进制补码表示的整数。最小值是-32768（-2^15），最大值是32767（2^15 - 1），默认值为0。一个short变量的空间占用是int类型的1/2。 实例： 1short s = 1000; int int类型是32位、有符号、二进制补码表示的整数。最小值是-2, 147, 483, 648（-2^31），最大值是2, 147, 483, 647（2^31 - 1），默认值为0。一般整型变量默认为int类型。 实例： 1int a = 10000; long long类型是64位、有符号的、二进制补码表示的整数。最小值是-9, 223, 372, 036, 854, 775, 808（-2^63），最大值是9, 223, 372, 036, 854, 775, 807（2^63 -1），默认值为0L。long类型主要是用在对于数字需求比较大的系统上。 实例： 12// 大小写皆可，不过为了区分它和1，建议采用大写的Llong a = 100000L; float float类型是单精度、32位、符合IEEE754标准的浮点数。float在存储大型浮点数组的时候可以节省内存空间。默认值为0.0f。浮点数不能用于表示精确的值。 实例： 1float f1 = 234.5f; double double类型是双精度的、64位、符合IEEE754标准的浮点数。浮点数默认类型为double类型。double也不能表示精确的值。默认值0.0d 实例： 1double d1 = 123.4; boolean boolean类型是表示一个比特的信息。boolean取值只有 true 和 false 。默认值 false 。 实例： 1boolean opened = true; char char类型是一个单一的16位unicode字符。最小值 \\u0000 （即为0），最大值 \\uffff （即为65, 535）。char类型可以存储任意字符。 实例： 1char words = 'this'; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class PrimitiveTypeTest { public static void main(String[] args) { // byte System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE); System.out.println(\"包装类：java.lang.Byte\"); System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE); System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE); System.out.println(); // short System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE); System.out.println(\"包装类：java.lang.Short\"); System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE); System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE); System.out.println(); // int System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE); System.out.println(\"包装类：java.lang.Integer\"); System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE); System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE); System.out.println(); // long System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE); System.out.println(\"包装类：java.lang.Long\"); System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE); System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE); System.out.println(); // float System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE); System.out.println(\"包装类：java.lang.Float\"); System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE); System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE); System.out.println(); // double System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE); System.out.println(\"包装类：java.lang.Double\"); System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE); System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE); System.out.println(); // char System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE); System.out.println(\"包装类：java.lang.Character\"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println(\"最小值：Character.MIN_VALUE=\" + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println(\"最大值：Character.MAX_VALUE=\" + (int) Character.MAX_VALUE); }} 输出： 基本类型：byte 二进制位数：8 包装类：java.lang.Byte 最小值：Byte.MIN_VALUE=-128 最大值：Byte.MAX_VALUE=127 基本类型：short 二进制位数：16 包装类：java.lang.Short 最小值：Short.MIN_VALUE=-32768 最大值：Short.MAX_VALUE=32767 基本类型：int 二进制位数：32 包装类：java.lang.Integer 最小值：Integer.MIN_VALUE=-2147483648 最大值：Integer.MAX_VALUE=2147483647 基本类型：long 二进制位数：64 包装类：java.lang.Long 最小值：Long.MIN_VALUE=-9223372036854775808 最大值：Long.MAX_VALUE=9223372036854775807 基本类型：float 二进制位数：32 包装类：java.lang.Float 最小值：Float.MIN_VALUE=1.4E-45 最大值：Float.MAX_VALUE=3.4028235E38 基本类型：double 二进制位数：64 包装类：java.lang.Double 最小值：Double.MIN_VALUE=4.9E-324 最大值：Double.MAX_VALUE=1.7976931348623157E308 基本类型：char 二进制位数：16 包装类：java.lang.Character 最小值：Character.MIN_VALUE=0 最大值：Character.MAX_VALUE=65535java中各个类型的默认值： 实例：输出各个数据类型的默认值 1234567891011121314151617181920212223public class Test { static boolean bool; static byte by; static char ch; static double d; static float f; static int i; static long l; static short sh; static String str; public static void main(String[] args) { System.out.println(\"Bool :\" + bool); System.out.println(\"Byte :\" + by); System.out.println(\"Character:\" + ch); System.out.println(\"Double :\" + d); System.out.println(\"Float :\" + f); System.out.println(\"Integer :\" + i); System.out.println(\"Long :\" + l); System.out.println(\"Short :\" + sh); System.out.println(\"String :\" + str); }} 输出： Bool :false Byte :0 Character: Double :0.0 Float :0.0 Integer :0 Long :0 Short :0 String :null引用类型引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明的时候被指定为一个特定类型比如Puppy等等，一旦声明就不能改变。 对象、数组都是引用数据类型。 所有引用类型默认值都是 null 。 一个引用变量可以用来引用任何与之兼容的类型。 实例： 1Site site = new Site(\"cool\"); 常量常量也就是不能被修改的量。 如何定义常量？使用 final 关键字修饰常量： 1final double PI = 3.1415; 正如上面缩写，常量名为了便于识别一般使用全大写。 字面量字面量：\b其实，字面量的意思就是“字面上的量”，比如java中的一个数字 66 就是一个字面量，还有 &quot;this is a line of string!&quot; 就是一个字面量，还比如 true 和 false 也是字面量。 字面量表示的是如何表达一个值，所以在声明并赋值变量的时候，赋值符号 = 后面的 ; 前面的就是字面量。 byte, int, long, short都可以用十进制、八进制、十六进制表示。前缀 0 表示八进制，前缀 0x 表示十六进制。实例： 123int decimal = 100;int octal = 0144;int hexa = 0x64; java的字符串字面量是由两个引号包裹的字符串： 123\"Hello World\"\"two\\nlines\"\"\\\"This is in quotes\\\"\" 除此之外，字符串还可以包含任意unicode字符： 12char a = '\\u0001';String a = \"\\u0001\"; 转义字符： 换行： \\n 回车： \\r 换页符： \\f 退格： \\b 空字符： \\0 空格： \\s 制表符： \\t 双引号： \\&quot; 单引号： \\' 反斜杠： \\\\ 八进制字符： \\ddd 16进制unicode字符： \\uxxx 类型转换整型、常量、字符型数据可以混合运算。转换从低级到高级。 低级 --------------------------------------- 高级 byte,short,char —&gt; int —&gt; long —&gt; float —&gt; double 数据类型转换规则： 对boolean类型不能转换。 不能将对象类型转换为不相关类的对象。 将容量大的类型转换为小容量的类型的时候需要使用强制类型转换。 转换可能导致数据溢出或者精度损失。 浮点数转换到整数是通过舍弃小数得到的。 实例： 123456789// 声明一个int型变量i并赋值128int i = 128;// 对i进行强制类型转换为byte型，因为byte最大值为127，故而强制类型转换会导致溢出byte b = (byte)i;// 浮点数转换为整数(int)12.3 == 12;(int)-45.89f == -45 自动类型转换规则：转换前的数据类型的位数要低于转换后的数据类型。 实例： 12345678910public class ZiDongLeiZhuan{ public static void main(String[] args){ char c1='a';//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println(\"char自动类型转换为int后的值等于\"+i1); char c2 = 'A';//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println(\"char类型和int计算后的值等于\"+i2); }} 输出： char自动类型转换为int后的值等于97 char类型和int计算后的值等于66上面字符对应的数字要查ASCII码。 强制类型转换规则：转换的数据类型必须兼容。 格式：新类型 新变量名 = (新类型)旧变量名比如： byte b = (byte)a; 实例： 1234567public class QiangZhiZhuanHuan{ public static void main(String[] args){ int i1 = 123; byte b = (byte)i1;//强制类型转换为byte System.out.println(\"int强制类型转换为byte后的值等于\"+b); }} 输出： int强制类型转换为byte后的值等于123隐含强制类型转换 整数的默认类型是int 浮点型不存在隐含强制类型转换，因为定义float/double的时候必须在浮点数后面加上f/F或者d/D。 Day01: 2020.09.04","link":"/2020/09/04/java-review-01/"},{"title":"jQuery学习笔记（三）","text":"这篇是jquery操作DOM的部分。 捕获元素和属性获取内容和属性值 text()：获取或设置元素的文本内容。 html()：获取或设置元素的内容。 val()：获取或设置表单字段的值。 实例： 1234567891011$(\"#btn1\").click(function() { alert(\"Text: \" + $(\"#test\").text());});$(\"#btn2\").click(function() { alert(\"HTML: \" + $(\"#test\").html());});$(\"#btn1\").click(function() { alert(\"值为: \" + $(\"#test\").val());}); attr()：获取和设置元素的属性值。 实例： 123456789101112131415161718192021222324// 获取$(\"button\").click(function() { alert($(\"#runoob\").attr(\"href\"));});// 设置$(\"button\").click(function() { $(\"#runoob\").attr(\"href\", \"http://www.runoob.com/jquery\");});// 同时设置多个属性值$(\"button\").click(function() { $(\"#runoob\").attr({ \"href\": \"http://www.runoob.com/jquery\", \"title\": \"jQuery 教程\" });});// attr()回调函数$(\"button\").click(function() { $(\"#runoob\").attr(\"href\", function(i, origValue) { return origValue + \"/jquery\"; });}); 设置内容和属性值设置内容和属性值使用的也是上面三个方法。 实例： 1234567891011$(\"#btn1\").click(function() { $(\"#test1\").text(\"Hello world!\");});$(\"#btn2\").click(function() { $(\"#test2\").html(\"&lt;b&gt;Hello world!&lt;/b&gt;\");});$(\"#btn3\").click(function() { $(\"#test3\").val(\"RUNOOB\");}); 设置内容可以有回调函数，回调函数有两个参数，第一个参数是被选元素列表中当前元素的下标，第二个参数是旧值。 实例： 1234567891011$(\"#btn1\").click(function() { $(\"#test1\").text(function(i, origText) { return \"旧文本: \" + origText + \" 新文本: Hello world! (index: \" + i + \")\"; });});$(\"#btn2\").click(function() { $(\"#test2\").html(function(i, origText) { return \"旧 html: \" + origText + \" 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: \" + i + \")\"; });}); tips attr()：自定义属性用attr() prop()：元素固有属性用prop() 添加元素 append()：在被选元素中最后面插入内容。 prepend()：在被选元素中最前面插入内容。 after()：在被选元素后面插入内容。 before()：在被选元素前面插入内容。 实例： 12$('p').append('abc');$('p').prepend('abc'); 实例： 1234567function appendText() { var text1 = '&lt;p&gt;文本-1。&lt;/p&gt;'; var text2 = $(\"&lt;p&gt;&lt;/p&gt;\").text(\"文本-2。\"); var text3 = document.createElement(\"p\"); text3.innerHTML = '文本'; $('p').append(text1, text2, text3);} 实例： 12$(\"img\").after(\"在后面添加文本\");$(\"img\").before(\"在前面添加文本\"); 实例： 1234567function afterText() { var text1 = '&lt;p&gt;文本-1。&lt;/p&gt;'; var text2 = $(\"&lt;p&gt;&lt;/p&gt;\").text(\"文本-2。\"); var text3 = document.createElement(\"p\"); text3.innerHTML = '文本'; $('p').after(text1, text2, text3);} 删除元素 remove()：删除被选元素及其子元素。 empty()：删除被选元素的子元素。 实例： 12$('div').remove();$('div').empty(); 还可以传一个参数（选择器）来选择要删除的元素： 1$(\"p\").remove(\".italic\"); 获取和设置css操作css addClass()：给元素添加类。 removeClass()：移除类。 toggleClass()：切换添加删除类。 css()：获得或者设置css属性。 实例： 123456789101112131415161718192021// 添加类$(\"button\").click(function() { $(\"h1,h2,p\").addClass(\"blue\"); $(\"div\").addClass(\"important warn alert\");});// 移除类$(\"button\").click(function() { $(\"h1,h2,p\").removeClass(\"blue\");});// 切换类$(\"button\").click(function() { $(\"h1,h2,p\").toggleClass(\"blue\");});// css()$(\"p\").css(\"background-color\");$(\"p\").css(\"background-color\",\"yellow\");$(\"p\").css({\"background-color\":\"yellow\",\"font-size\":\"200%\"});$(\"p\").eq(index).css(); jquery盒子模型 width()：取得或设置元素的宽度。 height()：取得或设置元素的高度。 innerWidth()：取得元素的width加上左右padding。 innerHeight()：取得元素的height加上上下padding。 outerWidth()：取得元素的width加上左右padding和border-width。 outerHeight()取得元素的height加上上下padding和border-width。","link":"/2018/06/11/jquery-tutorial-3/"},{"title":"jQuery学习笔记（六）","text":"如何在项目中同时使用jquery和其他类库。 noConflict()noConflict() 的作用是避免 $ 和其他类库冲突。 noConflict()会释放对 $ 标识符的控制，这样其他脚本就可以使用它了。 实例： 123456$.noConflict();jQuery(document).ready(function() { jQuery(\"button\").click(function() { jQuery(\"p\").text(\"jQuery 仍然在工作!\"); });}); 也可以创建自己的缩写，noConflict()可返回对 jQuery 的引用，可以把它存入变量，以供稍后使用。 123456var jq = $.noConflict();jq(document).ready(function() { jq(\"button\").click(function() { jq(\"p\").text(\"jQuery 仍然在工作!\"); });}); 如果你的jQuery代码块使用 $ 简写，并且您不愿意改变这个快捷方式，那么您可以把 $ 符号作为变量传递给ready方法。这样就可以在函数内使用 $ 符号了，而在函数外，依旧不得不使用 jQuery ： 123456$.noConflict();jQuery(document).ready(function($) { $(\"button\").click(function() { $(\"p\").text(\"jQuery 仍然在工作!\"); });});","link":"/2018/06/12/jquery-tutorial-6/"},{"title":"jQuery学习笔记（五）","text":"Ajax（异步js和XML）是浏览器和服务器交换数据的技术，它实现了在不刷新页面的情况下对于页面的局部刷新。 jquery提供了多个Ajax方法，可以 GET/POST 服务器数据。 load()load() 是从服务器家在数据并将返回的数据写入到页面元素中。 语法： $(selector).load(URL,data,callback); URL：请求的地址。data：随请求发送到服务器的数据（键值对集合）。callback：load()完成后的回调函数。 实例： 12$(\"#div1\").load(\"demo_test.txt\");$(\"#div1\").load(\"demo_test.txt #p1\"); callback()的参数： responseTxt：包含调用成功时的结果内容 statusTXT：包含调用的状态 xhr：包含XMLHttpRequest对象 实例： 12345678$(\"button\").click(function() { $(\"#div1\").load(\"demo_test.txt\", function(responseTxt, statusTxt, xhr) { if (statusTxt == \"success\") alert(\"外部内容加载成功!\"); if (statusTxt == \"error\") alert(\"Error: \" + xhr.status + \": \" + xhr.statusText); });}); GET/POST浏览器请求服务器数据有两种方式：GET和POST。 GET：从指定url请求数据，可能会返回缓存数据。 POST：向指定url提交数据，不会缓存数据。 GET和POST的不同：https://www.runoob.com/tags/html-httpmethods.html $.get()语法： $.get(URL, callback); 实例： 12345$(\"button\").click(function() { $.get(\"demo_test.php\", function(data, status) { alert(\"数据: \" + data + \"\\n状态: \" + status); });}); $.post()语法： $.post(URL, callback); 实例： 123456789$(\"button\").click(function() { $.post(\"/try/ajax/demo_test_post.php\", { name: \"菜鸟教程\", url: \"http://www.runoob.com\" }, function(data, status) { alert(\"数据: \\n\" + data + \"\\n状态: \" + status); });}); GET和POST的区别1、发送的数据数量 在 GET 中，只能发送有限数量的数据，因为数据是在 URL 中发送的。在 POST 中，可以发送大量的数据，因为数据是在正文主体中发送的。 2、安全性 GET 方法发送的数据不受保护，因为数据在 URL 栏中公开，这增加了漏洞和黑客攻击的风险。POST 方法发送的数据是安全的，因为数据未在 URL 栏中公开，还可以在其中使用多种编码技术，这使其具有弹性。 3、加入书签中 GET 查询的结果可以加入书签中，因为它以 URL 的形式存在；而 POST 查询的结果无法加入书签中。 4、编码 在表单中使用 GET 方法时，数据类型中只接受 ASCII 字符。在表单提交时，POST 方法不绑定表单数据类型，并允许二进制和 ASCII 字符。 5、可变大小 GET 方法中的可变大小约为 2000 个字符。POST 方法最多允许 8 Mb 的可变大小。 6、缓存 GET 方法的数据是可缓存的，而 POST 方法的数据是无法缓存的。 7、主要作用 GET 方法主要用于获取信息。而 POST 方法主要用于更新数据。 $.ajax() refs: https://www.w3school.com.cn/jquery/ajax_ajax.asp https://www.runoob.com/jquery/ajax-ajax.html jquery中get(), post(), ajax()三者的区别 https://blog.csdn.net/qq_34202873/article/details/86759541 一般ajax的jquery实现： 12345678910$.ajax({ url: '', async: true, dataType: 'json', data: {}, type: 'POST', success: function() { }});","link":"/2018/06/11/jquery-tutorial-5/"},{"title":"jQuery学习笔记（二）","text":"第二部分是jquery的效果。 jquery显示隐藏jquery的效果有显示、隐藏、切换、滑动、淡入淡出、动画。 隐藏和显示使用 hide() 和 show() 。 语法： 12$(selector).hide(speed, callback);$(selector).show(speed, callback); speed参数规定了速度，可以是slow，fast或者毫秒数。 实例： 12345678910111213$(\"#hide\").click(function() { $(\"p\").hide(1000， callback);});$(\"#show\").click(function() { $(\"p\").show(1000, callback);});$(\"#hide\").click(function() { $(\"div\").hide(1000, \"linear\", function() { window.alert(\"已经隐藏\"); });}); 缓动函数可以是linear或者swing。 toggle()toggle() 用于切换hide()和show()。 语法： $(selector).toggle(speed, callback); 123$(\"button\").click(function() { $(\"p\").toggle();}); tips 如果写成callback()则会立即执行函数。 callback可以是匿名函数。 jquery淡入淡出jquery有四种淡入淡出方法。 fadeIn() fadeOut() fadeToggle() fadeTo() fadeIn()将已经隐藏的元素淡入地显示。 语法： $(selector).fadeIn(speed, callback); 实例： 12345$(\"button\").click(function() { $(\"#div1\").fadeIn(); $(\"#div2\").fadeIn(\"slow\"); $(\"#div3\").fadeIn(3000);}); fadeOut()将显示的元素淡出地隐藏。 语法： $(selector).fadeOut(speed, callback); 实例： 12345$(\"button\").click(function() { $(\"#div1\").fadeOut(); $(\"#div2\").fadeOut(\"slow\"); $(\"#div3\").fadeOut(3000);}); fadeToggle()fadeToggle()可以在fadeIn()和fadeOut()之间切换。 语法： $(selector).fadeToggle(speed, callback); 实例： 12345$(\"button\").click(function() { $(\"#div1\").fadeToggle(); $(\"#div2\").fadeToggle(\"slow\"); $(\"#div3\").fadeToggle(3000);}); fadeTo()将元素渐变为指定的透明度（0-1）。 语法： $(selector).fadeTo(speed, opacity, callback); speed是必须的参数。 实例： 12345$(\"button\").click(function() { $(\"#div1\").fadeTo(\"slow\", 0.15); $(\"#div2\").fadeTo(\"slow\", 0.4); $(\"#div3\").fadeTo(\"slow\", 0.7);}); jquery滑动滑动着隐藏和显示元素。 slideDown(), slideUp(), slideToggle() slideDown()slideDown()用于向下（显示）滑动元素。 语法： $(selector).slideDown(speed, callback); 实例： 1234$(\"#flip\").click(function() { // 这里#panel要设为display: none; $(\"#panel\").slideDown();}); slideUp()用于向上滑动元素（隐藏）。 语法： $(selector).slideUp(speed, callback); 实例： 123$(\"#flip\").click(function() { $(\"#panel\").slideUp();}); slideToggle()用于在slideDown()和slideUp()中切换。 实例： 先要将panel隐藏 123$(\"#flip\").click(function() { $(\"#panel\").slideToggle();}); jquery动画animate()可以自定义动画。 animate()语法： $(selector).animate({params}, speed, callback); params参数定义动画的css。 实例： 123456// 先将position设置为positioned$('button').click(function() { $('div').animate({ left: '100px' }, 1000, callback);}); 操作多个属性实例： 123456789$(\"button\").click(function() { // 这里每条css属性后面用的是逗号不是分号，属性名使用驼峰式 $(\"div\").animate({ left: '250px', opacity: '0.5', height: '150px', width: '150px' }, 1000, callback);}); 使用相对值实例： 1234567$(\"button\").click(function() { $(\"div\").animate({ left: '250px', height: '+=150px', width: '+=150px' });}); 使用预定义的值实例： 12345$(\"button\").click(function(){ $(\"div\").animate({ height:'toggle' });}); 使用队列如果创建了多个animate()则jquery会逐一运行。 停止动画在动画停止之前可以使用stop()手动停止动画。 语法：$(selector).stop(stopAll, goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 默认地，stop() 会清除在被选元素上指定的当前动画。 实例： 123$('div').click(function() { $('input').stop();}); callback()callback()在动画完成后执行。 chainingjquery支持链式操作，可以将一系列方法写成一个链。 实例： 1$(\"#p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000); 也可以这样写： 123$(\"#p1\").css(\"color\",\"red\") .slideUp(2000) .slideDown(2000);","link":"/2018/06/10/jquery-tutorial-2/"},{"title":"jQuery的when, then, done, fail","text":"$.when(deferreds) 提供一种方法来执行一个或多个对象的回调函数，Deferred(延迟)对象通常表示异步事件。可以将 deferreds 认为是多个异步请求。$.when() 中可异步执行多个函数，函数之间使用逗号隔开。实例： $.when(func1(), func2(), ...) $.when(deferreds) 如果向 $.when(deferreds) 传入一个延迟对象，那么会返回它的Promise对象(延迟方法的一个子集)。 可以继续绑定Promise对象的其它方法，例如，defered.then。当延迟对象已经被受理（resolved） 或被拒绝(rejected）（通常是由创建延迟对象的最初代码执行的），那么就会调用相应的回调函数。 $.when() 一般和 then() , done() , fail() 配合使用。 done(func) : when() 都处理完毕时执行 func 。fail(func) : when() 中有处理失败的时执行 func 。then(func1, func2) : when() 中都成功则执行 func1 ，有失败的则执行 func2 。 参考 https://www.jquery123.com/jQuery.when/ https://www.jquery123.com/deferred.done/ https://www.jquery123.com/deferred.fail/ https://www.jquery123.com/deferred.then/","link":"/2018/09/16/jquery-when-done-then/"},{"title":"《JavaScript高级程序设计》：第一章","text":"基于第四版所做笔记。 一个完整的javascript实现由ES、DOM、BOM组成。 ES实现的宿主环境有浏览器、node、flash。 ECMA-262ECMA-262规定了： 语法 类型 语句 关键字 保留字 操作符 对象 ES就是对实现了以上标准规定的各个方面内容的语言的描述。 JavaScript实现了ES，Adobe ActionScript也实现了ES。 DOMDOM概念文档对象模型是应用程序编程接口（API）。 DOM把整个页面映射为一个多层节点结构。 借助DOM提供的API，开发者可以自由的控制页面内容和结构。 DOM级别Level1：DOM core 和 DOM HTML构成。 DOM core：规定了如何映射基于XML的文档结构。 DOM HTML：在core的基础上扩展添加了针对HTML的对象和方法。 Level2：在原来的DOM基础上扩充了鼠标和用户界面事件、范围、遍历等等模块。增加了css支持。 Level3：进一步扩展了DOM，引入了统一方式加载和保存文档的方法。 level0：实际上不存在level0，只是DOM历史中的一个参照点，指的是ie4.0和navigator4.0最初支持的DHTML。 BOM浏览器对象模型。 小结JS构成：ES，DOM，BOM。 ES：由ECMA-262定义，提供核心语言功能。 DOM：提供访问和操作网页内容的方法和接口。 BOM：提供和浏览器交互的方法和接口。","link":"/2019/01/08/js-advanced-chapter-01/"},{"title":"详解js中的get&#x2F;set","text":"js对象有两种属性： 数据属性：就是对象中的普通成员。 存取属性：一组get/set函数，读取对象属性时调用get（不带参数，可以return），设置对象属性时调用set（set中return无效）。 如果对象内只声明了get，则get/set属性值只可读。如果对象内只声明了set，则get/set属性值只可写且值永远为 undefined 。 get/set写法1234567891011// func是obj的存取属性名称let obj = { get func() { // code return; }, set func(val) { // code }};console.log(obj.func); 实例只声明get： 1234567891011let obj = { name: 'Mason', age: 22, get func() { return this.name; }};console.log(obj.func); // 'Mason'obj.func = ''; // 这里无法修改funcobj.name = 'Jason'; // 修改成功 只声明set： 123456789101112let obj = { name: 'Mason', age: 22, set func(val) { this.name = val; }};console.log(obj.func); // undefinedobj.name = 'Jason'; // 修改成功console.log(obj.func); //undefinedconsole.log(obj.name); // 'Jason' 同时声明： 1234567891011121314let obj = { name: 'Mason', age: 22, get func() { return this.name; }, set func(val) { this.name = val; }};console.log(obj.func); // 'Mason'obj.func = ''; // 修改成功console.log(obj.func); // ''","link":"/2021/10/09/js-get-set/"},{"title":"《JavaScript高级程序设计》：第二章","text":"如何在在html文档中使用javascript。 script标签script标签定义了6个属性： async：可选，立即下载但不妨碍页面中的其他操作，只对外部脚本文件有效。 charset：可选，表示src指定的代码字符集，基本不用这个属性。 defer：可选，表示延迟到文档完全解析和渲染后执行，只对外部脚本文件有效。 language：已废弃。 src：可选，外部脚本路径。 type：可选，可以看成language的替代品，表示MIME类型，值可以为”text/javascript”或者不写。 只要不包含async和defer，浏览器会从上到下依次解析js文件。 引入js的方式 html文件中嵌入js代码。 123&lt;script type=\"text/javascript\"&gt; // js code&lt;/script&gt; html文件中包含外部js代码。 1&lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt; 以上方式若在标签中嵌入js代码会被浏览器忽略。 可以包含来自外域的js文件，利用这点可以包含位于cdn上的js文件来提高下载速度。 标签的位置为了避免因为下载js文件带来的阻塞，一般将&lt;script&gt;放在body标签中的最后面。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html code --&gt; &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 延迟脚本defer属性：表明脚本执行不影响页面构造，会延迟到页面解析完运行。浏览器会立刻下载但延迟执行。 最好只包含一个带defer属性的脚本。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"main.js\" defer=\"defer\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html code --&gt;&lt;/body&gt;&lt;/html&gt; 一般不使用defer而是将标签放在body中最后面。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html code --&gt; &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 异步脚本async也只用于外部脚本文件，作用是告诉浏览器立刻下载但是不能保证按照指定的顺序下载。 故而只能用于不依赖脚本顺序的情况。 html中使用async： 1&lt;script type=\"text/javascript\" src=\"main.js\" async&gt;&lt;/script&gt; XHTML中使用async： 1&lt;script type=\"text/javascript\" src=\"main.js\" async=\"async\"&gt;&lt;/script&gt; 一般不用async。 在XHTML中用法本节内容可以跳过，应该遵循html5标准。 嵌入脚本与外部脚本推荐使用包含外部脚本。 优点：可维护，可缓存，适应未来。 noscript标签让页面平稳退化，只有浏览器不支持或未开启js的时候会显示&lt;noscript&gt;中的内容，放在body中。 123&lt;body&gt; &lt;noscript&gt;javascript没有开启或浏览器不支持&lt;/noscript&gt;&lt;/body&gt; 记笔记太浪费时间，从第三章开始就不记了。","link":"/2019/01/09/js-advanced-chapter-02/"},{"title":"拷贝一个js对象","text":"如何拷贝一个js对象，拷贝对象分为拷贝地址、浅拷贝和深拷贝。 基本概念js对象作为引用类型不同于基本类型，基本数据类型的拷贝直接用 = 赋值即可。 声明一个js变量，并将一个对象赋值给变量，变量此时其实存储的是变量的地址而不是变量的内容。故而，将一个对象变量赋值给另一个变量其实传的是地址，而不是拷贝了一个新的对象。此时原变量以及新变量其实都指向同一个内存地址。 基本类型保存值，引用类型保存指针。 比如这样： 那么如何拷贝一个对象呢？ 浅拷贝浅拷贝会申请一块新的内存空间存放对象，但是只能拷贝到原对象的第一层中的基本数据类型，如果原对象第一层中含有对象则拷贝到的这个对象的对象成员依然是地址。 Object.assign()Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。 会创建新的内存空间，并拷贝第一层，在深层拷贝的依然是地址。 1var o1 = Object.assign({}, obj); 展开运算符展开运算符 ...arr 作用是把数组展开。可以使用展开运算符将数组展开、合并数组、合并对象、传参等等。 12345678910111213141516171819202122232425262728// 展开数组var arr = [1, 2, 3, 4, 5];console.log(...arr);// 1 2 3 4 5// 合并数组var arr = [1, 2, 3, 4, 5];var arr2 = [...arr, 6];// 1 2 3 4 5 6// 合并对象var obj = { name: 'mason'};var o1 = { ...obj, age: 22};// 传参var arr = [1, 2, 3];function func(a, b, c) { console.log(a); console.log(b); console.log(c);}func(...arr); 会创建新的内存空间，并拷贝第一层，在深层拷贝的依然是地址。 123var o1 = { ...obj}; 深拷贝深拷贝就是从内存中开辟新的一块空间用于存放新对象，新的对象与原有对象完全独立并且和原对象一模一样。 使用JSON方法先 JSON.stringify() 再 JSON.parse() ，会忽略 undefined 和函数，无法拷贝原型链上的属性和方法，层级过深会栈溢出。 1234var obj = { name: 'mason'};var o1 = JSON.parse(JSON.stringify(obj)); DFS无法保持引用，层级很深会栈溢出。 1234567891011121314151617function deepCopy(obj) { // 根据传入的是对象还是数组初始化目标对象target let target = Array.isArray(obj) ? [] : {}; for (var k in obj) { if (obj.hasOwnProperty(k)) { // 如果是对象则递归 if (typeof obj[k] === 'object') { target[k] = deepCopy(obj[k]); } else { // 如果是基本类型则直接拷贝 target[k] = obj[k]; } } } return target;} 防栈溢出深层级不会栈溢出。 1234567891011121314151617181920212223242526272829303132333435363738394041function cloneLoop(x) { const root = {}; // 栈 const loopList = [{ parent: root, key: undefined, data: x, }]; while (loopList.length) { // 深度优先 const node = loopList.pop(); const parent = node.parent; const key = node.key; const data = node.data; // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素 let res = parent; if (typeof key !== 'undefined') { res = parent[key] = {}; } for (let k in data) { if (data.hasOwnProperty(k)) { if (typeof data[k] === 'object') { // 下一次循环 loopList.push({ parent: res, key: k, data: data[k], }); } else { res[k] = data[k]; } } } } return root;}","link":"/2021/07/21/js-copy-object/"},{"title":"js刷新页面的几种方法","text":"js刷新页面的几种方法： window.history.go(0) window.location = window.location window.location.assign(window.location) window.location.replace(window.location.href) window.location.reload()","link":"/2018/02/20/js-refresh-page/"},{"title":"js模块化编程与AMD规范","text":"模块就是实现特定功能的一组方法。 随着前端项目的日渐庞大，前端工程模块化成为必须。 原始写法定义： 1234567function func1() { // statement}function func2() { // statement} 使用： 12func1();func2(); 缺点： 函数名污染了全局变量 可能与其他模块冲突 模块之间的依赖关系不明显 对象写法将模块写成一个对象。 定义： 12345var module_name = new Object({ count: 0, func1: function() {}, func2: function() {}}); 使用：module_name.func1();module_name.count 缺点：会暴露模块的所有属性和方法，外部可以随意改写模块。 IIFE使用立即执行函数可以不暴露模块中的属性和方法。 定义： IIFE写法1234567891011121314var module_name = (function(){ var count = 0; var func1 = function() { }; var func2 = function() { }; return { func1: func1, func2: func2 };})(); 这样外部就无法读取模块内部的属性和方法了。 放大模式module_name模块12345var module_name = (function(mod){ mod.func3 = function() { // statement }})(module_name); module_name模块被添加了一个新的方法func3()，也就是被放大了。 宽放大模式就是让放大模式的参数可以为空对象。 1234var module_name = (function (mod) { // ... return mod;})(window.module_name || {}); 输入全局变量模块是独立的，想要在模块内部调用全局变量必须显式地将变量传入模块。 123var module_name = (function(brand_a, brand_b){ // ...})(samsung, apple); 模块规范流行的js模块规范有CommonJS和AMD。 CommonJS（适合后端）node.js的模块化就是参考CommonJS设计的。 CommonJS使用require()加载模块。 require()1var math = require('math'); 调用模块中的方法12var math = require('math');math.add(1,2); 浏览器环境上面使用CommonJS如果运行在浏览器会有问题，浏览器要等待require()完成才能继续执行。 故而，为了采用异步加载，AMD诞生了。 AMD规范（适合浏览器端）AMD就是异步模块定义，加载是异步的。 AMD规范的实现有require.js和curl.js AMD也是用require()加载模块，但是有两个参数。 1require([module1, module2], callback);","link":"/2020/12/18/js-modularize-and-amd/"},{"title":"使用jsDelivr+github自建静态资源CDN","text":"发现用了几年的sm.ms没有以前好用了，白天加载图片速度巨慢，原因可能是sm.ms在大陆已经没有cdn节点了。故而选择折腾一个新图床来提高页面加载速度。 一阵搜寻发现jsDelivr还可以用来作图床并且在国内速度还很不错，于是搞了个jsDelivr的图床。 jsDelivr官网：https://www.jsdelivr.com/ 新建github仓库仓库名称随意，根据需求可以选择性添加描述和README.md这里新建仓库名为：CDN git clone仓库到本地1git clone &lt;repo&gt; 提交现在就可以向本地仓库中加入需要做cdn的资源文件了。然后提交到github仓库： 123git add .git commit -m 'info'git push jsDelivr支持单个文件最大20MB。提交过慢可以参考我之前配置git代理的文章：git配置本地代理 releases点击CDN仓库的raleases并创建新的版本。生成releases的作用是给不同的版本代码以不同的资源版本，便于管理。个人使用的话还是建议不要生成。 引用引用特定版本资源：https://gcore.jsdelivr.net/gh/用户名/仓库名@版本号/文件路径引用最新资源：https://gcore.jsdelivr.net/gh/用户名/仓库名/文件路径 tipsreleases用于区分不同版本项目所用的静态资源文件，但并非必须。不适用版本号将直接引用最新资源。个人用途建议不用releases，直接引用即可。 加载任何Github发布、提交或分支https://gcore.jsdelivr.net/gh/user/repo@version/file 加载 jQuery v3.2.1https://gcore.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js 使用版本范围而不是特定版本https://gcore.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://gcore.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js 完全省略该版本以获取最新版本https://gcore.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://gcore.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js 在末尾添加 / 以获取资源目录列表https://gcore.jsdelivr.net/gh/jquery/jquery/ 反复测了几张图，比sm.ms真的是快多了以后慢慢把在sm.ms上的图片搬过去。 测试 还有就是markdown的写作今天从Typora转向VScode了，Typora的bug真的是太多了。Typora不光优点明显缺点也很明显，不然怎么到了2020年了Typora还是测试版呢。 刷新缓存jsdelivr不会自动刷新已经更新了的文件，需要手动访问URL刷新。 方法：将资源url中最前面的cdn替换为purge即可。","link":"/2020/06/07/jsdelivr-cdn/"},{"title":"JSX语法","text":"JSX是JavaScript的扩展语法，react使用JSX代替JavaScript。 使用JSX需要引入babel。 JSX语法规则 创建VDOM不能用引号包裹html代码。 标签中使用{}包裹js表达式。 用className代替class，用htmlFor代替for。 标签style属性的值要用两对花括号包裹，花括号中间是属性名:属性值的写法，用逗号隔开。 只能有一个根标签。 所有标签都要闭合。 react对于大写开头的标签会渲染对应的组件，对于正常的html标签不作处理。 如何创建组件 直接创建VDOM变量，然后用render函数渲染 使用babel解析JSX语法。 JSX1234567// 创建VDOMconst VDOM = &lt;div id={data.id.toLowerCase()}&gt;hello, it's me!&lt;/div&gt;// react渲染VDOMReactDOM.render(VDOM, document.getElementById(\"container_id\"))// 卸载VDOMReactDOM.unmountComponentAtNode(document.getElementById(\"container_id\")); 使用函数创建VDOM JSX12345function componentA(porps) { const {name, age} = props; const VDOM = &lt;div&gt;my name is : {name}, and {age} yo.&lt;div/&gt;; return VDOM;} 使用class创建VDOM JSX12345678910111213141516class componentB extends React.component { constructor(props) { super(props); this.state = { name: 'Mason' }; } render() { return ( &lt;div&gt;{this.state.name} &lt;div /&gt; ); }} 模块和组件react的模块和组件思想和vue一样。 react组件分为函数式组件和类式组件。","link":"/2022/06/02/jsx%E8%AF%AD%E6%B3%95/"},{"title":"js交换两个变量的几种方法","text":"js交换两个变量的几种方法。 使用临时变量优点：直观，可以用于交换数组元素缺点：比较low 12345let param1, param2, tmp;tmp = param1;param1 = param2;param2 = tmp; 使用es6解构优点：直观，可以用于交换数组元素 1[param1, param2] = [param2, param1]; 算数运算缺点：不直观，容易溢出，只能用于数字。 123a = a + b;b = a - b;a = a - b; 异或运算优点：能装逼缺点：不直观，不能交换数组元素 12345678a = a ^ b;b = a ^ b;a = a ^ b;// 简写a ^= b;b ^= a;a ^= b; 利用数组优点：能装逼，可以交换数组元素缺点：不直观 方法一： 123a = [a, b];b = a[0];a = a[1]; 方法二： 1a = [b, b = a][0]; 利用对象优点：直观，可以交换数组元素 123456a = { a: b, b: a};b = a.b;a = a.a;","link":"/2021/08/25/js%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js删除数组中元素的几种方法","text":"js删除数组中元素的几种方法。 清空数组12345let arr = [1, 2, 3, 4, 5];arr.length = 0;// 或者arr = []; 截断数组（保留前半部分）123let arr = [1, 2, 3, 4, 5];arr.length = 4; delete 命令将指定元素置为 undefined12let arr = [1, 2, 3, 4, 5];delete arr[0]; 栈方法12let arr = [1, 2, 3, 4, 5];let last = arr.pop(); 队列方法12let arr = [1, 2, 3, 4, 5];let first = arr.shift(); splice() 删除替换指定元素12let arr = [1, 2, 3, 4, 5];arr.splice(begin_index, delete_num, insert_item1, ..., insert_itemN); slice() 删除指定元素Array.prototype 上添加方法不推荐 循环迭代多种方法可以遍历数组元素并删除元素，此处省略一万字。","link":"/2021/09/06/js%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js判断变量类型的方法","text":"js判断变量类型的方法有好几个。 typeoftypeof操作符或者typeof()方法可以判断number, string, boolean这三个基本数据类型, 其他类型结果均为object。 instanceofinstanceof操作符判断前面的变量是否是后面的变量的实例。 instanceof可以判断除了以下几种类型： undefined和null结果都是object 三个基本数据类型无法判断，但是对应的包装类型可以判断 constructorconstructor指向构造函数。 constructor可以判断除了undefined和null之外的类型。 Object.prototype.toString.call()利用 Object.prototype.toString() 判断数据类型 123456789const getType = (data) =&gt; { return Object.prototype.toString .call(data) .replace(/\\[object (\\w+)\\]/, \"$1\") .toLowerCase();};// 返回值是类型字符串getType(\"asd\"); // 'string'","link":"/2021/09/08/js%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"js反转字符串的几种方法","text":"js反转字符串的几种方法。 先把字符串拆分成数组，再反转数组，最后再转为字符串 12let str = 'abcd';let new_str = str.split('').reverse().join(''); 先把字符串变成数组，再反转，最后再转为字符串 12let str = 'abcd';let new_str = [...str].reverse().join(''); 遍历字符串 1234567let str = 'abcd';let len = str.length;let new_str = '';for (let i = 0; i &lt; str.length; i++) { new_str = str[i] + new_str;}","link":"/2021/08/27/js%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js反转数组的几种方法","text":"js反转数组的几种方法。 reverse() reverse() 会改变原数组，不会返回新数组。 1234let arr = [1, 2, 3, 4];arr.reverse();// [4, 3, 2, 1] reverse()配合展开符... 这种方法不会改变原数组。 12345let arr = [1, 2, 3, 4];// 这里使用展开符产生了一个新数组实例，这个实例和arr一模一样，然后反转这个新数组实例并赋值给一个变量let new_arr = [...arr].reverse();// [ 4, 3, 2, 1 ] slice()配合reverse() 123let arr = [1, 2, 3, 4];let new_arr = arr.slice().reverse(); reduce()配合... 12345let arr = [1, 2, 3, 4];let new_arr = arr.reduce(function(acc, val) { return [val, ...acc]}); 同理可以使用 reduceRIght 和 ... 。 遍历每个元素 1234567let arr = [1, 2, 3, 4];let new_arr = [];for (let i = arr.length - 1; i &gt;= 0; i--) { new_arr.push(arr[i]);} 手动反转 会改变元数组。 1234567const reverseArray = function(arr) { for (let i = 0, len = arr.length; i &lt; len / 2; i++) { let cur = arr[i]; arr[i] = arr[len - 1 - i]; arr[len - 1 - i] = cur; }}","link":"/2021/08/27/js%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js判断两个对象是否相同","text":"js判断两个对象是否相同（两个对象拥有相同的key和value就视为相同）。 此方法可以兼容key顺序不一致的情况。 1234567891011121314const isSameObj = (obj1, obj2) =&gt; { const obj1Keys = Object.keys(obj1); const obj2Keys = Object.keys(obj2); if (obj1Keys.length !== obj2Keys.length) return false; for (let i = 0; i &lt; obj1Keys.length; i++) { let key = obj1Keys[i]; if (!obj2Keys.includes(key)) return false; if (obj1[key] !== obj2[key]) return false; } return true;}","link":"/2021/09/27/js%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C/"},{"title":"js封装删除字符串中的空格函数","text":"删除字符串中的空格。 range: both, all 1234567891011121314151617const trimSpace = (str, range) =&gt; { if (typeof str === 'string') return false; switch (range) { case 'both': { return str.replace(/(^\\s*)|(\\s*$)/g, \"\"); break; } case 'all': { return str.replace(/\\s+/g, \"\"); break; } default: { return false; } }}","link":"/2021/09/08/js%E5%B0%81%E8%A3%85%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%87%BD%E6%95%B0/"},{"title":"js变量和文件命名","text":"总结一下js中的各种命名。 一般来说命名变量使用驼峰式 12345let firstName = 'Mason';let getName = function() { return name;} 命名布尔型前缀使用is, are, has 1let isNum = false; 函数采用动词前缀 1234567let getData = function() {}let queryString = function() {} 类采用PascalCase声明 123class ProblemSolution {} 组件名采用PascalCase 1&lt;NavBar&gt;&lt;/NavBar&gt; 方法采用驼峰式 12345class ProblemSolution { getName() { }} 私有变量 私有变量仅能在类内部使用 12345class ProblemSolution { _getName() { }} 常量用全大写 若遇到多个单词则中间插入下划线。 12const NAME = 'Mason';const GRADUATE_INSTITUTION = 'MIT'; 全局变量在文件顶部声明 12345let edition = 'v1.0';const NAME = 'Mason';......... 不要使用破折号 js文件使用PascalCase或者kebab-case命名。 使用PascalCase命名组件。 使用kebab-case命名其他文件。","link":"/2021/09/30/js%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"title":"js对象判空的几种方法","text":"js无法直接比较一个对象是否为空( obj === {} 永远为 false )，原因是js在对比两者时是比对的两者的内存地址，而 {} 放在js引擎新分配的内存地址中，故而两者永远不相等。 Object.getOwnPropertyNames()1let isEmpty = (Object.getOwnPropertyNames(obj).length === 0); Object.keys()1let isEmpty = (Object.keys(obj).length === 0); JSON.stringify()1const isEmpty = obj =&gt; JSON.stringify(obj) === \"{}\" for…in123456const isEmpty = obj =&gt; { for (var key in obj) { return false; } return true;} Reflect.ownKeys()1const isEmpty = obj =&gt; Reflect.ownKeys(obj).length === 0 &amp;&amp; obj.constructor === Object jQuery中的isEmptyObject()1let isEmpty = $.isEmptyObject(obj); updated on: 2021-12-06","link":"/2021/12/06/js%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%A9%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js数组去重的几种方法","text":"js数组去重的几种方法。 使用flag如果数组元素都是自然数，可以利用数组key都为自然数的特性，value记录对应的key是否已经存在于数组中。 123456789101112var source = [1, 2, 3, 2, 4, 6, 3];var flags = [];for (let i = 0; i &lt; source.length; i++) { if (flags[source[i]]) { // 删除该元素 source.splice(i, 1); } else { flags[source[i]] = true; }} 利用indexOf()构造只有唯一值数组12345678var source = [1, 2, 3, 2, 4, 6, 3];var target = [];for (let i = 0; i &lt; source.length; i++) { if (target.indexOf(source[i]) === -1) { target.push(source[i]); }} filter()配合indexOf()12345678var source = [1, 2, 3, 2, 4, 6, 3];var target = [];target = source.filter( (value, index) =&gt; { return source.indexOf(value) == index; }); Set()和扩展运算符Set 是es6新提供的数据类型，它是没有重复值的类数组。Set 转化为数组需要通过 [...new Set(arr)] 。 12var source = [1, 2, 3, 2, 4, 6, 3];const target = [...new Set(source)];","link":"/2021/07/28/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js手写发布订阅（pubsub）","text":"面了一个央企，一上来就让我手写pubsub，没写出来，今天梳理和学习一下怎么写。 发布订阅模式：包含发布者（publisher），订阅者（subscriber），消息中心（message center）。 发布者发布消息给消息中心，并且可以携带参数。 订阅者向消息中心订阅消息，并且可以获取发布者发送的参数。 消息中心在获取到发布者的消息后通知订阅者并且转发参数。 消息中心消息中心具有的功能是：消息中心类被实例化后可以接受publish新消息进去，也可以接受subscribe消息，如果消息中心收到了新的publish的消息是有人订阅的则通知订阅者。 消息中心本身可以以消息类型和消息内容的方式存储消息。 消息中心还可以以订阅者和订阅的消息类型的方式存储用户的订阅。 MessageCenter12345678910111213141516171819202122232425262728293031class MessageCenter { constructor() { // 消息集合：存放形式是消息类型（消息名称）和消息内容的键值对 this.messages = {}; // 监听集合：存放形式是订阅者和订阅消息类型的键值对 this.listeners = {}; } // publish方法：在消息中心中添加发布者的消息，参数是消息类型和消息内容 publish(type, content) { if (!this.messages.hasOwnProperty(type)) { this.messages[type] = []; } this.messages[type].push(content); } // subscribe方法：在消息中心中添加订阅者订阅的内容 subscribe(type, callback) { if (!this.listeners.hasOwnProperty(type)) { this.listeners[type] = []; } this.listeners[type].push(callback); } // notify方法：通知订阅者 notify(type) { const contents = this.messages[type]; const subscribers = this.listeners[type] || []; subscribers.forEach((callback, index) =&gt; callback(contents[index])); }} 发布者Publisher1234567891011class Publisher { // context是MessageCenter实例 constructor(name, context) { this.name = name; this.context = context; } publish(type, content) { this.context.publish(type, content); }} 订阅者Subscriber1234567891011class Subscriber { // context是MessageCenter实例 constructor(name, context) { this.name = name; this.context = context; } subscribe(type, callback) { this.context.subscribe(type, callback); }}","link":"/2022/08/30/js%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"},{"title":"js数组去空值","text":"js数组去空值的几种方法。 for遍历12345678910111213var arr = [1, 2, 3, '',, undefined, null,,];var r = removeEmptyElem(arr);function removeEmptyElem(rawArr) { let result = []; // 深拷贝 for (let i = 0; i &lt; rawArr.length; i++) { if (rawArr[i] !== undefined &amp;&amp; rawArr[i] !== null &amp;&amp; rawArr[i] !== '') { result.push(rawArr[i]); } } return result;} filter过滤1234var arr = [1, 2, 3, '',, undefined, null,,];var r = arr.filter(function(s) { return s;}); splice切片123456789101112var arr = [1, 2, 3, '',, undefined, null,,];spliceArr(arr);function spliceArr(rawArr) { for (let i = 0; i &lt; rawArr.length; i++) { if (rawArr[i] == undefined || rawArr[i] == null || rawArr[i] == '') { rawArr.splice(i, 1); i -= 1; } } return rawArr;}","link":"/2021/07/14/js%E6%95%B0%E7%BB%84%E5%8E%BB%E7%A9%BA%E5%80%BC/"},{"title":"js中的垃圾回收机制(Garbage Collection)和内存泄漏(Memory Leak)","text":"垃圾回收机制（Garbage Collection）js 有自动垃圾回收机制（GC），GC 会周期性的清理不使用的变量所占用的内存空间。 不同浏览器的 GC 机制都不同，不同环境的 GC 机制也不同。 不使用的变量主要是指局部变量，GC 会在局部变量使用完后等到下一个 GC 周期时释放该变量所占用的内存空间（在堆或者栈中）。 GC 判断变量是否需要被释放是通过标记清除（更为常用）和引用计数。 手动解除内存占用，就是将变量赋值为 null： var_name = null; 垃圾回收策略标记清除GC 会给所有进入环境（指的是全局环境或者局部）的变量（发生在变量声明时）打上标记“进入环境”，在变量离开环境时将其标记为“离开环境“，GC 会在下一个 GC 周期时释放被标记为离开环境的变量所占用的内存。 不同浏览器标记清除的策略略有不同。 引用计数GC 统计变量值的引用数量，引用计数变为 0 则表明该变量所占用的内存可以被释放，这样 GC 会在下一次运行的时候回收该内存空间。 故而，只声明了但是没有被使用的变量的引用计数为 1，所以也会造成内存泄漏。 引用计数会带来一个问题：循环引用。 比如： 12345678910function fn() { var a = {}; var b = {}; a.pro = b; // a引用了b b.pro = a; // b引用了a // do sth}fn(); 上面的代码运行结果是 a 和 b 的引用计数都为 2，a 和 b 的引用计数都无法降为 0，故而造成了这部分内存始终无法被 GC 释放，随着 fn 被多次调用，a 和 b 所占用的内存就会线性增长，造成内存泄漏。 IE7&amp;8 中有部分对象不是 js 原生对象而是 COM 对象，COM 对象的垃圾回收机制采用的就是引用计数策略。故而在 IE7&amp;8 中访问 COM 对象如果存在循环引用就会导致内存泄漏。 循环引用的解决方法：在变量使用完后手动破坏变量之间的互相引用关系。 123456789101112function fn() { var a = {}; var b = {}; a.pro = b; // a引用了b b.pro = a; // b引用了a // do sth a.pro = null;}fn(); 垃圾回收策略优化GC 在其运行期间会造成浏览器无响应。 需要优化 GC 策略来缩短无响应 duration。 优化策略一：分代回收（Generation GC）和 JVM GC 策略一样。 js 将待回收的变量分为临时（young generation）和持久（tenured generation），多回收 young generation，少回收 tenured generation，从而减少了整体回收的变量。 变量在 young generation 和 tenured generation 之间的迁转移需要额外的开销。 优化策略二：增量回收增量回收的策略就是每次只回收一点，提高回收的频率。 这种方法可以使每次回收的时间很短，但是带来了回收的次数很频繁。 内存泄漏（Memory Leak）内存泄漏：不再用到的变量占着内存并且没有被释放。 不合法的全局变量原因 1：未声明的变量或者 this 创建的变量会引发内存泄漏。 解决方法：1. 避免申明全局变量。 2. 使用严格模式。 原因 2：vue 单页面中声明全局变量在切换页面时没有释放。 解决方法：卸载页面时销毁引用，销毁引用并不能回收内存，而是让变量脱离执行环境从而可以让 GC 在下一次执行的时候回其收内存。 vue 中的其他内存泄漏的情况：https://segmentfault.com/a/1190000012738358#item-5 123destroyed() { window.variate_name = null;} 闭包原因：闭包保持它的变量一直在内存中，故而使用闭包的时候要注意内存泄漏。 解决方法：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对 DOM 的引用。 定时器和事件监听卸载页面之前需要清除定时器和事件监听。 1234beforeDestroy() { // 清除定时器 // 清除事件监听} DOM DOM 引用了对象作为其属性或者样式。 将 DOM 赋值给了一个变量，最后要给变量赋值 null。 WeakMap和WeakSet 解决内存泄漏es6 提供了 WaekMap 和 WeakSet 来解决引用带来的内存泄漏。 WeakMap12345const wm = new WeakMap(); const element = document.getElementById(\"example\"); wm.set(element, \"some information\"); wm.get(element); // \"some information\" GC 会忽略 wm 对于 element 的引用，故而 element 实际的引用计数为 1。 ref https://www.jb51.net/article/187661.htm https://segmentfault.com/a/1190000012738358 http://www.ruanyifeng.com/blog/2017/04/memory-leak.html","link":"/2021/12/18/js%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"title":"js类型转换","text":"js中时长发生着各种类型转换，有显式的有隐式的。本文总结了js中的类型转换的场景和类型。 js中的数据类型js中的数据类型可以分为：基本数据类型和引用数据类型。 基本数据类型： number string boolean undefined null symbol bigint 引用数据类型： object Array Date RegExp Math Error Number String Boolean function 类型之间的转换类型转换分为显式转换和隐式转换。 显式转换：代码中使用函数进行类型转换。隐式转换：不同数据类型之间使用运算符的时候，js自动的进行了类型转换。 类型转换最终只会转换成三种数据类型： Number: Number(), parseInt(), parseFloat() String: String(), toString() Boolean: Boolean() 转换为布尔型显式转换： Boolean(2) 隐式转换：逻辑运算时触发， if(2){} , !!2 , 2&amp;&amp;true 只有以下会被转为 false ，其余的都是 true ： 0 NaN &quot;&quot; null undefined 转换为字符串显式转换： String([1, 2, 3]) , String({}) 123451 + '2'// '12'1 + {}// 1[object Object] 隐式转换：使用 + 连接一个string的时候触发，或者使用 + 连接一个bject的时候触发。 转换为数字显式转换： Number() 。 1234567891011121314151617181920212223242526Number('')// 0Number('10px')// NaNNumber('10')// 10Number(true)// 1Number(false)// 0Number(null)// 0Number(undefined)// NaNNumber(Symbol())// 报错Number(12312412321312312n)// 12312412321312312 隐式转换：在比较运算符、按位操作、算术运算以及 + 触发。 ==转换规则== 运算符如果两边类型不同会进行类型转换。 对象==字符串：会将对象转换为字符串。 对象==对象：比较指针。 最佳实践Q:let result = 100 + true + 21.2 + null + undefined + &quot;Tencent&quot; + [] + null + 9 + false; 结果是什么？ A:100 + true101 , 加号两边存在数字则将另一个转为数组 101 + 21.2122.2 , 数字加数字 122.2 + null122.2 , 加号两边存在数字则将另一个转为数字 122.2 + undefinedNaN , 加号两边存在数字则将 undefined 转为 NaN ，结果仍为 NaN NaN + &quot;Tencent&quot;&quot;NaNTencent&quot; , 加号两边存在字符串则将另一个转为字符串 &quot;NaNTencent&quot; + []&quot;NaNTencent&quot; , 加号两边存在字符串则将另一个 [] 转为字符串 &quot;&quot; &quot;NaNTencent&quot; + null&quot;NaNTencentnull&quot; , null 转为字符串为 null &quot;NaNTencentnull&quot; + 9&quot;NaNTencentnull9&quot; , 两边存在字符串，将 9 转为字符串 &quot;NaNTencentnull9&quot; + false&quot;NaNTencentnull9false&quot; , 同上","link":"/2021/09/08/js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"js获取数组中的最小值和最大值的几种方法","text":"js获取数组中的最小值和最大值的几种方法。 Math.max()配合扩展符123let nums = [1, 6, 2, 8, 10, 11, 24, 3, 9];let max = Math.max(...nums);let min = Math.min(...nums); Math.max()配合apply()123let nums = [1, 6, 2, 8, 10, 11, 24, 3, 9];let max = Math.max.apply(Math, nums); // 24let min = Math.min.apply(Math, nums); // 1 Math.max()配合reduce()1234567let nums = [1, 6, 2, 8, 10, 11, 24, 3, 9];let max = nums.reduce(function(prev, cur) { return Math.max(prev, cur);});let min = nums.reduce(function(prev, cur) { return Math.min(prev, cur);}); sort()排序123456let nums = [1, 6, 2, 8, 10, 11, 24, 3, 9];nums.sort(function(a, b) { return a - b;});let min = nums[0];let max = nums[nums.length - 1];","link":"/2021/09/06/js%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E5%92%8C%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js计算代码运行时间","text":"js计算代码运行时间。 利用 performance 计时12345const START_TIME = performance.now();// codeconst END_TIME = performance.now();const DURATION = END_TIME - START_TIME;cosnole.log(DURATION); 利用 console.time 计时123console.time('timer_name');// codeconsole.timeEnd('timer_name'); 手写计时器12345const START_TIME = new Date();// codeconst END_TIME = new Date();const DURATION = END_TIME - START_TIME;cosnole.log(DURATION);","link":"/2021/09/06/js%E8%AE%A1%E7%AE%97%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"},{"title":"js遍历对象的几种方法","text":"总结一下js遍历对象的几种方法。 for…in123for (let key in obj) {} Object.keys(), Object.values()12let keyArr = Object.keys(obj);let valueArr = Object.values(obj); Object.getOwnPropertyNames()返回数组，成员是对象自己拥有的\b属性。 1let objPropert = Object.getOwnPropertyNames(obj);","link":"/2021/07/15/js%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js箭头函数(lambda表达式)和普通函数的区别","text":"区别从书写形式 -&gt; 函数是否具名 -&gt; 是否有arguments对象 -&gt; 是否可以作为构造函数 -&gt; this指向 书写形式不同略。 函数匿名性普通函数可以匿名或者具名，箭头函数只能匿名。 可否引用arguments匿名函数不绑定arguments对象（可以使用剩余参数替代），普通函数绑定arguments。 可否作为构造函数箭头函数不能作为构造函数。 为什么箭头函数不能作为构造函数？ 因为普通函数有constructor，来自原型链（prototype）上。 箭头函数没有prototype，故而没有constructor，故而不能作为构造函数。 this指向不同箭头函数this指向这个箭头函数被定义时所处的对象，如果没有对象则指向window，无法改变this指向。 普通函数this指向调用这个函数的对象（在构造函数中，this指向实例对象），如果没有调用对象则指向window，可以通过call，apply，bind改变this指向。","link":"/2022/08/30/js%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"js遍历数组的几种方法","text":"js遍历数组的几种方法。 for性能第二好 123for (let i = 0; i &lt; arr.length; i++) {} for(优化)性能最好 123for (let i = 0, len = arr.length; i &lt; len; i++) {} forEach123arr.forEach(function(element, index) {}); forEach(原型链方法)123Array.prototype.forEach.call(arr, function(element, index) {}); for…in123for (val in arr) {} map123var r = arr.map(function() {}); for…of(es6)123for (let value of arr) {}","link":"/2021/07/14/js%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"初识JVM","text":"JVM，也就是Java Virtual Machine（Java虚拟机），JVM是虚构出来的计算机，它的作用是在物理计算机上模仿各种计算机功能实现的。 Java能“一次编译，到处运行”的原因就是JVM屏蔽了不同操作系统和不同硬件的差异，这样Java开发者就可以无需考虑平台差异，只需要面向JVM编程即可。 JVM的本质是一个程序，当它开始执行class文件的时候就执行class文件中的指令。JVM上运行的是 .class 字节码文件，字节码文件是由 .java 文件经过编译器javac编译产生的，可以在JRE（JVM+Java类库）上运行。 正是由于JVM上面运行的是 .class ，所以不仅是Java，只要是能编译成 .class 的语言都可以在JVM上运行。比如python，python可以通过编译器jython将 .py 编译为 .class ，然后在JVM上运行。除此之外还有：kotlin, scala, clojure, groovy, jruby, ceylon, eta, haxe, fantom, rhino。 JVM的组成：堆，方法区，栈，本地方法栈，程序计数器等等。其中方法回收堆和方法区是共享区，而栈、程序计数器和本地方法栈区是JVM的。 JVM、JRE和JDK三者的关系JDK（Java开发工具包）包含了Java语言、JVM、Java API和Javac等工具。JRE（Java运行时环境）包含了JVM和Java API。也就是说：JDK包含了JRE，JRE又包含了JVM。 层级图示： JVM的实现原理类装载器（ClassLoader）类装载器（ClassLoader），负责装载class文件，然后交由execution engine执行。类装载器：启动类加载器（JVM实现的一部分）和用户自定义类加载器（Java程序的一部分）。 本地方法栈（native method stack）本地方法栈的作用是登记native方法，然后在execution engine执行的时候加载本地方法库。 栈（stack）又叫内存栈，栈负责java程序的运行，在线程创建的时候创建出来，在线程销毁的时候释放。 程序计数器（program counter）是方法区中的方法字节码由引擎读取下一条指令。 方法区（method area）是线程共享的。 堆（heap）用于存储对象实例。堆的内存空间需要JVM GC回收。 本地接口（native interface）用于融合不同的编程语言。 参考 wikipedia: JVM","link":"/2020/09/06/jvm-primary/"},{"title":"js调试技巧","text":"js调试技巧 缩短 console.log12let cl = console.log.bind(document);cl(123); 使用table展示数组和对象12let obj = {};console.table(obj);","link":"/2021/09/06/js%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"},{"title":"laydate日期格式不合法","text":"遇到了laydate无法正确渲染的问题。 在render的时候给value就可以了。 123456laydate.render({ elem: '#id', trigger: 'click', type: 'date', value: [yyyy - MM - dd]}); 还有一种是lay-key导致的渲染失败：https://blog.csdn.net/u013781343/article/details/82016042","link":"/2021/10/29/laydate%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E4%B8%8D%E5%90%88%E6%B3%95/"},{"title":"初识JVM调优","text":"关于jvm调优，其实大多数项目不需要jvm调优，需要调优的往往是比较极端的业务。 是否需要调优一般项目不需要调优，加xms和xmx参数就可以了。即使是高并发服务也不需要调优，jvm本身就是为低延时、高并发、大吞吐的服务设计和优化的。 1java -Xms1g -Xmx2g -jar abc.jar 对于项目来说，主要还是要将精力放在项目本身的调优。 jvm调优的前提是对服务的全面监控和性能数据的收集以及我们对jvm的运行原理的非常熟悉。 首先需要了解系统的运行状况，如果系统的响应时间很短，资源占用也不高，那么这种调优是没什么意义的。系统运行状况参数： 响应时间 TPS（每秒处理事务数量） 资源占用量（系统性能受限于最差的那个） jvm调优主要针对一些极端的项目，比如一些对吞吐量要求高而对时延要求不高的服务，就像12306。针对12306这种服务，可能需要调整一些参数，比如让gc中的generation分布更加合理。 如何调优jvm调优主要包括：1. 合理分配jvm内存空间。2. 选择适合的gc回收器。 合理分配jvm内存空间：jvm内存分配不合理的表现是频繁的gc从而降低系统的吞吐量和增加响应时间。 主要方法是调整堆内存空间以减少Full GC，调整新生代减少MinorGC，设置合理的Eden和Survivor区的比例。 选择合理的垃圾回收器 垃圾回收主要回收堆（主要是对象）和方法区（主要是废弃常量和类），需要响应快可以选择CMS和G1，需要吞吐高可以选择Parallel Scavenge。 jvm调优大部分调的是gc参数，主要是下面几点： 最大堆和最小堆的大小 gc算法 新生代的大小 jdk8及以前：gc算法会自动在Parallel和CMS中选择，新生代根据经验调节大小，这样就达到了性能和STW的平衡。 jdk9开始的版本：gc默认算法变为G1，只需要调整最大堆大小和STW期望值既可。","link":"/2020/09/07/jvm-tuning/"},{"title":"lambda表达式（箭头函数）","text":"lambda表达式就是匿名函数，同时也是一个闭包。 语法以js中的lambda为例： 1234567// 单行( [param1, parma2,…param n ) =&gt; statement;// 多行( [param1, parma2,…param n] )=&gt; { statement;} 作用 避免了污染全局变量。 简化了函数代码。 本身是一个闭包。","link":"/2021/02/24/lambda-expression/"},{"title":"flex布局","text":"flex简单布局： 1234567891011.container { display: -webkit-flex; display: flex;}nav { width: 200px;}.flex-column { -webkit-flex: 1; flex: 1;} flex复杂布局： 1234567891011121314151617181920212223.container { display: -webkit-flex; display: flex;}.initial { -webkit-flex: initial; flex: initial; width: 200px; min-width: 100px;}.none { -webkit-flex: none; flex: none; width: 200px;}.flex1 { -webkit-flex: 1; flex: 1;}.flex2 { -webkit-flex: 2; flex: 2;} flex居中布局： 123456789.vertical-container { height: 300px; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center;}","link":"/2020/04/30/layout-flex/"},{"title":"学习资源","text":"收录开发资料、设计资料以及各种电子书。 html&amp;css 《css权威指南》 《css世界》 《css揭秘》 《head first html &amp; css》 MDN css-tricks，google: 关键词 css-tricks 阮一峰博客，google: 关键词 阮一峰 张鑫旭，google: 关键词 张鑫旭 codrops css2.1中文spec js 《javascript DOM编程艺术》 《javascript高级程序设计》 《javascript语言精粹》 《javascript权威指南》 《你不知道的javascript》 《javascript设计模式》 《高性能javascript》 《web性能权威指南》 MDN 阮一峰js教程 阮一峰es6教程 算法 《学习javascript数据结构与算法第三版》 《我的第一本算法书》 《算法图解》 计算机网络 《http权威指南》 《图解http》 《图解tcp/ip第五版》","link":"/2018/10/06/learning-assets/"},{"title":"开源围棋人工智能leela-zero的使用和学习","text":"最近迷恋上了围棋， AlphaGo 不开放API，了解到一个开源的围棋AI叫 leela-zero ，小试一下。 安装及编译（macos） 方法一：macos可以直接brew安装leela-zero 1brew install leela-zero 方法二：手动编译 1234567891011121314git clone https://github.com/leela-zero/leela-zerocd leela-zerogit submodule update --init --recursivebrew install boost cmake zlibmkdir build &amp;&amp; cd buildcmake ..cmake --build .# 测试./tests 交互leela-zero无法直接使用，需要先安装一个GUI并通过GTP协议与其进行交互，支持GTP2。 主要有下面几种： Lizzie：Leela Zero的专门客户 Sabaki LeelaSabaki GoReviewPartner 参考 project: leela-zero","link":"/2020/11/15/leela-zero/"},{"title":"leetcode-11. 盛最多水的容器","text":"难度：中等 problem给你 $n$ 个非负整数 $a_1，a_2，…，a_n$，每个数代表坐标中的一个点 $\\left(i, a_i\\right)$ 。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $\\left(i, a_i\\right)$ 和 $\\left(i, 0\\right)$ 。找出其中的两条线，使得它们与 $x$ 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。示例 2： 输入：height = [1,1] 输出：1示例 3： 输入：height = [4,3,2,1,4] 输出：16示例 4： 输入：height = [1,2,1] 输出：2solution双指针设两个端点为$\\left(i, a_i\\right)$和$\\left(j, a_j\\right)$, 且$i &lt; j$。 盛水的容量：$\\left(j - i\\right) \\times \\min\\left(a_i, a_j\\right)$ 求两条线使得盛水量最大就是求$\\max\\left(\\left(j - i\\right) \\times \\min\\left(a_i, a_j\\right)\\right)$。 设置两个指针$i$和$j$，每次都将短的指针向内侧移动，每次移动判断一下容量，直到$i$和$j$相遇。 code双指针123456789101112131415161718/** * @param {number[]} height * @return {number} */var maxArea = function(height) { let area = 0, max = 0; let i = 0, j = height.length - 1; while (i &lt; j) { area = (j - i) * Math.min(height[i], height[j]); max = Math.max(area, max); height[i] - height[j] &gt; 0 ? j-- : i++; } return max;}; trap错误的将 height[i] - height[j] &gt; 0 简写为了 height[i] - height[j] 造成了排查排了好久，其实 !!(-1) 为 true 。 对于0之外的正负数求布尔值都为true。","link":"/2021/10/25/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"leetcode-2-两数相加","text":"难度：中等 题目给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字0之外，这两个数都不会以0开头。 示例示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807.示例 2： 输入：l1 = [0], l2 = [0] 输出：[0]示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1]提示： 每个链表中的节点数在范围 [1, 100] 内0 &lt;= Node.val &lt;= 9题目数据保证列表表示的数字不含前导零 代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var addTwoNumbers = function(l1, l2) { let head = null, tail = null; let carry = 0; while (l1 || l2) { const n1 = l1 ? l1.val : 0; const n2 = l2 ? l2.val : 0; const sum = n1 + n2 + carry; if (!head) { head = tail = new ListNode(sum % 10); } else { tail.next = new ListNode(sum % 10); tail = tail.next; } carry = Math.floor(sum / 10); if (l1) { l1 = l1.next; } if (l2) { l2 = l2.next; } } if (carry &gt; 0) { tail.next = new ListNode(carry); } return head;};","link":"/2021/03/10/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"leetcode-17.19-消失的两个数字","text":"链接：https://leetcode.cn/problems/missing-two-lcci/ 难度：困难 problem给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？ 以任意顺序返回这两个数字均可。 示例 1: 输入: [1] 输出: [2,3]示例 2: 输入: [2,3] 输出: [1,4]提示：nums.length &lt;= 30000 solutionDP先给原数组排序，再对排序完的数组进行判断是否存在缺失数字，如果存在就push进res数组直到res数组满了，如果不存在就往两边搜索。 求差集时间复杂度和空间复杂度都比较高。 codeDP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param {number[]} nums * @return {number[]} */var missingTwo = function(nums) { // 先对于nums做升序排序 let sortedNums = nums.sort(function(a, b) { return a - b; }); let sortedNumsLen = sortedNums.length; // 返回值 let res = []; // 扫描sortedNums中是否存在缺的数字 for (let i = 0; i &lt; sortedNums.length - 1; i++) { let cur = sortedNums[i]; let next = sortedNums[i+1]; if (cur + 1 !== next) { res.push(cur+1); } } // 如果仍然有缺失的数字则往两边搜索 // 向左搜索 if (res.length &lt; 2) { let head = sortedNums[0]; for (let i = 0; i &lt; head - 1; i++) { res.push(i + 1); } } // 向右搜索 if (res.length &lt; 2) { let tail = sortedNums[sortedNumsLen - 1]; // 这里需要保存一下res.length当前的值，因为for循环体内改变了res.length let resLen = res.length; for (let i = 0; i &lt; (2 - resLen); i++) { res.push(tail + i + 1); } } return res;}; 求差集123456789101112131415161718192021222324252627282930/** * @param {number[]} nums * @return {number[]} */var missingTwo = function(nums) { // 先对于nums做升序排序 let sortedNums = nums.sort(function(a, b) { return a - b; }); let sortedNumsLen = sortedNums.length; let correctNums = new Array(sortedNumsLen+2); // 填充对照的数组 for (let i = 0, len = correctNums.length; i &lt; len; i++) { correctNums[i] = i + 1; } let sortedNumsSet = new Set(sortedNums); let correctNumsSet = new Set(correctNums); let res = []; for (let item of correctNums) { if (!sortedNumsSet.has(item)) { res.push(item); } } return res;}; trap向右搜索的for循环应该先保存一下res.length（见代码）。","link":"/2022/09/27/leetcode-17-19-%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"},{"title":"leetcode-2119-反转两次的数字","text":"难度：简单 Description反转 一个整数意味着倒置它的所有位。 例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。 示例 1： 输入：num = 526 输出：true 解释：反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。示例 2： 输入：num = 1800 输出：false 解释：反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。示例 3： 输入：num = 0 输出：true 解释：反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。Solution模拟数字先转为字符串，再逆转字符串，丢掉前面的0，再逆转字符串，再丢掉前面的0。 求余原始的数字，如果第一位为0，则两次反转后不会丢失。如果最后一位为0，那么在第一次反转后就会丢失。 故而：如果最后一位为0就return false，如果不为0就return true。 Code模拟123456789101112131415161718192021222324252627282930313233/** * @param {number} num * @return {boolean} */var isSameAfterReversals = function(num) { if (!num) return true; let numStr = num + ''; let numStrReversedArray = numStr.split('').reverse(); for (let i = 0, len = numStrReversedArray.length; i &lt; len; i++) { if (numStrReversedArray[i] === '0') { numStrReversedArray.shift(); } else { break; } } let numStrReversedArrayResult = numStrReversedArray.reverse(); for (let i = 0, len = numStrReversedArrayResult.length; i &lt; len; i++) { if (numStrReversedArrayResult[i] === '0') { numStrReversedArrayResult.shift(); } else { break; } } let result = numStrReversedArrayResult.join(''); return numStr === result;}; 求余123456789/** * @param {number} num * @return {boolean} */var isSameAfterReversals = function(num) { if (!num) return true; return num % 10 !== 0;};","link":"/2022/06/28/leetcode-2119-%E5%8F%8D%E8%BD%AC%E4%B8%A4%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"leetcode-226-翻转二叉树","text":"难度：简单 problem翻转一棵二叉树。 示例： 输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1备注: 这个问题是受到Max Howell的原问题启发的 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。solution递归从root开始，每遇到一个节点就交换左右子树，再调用自身遍历左右子树。 code递归123456789101112131415161718192021/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {TreeNode} */const invertTree = function(root) { if (!root) return null; [root.left, root.right] = [root.right, root.left]; invertTree(root.left); invertTree(root.right); return root;}","link":"/2021/10/28/leetcode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"解析let和const声明的变量不在window下的原因","text":"使用es5中 var 命令声明的变量可以在 window 下找到，比如： var myName = 'mason' ，可以使用 window.myName 访问到。 但是使用es6的 let 和 const 声明的变量却没有在window下，这是为什么呢？ 这里就要说到window对象和 global 对象。 对于window和global的看法，之前一直都是：window是浏览器的顶层对象，global是node的顶层对象。 但是其实window是global在浏览器的代理，window是global的一部分。我们使用var声明的变量会被挂载到window下。 而let和const声明的变量会被挂载到 script 对象下，script和global是同一层级的。","link":"/2022/01/14/let%E5%92%8Cconst%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/"},{"title":"命令行下有趣的工具","text":"持续收集linux实用的命令行工具。 wttr.in 获取天气 获取当前所在位置天气： 1curl wttr.in 效果： 获取制定城市天气： 1curl wttr.in/shanghai 效果： 参数 加参数-o保存为文件 1curl -o weather.html wttr.in/shanghai 封装为脚本 1234567891011121314#!/bin/shset -euxCITY=shanghaiLANGUAGE=\"zh-CN\"UNIT=mUA=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36\"curl \\ -H \"Accept-Language: $LANGUAGE\" \\ -H \"User-Agent: $UA\" \\ -o result.html \\ wttr.in/$CITY?format=4\\&amp;$UNIT bashtopbashtop bashtop是一个开源的linux资源监视器。 其主要作用是用于展示当前 Linux 系统的处理器、内存、硬盘、网络和进程等各项资源的使用情况与统计报告。 这款工具功能众多，但比较亮眼的，主要是以下几项： 可高效响应的操作界面 可显示所选进程的详细统计信息 可过滤进程 可轻松切换不同排序 可自动缩放网络使用情况图标 支持多个不同主题风格的配置","link":"/2020/03/25/linux-command-tools/"},{"title":"linux运维基础","text":"上周末刷了个慕课网的linux基础运维课程，感觉初入linux还是需要及时总结一下加强记忆的。 https://www.imooc.com/learn/175 https://www.imooc.com/learn/111 shell内置命令：cd：进入家目录（若登录用户为root则进入root目录） cd xxx：进入本文件夹下的xxx目录 cd /xxx：进入根目录下的xxx目录 cp file1/dir1 file2/dir2：将文件1或者文件夹1复制到文件2或文件夹2（若源文件夹下有文件则需加上-r选项来递归复制） mv file dir：将文件复制到目录下 mv filename1 filename2：将文件2重命名为文件1 rm -rf file/dir：删除文件或目录（包括目录下的文件），该命令是不会提示是否删除的，所以用之前要看好是否要删除 mkdir dir：创建dir目录 touch file：创建file文件 ls：以简要信息显示当前目录下所有文件 ls -l：以列表形式显示当前目录下所有文件 ll=ls -l ls -lh：以人性化列表形式显示当前目录下所有文件 locate file：按文件名搜索文件（该命令直接搜索updatedb这个文件，该文件每次重启或者第二天都会刷新） whereis cmd：搜索cmd命令并显示位置和帮助文档 which cmd：搜索cmd命令并显示别名和位置 whatis file：查找文件 echo $PATH：显示搜索目录 pwd：显示当前工作目录 精确匹配搜索：find scale condition： find /root -name xxx（默认区分大小写） find /root -iname filename（不区分大小写） find /root -user root find /root -nouser find / -mtime +10 ​ -atime ​ -ctime +10十天前 -10十天内 10第十天当天 find dir -size 25k：查找大小为25k的文件 find dir -size +25k：查找大小大于25k的文件 find dir -size -25k：查找大小小于25k的文件 单位k，M，G等 find /etc -size +20k -a -size -50k：查找20k-50k之间的文件 find /etc -size +20k -o -size -50k：查找20k-50k之间的文件 以上后面空格+-exec ls -lh{} ; 标识将以上的结果交由后面处理 grep -r（无的）/-i（不分大小写） xxx ：在xxx文件中查找size man cmd：显示cmd命令的帮助文档（先要安装：yum install man） cmd –help：获取cmd命令的选项 whereis cmd：有文档则为外装的 help cmd：获取内部命令cmd的帮助文档 info：整个文档 压缩： zip long.zip long:文件 zip -r long.zip long：目录 解压： unzip long.zip gzip long gzip -d","link":"/2018/02/05/linux-basic/"},{"title":"mac使用技巧与问题汇总","text":"汇总一下mac使用技巧和常用软件和问题。 macos大多数问题可以参考：http://www.sdifen.com/ 右侧常见问题处理方法。 常用的brew命令homebrewlink1234567891011121314151617181920212223242526272829303132333435363738394041424344# 搜索软件包brew search [software]# 安装软件包brew install [software]# 卸载软件包brew uninstall [software]# 更新软件包brew update# 更新指定的软件包brew upgrade [software]# 显示已经安装的软件包brew list# 查看软件信息brew info [software]# 用浏览器打开软件信息页面brew home [software]# 查看需要更新的软件brew outdated# 查看包依赖brew reps# 查看帮助brew help 常用的软件包 代替 cat 的工具：bat，支持语法高亮、同时显示行号，使用: bat xx.yyy 安装： brew install bat man 命令的替代品：tldr 安装： brew install tldr 命令行显示动态的火焰，运行: aafire 安装: brew install aalib 命令行显示黑客帝国数字雨，运行: cmatrix 安装: brew install cmatrix 在命令行中开火车，运行：sl 安装: brew install sl 在命令行把输出变成七彩，运行: ls | lolcat，需要配合其他程序使用 安装: brew install lolcat 把你的命令行变成海洋馆，运行: asciiquarium 安装: brew install asciiquarium 会说话的 ascii 奶牛, 运行：cowsay &lt;你想说的话&gt; 安装: brew install cowsay mac自带的say命令 say hello 升级到Monterey后部分软件打不开1sudo xattr -d com.apple.quarantine /Applications/xxxx.app","link":"/2019/06/25/mac-usage/"},{"title":"linux使用技巧","text":"记录一些linux使用技巧。 command !! !!命令指向最近执行的一条命令，当我们使用apt-get安装软件的时候有时候会忘了写sudo，这个时候只需要如下既可： 1sudo !! cd - 返回刚才的目录。 ^old^new 比如： 1echo \"goed\" 错误将good写成了goed。 只需要^e^o既可。 代码： 12echo \"goed\"^e^o 回车既可。 man ascii 显示ascii码表。 有时候需要用到ascii码的时候就不需要打开浏览器然后再打开google搜索了。 ctrl-x e 快速启动默认编辑器。 netstat -tlnp 列出本机进程监听的端口号。 tail -f /path/to/file.log | sed ‘/^Finished: SUCCESS$/ q’ 1tail -f /path/to/file.log | sed '/^Finished: SUCCESS$/ q' 当log文件里面出现Finished: SUCCESS的时候退出tail，用于实时监控并且过滤log是否出现了某条记录。 ssh user@server bash &lt; /path/to/local/script.sh 用到了输入重定向。在远程服务器运行本地一个脚本文件。 screen -d -m -S some_name ping my_router 后台运行一段不终止的程序，可以随时查看它的状态。 -d -m参数启动分离模式，-S指定一个session标识。 可以通过-R命令重新挂载一个标识的session。 参考：man screen或者tldr screen wget 下载一个网站： 1wget --random-wait -r -p -e robots=off -U mozilla https://www.baidu.com curl 1curl www.baidu.com lsof -i 实时查看本机网络服务活动状态。 python -m SimpleHTTPServer 将当前目录设置为HTTP服务目录，并可以通过8000端口访问： 1234python -m SimpleHTTPServer# 默认运行在8000端口http://localhost:8000/ 列出我最常用的十条命令 123history | awk '{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a]\" \" CMD[a]/count*100 \"% \" a }' | grep -v \"./\" | column -c3 -s \" \" -t | sort -nr | nl | head -n10 tools cmatrix cmatrix是一款在命令行下显示黑客帝国中代码雨的插件，简直是中二少年的福音啊。 12345# 安装brew install cmatrix# 运行cmatrix cmatrix还有个进阶版叫unimatrix，效果差不多，不过可配置的东西很丰富。 neofetch neofetch是一款显示系统信息的工具。 官网：https://www.cyberciti.biz/howto/neofetch-awesome-system-info-bash-script-for-linux-unix-macos/ 12345# 安装brew install neofetch# 使用neofetch lolcat lolcat是一款将输出信息变为彩虹色的工具。 12345# 安装brew install lolcat# 使用ls -lha | lolcat tldr 我们知道man的替代品有info（英文手册）和cman（中文的man）。 除此之外还有tldr，tldr是直接给出了命令的常用用法。 1tldr ls","link":"/2020/08/06/linux-tips-01/"},{"title":"markdown精粹及工作流","text":"这是一片markdown的使用教程，以及一点使用markdown的工作方式。 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 段落 段落尾部敲至少两个空格后回车。 12段落1 段落2 段落后面回车一个空行 123段落1段落2 字体123*斜体***加粗*****加粗斜体*** 分割线连续三个以上的*或者- 12***--- 效果 删除线用~~包裹文本 1~~删除我~~ 文本 效果真的很好 下划线1&lt;u&gt;文本&lt;/u&gt; 文本 注脚文本[^注脚文本] 1文本[^注脚文本] 列表无序列表使用*空格，或者-/+空格 12* 第一项* 第二项 第一项 第二项 有序列表使用数字+.空格 121. 第一项2. 第二项 列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可 区块引用开头&gt;空格 123&gt; 引用的内容&gt; 引用的内容&gt; 引用的内容 引用的内容 引用的内容 引用的内容 可嵌套 第一层引用 第二层引用 第三层引用 可在区块中使用列表，也可在列表中使用区块 代码 短代码使用一对反引号`包裹 code 长代码使用三个反引号+langType+回车 123$(document).ready(function () { //js code}); 代码区块（无高亮）,代码区块使用 4 个空格或者一个制表符（Tab 键。 ​ code line1 ​ code line2 连接url123[链接名称](链接地址)or&lt;https://www.google.com&gt; google or https://www.google.com 高级链接1[title]: url 图片1![属性文本](url) 12![属性文本](url \"标题\")鼠标hover图片的时候会显示标题 1[图片]: https://cdn.pixabay.com/photo/2016/01/02/01/59/oranges-1117628_960_720.jpg 表格使用|分割单元，使用-分割表头和其他 123| 姓名 | 年龄 | 性别 || ---- | ---- | ---- || 小明 | 10 | 男 | 效果： 姓名 年龄 性别 小明 10 男 还有对齐什么的，使用过于麻烦，typora直接右键插入表格 高级标签不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持：kbd,b,i,em,sup,sub,br等标签 例子： windows用户按ctrl+F4关闭本窗口 mac用户按commad+Q退出程序 我是黑体 我是斜体 强调 210=1024 &lt;br&gt;标签 转义想要显示**文本**的话在符号前加\\ 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。 世界上最美的公式:欧拉公式123$$ e^{ \\pm i\\theta } = \\cos \\theta \\pm i\\sin \\theta$$ $$e^{ \\pm i\\theta } = \\cos \\theta \\pm i\\sin \\theta$$ 工作流我是用的是Typora，一般的markdown写作流是这样的： touch file.md后先写上文章标题 1# 文章标题 写上一段引言，不用很多，几十个字足够 1本文档旨在提炼出markdown写作中最常用的语法以及本人的工作流。 生成目录树toc（部分md写作工具支持），toc会随着你的标题而自动生成。 1[toc] 效果（hexo不支持toc故而放截图）： 文章一级内容用## 标题，文章二级内容用### 标题，以此类推，除了文章标题，内容尽量不要超过三层 列表要使用有序或无序列表，尽量不要直接回车换行 每个文档至少配一张图，hexo支持显示在文章顶部。图片文件放在md文件同目录下的assets目录下，或者使用sm.ms这样的图床，新浪图床尽量别用图片已经丢了好多了。 写技术文档避免不了要引入代码，一般短代码使用两个反引号包裹，大段代码使用三个反引号加上语言名称然后回车。 需要高亮而又非代码的文本我一般用三个反引号回车，这样文本就不会被高亮了。 最后一步查看toc目录看看是否有层级错误，检查文章逻辑，补充要点。","link":"/2020/03/10/markdown%E7%B2%BE%E7%B2%B9%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"title":"使用md5,sha1,sha256校验文件","text":"为了校验文件的真实性，我们使用哈希算法来校验文件的唯一性。 文件经过哈希算法会生成一个唯一的字符串，我们使用的软件经过哈希函数计算返回字符串用来和软件作者给出的字符串进行对比即可知道该文件是否有被修改。 常用的hash函数有三种，按照安全性排列：md5 &lt; sha1 &lt; sha256。 使用linux获取哈希值123md5sum filenamesha1sum filenamesha25sum filename 获取哈希值并与哈希文件比对123md5sum -c filename.md5filesha1sum -c filename.sha1filesha256sum -c filename.sha256file macos安装md5sha1sum: 1brew install md5sha1sum 123md5sum filenamesha1sum filenameshasum -a256 filename 我一般就使用macos上的自带的md5命令： 1md5 filename window方法一：安装GUI软件：quick hash或者其他软件均可。 方法二：powershell: 1certutil -hashfile or 1Get-FileHash Cmdlet or 1Get-FileHash -Algorithm MD5 or 12sha1 filenamesha256 filename","link":"/2019/08/02/md5-sha1-sha256/"},{"title":"leetcode-633-平方数之和","text":"难度：中等 题目给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c 。 示例示例 1： 输入：c = 5 输出：true 解释：1 * 1 + 2 * 2 = 5示例 2： 输入：c = 3 输出：false示例 3： 输入：c = 4 输出：true示例 4： 输入：c = 2 输出：true示例 5： 输入：c = 1 输出：true代码单指针123456789101112131415/** * @param {number} c * @return {boolean} */var judgeSquareSum = function(c) { for (let i = 0; i*i &lt;= c; i++) { let j = Math.sqrt(c - i*i); if (j === parseInt(j)) { return true; } } return false;}; 双指针123456789101112131415161718192021/** * @param {number} c * @return {boolean} */var judgeSquareSum = function(c) { let i = 0; let j = Math.floor(Math.sqrt(c)); while (i &lt;= j) { let sum = i*i + j*j; if (sum === c) { return true; } else if (sum &gt; c) { j--; } else { i++; } } return false;};","link":"/2021/03/09/leetcode-633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"mac卸载java8","text":"卸载java8换成java11 LTS。 12345sudo rm -rf /Library/Internet\\ Plug-Ins/JavaAppletPlugin.pluginsudo rm -rf /Library/PreferencesPanes/JavaControlPanel.prefPanesudo rm -rf ~/Library/Application\\ Support/Java# jdk版本使用ls /Library/Java/JavaVirtualMachines/查询sudo rm -rf /Library/Java/JavaVirtualMachines/[jdk version]","link":"/2020/09/26/mac-uninstall-jdk8/"},{"title":"什么是MVC模式和MVVM模式","text":"MVC和MVVM都是是软件架构。 MVC MVC的组成： 视图（View）：用户界面，接受用户的操作。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 MVC的工作方式： View传送指令到Controller。 Controller完成业务逻辑后，要求Model改变。 Model将新的数据发送到View，用户得到反馈。 MVVM MVVM的组成： 视图（View）：用户界面。 模型（Model）：数据保存 视图模型（ViewModel）：业务逻辑，与View双向绑定，与Model双向通信。 MVVM的工作方式： ViewModel将Model转化为View，就是将后端传递的数据可视化。 ViewModel将视图转为Model，就是将可视化的页面转为后端的数据。 参考 http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html 《Vue.js 3.0从入门到精通》","link":"/2020/05/26/mvc-and-mvvm/"},{"title":"MacOS安装MySQL","text":"mac上安装和使用MySQL。 安装MySQL使用安装包安装MySQLMySQL官网下载：https://dev.mysql.com/downloads/mysql/ 清华tuna下载：https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/ homebrew安装MySQLbash1brew install mysql@5.7 mysql-client@5.7 使用MySQLbash1234567891011# 启动MySQLmysql.server start# 关闭MySQLmysql.server stop# 重启MySQLmysql.server restart# 登录mysql -u root -p sql12345-- 展示所有数据库SHOW DATABASES;-- 选择一个数据库use DATABASE_NAME; GUI工具 Navicat(支持 MySQL、MariaDB、MongoDB、SQL Server、Oracle、PostgreSQL 和 SQLite) 替代品MySQL被oracle收购以后出现了mariadb，其API和命令与MySQL一模一样，用以规避MySQL可能会闭源的未来。","link":"/2021/12/20/mysql-on-mac/"},{"title":"使用neofetch和lolcat美化输出","text":"官网：https://www.cyberciti.biz/howto/neofetch-awesome-system-info-bash-script-for-linux-unix-macos/ 安装12brew install neofetchbrew install lolcat 使用使用neofetch查看本机信息： 1neofetch 使用lolcat彩虹化输出信息颜色： 1ls -lha | lolcat 当然也可以使用neofetch配合lolcat将输出的本机信息彩虹化： 1neofetch | lolcat 疗效单独使用fetch： fetch+lolcat：","link":"/2020/07/17/neofetch/"},{"title":"nginx基本配置、反向代理、负载均衡以及高可用","text":"nginx的基本配置。 配置nginx是通过编辑nginx的配置文件实现的。 nginx配置文件位于/etc/nginx/nginx.conf或者/etc/nginx/conf.d/目录中。 nginx安装bash12# 安装nginxsudo yum install -y nginx nginx命令bash1234567891011121314151617181920# 查看nginx状态sudo systemctl status nginx# 启动nginxsudo systemctl start nginx# 停止nginxsudo systemctl stop nginx# 重启nginxsudo systemctl restart nginx# 重新载入nginx配置文件sudo systemctl reload nginx# 系统启动时启动nginxsudo systemctl enable nginx# 测试nginx配置文件是否正确sudo nginx -t nginx基本配置conf1234567891011121314151617181920212223242526server { # 监听80端口 listen 80; # 域名 server_name example.com www.example.com; # 网站根目录 root /var/www/example; # 默认首页 index index.html index.htm; location / { try_files $uri $uri/ =404; } # 定义错误页面 error_page 404 /404.html; location = /404.html { internal; } error_page 500 502 503 504 /50x.html; location = /50x.html { internal; }} nginx配置静态资源目录conf12345678910111213server { listen 80; server_name example.com; location / { proxy_pass http://localhost:3000; } # 配置静态文件目录，当客户端访问下面的几种格式的静态文件时nginx会定向到/static目录下 location ~ \\.jpg|.png|.gif|.css|.js$ { root static; }} nginx配置反向代理nginx除了可以支持正向代理还可以支持反向代理，反向代理就是对客户端隐藏了真实的服务端。 下面的配置会将所有传入的请求转发给本地的http://localhost:3000服务器。 conf123456789101112server { listen 80; server_name example.com; location / { proxy_pass http://localhost:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; }} nginx配置负载均衡conf12345678910111213141516# 服务器集群，serverlist是集群名称upstream serverlist { # 真实服务器 server 192.168.1.101:8080; server 192.168.1.102:8080;}server { listen 80; server_name example.com; location / { # 指定服务器集群 proxy_pass http://serverlist; }} 负载均衡策略： 轮询 nginx默认使用轮询策略。 权重 给服务器集群的每台真实服务器添加权重，各个权重表示各个服务器被访问的频率比例。 conf12345678910111213141516# 服务器集群，serverlist是集群名称upstream serverlist { # 真实服务器，带权重 server 192.168.1.101:8080 weight=1; server 192.168.1.102:8080 weight=2;}server { listen 80; server_name example.com; location / { # 指定服务器集群 proxy_pass http://serverlist; }} ip_hash 根据客户端ip分配真实服务器。 conf123456789101112131415161718# 服务器集群，serverlist是集群名称upstream serverlist { # ip_hash ip_hash; # 真实服务器 server 192.168.1.101:8080; server 192.168.1.102:8080;}server { listen 80; server_name example.com; location / { # 指定服务器集群 proxy_pass http://serverlist; }} 第三方插件 使用第三方插件，插件可能使用了其他策略。 nginx配置https下面配置了Let’s Encrypt证书： conf1234567891011121314151617181920server { listen 80; server_name example.com; return 301 https://$host$request_uri;}server { listen 443 ssl; server_name example.com; ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; root /var/www/example; index index.html index.htm; location / { try_files $uri $uri/ =404; }} 安装certbot和获取证书： bash12sudo apt install certbot python3-certbot-nginxsudo certbot --nginx -d example.com -d www.example.com nginx高可用以上都是基于单个nginx节点进行的配置，如果这个节点挂了那么整个后端服务都挂了。 为了实现nginx的高可用，一般是在多台服务器上部署nginx节点，在每台服务器上安装keepalived，再配置keepalived。 准备多台服务器并部署nginx 在每个服务器上安装keepalived bash1sudo yum install -y keepalived 配置keepalived 文件路径：/etc/keepalived/keepalived.conf conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849global_defs { notification_email { acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc } notification_email_from Alexandre.Cassen@firewall.loc # 节点ip smtp_ server 192.168.232.166 smtp_connect_timeout 30 # 节点ip router_id 192.168.232.166} # 定义chk_http_portvrrp_script chk_http_port { # nginx检测脚本 script &quot;/usr/local/src/nginx_check.sh&quot; interval 2 # 如果上面脚本检测成功则降低优先级，反之则相反 weight -20}# 节点配置vrrp_instance VI_1 { # 将这个节点配置为主节点，BACKUP为从节点 state MASTER # 使用的网络接口 interface eth0 # VRID，必须在主备服务器上保持一致 virtual_router_id 51 # 节点优先级，数值越大优先级越高 priority 100 # 通告间隔时间，秒 advert_int 1 # 认证密码，主从服务器必须保持一致 authentication { auth type PASS auth pass 1111 } # 虚拟ip，该ip需要配置和其他节点ip在同一个网段，主备节点共享 virtual_ipaddress { 192.168.0.100 } #将 track_script 块加入 instance 配置块 track_script { chk_http_port #执行 Nginx 监控服务 }} 在/usr/local/src下添加nginx_check.sh文件 shell123456#!/bin/bash# 检查是否开启nginxA=`ps -C nginx --no-header |wc -l`if [ $A -eq 0 ];then systemctl stop keepalivedfi 启动keepalived 在配置完所有的节点后，在每个节点启动keepalived。 bash12sudo systemctl enable keepalivedsudo systemctl start keepalived.service 验证配置 6.1 在主节点上查看虚拟ip是否已经绑定到了接口。 bash1ip addr show 6.2 在备用服务器上，停止主服务器的keepalived服务，检查虚拟IP是否切换到备用服务器。 6.3 检查日志文件确保keepalived正常工作。 bash12cat /var/log/syslogcat /var/log/messages 访问虚拟ip获取服务 现在可以访问虚拟ip获取服务。","link":"/2024/05/18/nginx-conf/"},{"title":"node.js开发笔记——命令行输入输出","text":"总结一下命令行输入输出。 命令行输出nodejs命令行输出一般有： console.log console.error console.dir console.clear console.count console.trace console.time console.timeEnd 着色可以使用输出格式化给输出添加样式。 可以使用Chalk着色器：https://github.com/chalk/chalk 安装： 1cnpm install chalk 使用： 12const chalk = require('chalk')console.log(chalk.yellow('你好')) 进度使用progress：https://www.npmjs.com/package/progress 1234567891011const ProgressBar = require('progress')const bar = new ProgressBar(':bar', { total: 10})const timer = setInterval(() =&gt; { bar.tick() if (bar.complete) { clearInterval(timer) }}, 100) 命令行输入如何在命令行读取用户的输入： 1234567891011const rl = require('readline')let getUser = rl.createInterface({ input: process.stdin, output: process.stdout})getUser.question('请输入用户名：', (username) =&gt; { console.log(`用户名是: ${username}`) getUser.close()}) 可以使用inquirer包： cnpm install inquirer 1234567891011const inquirer = require('inquirer')var questions = [{ type: 'input', name: 'name', message: \"你叫什么名字?\"}]inquirer.prompt(questions).then(answers =&gt; { console.log(`你好 ${answers['name']}!`)})","link":"/2019/05/22/nodejs%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"node.js开发笔记——从命令行接收参数","text":"如何在使用node命令运行node.js程序的时候传递一些参数。 比如： node app.js 直接在 app.js 后面传参： node app.js param1 param2 然后在 app.js 文件中使用 process.argv 来接收命令行传进来的参数数组。 process.argv 数组第一个元素是node绝对路径，第二个参数是app.js的绝对路径，从第三个参数开始是命令行传递的参数。 所以可以直接截取index为2开始之后的所有元素： 1234567// 获取传入的参数const args = process.argv.slice(2)// 如果传入的参数是key=value的情况，需要解析，可以使用minimist库来解析const args = require('minimist')(process.argv.slice(2))// 获取解析后的参数args['paramName'] 使用了minimist库的话需要在命令行中每一个参数前面加上--，比如node app.js --name=Mason --age=22 minimist: https://www.npmjs.com/package/minimist","link":"/2019/05/21/nodejs%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0/"},{"title":"node.js开发笔记——创建http服务","text":"在桌面创建一个用于存放server的目录，并且创建server.js bash12345cd ~/Desktop/mkdir node-servercd node-servertouch server.jsvim server.js 编写服务器server.js server.js1234567891011121314151617181920212223242526var http = require('http')var fs = require('fs')var url = require('url')var port = process.argv[2]if (!port) { console.log(\"请指定端口号，比如\\nnode server.js 8888\") process.exit(1)}var server = http.createServer(function(request, response) { var parsedUrl = url.parse(request.url, true) var path = request.url var query = '' if (path.indexOf('?') &gt;= 0) { query = path.substring(path.indexOf('?')) } var pathNoQuery = parsedUrl.pathname var queryObject = parsedUrl.query var method = request.method console.log('得到 HTTP 路径\\n' + path) console.log('查询字符串为\\n' + query) console.log('不含查询字符串的路径为\\n' + pathNoQuery) response.write('hi') response.end()})server.listen(port)console.log('监听 ' + port + ' 成功\\n请打开 http://localhost:' + port) 运行server.js服务器 bash1node server.js 8888 这里一个括号空格都不能错，如果报错则百度一下错误代码。这样server.js就成功运行起来了，server.js开始监听8888端口，开始接受来自client的服务请求。 测试 保持这个gitbash窗口运行，新建一个gitbash窗口 curl 一下 http://localhost:8888/docName 来测试一下server.js是否能响应请求 服务器正确监听到curl对于8888端口的请求并打印出请求的路径，并给出response：hi，而后end了这个response，此时client收到应答结束了会话回到了可以输入命令行的界面，而server继续处于等待请求的状态，我们使用ctrl+c来中断server.js的进程。 使用 curl -s -v — “http://localhost:8888/docName” 可以查看完整的请求和响应 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243var http = require('http')var fs = require('fs')var url = require('url')var port = process.argv[2]if (!port) { console.log(\"请指定端口号，比如\\nnode server.js 8888\") process.exit(1)}var server = http.createServer(function(request, response) { var parsedUrl = url.parse(request.url, true) var path = request.url var query = '' if (path.indexOf('?') &gt;= 0) { query = path.substring(path.indexOf('?')) } var pathNoQuery = parsedUrl.pathname var queryObject = parsedUrl.query var method = request.method console.log('HTTP 路径为\\n' + path) if (path == '/style.js') { response.setHeader('Content-Type', 'text/css; charset=utf-8') response.write('body{background-color: #ddd;}h1{color: red;}') response.end() } else if (path == '/script.html') { response.setHeader('Content-Type', 'text/javascript; charset=utf-8') response.write('alert(\"这是JS执行的\")') response.end() } else if (path == '/index.css') { response.setHeader('Content-Type', 'text/html; charset=utf-8') response.write('&lt;!DOCTYPE&gt;\\n&lt;html&gt;' + '&lt;head&gt;&lt;link rel=\"stylesheet\" href=\"/style.js\"&gt;' + '&lt;/head&gt;&lt;body&gt;' + '&lt;h1&gt;你好&lt;/h1&gt;' + '&lt;script src=\"/script.html\"&gt;&lt;/script&gt;' + '&lt;/body&gt;&lt;/html&gt;') response.end() } else { response.statusCode = 404 response.end() }})server.listen(port)console.log('监听 ' + port + ' 成功\\n请打开 http://localhost:' + port)","link":"/2019/05/24/nodejs-server/"},{"title":"寻找peak元素","text":"面试问到的算法题。 Problem给定一个数组（元素为数字），数组内的值相邻的两个元素值不同，如果一个元素的左右两边的元素值都小于该元素，则该元素为peak元素（对于两个端点元素一边符合即可）。 要求返回一个peak元素即可。 算法的时间复杂度越小越好。 Solution采用暴力解法的时间复杂度为O(n)。 如果采用二分查找可以将时间复杂度降到O(logn)。 可以用二分查找，寻找中间点，如果中间点大于右边的点，那么左半边（包含中间点在内）一定有一个点符合peak，反之一样。这样不断地每次缩小1/2的范围最终就可以使用O(logn)的时间复杂度找到peak点。 Codets123456789101112131415161718192021222324const findPeak = (mountains: number[]): number =&gt; { let left: number = 0 let right: number = mountains.length - 1 while (left &lt; right) { // 找到中间点 let mid: number = Math.floor((left + right) / 2) if (mountains[mid] &gt; mountains[mid + 1]) { // 左半边一定有peak right = mid } else { // 右半边一定有peak left = mid + 1 } } return mountains[left]}console.log(findPeak([1,2,3,4,8,5]))console.log(findPeak([3,2,6,4,8,5]))console.log(findPeak([1,2,3,4,5]))console.log(findPeak([5,4,3,2,1])) Review 本题难点在于想不到可以使用二分查找来缩小查询范围，因为本题的要求是只要找到任意一个peak即可。 要想到在使用二分查找时如果中间点大于右边的点，那么左半边（包含中间点）在内的区间一定存在peak，反之亦然，这样就缩小了一半的范围。","link":"/2024/05/29/peak/"},{"title":"node.js开发笔记——npm常用命令","text":"整理一些常用的npm(node package manager)命令。 npm -v查看版本 npm initnpm init 用来创建package.json文件，这个文件用于记录项目的一些信息以及依赖包。再 npm install 则会根据package.json文件来安装依赖到node_modules目录。 npm search搜索模块： npm search module_name npm install局部安装：会安装在在当前目录下的node_modules目录。 npm install module_name 安装指定版本： npm install module_name@version_num 全局安装： npm install -g module_name 局部安装并将其添加到package.json中的dependencies:npm install module_name --save 缩写 npm install module_name -S 局部安装并将其添加到package.json中的devDependencies(该包会只被用于开发环境):npm install module_name --save-dev 缩写 npm install module_name -D 如果安装不成功，则先删除node_modules再清缓存再重试： 12npm cache cleannpm install 安装完包后在代码里require就可以使用： var new_module_name = require('module_name'); 升级npm： npm install -g npm npm uninstall npm uninstall module_name npm remove module_name npm update npm update module_name npm update module_name -g npm cache clear清空本地npm缓存 npm publish先创建package.json 在npm注册： 1234npm adduserUsername: MasonPassword: ******Email: (this IS public) herotiga@vip.qq.com 发布模块： 1npm publish 之后就可以使用 npm install 安装了。 npm unpublish撤销已经发布的模块的某个版本： npm unpublish module_name@version 查看相关查看一个包的详细信息： npm info module_name 查看一个包的所有版本： npm view module_name versions 查看一个包最新版本： npm view module_name version 查看安装了的包： npm list 缩写 npm ls 查看全局安装的包： npm list -g 查看全局包的安装位置： npm root -g 修复包： npm audit fix 查看当前包的版本： npm is module_name npm help查看帮助： npm help 查看特定命令帮助： npm help install cnpm参见：https://npmmirror.com/","link":"/2021/10/08/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"python3学习笔记(学完了 没记全)","text":"初学python，不想一上来就直接写helloworld，了解一门语言的发展和语言的特性也是非常重要的，所以笔记会比较详细。 python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。python具有很强的可读性。python3相对python2是较大的一个升级并且没有考虑向下兼容。 简介 python是解释型语言 python是交互式语言 python是面向对象的语言 python是初学者的语言 发展历史 Python 2.0 于 2000 年 10 月 16 日发布，增加了实现完整的垃圾回收，并且支持 Unicode。Python 3.0 于 2008 年 12 月 3 日发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性后来也被移植到旧的Python 2.6/2.7版本。Python 3.0 版本，常被称为 Python 3000，或简称 Py3k。相对于 Python 的早期版本，这是一个较大的升级。Python 2.7 被确定为最后一个 Python 2.x 版本，它除了支持 Python 2.x 语法外，还支持部分 Python 3.1 语法。 特点 易于学习 易于阅读 易于维护 广泛的标准库 交互模式 可移植 可扩展 数据库 GUI编程 可嵌入 缺点 运行速度较慢 国内使用较少 中文文档少 应用领域 云计算 web 科学计算、人工智能 运维 金融 GUI 爬虫 等等还有很多 查看版本查看python版本： 1python3 -V 可以输入 python3 命令进入交互式编程界面。 HelloWorld12#!/usr/bin/python3print(\"Hello World!\") python解释器建议写法： 1#!/usr/bin/env python3 将上面的代码保存为HelloWorld.py，然后使用python3命令运行。 环境搭建安装python python官网：https://www.python.org/ 在官网下载源码编译安装或者直接下载安装包即可，macos和linux可以使用包管理器安装。 运行python 交互解释运行（python命令，ipython） python命令运行文件 IDE、编辑器中运行（pycharm，vscode） 基本语法标识符 必须以字母或者下划线_开头。 标识符的其他的部分由字母、数字和下划线组成。 大小写敏感。 在python3中，可以用ASCII字符作为标识符包括汉字。 python标识符保留字： 使用下面的方法查询保留的关键字： 12import keywordkeyword.kwlist 注释123456789# 单行注释'''多行注释'''\"\"\"多行注释\"\"\" 行与缩进python使用缩进来表示代码块。 1234if True: print (\"True\")else: print (\"False\") 多行语句123total = item_one + \\ item_two + \\ item_three [], {}, ()中使用多行语句不需要斜杠。 Number类型 int: 1 bool: True, False float: 1.23 complex: 1 + 2j、 1.1 + 2.2j String类型123456name = 'Mason'name = \"Mason\"full_name = '''my name isMason'''full_name = \"\"\"my name isMason\"\"\" 单行字符串使用单引号或者双引号包裹。 多行字符串使用三引号'''或者&quot;&quot;&quot;包裹。 转义字符\\，使用r可以阻止转义。 字符串使用+拼接，可以使用*重复字符串。 字符串两种索引方式：从左往右（0开始），从右往左（最右边的索引是-1）。 字符串中的字符不能改变。 python中只有字符串没有字符。 阻止转义： 12print('hello\\nworld')print(r'hello\\nworld') 截取字符：变量[头下标: 尾下标: 步长] 123456name = 'Mason'print(name[0])print(name[0:3])print(name[0:])print(name[0:-1])print(name[0:-1:2]) 空行函数之间、类方法之间、类和函数入口之间都要用空行隔开，便于区分。 用户输入1input('\\n\\n请输入并以回车结束') 多条语句使用分号分隔多条语句。 代码组比如： 123456if exp1: suiteelif exp2: suiteelse: suite print输出print输出默认换行。 1234567name = 'Mason'# 默认换行print(name)# 加参数不换行print(name, end=' ') import和from…import使用import和from…import来导入模块。 导入模块： import module 导入模块中的一个函数： from module import function 导入模块中的多个函数： from module import function1, function2, function3 导入模块中的全部函数： from module import * 基本数据类型python中的数据类型不需要声明，直接赋值。python中的变量是弱类型的。 123name = 'Mason'age = 22balance = 10000.5 赋值多个变量1a = b = c = 1 还有类似es解构赋值的赋值方式： 1a, b, c = 'mason', 1, 3.14 标准数据类型 Number：数字 String：字符串 List：列表 Tuple：元祖 Set：集合 Dictionary：字典 注意布尔型属于Number类型。 其中，分为可变数据类型和不可变数据类型 可变类型：Number, String, Tuple不可变类型：List, Set, Dictionary Number分为：int（长整型）, float, bool, complex 使用 type() 可以查询变量指向的数据类型。 123type(1)# &lt;class 'int'&gt;# 其他类型&lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt; 还可以用 isinstance() 判断类型。 12isinstance(1, int)# True 两者的区别： type() 不会认为子类是一种父类类型，而 isinstance() 会认为是。 bool是int的子类。 1234567891011121314151617181920issubclass(bool, int) # TrueTrue == 1# TrueFalse == 0# FalseTrue + 1# 2False + 1# 11 is True# False0 is False# False 删除变量引用： 12del mynamedel myname, age 数学计算： 使用： + （加法）, - （减法）, * （乘法）, / （除法，得到浮点数）, // （除法，得到整数）, % （求余数）, ** （乘方） complex类型：是复数，由实部和虚部组成 a+bj ，或者 complex(a, b) ，a和b都是浮点型。 String省略的部分笔记参考上一章节。 反斜杠还可以作为续行符： 1234str = 'my name is\\Mason'# my name is Mason 也可以使用三引号跨行。 ListList（列表）就是数组，形如 ['abc', 123, False] 。 空列表： [] List中的每一个元素可以是任何类型。 截取List中的元素的方法和上面的String截取方式一样。 List中的+和*： 12345678910list1 = ['abc', 123]lsit2 = [345, 'efg']# 使用乘号可以重复print(list1*2)# ['abc', 123, 'abc', 123]# List可以通过加号拼接print(list1 + list2)# ['abc', 123, 345, 'efg'] List中的元素可以改变。 12345678910list = [1, 2, 3, 4, 5, 6]list[0] = 0# [0, 2, 3, 4, 5, 6]list[1:4] = [7, 7, 7]# [0, 7, 7, 7, 5, 6]list[1:-1] = []# [0, 6] List也可以像String一样设置步长来跳着选取元素。 1234list = [1, 2, 3, 4, 5, 6]print(list[0:5:2])# [1, 3, 5] 翻转句子词语顺序实例： 123456789101112131415# 翻转句子词序def reverseWords(sentence): # 先将句子通过空格分割为List sentenceList = sentence.split(' ') # 翻转句子sentenceList reversedSentenceList = sentenceList[-1::-1] # 再将reversedSentenceList转为String并返回 return ' '.join(reversedSentenceList)# testif __name__ == '__main__': # WTF s = 'my name is Mason' print(reverseWords(s)) # Mason is name my TupleTuple与List类似，不过元组中的元素不能修改，而且放在小括号()中，使用逗号隔开。Tuple的其他用法和List一致。 字符串可以看成是一种特殊的元组。 实例： 1tuple = (123, 'abc') 空元组： () 一个元素的元组这样写： (10,) 一个元素的列表可以这样写： [10] String, List, Tuple都属于序列。 Set集合（Set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。 Set可以用于成员关系测试和删除重复元素。 创建空的Set只能用 set() 创建一个Set： 123newSet = {elem1, elem2, elem3}newSet = set(elem1) Set实例： 1234567891011121314151617181920212223# Set去重newSet = {'a', 'b', 'c', 'd', 'a'}print(newSet) # {'a', 'b', 'c', 'd'}# 测试一个值是否是Set的成员if 'a' in newSet: print('true')else: print('false')# Set的集合运算a = {1,2,3,4}b = {3,4,5,6}# 交集运算print(a &amp; b)# 并集运算print(a | b)# 差集运算print(a - b)# a和b中不同时存在的元素，相当于a-b和b-a的并集print(a ^ b)print(a-b | b-a) Dictionary字典是无序对象的集合，就相当于js里面的对象。字典使用{}包裹，里面是键值对。key必须是不可变类型String, Number, Tuple，且key必须唯一。 12345678910111213141516# 新建一个字典并向里面添加键值对dict = {}dict['name'] = 'mason'dict[1] = 123# 直接赋值一个字典dict = { 'name': 'mason', 'age': 22}# 使用字典print(dict['name'])print(dict(1))print(dict.keys())print(dict.values()) 可以使用 dict() 构建字典，传入参数为序列。 数据类型转换int(x [,base]) : 将x转换为一个整数 float(x) : 将x转换到一个浮点数 complex(real [,imag]) : 创建一个复数 str(x) : 将对象 x 转换为字符串 repr(x) : 将对象 x 转换为表达式字符串 eval(str) : 用来计算在字符串中的有效Python表达式, 并返回一个对象 tuple(s) : 将序列 s 转换为一个元组 list(s) : 将序列 s 转换为一个列表 set(s) : 转换为可变集合 dict(d) : 创建一个字典。d 必须是一个 (key, value)元组序列。 frozenset(s) : 转换为不可变集合 chr(x) : 将一个整数转换为一个字符 ord(x) : 将一个字符转换为它的整数值 hex(x) : 将一个整数转换为一个十六进制字符串 oct(x) : 将一个整数转换为一个八进制字符串 数据类型转换 隐式转换（自动） 两个不同数据类型之间进行运算的时候，python会自动将低精度数据类型转换为高精度数据类型。 将数字和字符串进行加法操作会报错。 显式转换（手动） 参考上一张最后的api。 推导式 推导式是一种数据处理方式，可以将一个数据序列转为另一个数据序列。 列表推导式12345[表达式 for 变量 in 列表][out_exp_res for out_exp in input_list][表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition] 实例：过滤掉小于等于3的数并返回新的List 12nums = [1, 2, 3, 4, 5, 6]nums_filtered = [num for num in nums if num &gt; 3] 字典推导式123{ key_expr: value_expr for value in collection }{ key_expr: value_expr for value in collection if condition } 实例：将一个List通过字典推导式转为Dictionary 1234list = ['abc','abcd', 'abcde']dict = {key:len(key) for key in list}# {'abc': 3, 'abcd': 4, 'abcde': 5} 集合推导式123{ expression for item in Sequence }{ expression for item in Sequence if conditional } 实例：计算集合中元素的平方 12set = {item**2 for item in (1,2,3)}# {1,4,9} 元组推导式123(expression for item in Sequence )(expression for item in Sequence if conditional ) 元组推导式返回的是生成器对象。 12345# tuple_object是生成器对象tuple_object = (item for item in rrange(1,10))# 将生成器对象转为元组tuple(tuple_object) 解释器12345678# 运行python脚本python3 main.py# 赋予脚本执行权限chmod +x main.py# 执行脚本./main.py 注释123456789# 单行注释'''多行注释'''\"\"\"多行注释\"\"\" 运算符python中有以下运算符。 算术运算符：+ - * / % ** // 比较运算符：== != &gt; &gt;= &lt; &lt;= 赋值运算符：= += -= = /= %= *= //= :=(海象运算符) 逻辑运算符：and or not 位运算符：&amp; | ^ ~ &lt;&lt; &gt;&gt; 成员运算符：in, not in, 支持List，String，Tuple 身份运算符 is：判断两个变量是否是同一个对象的引用，a is b，相当于id(a)==id(b)。 is not：参上 id()：用于获取变量的内存地址。 123456789a = 10b = 10a is b# Trueb = 20a is b # False is用于判断两个变量引用对象是否为同一个，==用于判断引用变量的值是否相等。 运算符优先级：参考https://www.runoob.com/python3/python3-basic-operators.html 注意and比or优先级高。 数字要引入math包：import math 下面的api都要用math.round()的形式写。 123456num = 3.14a = 1b = 2# 删除变量对于对象的引用del a,b Number的类型： int：整形或者说可以作为long使用，bool型是int的子类型。 float complex：复数，a+bj或者complex(a, b)，其中a和b都是float。 数字类型转换 int() float() complex() 数字运算参考之前的章节。 交互模式中，最后被输出的表达式结果会被赋值给_。 数学函数 sqrt()：开方 abs() ceil() floor() round(x, n)：四舍五入精确到n位 cmp(x, y) exp(x) pow(x, y) fabs() log() log10() max(x1, x2, …xn) min(x1, x2, …xn) modf(x)：返回x的整数部分和小数部分。 随机数函数 choice()：从参数序列中随机挑选一个，random.choice(range(10)) randrange(start, stop, step)：从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random()：生成一个随机数，范围[0, 1) seed() shuffle(list)：将list打乱随机排列。 uniform(x, y)：随机生成一个[x, y]之间的实数。 三角函数就是各种正弦余弦，反正弦反余弦。 常量 pi：圆周率π e：自然常数e 字符串和之前字符串重复的地方不作笔记。 转义字符 \\在行尾：作为续行符 \\\\：反斜杠 \\'：单引号 \\a：响铃 \\b：退格 \\000：空 \\n：换行 \\t：横向制表符 \\v：纵向制表符 \\r：替换符，将r之后的字符串逐一替换r之前的字符串。 \\f：换页 字符串运算符 +：拼接字符串。 *：重复字符串。 []：获取字符串下标对应的字符。 [start:end]：截取字符串。 in：成员运算符，判断字符是否在字符串中。 not in r/R：表示raw原始字符串，用于避免转义。 %：字符串格式化 字符串格式化实例： 12print (\"我叫%s今年%d岁!\" % ('mason', 11))# 我叫mason今年11岁 %c：格式化字符及其ASCII码 %s：格式化字符串 %d：格式化整数 %u：格式化无符号整型 %o：格式化无符号八进制数 %x：格式化无符号十六进制数 %X：格式化无符号十六进制数（大写） %f：格式化浮点数字，可指定小数点后的精度 %e：用科学计数法格式化浮点数 %E：作用同%e，用科学计数法格式化浮点数 %g：%f和%e的简写 %G：%f和%E的简写 %p：用十六进制数格式化变量的地址 三引号三引号可以让字符串跨多行。 f-stringf-string是新的格式化字符串的方法。 用法： 12name = 'mason'print(f'my name is {name}, and {10+10} years old') 3.8以上版本可以用=来拼接运算式和运算结果： 12print(f'{1+2=}')# 1+2=3 unicode字符串用到的时候查表。 字符串函数随用随查：https://www.runoob.com/python3/python3-string.html 参考文档 https://www.runoob.com/python3/python3-tutorial.html","link":"/2022/04/20/python3-note/"},{"title":"React井字棋实例","text":"React官网的入门实例井字棋。 感觉React比Vue容易学一些，比Vue更加直观简单且更接近原生JavaScript。 JSX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144function Square(props) { return ( &lt;button className=\"square\" onClick={props.onClick}&gt; {props.value} &lt;/button&gt; );}class Board extends React.Component { renderSquare(i) { return ( &lt;Square value={this.props.squares[i]} onClick={() =&gt; this.props.onClick(i)} /&gt; ); } render() { return ( &lt;div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(0)} {this.renderSquare(1)} {this.renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(3)} {this.renderSquare(4)} {this.renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(6)} {this.renderSquare(7)} {this.renderSquare(8)} &lt;/div&gt; &lt;/div&gt; ); }}class Game extends React.Component { constructor(props) { super(props); this.state = { history: [ { squares: Array(9).fill(null) } ], stepNumber: 0, xIsNext: true }; } handleClick(i) { const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length - 1]; const squares = current.squares.slice(); if (calculateWinner(squares) || squares[i]) { return; } squares[i] = this.state.xIsNext ? \"X\" : \"O\"; this.setState({ history: history.concat([ { squares: squares } ]), stepNumber: history.length, xIsNext: !this.state.xIsNext }); } jumpTo(step) { this.setState({ stepNumber: step, xIsNext: (step % 2) === 0 }); } render() { const history = this.state.history; const current = history[this.state.stepNumber]; const winner = calculateWinner(current.squares); const moves = history.map((step, move) =&gt; { const desc = move ? 'Go to move #' + move : 'Go to game start'; return ( &lt;li key={move}&gt; &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt; &lt;/li&gt; ); }); let status; if (winner) { status = \"Winner: \" + winner; } else { status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\"); } return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board squares={current.squares} onClick={i =&gt; this.handleClick(i)} /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;{status}&lt;/div&gt; &lt;ol&gt;{moves}&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); }}const root = ReactDOM.createRoot(document.getElementById(\"root\"));root.render(&lt;Game /&gt;);function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i &lt; lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) { return squares[a]; } } return null;}","link":"/2022/06/17/react%E4%BA%95%E5%AD%97%E6%A3%8B%E5%AE%9E%E4%BE%8B/"},{"title":"快速排序","text":"快速排序 算法思想 快排的原理是：在数组中选取一个基准，将小于基准的元素放到基准的左边，将大于基准的元素放到基准的右边，递归重复这个过程。 代码a[s] 作为基准元素： C12345678910111213141516171819202122void quicksort(int* a, int s, int t) { if (s &gt;= t) {return;} // 选择a[s]作为基准 int pivot = a[s]; // 指针i, j int i = s, j = t; while (i &lt; j) { while (i &lt; j &amp;&amp; a[j] &gt;= pivot) {j--;} if (i == j) {break;} a[i] = a[j]; i++; while (i &lt; j &amp;&amp; a[i] &lt;= pivot&gt;) {i++;} if (i == j) {break;} a[j] = a[i]; j--; } a[i] = pivot; quicksort(a, s, i-1); quicksort(a, i+1, t);} 随机生成基准元素： C12345678910111213141516171819202122void quicksort(int* a, int s, int t) { if (s &gt;= t) {return;} // 选择a[s]作为基准 int r = s + rand() % (t - s + 1); int povit = a[r]; a[r] = a[s]; // 指针i, j int i = s, j = t; while (i &lt; j) { while (i &lt; j &amp;&amp; a[j] &gt;= pivot) {j--;} if (i == j) {break;} a[i] = a[j]; i++; while (i &lt; j &amp;&amp; a[i] &lt;= pivot&gt;) {i++;} if (i == j) {break;} a[j] = a[i]; j--; } a[i] = pivot; quicksort(a, s, i-1); quicksort(a, i+1, t);} 扩展quickminK求一个数组中前k小的元素并排序。 如果k很小，使用选择排序或者插入排序。 如果k比较大，可以使用快速排序。 C123456789101112131415161718192021222324void quickmink(int* a, int s, int t, int k) { if (s &gt;= t || s &gt;= k) {return;} // 选择a[s]作为基准 int r = s + rand() % (t - s + 1); int povit = a[r]; a[r] = a[s]; // 指针i, j int i = s, j = t; while (i &lt; j) { while (i &lt; j &amp;&amp; a[j] &gt;= pivot) {j--;} if (i == j) {break;} a[i] = a[j]; i++; while (i &lt; j &amp;&amp; a[i] &lt;= pivot&gt;) {i++;} if (i == j) {break;} a[j] = a[i]; j--; } a[i] = pivot; quickmink(a, s, i-1, k); quickmink(a, i+1, t, k);} quickselect求第k小的元素。 C12345678910111213141516171819202122void quickselect(int* a, int s, int t, int k) { if (s &gt; k - 1 || t &lt; k - 1) {return;} // 选择a[s]作为基准 int r = s + rand() % (t - s + 1); int povit = a[r]; a[r] = a[s]; // 指针i, j int i = s, j = t; while (i &lt; j) { while (i &lt; j &amp;&amp; a[j] &gt;= pivot) {j--;} if (i == j) {break;} a[i] = a[j]; i++; while (i &lt; j &amp;&amp; a[i] &lt;= pivot&gt;) {i++;} if (i == j) {break;} a[j] = a[i]; j--; } a[i] = pivot; quickselect(a, s, i-1, k); quickselect(a, i+1, t, k);}","link":"/2021/07/26/quicksort/"},{"title":"机器学习学习顺序","text":"推荐一个机器学习大佬：https://morvanzhou.github.io/","link":"/2019/01/09/ml-learning-order/"},{"title":"node.js开发笔记——cluster","text":"node启动的服务是一个进程的，且进程内只有一个线程，这样就只能使用一个核心的算力。 可以使用cluter创建多进程来利用多核心cpu。 创建多个进程主进程用于创建多个工作进程，服务代码写在工作进程中。 js 1234567891011121314151617181920212223242526const cluster = require('node:cluster')const os = require('node:os')const http = require('node:http')const cpus = os.cpus().lengthif (cluster.isMaster) { console.log(`工作进程${worker.process.pid}已运行`) // 当前在主进程，通过fork创建多个进程（工作进程） for (let i = 0; i &lt; cpus; i++) { cluster.fork() } cluster.on('exit', (work, code, signal) =&gt; { console.log(`工作进程${worker.process.pid}已停止`) })} else { // 当前在工作进程，启动服务 http.createServer((req, res) =&gt; { res.writeHead(200) res.end('hello\\n') }) .listen(3333) console.log(`工作进程${worker.process.pid}已运行`)}","link":"/2021/10/09/node-cluster/"},{"title":"Redis安装配置和入门","text":"学习一下Redis 安装Redis前置条件：homebrew 1brew install redis 初步配置homebrew安装的软件会在/usr/local/etc下面 Redis配置文件为/usr/local/etc/redis.conf 修改Redis运行方式为守护进程方式： 1vim /usr/local/etc/redis.conf 修改daemonize为yes。 注释掉bind 127.0.0.1，作用是允许远程访问。 protected-mode yes改为protected-mode no 修改requirepass为自定义密码。 保存。 启动服务端 方法一 1brew services start redis 方法二 1redis-server /usr/local/etc/redis.conf 查看Redis进程1ps aux | grep redis 启动Redis客户端默认端口6379 1redis-cli 关闭Redis 正常关闭 1redis-cli shutdown 强制关闭（可能会丢失数据） 1sudo pkill redis-server brew关闭Redis服务 1brew services stop redis brew重启Redis服务 1brew services restart redis","link":"/2020/01/02/redis-installation/"},{"title":"使用require.js","text":"require.js 是一个js模块加载器。 官网：require.js require.js是为了解决两个问题： 传统多个js文件会导致网页响应时间变长，require.js实现了js文件的异步加载以避免网页失去响应。 管理模块之间的依赖性，便于代码的维护。 使用require.js 官网下载require.js，放到js目录下。 在代码中引入require.js，可以把它放到网页底部，或者可以放在head中（如下）。 1&lt;script src=\"js/require.js\" defer async=\"true\"&gt;&lt;/script&gt; 引入自己的js文件，如果我们自己的js文件名叫main.js，则这样引入。 1&lt;script src=\"js/require.js\" data-main=\"js/main\"&gt;&lt;/script&gt; 书写主模块上面的main.js是主模块，也就是js的入口文件。 可以在主模块中依赖其他模块，使用 require() （AMD规范定义的）就可以引入其他模块。 123require(['moduleA', 'moduleB', 'moduleC'], function(moduleA, moduleB, moduleC) { // some code here}); 上面的三个模块会被异步加载，加载完毕才会运行。 那么js代码写在哪里呢？ 其实只要写在require()中的回调函数中就可以。 加载模块在上面的require()语句中使用了三个模块，require.js默认三个模块都和main.js在同一目录下，如果要加载其他目录的模块则需要配置 require.config() 方法。 require.config() 写在main.js中，参数是一个对象。 12345678require.config({ paths: { 'moduleA': 'lib/moduleA.min', 'moduleB': 'lib/moduleB.min', 'moduleC': 'lib/moduleC.min', 'remoteD': 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min' }}); 也可以设置base目录： 12345678910require.config({ baseUrl: 'js/lib'; paths: { 'moduleA': 'lib/moduleA.min', 'moduleB': 'lib/moduleB.min', 'moduleC': 'lib/moduleC.min', 'remoteD': 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min' }}); require.js每个模块都是一个单独的js文件。可以使用requirejs optimizer工具将多个模块合并到一个模块中以减少http请求。 AMD模块写法require.js加载的模块采用AMD书写规范。 定义一个名为module.js的module模块，下面是一个单独的文件。 123456789define(function() { var add = function(x, y) { return x + y; }; return { add: add };}); 使用模块： 123require(['module'], function(module) { module.add(1, 2);}); 如果要定义的模块依赖其他的模块，则这样写： 123456789define(['module1', 'module2'], function() { var add = function(x, y) { return x + y; }; return { add: add };}); 加载非规范的模块比如要加载 underscore 和 backbone 这两个模块： 1234567891011require.config({ shim: { 'underscore': { exports: '_' }, 'backbone': { deps: ['underscore', 'jquery'], exports: 'Backbone' } }}); exports字段配置输出的变量名。deps字段表示依赖的模块。 实例：定义jquery插件 12345678require.config({ shim: { 'jquery.scroll': { deps: ['jquery'], exports: 'jQuery.fn.scroll' } }}); 插件 domready：让回调函数在DOM加载完毕后运行。 text、image：允许require.js加载文本和图片。 json：用于加载json。 markdown：加载markdown文件。 tips 类似require.js的还有SeaJS","link":"/2020/12/19/require-js/"},{"title":"require和import的区别","text":"require 和 import 都是引入模块。 区别 require是赋值过程，过程就是将对象数字字符串赋值给变量，import是结构过程，浏览器不支持import，node中会被编译为require。 require是AMD规范，import是ES6规范。 require在运行时调用，所以require可以用在任何地方，import在编译时调用，所以import要写在文件顶部。 ref https://www.zhihu.com/question/56820346","link":"/2021/11/25/require%E5%92%8Cimport/"},{"title":"将闲置主机作为云计算平台","text":"如果你有一个闲置的主机比如PC，可以为其安装linux或者就使用windows，为其安装OpenSSH将其变为linux server，从而我们就可以用性能较弱的mac搭配一些linux命令就可以在PC上进行高性能或者长时间的运算。 linux安装openssh 12345# ubuntusudo apt-get install openssh-server# centossudo yum install openssh-server windows安装openssh 先下载openssh-win61.zip并解压至C:\\Program Files\\OpenSSH 打开powershell并进入C:\\Program Files\\OpenSSH 安装 1powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 启动openssh并设置openssh自启动 12sc config sshd start= autonet start sshd 配置参考：https://www.jianshu.com/p/6e5bc39d386e 在云端运行本地脚本比如我要在server上运行本地的一个python脚本test.py： 1ssh root@192.168.0.101 python3 &lt; ~/Desktop/test.py tips: python3是服务器端python3的命令，&lt;是重定向，~/Desktop/test.py是本地的python文件。 在云端和本地之间传输文件12345678# 将本地的~/Desktop/test.py文件复制到云端root@192.168.0.101下的~/Desktop目录scp ~/Desktop/test.py root@192.168.0.101:~/Desktop# 将本地的~/Desktop/test.py以及~/Desktop/test2.py文件复制到云端root@192.168.0.101下的~/Desktop目录scp ~/Desktop/{test,test2}.py root@192.168.0.101:~/Desktop# 反之亦可，将云端文件传输到本地scp root@192.168.0.101:~/Desktop/b.py ~/Desktop 在云端执行命令双引号中的代表在云端环境执行的命令 1ssh root@192.168.0.101 \"python3 ~/Desktop/test.py\"","link":"/2020/06/09/run-on-linux-server/"},{"title":"响应式设计","text":"总结一下css的响应式设计。 可视区域viewport是页面的可视区域。 针对移动端优化： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; user-scalable ：用户是否可以手动缩放。 网格视图响应式网格视图一半是12cols，宽度100%，自动伸缩。 创建响应式网格： 12345678910111213141516171819202122232425&lt;style&gt;* { box-sizing: border-box;}.header { border: 1px solid red; padding: 15px;}.menu { width: 25%; float: left; padding: 15px; border: 1px solid red;}.main { width: 75%; float: left; padding: 15px; border: 1px solid red;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"header\"&gt;&lt;h1&gt;Chania&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"menu\"&gt;&lt;ul&gt;&lt;li&gt;The Flight&lt;/li&gt;&lt;li&gt;The City&lt;/li&gt;&lt;li&gt;The Island&lt;/li&gt;&lt;li&gt;The Food&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=\"main\"&gt;&lt;h1&gt;The City&lt;/h1&gt;&lt;p&gt;Chania is the capital of the Chania region on the island of Crete. The city can be divided in two parts,the old town and the modern city.&lt;/p&gt;&lt;p&gt;Resize the browser window to see how the content respond to the resizing.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 一列对应8.33%的宽度。 创建不同宽度对应的class： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.col-1 { width: 8.33%;}.col-2 { width: 16.66%;}.col-3 { width: 25%;}.col-4 { width: 33.33%;}.col-5 { width: 41.66%;}.col-6 { width: 50%;}.col-7 { width: 58.33%;}.col-8 { width: 66.66%;}.col-9 { width: 75%;}.col-10 { width: 83.33%;}.col-11 { width: 91.66%;}.col-12 { width: 100%;} 所有的列左浮动： 12345[class*=\"col-\"] { float: left; padding: 15px; border: 1px solid red;} 每一行使用div包裹： 1234&lt;div class=\"row\"&gt; &lt;div class=\"col-3\"&gt;...&lt;/div&gt; &lt;div class=\"col-9\"&gt;...&lt;/div&gt;&lt;/div&gt; 清除浮动： 12345.row:after { content: \"\"; clear: both; display: block;} 媒体查询例子： 12345@media only screen and (max-width: 500px) { body { background-color: lightblue; }} 添加断点：为不同的设备添加断点以判断设备。 桌面端优先 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 桌面端样式 */.col-1 { width: 8.33%;}.col-2 { width: 16.66%;}.col-3 { width: 25%;}.col-4 { width: 33.33%;}.col-5 { width: 41.66%;}.col-6 { width: 50%;}.col-7 { width: 58.33%;}.col-8 { width: 66.66%;}.col-9 { width: 75%;}.col-10 { width: 83.33%;}.col-11 { width: 91.66%;}.col-12 { width: 100%;}@media only screen and (max-width: 768px) { /* 移动端样式 */ [class*=\"col-\"] { width: 100%; }} 移动端优先 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 移动端样式 */[class*=\"col-\"] { width: 100%;}@media only screen and (min-width: 768px) { /* 桌面端样式 */ .col-1 { width: 8.33%; } .col-2 { width: 16.66%; } .col-3 { width: 25%; } .col-4 { width: 33.33%; } .col-5 { width: 41.66%; } .col-6 { width: 50%; } .col-7 { width: 58.33%; } .col-8 { width: 66.66%; } .col-9 { width: 75%; } .col-10 { width: 83.33%; } .col-11 { width: 91.66%; } .col-12 { width: 100%; }} 移动端、pad、桌面端兼容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/* 手机端样式 */[class*=\"col-\"] { width: 100%;}@media only screen and (min-width: 600px) { /* pad样式 */ .col-m-1 { width: 8.33%; } .col-m-2 { width: 16.66%; } .col-m-3 { width: 25%; } .col-m-4 { width: 33.33%; } .col-m-5 { width: 41.66%; } .col-m-6 { width: 50%; } .col-m-7 { width: 58.33%; } .col-m-8 { width: 66.66%; } .col-m-9 { width: 75%; } .col-m-10 { width: 83.33%; } .col-m-11 { width: 91.66%; } .col-m-12 { width: 100%; }}@media only screen and (min-width: 768px) { /* 桌面端样式 */ .col-1 { width: 8.33%; } .col-2 { width: 16.66%; } .col-3 { width: 25%; } .col-4 { width: 33.33%; } .col-5 { width: 41.66%; } .col-6 { width: 50%; } .col-7 { width: 58.33%; } .col-8 { width: 66.66%; } .col-9 { width: 75%; } .col-10 { width: 83.33%; } .col-11 { width: 91.66%; } .col-12 { width: 100%; }} 查询横竖屏：横屏landscape、竖屏portrait。 12345@media only screen and (orientation: landscape) { body { background-color: lightblue; }} 响应式图片&lt;img&gt; 图片： width属性设置为100%，配合max-width避免图片放大。 或者直接使用max-width设置为100%，效果同上。 背景图片： 背景图片可以相应式的调整大小和缩放，有下面三种方法。 background-size 属性设置为 “contain”，按比例自适应缩放。 background-size 属性设置为 “100% 100%”，拉伸充满整个元素。 background-size 属性设置为 “cover”，按比例拉伸直到充满整个元素。 使用媒体查询让不同的设备显示不同的图片： 123456789body { background-image: url('img_smallflower.jpg');}@media only screen and (min-width: 400px) { body { background-image: url('img_flowers.jpg'); }} 可以使用min-device-width替代min-width。 还可以使用html5的 &lt;picture&gt; 元素为不同的设备提供不同的图片，该元素类似于video和audio。 12345&lt;picture&gt; &lt;source srcset=\"img_smallflower.jpg\" media=\"(max-width: 400px)\"&gt; &lt;source srcset=\"img_flowers.jpg\"&gt; &lt;img src=\"img_flowers.jpg\" alt=\"Flowers\"&gt;&lt;/picture&gt; 响应式视频 使用max-width 1234video { max-width: 100%; height: auto;} 自动填充容器 1234video { width: 100%; height: auto;} 框架使用bootstrap快速创建响应式布局。 例子： 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"http://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css\"&gt; &lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"http://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;我的第一个 Bootstrap 页面&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-4\"&gt; ... &lt;/div&gt; &lt;div class=\"col-sm-4\"&gt; ... &lt;/div&gt; &lt;div class=\"col-sm-4\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/06/01/responsive-design/"},{"title":"服务器的容错、灾备和高可用","text":"容错、备灾和高可用比较容易混淆。 容错基于容错技术，硬件上采用冗余设计，保证在故障时切换到临时服务器。 灾备指的是发生灾难的时候能让服务回复正常的能力。 此时业务一般已经遭受到了灾难性毁灭，灾备进行的是抢救性工作，也就是如何抢救数据减少损失。 高可用也就是高耐久度，比如服务器无法保证一年100%在线，而尽量缩短离线率就称之为高可用。","link":"/2019/06/26/server-problems/"},{"title":"shell脚本入门","text":"学习 shell脚本 的目的是更好的管理github博客以及服务器。 为了给博客写一些自动化运维的脚本，比如定期创建hexo生成器的备份，定期生成和部署等等，shell脚本配合crontab，这样使用hexo博客的时候就只需要一篇一篇的书写博客就行了，生成部署备份的工作都可以交由crontab定期运行shell脚本来完成，定期创建新备份的同时还可以同时删除老备份，这样即使是失误破坏了hexo生成器也可以迅速找到之前的备份用于恢复。 shellshell 使用c语言编写的程序。 shell既是命令语言又是编程语言。 shell是一层给linux内核与用户之间建立桥梁的中间层。用户通过shell访问linux内核功能。 windows中的explorer就是GUI的shell。 shell脚本shell脚本 是为shell编写的脚本程序。我们通常说的shell是指shell脚本，但我们要知道shell和shell脚本是两个不同的概念。故而，我们所说的shell编程指的是shell脚本编写，而不是shell自身。 shell环境只需要一个文本编辑器和一个脚本解释器。 文本编辑器不用多说，脚本解释器就是 bash zsh 等等。 常见的有： Bourne Shell: /usr/bin/sh /bin/sh Bounrne Again Shell: bin/bash C Shell: /usr/bin/csh K Shell: /usr/bin/ksh Shell for Root: /sbin/sh 最常见的就是 bash ，也就是Bounrne Again Shell，bash也是绝大多数linux系统的默认shell解释器。 一般情况下，不区分Bourne Shell和Bounrne Again Shell，也就是 #!/bin/sh 可以改为 #!/bin/bash 。 编写shell脚本 新建file.sh文件，扩展名不影响脚本，.sh只是用来让用户知道这是个shell脚本而已。 12#!/bin/bashecho 'hello world!' 以上的 #! 后面带shell解释器路径，用于告诉shell这个脚本用什么解释器执行。 运行脚本 123456$ chmod +x file.sh# 给脚本添加执行权限，此时ls后发现.sh文件已经变色了，因为它已经获取了执行权限。$ ./file.sh$ /local/shellScript/file.sh# 输入脚本路径执行，绝对路径和相对路径均可 还有 /bin/bash file.sh , /bin/sh file.sh 这几种方法，意思是直接使用特定解释器解释脚本文件，无需在脚本文件里第一行添加 #! 声明。 shell变量定义变量变量命名规范： 变量名不能加美元符号。 变量名和等于号之间不能有空格。 命名只能用字母、数字、下划线，且不能以数字开头。 不能有空格。 不能使用bash里面的关键字。 正确变量命名： 12#!/bin/bashweb_site0=\"herotiga.github.io\" 还可以使用语句给变量赋值： 1234#!/bin/bashfor file in 'ls /etc'# orfor file in $(ls /etc) 使用变量在定义过的变量名之前加上 $ 即可： 1234#!/bin/bashwebsite=\"herotiga.github.io\"echo $websiteecho ${website} 加不加花括号都行，花括号用于识别变量边界，最好加上花括号。 可以重复定义之前定义过的变量： 12345#!/bin/bashwebsite=\"herotiga.github.io\"echo $websitewebsite=\"baidu.com\"echo $website 只读变量： 使用 readonly 命令可以将变量设置为只读： 12345#!/bin/bashwebsite=\"herotiga.github.io\"readonly websitewebsite=\"baidu.com\" 以上先定义变量后设置为只读，再重新定义变量，现在运行看看： 1/bin/bash: NAME: This variable is read only. 删除变量使用 unset 命令删除变量： 12#!/bin/bashunset website unset命令不能删除只读变量。 变量类型 局部变量：定义在脚本或命令中，仅仅在当前shell实例中生效，其他shell无法访问局部变量。 环境变量：所有程序都能访问。 shell变量：是特殊变量，其中一部分是环境变量一部分是局部变量。这些变量保证了shell正常运行。 shell字符串字符串可以用单引号双引号或者不用引号。 12#!/bin/bashstr='this is a string' 单引号 单引号中的所有字符都会原样输出，故而不能有变量。 单引号包裹中间不能出现单独的一个单引号。 双引号 双引号中可以有变量。 双引号中可以出现转义字符。 故而尽量使用双引号 拼接字符123456my_name=\"mason\"greeting=\"hello, \"$my_name\" !\" # hello, mason !greeting=\"hello, {$my_name} !\" # hello, mason !greeting='hello, '$my_name' !' # hello, mason !greeting='hello, ${my_name} !' # hello, ${my_name} ! 获取字符串长度12str=\"my name is barry allen.\"echo ${#str} # 23 提取子串下标从0开始 12str=\"my name is barry allen.\"echo ${str:0:2} # my 查找子串查找字符 i 首次出现的位置： 12str=\"my name is barry allen.\"echo `expr index \"$string\" i` shell数组bash支持一维数组，数组长度不限。 参考 菜鸟教程","link":"/2019/04/13/shellscript/"},{"title":"《锋利的jQuery》读书笔记","text":"读完了《锋利的jquery——第二版》，写点笔记。 认识jQuery变量 $ 是 jQuery 的别名。 一般获取jquery变量会使用 $ 作为变量名前缀。如： 1var $variableName = jQuery对象; 入口函数1234567891011121314&lt;!-- 全写 --&gt;&lt;script&gt; // 全写遵循了jQuery的语法。 $(document).ready(function() { // code... });&lt;/script&gt;&lt;!-- 简写 --&gt;&lt;script&gt; $(function() { // code... });&lt;/script&gt; 对比window.onload window.onload在网页所有资源加载完毕后执行，而$(document).ready()在DOM绘制完成后就会执行。 window.onload只能写一个，$(document).ready()可以写多个。 window.onload不能简写，$(document).ready()可以简写为$(function() {})。 代码风格 链式操作：有多个操作可以分成多行写。 添加注释 jQuery对象和DOM对象 DOM对象：使用原生js方法获取的元素就是DOM对象。 jquery对象：就是通过jquery包装DOM对象后产生的对象，可以使用jquery方法操作jquery对象。 对于DOM对象只能使用js方法，对于jquery对象只能使用jquery方法。 jquery对象和DOM对象的互相转化： 将jquery对象转化为DOM对象。 可以通过 [index] or get(index) 来将一个jquery对象转化为DOM对象。 12345// 获取一个jquery对象var $cr = $('#cr');// 转化为DOM对象var cr = $cr[0]; 12345// 获取一个jquery对象var $cr = $('#cr');// 转化为DOM对象var cr = $cr.get(0); DOM对象转化为jquery对象 对于一个DOM对象，只需要用 $() 将其包装起来就可以得到jquery对象。 12var cr = getElementById('cr');var $cr = $(cr); 解决jquery在其他库之后导入的冲突 将$移交给其他库使用。 12345678// 释放$jQuery.noConflict();// 使用jQuery代替$jQuery(function() { jQuery('p').click(function() { // code });}); 释放$并自定义快捷方式。 12345var jq = jQuery.noConflict();jq(function() { // code}); 继续使用$并与其他库共存。 方法一： 12345678// 释放$jQuery.noConflict();// 在jquery内部继续使用$jQuery(function($) { $('#id').show(); // code}); 方法二： 12345678// 释放$jQuery.noConflict();(function($) { $(function() { // jquery code });})(jQuery); 解决jquery在其他库之前导入的冲突直接使用 jQuery ，将 $ 交给其他库，无需 jQuery.noConflict() 。 jQuery选择器语法： $('#id') , $('.className') 等。 jQuery选择器获取到的永远是对象，无论存不存在该元素。如果需要判断jQuery对象是否存在，用length判断或者转化为DOM对象判断。 这里省略了各种选择器的语法，随用随查。 jQuery中的DOM操作DOM操作分为三个方面： DOM core HTML-DOM CSS-DOM 利用jquery工厂函数 $(html) 制造jquery节点，其中 html 为html字符串。 1var $html = $(\"&lt;div&gt;nothing&lt;/div&gt;\"); 插入DOM使用工厂函数创造了DOM节点后就要、将其插入到页面当中，使用到的方法有： append() appendTo(): 是append的反操作。 prepend(): 与append类似，是将元素插入到当前元素下的最前面。 prependTo(): 参考上面推断。 after(): 在元素后面插入。 insertAfter(): 上面的反操作。 before() insertBefore() 删除DOM remove(): remove操作返回这个DOM的引用，也就是该节点在被删除后依然可以被使用。还可以传一个选择器参数。 empty(): 清空节点的内部。 detach(): 和remove的区别是detach不会将该节点绑定的事件删除而remove会。 复制DOM clone(): 复制该节点，可传参true同时复制该节点绑定的事件。 替换DOM replaceWith() replaceAll(): 和replaceWith是反操作。 包裹DOM wrap(): 对每一个元素都进行包裹。 wrapAll()： 对所有匹配的元素进行一次包裹。 wrapInner()： 将匹配的元素的子内容进行包裹。 属性操作 attr(): get和set元素属性。 removeAttr() 样式操作 addClass() removeClass() toggleClass() hasClass() is() 操作html text和value html(): 相当于innerHTML，可以get和set节点内的html。 text(): 相当于innerText。可以get和set节点内的text。 val(): 可以get和set节点的value。 遍历节点 children() next() prev() siblings() closest(): 向上取得最近的匹配的元素。 parent() parents() CSS-DOM操作 css(): 获取和设置样式。 jQuery中的事件和动画jQuery事件 $(document).ready() $(document).load(): 相当于window.onload() $(document) 可以简写为 $() 。 事件绑定： $(&quot;#demo&quot;).bind(&quot;click&quot;, param, function() {}) 还可以直接写事件名比如： $(&quot;#demo&quot;).click(function() {}) hover()事件 toggle()事件 阻止事件冒泡： 12345678$(\"#demo\").bind(\"click\", function(event) { // do some thing. // 阻止冒泡 event.stopPropagation(); // 简写 return false;}); 事件捕获 jquery不支持 阻止事件默认行为： 12345678$(\"#demo\").bind(\"click\", function(event) { // do some thing. // 阻止默认行为 event.preventDefault(); // 简写 return false;}); 移除事件：unbind(type, fn) 一次性事件： one() 手动触发事件： trigger() 可以用事件代替： click() 出发事件而不执行默认行为： triggerHander() 事件的命名空间 jQuery动画 show() hide(): 等于display: none fadeIn() fadeOut() slideUp() slideDown() animate(): 语法animate(params, speed, callback); is(&quot;:animated&quot;): 判断元素是否处于动画状态 delay(1000): 延迟动画。 toggle(speed, [callback]): 切换元素可见性 slideToggle() fadeTo() fadeToggle() animate() 可以用来替代以上所有的动画。 jQuery操作表单表格等 addClass() removeClass() prop()和attr() is()：判断元素是否满足括号中的内容。 trigger(event) triggerHandler(event) end()：结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。 has() jQuery中的AjaxjQuery中的Ajax封装了 XMLHttpRequest 对象和 ActiveXObject 对象。 $.ajax() $.get() $.post() $.getScript()：加载js文件 $.getJSON()：可跨域 $.each()：遍历数组和对象 serialize()：序列化元素 serializeArray() $.param() jQuery插件的使用和写法插件用到什么的时候看插件的API文档即可。 暂时不需要写插件，需要写插件的时候再了解。 jQuery Mobile用不着 jQuery版本变化不作笔记 jQuery性能优化和技巧性能优化 使用合适的选择器 缓存对象 循环操作DOM尽量降低开销 使用js原生for循环代替$.each 减少绑定事件的DOM数量 将代码封装为jQuery插件 使用jQuery的data方法获取html5的data属性 尽量使用js原生方法 压缩js文件 技巧太多，用到的时候直接百度搜。 附录随用随查。","link":"/2018/07/02/sharp-jQuery/"},{"title":"split, splice和slice","text":"String.prototype.split() Array.prototype.splice() Array.prototype.slice() 一直记不得这三个哪个是哪个，加强记忆一下。以下摘录自MDN。 String.prototype.split() split() 方法使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 语法： str.split(separator, limit) 12345678910111213const str = 'The quick brown fox jumps over the lazy dog.';const words = str.split(' ');console.log(words[3]);// expected output: \"fox\"const chars = str.split('');console.log(chars[8]);// expected output: \"k\"const strCopy = str.split();console.log(strCopy);// expected output: Array [\"The quick brown fox jumps over the lazy dog.\"] split() 是把一个字符串分割成数组，通常结合 join() 使用， join() 是将一个数组中的所有元素拼接成一个字符串。join 也是可以传入一个字符串用于拼接时插入在数组元素之间。 Array.prototype.splice() splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组, 并以数组形式返回被修改的内容。此方法会改变原数组。 语法： array.splice(start, deleteCount, item1, item2, ...) 12345678910const months = ['Jan', 'March', 'April', 'June'];months.splice(1, 0, 'Feb');// inserts at index 1console.log(months);// expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"]months.splice(4, 1, 'May');// replaces 1 element at index 4console.log(months);// expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"] Array.prototype.slice() slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 语法： arr.slice(begin, end) 12345678910111213141516const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];console.log(animals.slice(2));// expected output: Array [\"camel\", \"duck\", \"elephant\"]console.log(animals.slice(2, 4));// expected output: Array [\"camel\", \"duck\"]console.log(animals.slice(1, 5));// expected output: Array [\"bison\", \"camel\", \"duck\", \"elephant\"]console.log(animals.slice(-2));// expected output: Array [\"duck\", \"elephant\"]console.log(animals.slice(2, -1));// expected output: Array [\"camel\", \"duck\"]","link":"/2021/09/06/split-splice-slice/"},{"title":"短链接原理及设计","text":"经常看到社交app以及短信中出现推销的链接很短。那么这是如何做到的呢？还有为什么要将长链接做短呢？这篇文章就探索一下什么是短链接，短链接的原理是什么，以及如何设计一个高性能的短链接。 什么是短链接例子这是一个真实的短链接： https://dwz.cn/4kuYDdGu 点击跳转后其真实的长链接为： https://app.smzdm.com/xiazai/?json=%7B%22url%22%3A%22https%3A%2F%2Ftest.smzdm.com%2Fp%2F10192%2F%3Futm_source%3D083002%26utm_medium%3D083002%26utm_campaign%3D083002%22%2C%22channel_name%22%3A%22test%22%2C%22article_id%22%3A%2210192%22%2C%22linkVal%22%3A%2210192%22%2C%22frompage%22%3A%22message%22%2C%22targetpage%22%3A%22test%22%2C%22roll_type%22%3A%222%22%2C%22download%22%3A%220%22%2C%22open_from%22%3A%22message%22%2C%22open_target%22%3A%22test%22%7D 优点发现了什么？ 原本的长链接真的太长了！有没有？ 故而，短链接的优点就是短，所以经常出现在对链接长度有限制的平台比如微博。其实短链接还有其他的优点，不过都是基于短链接长度短而来的衍生优势。 缺点那么问题来了，短链接带来的缺点又有什么？是响应时间的变长，其实短链接是靠时间换空间的一个东西。 原理我们分析一下刚才点击短链接到最终得到真实链接的过程： 客户端点击短链接后访问短链接服务器，服务器302暂时重定向到真实的url。所以说短链接是用时间换空间。 那么服务器用301还是302呢？用302。为什么？ 301，代表 永久重定向，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301。 302，代表 临时重定向，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302！ 短链接的设计哈希算法我们对比长链接和短链接，发现有一个共同点：都是由域名+域名后面一串字符构成。其实也就是将长链接域名后面的一长串映射成为了短链接的一短串。也就是说，我们的任务就是将长的那一串经可能变短。 想到了什么？对，哈希算法可以做到。不过常见的md5、sha系列的输出都太长，md5输出是128bit，sha1已经是输出最短的了也有160bit的输出。这个长度的输出太长了，而且md5，sha等哈希算法都是加密算法，所以对服务器的性能消耗较高，故而不适合作为长链接映射为短链接的哈希算法。 MurmurHash算法是一种非加密型哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的 key，MurmurHash的随机分布特征表现更良好，非加密也就意味着MurmurHash的性能比md5等好得多。 MurmurHash算法可选两种长度：32bit和128bit。32bit已经很够用了。 MurmurHash的输出是一串十进制数，可以将其转为62进制从而进一步压缩。 短链接工具 https://sina.lt/ http://tool.chinaz.com/tools/dwz.aspx 参考 高性能短链接设计：长链接 高性能短链接设计：短链接 怎么样？打开短链接是不是感觉比长链接要慢一点？","link":"/2020/08/31/short-url/"},{"title":"SQL和NoSQL的区别和优缺点","text":"关系型数据库：Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL、MariaDB、Sybase、PostgreSQL、OceanBase、SqLite等。 非关系型数据库：Cloudant、MongoDB、Redis、HBase、Memcached等。 区别 关系型数据库：建立在关系数据模型的基础上（由一张张二维的表和表之间的关系组成），借助集合代数等运算处理数据，比如使用了选择、投影、连接、并、交、差、除、增删查改等数学方法来实现对数据的存储和查询。可以用SQL语句在一个或者多个table中做复杂的数据查询。 非关系型数据库：可以是键值对(key, value)、文件、图片等，无需SQL解析，性能非常高，不适合复杂查询，用于超大规模数据的存储。 优缺点 关系型数据库：易于维护，可以用SQL做复杂的查询，安全性高。读写性能差，高并发读写下磁盘IO大，表结构固定故而不灵活， 非关系型数据库：性能非常高，数据无耦合，易于横向扩展。不支持SQL，无事务处理，数据结构复杂造成复杂查询较为困难，","link":"/2022/05/31/sql-and-nosql/"},{"title":"ssh远程登录","text":"总结一下ssh配置以及常用操作。 ssh是用于远程登录计算机的一种协议，用于安全地登录远程服务器。 远程登录主机 1$ ssh -p port_num user_name@ip_address ssh建立流程 远程主机收到用户ssh请求后把自己的公钥发送给用户。 用户端使用发来的公钥加密登录密码并且发送给远程主机。 远程主机用私钥解密用户端发来的登录密码，验证密码正确性。 这中间存在安全风险：如果有人截获了用户的登录请求并伪造服务器公钥发送给用户，用户几乎无法辨认真假，因为ssh的公钥没有公正都是自己签发的。故而，如果有人监听了用户的网络数据，则完全可以伪造服务器公钥骗取用户的登录密码。 这就是“中间人攻击”。 当用户登录进服务器后，服务器会在~/.ssh/known_hosts中保存公钥，以后服务器就不会再提示。 登录 为了解决每次都要输入密码的麻烦，可以使用公钥登录。 原理：用户将自己的公钥存储在远程主机上，登录的时候远程主机给用户发送一串随机字符串，用户用私钥加密后发给远程主机，远程主机用事先存储的公钥解密，成功则允许用户登录。 首先确保/etc/ssh/sshd_config中的如下三项开启： 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 开启后，重启ssh服务： 1234567891011# centos6$ service sshd restart# centos7+$ systemctl restart sshd.service# ubuntu$ service ssh restart# debian$ /etc/init.d/ssh restart 确保以上配置开启后。 首先，用户端生成公钥： 1$ ssh-keygen 一般不用设置。 现在~/.ssh下会生成公钥id_rsa.pub和私钥id_rsa。 再将公钥上传至远程主机： 1$ ssh-copy-id user@host 添加公钥到authorized_keys文件末尾 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 完成！ 总之，公钥用来加密，私钥用来解密。 使用ssh建立数据通路 看命令： 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 单引号中的再远程主机上执行，最后面将``~/.ssh/id_rsa.pub`输入重定向到远程主机，也就是说ssh可以再本地和远程之间建立命令和数据通道。 比如： 将本地src目录打包压缩传输到了远程服务器，远程服务器执行对本地传来的文件一个解压缩处理。中间的|是管道符，作用是将左侧命令的输出作为右侧命令的输入。 1$ cd &amp;&amp; tar -zcv src | ssh user@host 'tar xz' 同理，逆操作，将服务器上的src目录打包压缩后传输到本地并使用tar解压缩包。 1$ ssh user@host 'tar cz src' | tar zxv 本地远程查看服务器进程： 1$ ssh user@host 'ps aux | grep httpd' 绑定本地端口 让8080端口的数据通过ssh上传至远程主机： 1$ ssh -D 8080 user@host 此时ssh会建立socket监听本地8080，并将8080端口收到的数据自动通过ssh上传至远程主机。 可以通过这种方式加密端口。 本地端口转发 假设本地主机localhost与remotehost无法直接通信，有一台中间主机middlehost可以同时连接两台主机。 那么就可以设置本地端口转发至middlehost。 下面：指定本地ssh绑定端口2121，指定middlehost将所有数据转发到目标主机的21端口（21为ftp端口）。 1$ ssh -L 2121:remotehost:21 middlehost 参数分别是本地端口：目标主机：目标主机端口。 这个技术的作用是在本不能互相通信的localhost与remotehost之间建立了一条以middlehost为中继的ssh隧道。 下面是一个比较有趣的例子。 1$ ssh -L 5900:localhost:5900 host3 它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。 另一个例子是通过host3的端口转发，ssh登录host2。 1$ ssh -L 9001:host2:22 host3 这时，只要ssh登录本机的9001端口，就相当于登录host2了。 1$ ssh -p 9001 localhost 上面的-p参数表示指定登录端口。 远程端口转发 本地端口转发是指定本地端口的转发，而远程端口转发就是绑定远程端口的转发。 假设host1与host2无法通信，host3是一台内网主机可以连接外网的host1，但是host1不能连接host3。 这种情况解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。 我们在host3执行下面的命令： 1$ ssh -R 2121:host2:21 host1 R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。 绑定之后，我们在host1就可以连接host2了： 1$ ftp localhost:2121 这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。","link":"/2019/11/04/ssh/"},{"title":"SVN学习笔记","text":"除了主流的Git，SVN也需要学一下，特别是命令行的使用。 基本概念SVN(Apache Subversion)是Apache基金会的一个开源的VCS（版本控制系统）。 基本名词 repository: 代码仓库。 checkout: 从仓库检出代码到本地。 commit: 修改完代码需要提交到仓库。 update: 从代码仓库更新变更的代码到本地。 工作流一般的工作流是这样： 先checkout远程仓库的代码到本地。 修改、添加、删除代码。 改完代码，提交之前先update代码防止冲突（如果修改了同一个文件中的同一行代码则会冲突）。 然后提交commit代码到仓库。 安装官网：https://subversion.apache.org/ 生命周期 创建版本库 版本库存放了代码和文件的变动历史。使用create创建新的版本库。 检出 checkout用于从版本库拉取代码到本地。 更新 update用于更新版本库。 执行变更 执行变更包括：修改、添加、删除。变更完毕后需要commit提交到版本库中。 复查变化 执行变更后，本地的代码就会比版本库要新，在commit之前最好复查一下代码。使用status复查变更的文件，使用diff查看详细变更信息。 修复错误 想要撤销本地修改的文件，可以使用revert将本地文件恢复为版本库中的文件。 解决冲突 合并代码的时候可能发生冲突，merge操作可以自动处理合并代码。可以使用resolve找出冲突。 提交更改 使用commit将变更提交到版本库，commit之前最好update一下本地代码。 创建版本库 创建版本库repo create1svnadmin create /opt/svn/repo 检出checkout1svn checkout http://svn.server.com/svn/project_repo --username=user01 解决冲突先update： update1svn update 再提交。 如果再冲突则手动解决冲突。 提交commit12345678# 查看状态svn status# add到版本库svn add &lt;filename&gt;# commit到版本库，可以忽略-m参数打开一个编辑器输入多行svn commit -m \"infomation\" 版本回退放弃对文件的修改，使用revert。 revert12345678# 恢复单个文件svn revert &lt;filename&gt;# 恢复指定目录svn revert -R &lt;dir&gt;# 恢复为一个已经提交的版本svn merge -r 22:21 readme 查看历史 svn log log12345678# 查看两个版本之间的信息svn log -r 6:8# 查看特定文件的历史svn log &lt;filename&gt;# 显示指定书目的目录的信息svn log -l 5 -v svn diff diff12345678# 查看本地和版本库的差异svn diff# 比较指定版本的工作拷贝和版本库的区别svn diff -r 3 &lt;filename&gt;# 比较各个版本库svn diff -r 2:3 &lt;filename&gt; svn cat cat12# 查看一个版本的文件svn cat -r 5 &lt;filename&gt; svn list list12# 用于查看目录中的文件svn list http://192.168.0.1/runoob01 分支分支1234567891011121314# 创建分支svn copy trunk/ branches/branchA# 提交分支到版本库svn commit -m \"info\"# 切换分支cd branches/branchA/# 切换到trunk分支并合并分支到trunksvn merge ../branches/branchA/# 将合并完的trunk提交到版本库svn commit -m \"info\" 标签tag12345# 创建tagsvn copy trunk/ tags/v2.0# 提交tagsvn commit -m \"tag v2.0\" GUI工具windows平台有TortoiseSVN，mac平台有SnailSVN。 参考 https://www.runoob.com/svn/svn-tutorial.html","link":"/2021/02/02/svn-tutorial/"},{"title":"什么是系统调用","text":"计算机操作系统中对系统调用的解释已经很清楚了，看到一篇公众号文章，做了个脑图。","link":"/2019/01/11/system-call/"},{"title":"hexo写作模板","text":"hexo模版如下 12345678910111213title: {{ title }}date: {{ date }}updated:toc: truetags: - tag1 - tag2categories: - [cate1] - [cate2]thumbnail:permalink:comments: Summary paragraph 1&lt;!-- more --&gt; Content paragraph","link":"/2018/05/29/template/"},{"title":"undefined和null的区别","text":"js 最初设计的缺陷导致 js 神奇的存在两个空值： undefined 和 null 。其他语言中有且只有 null , NULL 等。 实际开发中，将一个变量赋值为 undefined 和 null 几乎没有区别，且两者都为 Falsy 。 那么两者的区别到底是什么呢？ 区别定义上的区别MDN 的解释： 值 null 是一个字面量，不像 undefined ，它不是全局对象的一个属性。null 是表示缺少的标识，指示变量未指向任何对象。把 null 作为尚未创建的对象，也许更好理解。在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。 undefined 是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined 的最初值就是原始数据类型 undefined。 我的理解是： undefined 表示未初始化。 null 表示已经初始化，但是没有指向任何对象。 一张经典的图帮助理解： 表现上的区别123456789101112131415161718typeof undefined; // 'undefined'typeof null; // 'object'Object.prototype.toString.call(null); // '[object Null]'Object.prototype.toString.call(undefined); // '[object Undefined]'null == undefined; // truenull === undefined; // false!!null === !!undefined; // trueundefined + 0; // NaNnull + 0; // 0// 在JSON.stringify()时，值为undefined的属性会被忽略JSON.stringify({ a: undefined, b: null}); // '{b: null}' ref https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html https://mp.weixin.qq.com/s/N43cy14qN5FkomwhGbuxAw","link":"/2022/03/01/undefined-and-null/"},{"title":"TypeScript中type（类型别名）和interface（接口）的区别","text":"type 和 interface 存在着很大的相同点，也存在不同点。 整理一下两者的基本概念、相同点、区别。 typetype就是类型别名，type可以表示基本类型、对象、联合类型、元组、交集。 定义类型别名123456789101112// 基本类型type name = stringtype age = number// 对象类型type Person = { name: string; age: number;}// 联合类型type id = string | number 使用类型别名1234let p: Person = { name: 'wang', age: 22,} 同时，type中的类型也可以是其他已经定义的类型别名。 interfaceinterface就是接口。 interface只能描述对象的类型。 定义接口1234interface Person { name: string; age: number;} 同时，interface中的类型也可以是其他已经定义的接口。 相同点 都可以用来描述对象类型。 都可以用来描述函数。 1234567// type描述函数的入参类型和返回值类型type FunctionType = (a: number, b: number) =&gt; number// interface描述函数的入参类型和返回值类型interface FunctionInterface { (a: numnber, b: number): number} 都可以实现继承 type可以继承type，interface可以继承interface。同时，type和interface也可以相互继承。 type通过 &amp; 继承type或者interface。interface通过 extends 继承type或者interface。 123456789101112131415161718192021222324252627282930313233343536373839// type继承typetype Person = { name: string; age: number;}type Engineer = Person &amp; { occupation: string}// interface继承interfaceinterface Person { name: string; age: number;}interface Engineer extends Person { occupation: string}// type继承interfaceinterface Person { name: string; age: number;}type Engineer = Person &amp; { occupation: string}// interface继承typetype Person = { name: string; age: number;}interface Engineer extends Person { occupation: string} 都可以使用可选属性 [propName] ?: [type] 不同点 type可以基本类型、联合类型、元组类型而interface不可以。 12// 描述元组type Item = [string, number] 定义多个同名的interface可以合并，而定义多个同名的type会报错。 总结优先用interface。","link":"/2023/06/20/typescript%E4%B8%ADtype%E5%92%8Cinterface%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"vscode的配置及使用技巧","text":"收录一下vscode的使用技巧。 修改资源管理器文件排序方式 设置中搜索sort order，找到工作区Explorer: Sort Order修改为modified（按照修改日期排序）。","link":"/2019/02/09/vscode-tips/"},{"title":"使用vite","text":"vite的使用。 安装vitebash1cnpm install -g create-vite-app 创建vite项目bash123create-vite-app project_namecva project_namecnpm init vite-app project_name 运行bash123cd project_namecnpm installnpm run dev 构建bash1npm run build ref https://vitejs.cn/","link":"/2021/11/11/vite-usage/"},{"title":"vscode自动编译ts代码","text":"使用vscode自动编译ts代码 生成配置文件首先生成配置文件 tsconfig.json 。 1tsc --init 修改配置文件修改输出目录：outDir修改严格模式：strict为false。 监视文件 vscode监控 终端 &gt; 运行任务 &gt; 显示所有任务 &gt; tsc监视 命令行监控 1tsc -w","link":"/2020/12/05/vscode-auto-compile-ts-code/"},{"title":"vue.js中static和assets目录的区别","text":"assets/ 会被webpack的file-loader编译，路径不能直接写。而对于 static/ 则会将其直接复制到 dist/ 下，需要只用绝对路径引用它的文件，比如 /staitc/[filename] 。 static/ 目录一般放外部文件， assets/ 放自己的文件。 引用 assets/ 中的图片必须要 require 。 示例： 123456789101112131415161718192021&lt;div class=\"\"&gt; &lt;!-- 确定路径 --&gt; &lt;img src=\"../assets/logo.png\" title=\"assets中的图片\"&gt; &lt;img src=\"/static/logo.png\" title=\"static中的图片\"&gt; &lt;!-- 动态路径 --&gt; &lt;img :src=\"asetUrl\" title=\"assets中的图片\"&gt; &lt;img :src=\"sticUrl\" title=\"static中的图片\"&gt;&lt;/div&gt;&lt;script&gt;export default { name: 'myDemo', data() { return { asetUrl: require('../assets/logo.png'), sticUrl: '/static/logo.png' } }}&lt;/script&gt;","link":"/2020/04/02/vue-js%E4%B8%ADstatic%E5%92%8Cassets%E7%9B%AE%E5%BD%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"TypeScript学习笔记","text":"TypeScript 是JavaScript的超集且支持ES6标准，由微软开发。 TypeScript是设计用来开发大型应用的，可以编译成js并运行在浏览器上。 语言特性ts扩展的内容TypeScript是js的扩展，扩展的内容如下： 类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 await 以及从ECMA2015一直了如下内容： 类 模块 lambda函数的箭头语法 可选参数和默认参数 ts和js的区别ts是js的超集，它扩展了js的语法。 ts通过类型注解提供编译时的静态类型检查。 ts可以处理已有的js代码并只对其中的ts代码进行编译。 实例12const str : string = \"this is a string.\"console.log(str); 安装npm安装12345# 使用npm全局安装tscnpm install -g typescript# 查看是否安装成功tsc -v 编译将ts编译为js代码： 123# ts文件扩展名为.tstsc demo.tstsc demo1.ts demo2.ts demo3.ts 运行ts已经被编译成了js文件，使用node命令运行js。 1node demo.js 基本语法TypeScript程序由模块、函数、变量、语句和表达式以及注释组成。 编译参数tsc常用编译参数： 1234567891011121314151617181920212223242526# 显示帮助信息--help# 载入扩展模块--module# 设置ECMA版本--target# 额外生成一个.d.ts扩展名的文件。tsc ts-hw.ts --declaration# 删除文件的注释--removeComments# 编译多个文件并合并到一个输出的文件--out# 生成一个 sourcemap (.map) 文件。sourcemap 是一个存储源代码与编译代码对应位置映射的信息文件。--sourcemap# 在表达式和声明上有隐含的 any 类型时报错--module noImplicitAny# 在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。--watch 保留关键字 保留关键字 123456789101112break as catch switchcase if throw elsevar number string getmodule type instanceof typeofpublic private enum exportfinally for while voidnull super this newin return true falseany extends static letpackage implements interface functionnew try yield constcontinue do 空白和换行 ts会忽略空格、tab和换行。 ts区别大小写 ts中分号可选 建议使用分号。 注释 建议每段代码都写注释以提高程序可读性。 编译器会忽略注释。 ts支持的注释类型： 12345// 单行注释/*多行注释。*/ 面向对象TypeScript是面向对象的编程语言。 面向对象有两个重要概念：对象和类。 类：类是一个模板，描述一类对象的状态和行为。 对象：对象是类的实例，有状态和行为。 方法：方法是类的操作的实现步骤。 实例： 12345678910111213// 定义一个类class Person { // 定义一个name方法 name():void { console.log(\"wangwei\") } }// 创建Person这个类的实例masonvar mason = new Person(); // 调用mason这个实例的name方法mason.name(); 现在将这个ts编译为js，编译之后的js代码为： 123456789var Person = /** @class */ (function() { function Person() {} Person.prototype.name = function() { console.log(\"wangwei\"); }; return Person;}());var mason = new Person();mason.name(); 基本数据类型 any关键字声明任意类型。 TypeScript针对类型不明确时提供了any类型。 三种用途： 变量的值会动态改变。 1234567let x: any = 1;x = 'abc';x = true;x = 2; 改写原有代码的时候，使用any类型可以允许在编译的时候可选择的包含或者移除类型检查。 12345let x: any = 4;x.ifItExists();x.toFixed(); 定义存储各种类型数据的数组的时候使用any。 12let arr: any[] = [1,'a string',true];arr[0] = 'new string'; number关键字声明数字类型，采用双精度64位浮点数，可以用来表示整数和分数。 1234567891011// 声明并赋值一个二进制数let num: number = 0b10101;// 声明并赋值一个八进制数let num: number = 0o712;// 声明并赋值一个十进制数let num: number = 9;// 声明并赋值一个十六进制数let num: number = 0xf100a; string关键字声明字符串类型，使用单引号或者双引号表示字符串，反引号`定义多行文本和内嵌表达式。 1234let name: string = 'mason';let age: number = 18;let gender: string = 'male';let words: string = `我的名字叫${name}，今年${age}岁，性别${gender}。`; boolean关键字声明布尔型，两个值为true和false。 1let fake: boolean = false; number[]来声明数组类型。 12345// 在元素类型后面加上[]即可声明数组let arr: number[] = [1,2,3];// 或者使用数组泛型let arr: Array&lt;number&gt; = [1,2,3]; 元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。 1234567891011// 声明元组，元组各个位置上的数据类型要相符，下面尝试赋值let x: [string, number];// 赋值正常x = ['asd',1];// 赋值报错x = [1,'add'];// 输出asdconsole.log(x[0]); enum关键字，枚举类型用于定义数值集合。 123enum Color {Red, Green, Blue};let c: Color = Color.Blue;console.log(c); void关键字用于标识方法没有返回值。 123function func(): void { console.log('done');} null关键字标识对象值缺失。 js中的null表示什么都没有。null是一个只有一个值的特殊类型，表示一个空对象引用。typeof null 得到 object 。 undefined关键字用于初始化变量为一个未定义的值。 js中的undefined是一个没有设置值的变量。 never是其他类型的子类型，代表不会出现的值。 声明为never类型的变量只能被never类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）。 123456789101112131415161718192021let x: never;let y: number;// 运行错误，数字类型不能转为never类型x = 123;// 运行正确，never类型可以赋值给never类型x = (()=&gt;{ throw new Error('exception')})();// 运行正确，never类型可以赋值给数字类型y = (()=&gt;{ throw new Error('exception')})();// 返回值为never的函数可以是抛出异常的情况function error(message: string): never { throw new Error(message);}// 返回值为never的函数可以是无法被执行到的终止点的情况function loop(): never { while (true) {}} JavaScript是弱类型语言故而没有整数类型，TypeScript是强类型语言但是只能用number关键字声明数字并且不区分整数和浮点数故而也没有整数类型。 可以使用|来支持多种类型 1let x: number | null | undefined; tips： 如果某个属性的值是计算出来的，则它后面的一个变量必须初始化，否则编译报错。 变量声明变量用于引用内存地址。 变量可以看做是存储数据的容器。 ts变量命名规则：变量名由数字、字母和 _ 以及 $ 构成，且不能以数字开头。 变量使用前必须声明。 各种声明方式： 1234567891011// 声明变量类型并初始化var [var_name]: [data_type] = [value];// 声明变量但不初始化，值默认为undefinedvar [var_name]: [data_type];// 声明变量并初始化，但不设置类型，此时变量可以是任意类型var [var_name] = [value];// 声明变量，不设置类型和初始化，类型可以是任意类型，值默认为undefinedvar [var_name]; 实例： 12345678var uname:string = \"mason\";var score1:number = 90;var score2:number = 41.5var sum = score1 + score2console.log(\"名字: \"+uname)console.log(\"第一个科目成绩: \"+score1)console.log(\"第二个科目成绩: \"+score2)console.log(\"总成绩: \"+sum) 变量名不能使用 name ，会与 windows.name 冲突。 编译为js： 12345678var uname = \"mason\";var score1 = 90;var score2 = 41.5;var sum = score1 + score2;console.log(\"名字: \" + uname);console.log(\"第一个科目成绩: \" + score1);console.log(\"第二个科目成绩: \" + score2);console.log(\"总成绩: \" + sum); ts是强类型语言，声明类型和字面量类型不同则编译错误： 12// 声明为number类型却复制为string类型，编译错误var num: number = \"this is a string.\"; 类型断言类型断言(Type Assertion)可以用于手动指定一个值的类型，也就是将一个变量改变为另一个类型。 12345// 方法一&lt;类型&gt;值// 方法二，在tsx中必须使用该方法值 as 类型 实例： 12345// 声明变量为string类型var str = '1';// 使用方法一将其变为number类型var str2: number = &lt;number&gt; &lt;any&gt; str; 关于断言： 当A类型是B类型的子集或者A类型是B类型的父集，A类型都能被成功断言为A类型，这个是为了安全考虑，若强行断言则可以使用any。 类型断言不是类型转换，类型转换是在程序运行时完成的，而类型断言则是纯粹的编译时语法。 类型推断当没有给出类型的时候，tsc会利用类型推断来推断类型。 如果缺乏声明而导致不能推断出类型，则默认其类型为 any 。 123456// 注意这里不是js声明，这里是ts声明变量，却没有声明类型，类型推断为numbervar num = 2;// 这里num已经被推断为number却赋值了string类型，故而编译失败num = 'this is a string.';console.log(num); 变量作用域ts中的变量作用域： 全局作用域：全局变量定义在程序结构的外部，在任何位置都可以调用。 类作用域：也称之为字段，类变量声明在一个类里面且在类的方法外面。可以使用类的对象访问。类变量可以使静态的，可以通过类名直接访问。 局部作用域：局部变量，生命在一个代码块中，作用域就在这个代码块。 实例： 123456789101112131415// 全局变量var global_var = 1;class Numbers { // 实例变量 template_var = 13; // 静态变量 static static_var = 14; varNum(): void { // 局部变量 var scoped_var = 123; }} 这是上面的四种变量对应的访问方式： 1234567891011// 全局变量console.log(global_var);// 实例变量，需要先new一个实例var obj = new Numbers();console.log(obj.template_var);// 静态变量console.log(Numbers.static_var);// 局部变量外部无法访问，只能在其所在的代码块访问 更多参考：https://ts.xcatliu.com/basics/type-assertion.html 运算符ts有以下几种运算符： 算术运算符 逻辑运算符 关系运算符 按位运算符 赋值运算符 三元/条件运算符 字符串运算符 类型运算符 算数运算符有 + , - , * , / , % , ++ , -- ，其中 ++ , -- 还有写在值之前和之后之分。 比如 ++ ，写在值之前是先自增再用，写在值之后是先用再自增。 关系运算符关系运算法计算表达式是 true 还是 false 。 关系运算符有这些： == , != , &gt; , &lt; , &gt;= , &lt;= 。 逻辑运算符逻辑运算符用于测定变量或者值之间的逻辑。 逻辑运算符有这些： &amp;&amp; , || , ! 。 其中 &amp;&amp; 和 || 可以短路： &amp;&amp; 左边为 true 则返回右边的， || 之前的变量或值为 true 则返回 &amp;&amp; 之前的变量或值。 位运算符位运算符是对变量按位进行二进制操作（有一元操作符和二元操作符）。 位运算符有这些： &amp;：按位与处理两个长度相同的二进制数。 |：按位或处理两个长度相同的二进制数。 ~：取反，取反是一元运算符，对一个二进制数的每一位执行逻辑反操作。 ^：按位异或运算，对等长二进制模式按位或二进制数的每一位执行逻辑异按位或操作。操作的结果是如果某位不同则该位为 1，否则该位为 0。 &lt;&lt;：把 &lt;&lt; 左边的运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数指定移动的位数，高位丢弃，低位补 0。 &gt;&gt;：把 &gt;&gt; 左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数指定移动的位数。 &gt;&gt;&gt;：无符号右移，与有符号右移位类似，除了左边一律使用0 补位。 123alert: 这里b是3，按位取反后为什么是-4？(~b) =&gt; -4 赋值运算符赋值运算符有： = , += , -= , *= , /= 。 三元运算符语法： condition ? expression1 : expression2 三元运算符 ? 有三个操作数，第一个操作数为 true 则返回第二个操作数，为 false 则返回第三个操作数。 实例： 12var num: number = -1;var result = num &gt;= 0 ? \"大于0\" : \"小于0\"; 类型运算符 typeof：一元运算符，返回数据类型。 1234var num: number = 12;console.log(typeof num);// 结果：number instanceof：判断对象是否是指定类型。 其他运算符 符号运算符：用于取负值。 字符串运算符（链接运算符）：用于拼接两个字符串。 条件语句条件语句用于基于不同的条件执行不同的操作。 if语句if语句由布尔表达式和多个语句组成。 语法： 1234567891011121314151617181920// type1if (expression) { // statement}// type2if (expression) { // statement1} else { // statement2}// type3if (expression) { // statement1} else if () { // statement2} else { // statement3} switch…case语句switch...case 语句允许测试一个变量等于多个值时的情况，每一个值都是一个case，被测变量以此检查case。 switch…case语句规则： expression是一个常量表达式（整形或者枚举型）。 case可以与多个，后面跟一个值和冒号。 expression和exp必须要是相同的数据类型。 expression和exp相等时执行case后面的语句，直到遇到break;跳出switch。 如果语句不包含break则顺序往下面的case执行直到遇到break。 switch可以有多个default，放置在switch最后面。 语法： 12345678910111213141516switch(expression) { case exp1: { // statement break; // 可选 } case exp2: { // statement break; // 可选 } ... ... ... default: { // statement }} 循环for循环123for (init; condition; inc) { // statement} 下面是 for 循环的控制流程解析： init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为 true，则执行循环主体。如果为 false，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为 true，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为 false 时，for 循环终止。 在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。 condition 可以是任意的表达式，当条件为 true 时执行循环，当条件为 false 时，退出循环。 实例：计算5的阶乘5! 123456var result: number = 1;for (let count: number = 5; count &gt; 0; count--) { result = result * count;}console.log(result);// 120 for…in循环for…in循环用于一组值的集合或列表进行迭代输出。 123for (var val in list) { // statement} val 为string或者any。 实例： 1234567891011121314var num: any;var str: any = \"a b c\";for (num in str) { console.log(str[num]);}/* a b c*/ for…of, forEach, every, some for...of是es6中引入的代替for...in和forEach()，用于创建一个循环来迭代可迭代的对象，支持新的迭代协议。 可以使用for…of遍历数组、字符串、映射（maps）、集合（sets）等等可迭代的数据结构。 实例： 12345let someArray = [1, \"string\", false]; for (let entry of someArray) { console.log(entry); // 1, \"string\", false} forEach , every 和 some 是js中的循环语法，ts也支持这几种循环。 forEach123456let list = [1,2,3];list.forEach((val, idx, array) =&gt; { // val: 当前值 // idx：当前index // array: Array}); every12345678let list = [4, 5, 6];list.every((val, idx, array) =&gt; { // val: 当前值 // idx：当前index // array: Array return true; // Continues // Return false will quit the iteration}); while123while (condition) { // statement} do…whiledo...while 中的statement代码至少被执行一次。 123do { // statement} while (); break用法： 在循环内使用的时候会终止并跳出当前循环。 switch…case中使用跳出switch。 语法： 1break; continuecontinue跳过当前循环开始下一个循环。 语法： 1continue; 无限循环for和while都可以创建无限循环（死循环）。 1234567for (;;) { // statement}while (true) { //statement} 函数函数是一组ts语句。 函数声明包括函数的名称、返回值类型和参数。 函数的定义123456789// 一个名为func的函数function func() { // statement}// 匿名函数function () { // statement} 调用函数调用上面的 func 函数。 1func(); 函数返回值有时我们希望函数能返回一个值用于调用它的地方，通过return语句可以返回一个值并停止函数的执行。 1234function func(): string { // statement return str;} 一个函数只能有一个return，返回值类型要和函数定义的返回值类型一样。 带参数的函数123function func(param1: number, param2: string,param3: boolean) { //statement} 可选参数和默认参数 可选参数 使用问号 ? 表示可选参数，且只能放在后面。 1234// 这里第三个参数是可选的function func(param1: number, param2: string,param3?: boolean) { //statement} 默认参数 1234这里给第三个参数默认值`true`function func(param1: number, param2: string,param3: boolean = true) { //statement} 剩余参数用于不知道向函数传多少个参数的时候。 使用 ...restOfName 表示剩余参数，是一个数组。 12345function buildName(firstName: string, ...restOfName: string[]) { return firstName + \" \" + restOfName.join(\" \");} let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); 匿名函数匿名函数就是没有函数名的函数。 匿名函数用的时候动态声明。 也可以将匿名函数赋值给变量，这种就叫做函数表达式。 1let func = function () { //statement } 匿名函数立即执行123(function () { // statement})(); 构造函数ts也支持js的 new Function() 来定义函数。 1var res = new Function ([arg1[, arg2[, ...argN]],] functionBody); 实例： 123var myFunction = new Function(\"a\", \"b\", \"return a * b\"); var x = myFunction(4, 3); console.log(x); 递归函数递归函数就是在函数内部调用自身。 12345678function factorial(number) { if (number &lt;= 0) { // 停止执行 return 1; } else { return (number * factorial(number - 1)); // 调用自身 } }; console.log(factorial(6)); // 输出 720 lambda函数lambda 函数就是箭头函数。 单个参数 () 可选，单行函数体则 {} 也是可选的，如果没有参数则要保留一堆括号 () 。 语法： 1234567// 单行( [param1, parma2,…param n] ) =&gt; statement;// 多行( [param1, parma2,…param n] )=&gt; { statement;} 实例： 1var foo = (x: number) =&gt; x++; 上面的代码等同于： 123var foo = function(x) { return x++;}; 函数重载重载就是调用的函数相同但是参数不同，返回值类型可以不同。 每个重载的方法都要有独一无二的参数类型列表。 重载的例子： 1234567891011// 参数类型不同function func(`str`): void;function func(1): void;// 参数数量不同function func(n1:number): void;function func(n1: number, n2: number): void;// 参数类型顺序不同function func(num: number, str: string): void;function func(str: string, num: number): void; 如果参数类型不同，则参数类型要设置为 any 。 参数数量不同，要将不同的参数设置为可选。 实例：参数数量和类型不同 123456789function disp(s1:string):void; function disp(n1:number,s1:string):void; function disp(x:any,y?:any):void { console.log(x); console.log(y); } disp(\"abc\") disp(1,\"xyz\"); Number对象ts也支持Number对象，Number对象是原始数据类型的包装对象。 1var num = new Number(1); Number对象属性 MAX_VALUE：可表示的最大的数字。 MIN_VALUE：可表示的最小的数字。 NaN：not a number。 POSITIVE_INFINITY：正无穷。 NEGATIVE_INFINITY：负无穷。 prototype：Number 对象的静态属性。使您有能力向对象添加属性和方法。 constructor：返回对创建此对象的Number函数的引用。 实例： 1234567891011121314console.log(\"最大值为: \" + Number.MAX_VALUE); console.log(\"最小值为: \" + Number.MIN_VALUE); console.log(\"负无穷大: \" + Number.NEGATIVE_INFINITY); console.log(\"正无穷大:\" + Number.POSITIVE_INFINITY);function employee(id:number,name:string) { this.id = id this.name = name }var emp = new employee(123,\"admin\") employee.prototype.email = \"admin@runoob.com\" console.log(\"员工号: \"+emp.id) console.log(\"员工姓名: \"+emp.name) console.log(\"员工邮箱: \"+emp.email) 输出： 1234员工号: 123员工姓名: admin员工邮箱: admin@runoob.com Number对象方法 toExponential()：将数字转化为指数计数法。 toFixed()：将数字指定小数点位数并转化为字符串。 toLocaleString()：把数字转换为字符串，使用本地数字格式顺序。 toPrecision()：把数字格式化为指定的长度。 toString()：把数字转换为字符串，使用指定的基数。数字的基数是2 ~ 36之间的整数。若省略该参数，则使用基数10。 valueOf()：返回一个Number对象的原始数字值。 String对象String对象用于处理字符串。 12var str = new String('this is a string.');var str = 'this is a string.'; String对象属性 constructor：对创建该对象的构造函数的引用。 length：返回字符串的长度。 prototype：可以向对象添加属性和方法。 String对象方法 charAt()：返回在指定位置的字符。 charCodeAt()：返回在指定的位置的字符的Unicode编码。 concat()：连接两个或更多字符串，并返回新的字符串。 indexOf()：返回某个指定的字符串值在字符串中首次出现的位置。 lastIndexOf()：从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 localeCompare()：用本地特定的顺序来比较两个字符串。 match()：查找找到一个或多个正则表达式的匹配。 replace()：替换与正则表达式匹配的子串。 search()：检索与正则表达式相匹配的值。 slice()：提取字符串的片断，并在新的字符串中返回被提取的部分。 split()：把字符串分割为子字符串数组。 substr()：从起始索引号提取字符串中指定数目的字符。 substring()：提取字符串中两个指定的索引号之间的字符。 toLocaleLowerCase()：根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射。 toLocaleUpperCase()：据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射。 toLowerCase()：把字符串转换为小写。 toString()：返回字符串。 toUpperCase()：把字符串转换为大写。 valueOf()：返回指定字符串对象的原始值。 Array对象ts如何声明数组： 12345// 声明一个变量为site的字符串类型的数组var sites: string[];// 初始化sites = ['twitter','google','amazon']; 或者声明并初始化： 1var sites: string[] = ['baidu','google','amazon']; 如果数组声明时未设置类型，则会被认为是 any 类型，在初始化时根据第一个元素的类型来推断数组的类型。 访问数组： 1234var sites: string[];sites = ['baidu','google','amazon'];console.log(sites[0]); 使用Array对象创建数组Array创建对象的时候可以接受两种值。 数组的长度。 初始化数组的元素。 1var sites: string[] = new Array(3); 或者： 1var sites: string[] = new Array('google','baidu','amazon'); 数组结构也可以将数组元素赋值给变量： 12var arr: number[] = [1,2];var [x,y] = arr; 数组迭代123456var nums:number[] = [1,2,3,4];var i:any;for (i in nums) { console.log(nums[i]);} 多维数组可以将一个数组作为另一个数组的元素，这就是多维数组。 二维数组定义： 1var arr: number[][] = [[1,2,3],[4,5,6]]; 数组在函数中的使用 作为参数传递到函数进行操作。 作为函数的返回值。 12345function returnArray():string[] { return new Array('google','facebook','amazon');}// 这里会返回一个数组 数组方法 concat()：连接多个数组。 1234var alpha = ['a','b','c'];var nums = [1,2,3];var alphaConcatNums = alpha.concat(nums); every()：检测数组元素是否都符合条件。 123456789// 声明并初始化待检测数组var arr = [1,2,3,4,5,6];// 定义检测函数function isBigEnough(element, index, array) { return (element &gt;= 3);}console.log(arr.every(isBigEnough)); filter()：检测数值元素并返回符合条件的数组。 123456789// 声明并初始化待检测数组var arr = [1,2,3,4,5,6];// 定义检测函数function isBigEnough(element, index, array) { return (element &gt;= 3);}console.log(arr.filter(isBigEnough)); forEach()：为数组的每一个元素都执行一次回调函数。 1234let nums = [1,2,3];nums.forEach(function (element) { console.log(element);}); indexOf()：返回一个元素所在的索引位置，找不到则返回-1. 1console.log([1,2,3,4].indexOf(2)); join()：将数组的所有元素都放入一个字符串。 12345678910var arr = ['i','have','a','pen'];console.log(arr.join());// i,have,a,penconsole.log(arr.join(', '));// i, have, a, penconsole.log(arr.join('+'));// i+have+a+pen lastIndexOf()：返回指定字符串最后出现的位置（会从最后面向前搜索）。 123var index = [12, 5, 8, 130, 44].lastIndexOf(8); console.log(\"index is : \" + index ); // 2 map()：用指定函数梳理数组中每一个元素并返回处理后的数组。 123var numbers = [1, 4, 9]; var roots = numbers.map(Math.sqrt); console.log(\"roots is : \" + roots ); // 1,2,3 pop()：删除数组的最后一个元素并返回删除的元素。 1234var numbers = [1, 4, 9]; var element = numbers.pop(); console.log(\"element is : \" + element ); // 9 push()：向数组添加元素并返回新数组的长度。 12345var numbers = [1, 4, 9]; var length = numbers.push(16); console.log(length);// 4 reduce()：从左到右将数组元素计算为一个值。 12345678var arr = [1,2,3,4];var total = arr.reduce(function (a,b) { return a + b;});console.log(total);// 10 reduceRight()：从右到左将数组元素计算为一个值。 reverse()：反转数组的元素顺序。 12345var arr = [1,2,3,4];var reverseArr = arr.reverse();console.log(reverseArr);// [4,3,2,1] shift()：删除并返回数组的第一个元素。 1234var arr = [1,2,3,4].shift();console.log(arr);// 1 slice()：选取数组的一部分并返回一个新数组。 123var arr = [\"orange\", \"mango\", \"banana\", \"sugar\", \"tea\"]; console.log(\"arr.slice( 1, 2) : \" + arr.slice( 1, 2) ); // mangoconsole.log(\"arr.slice( 1, 3) : \" + arr.slice( 1, 3) ); // mango,banana some()：检测数组中是否存在符合条件的元素并返回布尔值。 12345678910function isBigEnough(element, index, array) { return (element &gt;= 10); } var retval = [2, 5, 8, 1, 4].some(isBigEnough);console.log(\"Returned value is : \" + retval ); // false var retval = [12, 5, 8, 1, 4].some(isBigEnough); console.log(\"Returned value is : \" + retval ); // true sort()：对数组元素进行排序。 123var arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); var sorted = arr.sort(); console.log(\"Returned string is : \" + sorted ); // banana,mango,orange,sugar splice()：从数组中添加或者删除元素。 12345678var arr = [\"orange\", \"mango\", \"banana\", \"sugar\", \"tea\"]; var removed = arr.splice(2, 0, \"water\"); console.log(\"After adding 1: \" + arr ); // orange,mango,water,banana,sugar,tea console.log(\"removed is: \" + removed); removed = arr.splice(3, 1); console.log(\"After removing 1: \" + arr ); // orange,mango,water,sugar,tea console.log(\"removed is: \" + removed); // banana toString()：把数组转换为字符串，并返回结果。 123var arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); var str = arr.toString(); console.log(\"Returned string is : \" + str ); // orange,mango,banana,sugar unshift()：向数组的开头添加一个或更多元素，并返回新的长度。 1234var arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); var length = arr.unshift(\"water\"); console.log(\"Returned array is : \" + arr ); // water,orange,mango,banana,sugar console.log(\"Length of the array is : \" + length ); // 5 Map对象Map对象是es6引入的，用于保存键值对并且能记住键的原始插入顺序。 创建Map12345678// 声明let myMap = new Map();// 声明并用数组的方式传入键值对let myMap = new Map([ [\"key1\", \"value1\"], [\"key2\", \"value2\"] ]); Map属性与方法 map.clear()：删除map对象的所有键值对。 map.set()：设置键值对，返回该对象。 map.get()：读取键对应的值，不存在则返回undefined。 map.has()：查询map对象中是否存在某个键对应的值，返回布尔值。 map.delete()：删除map对象中的键值对，成功返回true，失败返回false。 map.size：返回map对象的长度，也就是键值对的个数。 map.keys()：返回一个Iterator对象（迭代器），包含了map对象中每个元素的键。 map.values()：返回一个Iterator对象，包含了map对象中每个元素的值。 实例： 123456789101112131415161718let nameSiteMapping = new Map();nameSiteMapping.set(\"Google\", 1);nameSiteMapping.set(\"Runoob\", 2);nameSiteMapping.set(\"Taobao\", 3);console.log(nameSiteMapping.get(\"Runoob\")); //40console.log(nameSiteMapping.has(\"Taobao\")); //trueconsole.log(nameSiteMapping.has(\"Zhihu\")); //falseconsole.log(nameSiteMapping.size); //3console.log(nameSiteMapping.delete(\"Runoob\")); // trueconsole.log(nameSiteMapping);nameSiteMapping.clear(); //清除 Mapconsole.log(nameSiteMapping); 使用es6编译： 1tsc --target es6 test.ts 运行结果： 1234567892truefalse3trueMap { 'Google' =&gt; 1, 'Taobao' =&gt; 3}Map {} 迭代Map使用for…of迭代： 12345678910111213141516171819202122232425let nameSiteMapping = new Map(); nameSiteMapping.set(\"Google\", 1);nameSiteMapping.set(\"Runoob\", 2);nameSiteMapping.set(\"Taobao\", 3); // 迭代 Map 中的 keyfor (let key of nameSiteMapping.keys()) { console.log(key); } // 迭代 Map 中的 valuefor (let value of nameSiteMapping.values()) { console.log(value); } // 迭代 Map 中的 key =&gt; valuefor (let entry of nameSiteMapping.entries()) { console.log(entry[0], entry[1]); } // 使用对象解析for (let [key, value] of nameSiteMapping) { console.log(key, value); } 使用es6编译： 1tsc --target es6 test.ts 执行结果： 1234567891011GoogleRunoobTaobao123Google 1Runoob 2Taobao 3Google 1Runoob 2 元组数组中存储的元素类型都是一样的，如果要在数组中存储不同类型的元素则用元组。 定义元组1var mytuple = [val1,val2,val3...]; 实例： 12345678var mytuple = [1,'asd',false];或者var mytuple = [];mytuple[0] = 1;mytuple[1] = 'asd';mytuple[2] = false; 访问元组1mytuple[index]; 元组的运算 push()：向元组最后面添加元素。 pop()：删除元组最后面一个元素并返回被删除的元素。 更新元组可以改变元组元素。 结构元组1234var a =[10,\"Runoob\"] var [b,c] = a console.log( b ) console.log( c ) 联合类型可以通过使用管道符 | 将变量设置为多种类型。 1type1 | type2 | type3 实例： 123var val: string | number;val = 12;val = 'string.'; 将联合类型作为函数的参数使用： 12345678910111213function disp(name:string|string[]) { if(typeof name == \"string\") { console.log(name) } else { var i; for(i = 0;i&lt;name.length;i++) { console.log(name[i]) } } } disp(\"Runoob\") console.log(\"输出数组....\") disp([\"Runoob\",\"Google\",\"Taobao\",\"Facebook\"]) 联合类型数组将数组声明为联合类型： 123456789101112131415var arr:number[]|string[]; var i:number; arr = [1,2,4] console.log(\"**数字数组**\") for(i = 0;i&lt;arr.length;i++) { console.log(arr[i]) } arr = [\"Runoob\",\"Google\",\"Taobao\"] console.log(\"**字符串数组**\") for(i = 0;i&lt;arr.length;i++) { console.log(arr[i]) } 接口接口的定义 接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。 ts接口的定义： 12interface interface_name {} 实例： 12345678910111213141516171819202122232425262728// 定义了接口IPersoninterface IPerson { firstName:string, lastName:string, sayHi: ()=&gt;string } // 定义了类型为IPerson的变量customervar customer:IPerson = { firstName:\"Tom\", lastName:\"Hanks\", sayHi: ():string =&gt;{return \"Hi there\"} } console.log(\"Customer 对象 \") console.log(customer.firstName) console.log(customer.lastName) console.log(customer.sayHi()) var employee:IPerson = { firstName:\"Jim\", lastName:\"Blakes\", sayHi: ():string =&gt;{return \"Hello!!!\"} } console.log(\"Employee 对象 \") console.log(employee.firstName) console.log(employee.lastName) 接口不能编译为js。 联合类型和接口在接口中使用联合类型： 12345678910111213141516171819interface RunOptions { program:string; commandline:string[]|string|(()=&gt;string); } // commandline 是字符串var options:RunOptions = {program:\"test1\",commandline:\"Hello\"}; console.log(options.commandline) // commandline 是字符串数组options = {program:\"test1\",commandline:[\"Hello\",\"World\"]}; console.log(options.commandline[0]); console.log(options.commandline[1]); // commandline 是一个函数表达式options = {program:\"test1\",commandline:()=&gt;{return \"**Hello World**\";}}; var fn:any = options.commandline; console.log(fn()); 接口和数组接口中可以将数组的index和value设置为不同类型。 接口的继承接口的继承就是一个接口可以继承多个接口。使用关键字 extends 。 使用： 123interface_A extends interface_Binterface_A extends interface_B, interface_C, interface_D 实例：单继承 1234567interface Person { age:number } interface Musician extends Person { instrument:string } 实例：多继承 123456789interface IParent1 { v1:number } interface IParent2 { v2:number } interface Child extends IParent1, IParent2 { } 类类的定义ts是面向对象的js。 类描述了所创建对象的共同的属性和方法。 ts支持面向对象的所有特性：类、接口等。 ts类的定义： 12345class class_name { // 字段：是类里面声明的变量。字段表示对象的有关数据。 // 构造函数：类实例化时调用，可以为类的对象分配内存。 // 方法：方法为对象要执行的操作。} 实例： 12class Person {} 创建类的数据成员1234567891011121314class Car { // 字段 engine:string; // 构造函数 constructor(engine:string) { this.engine = engine; } // 方法 disp():void { console.log(\"发动机为 : \"+this.engine) } } 实例化使用 new 来实例化类的对象。 12345var object_name = new class_name([ arguments ]);var obj = new Car(\"Engine 1\");obj.var_name;obj.function_name(); 实例： 1234567891011121314151617181920212223class Car { // 字段 engine:string; // 构造函数 constructor(engine:string) { this.engine = engine } // 方法 disp():void { console.log(\"函数中显示发动机型号 : \"+this.engine) } } // 创建一个对象var obj = new Car(\"XXSY1\") // 访问字段console.log(\"读取发动机型号 : \"+obj.engine) // 访问方法obj.disp() 类的继承使用关键字 extends 继承父类，只能继承一个父类。 1class class_A extends class_B 实例： 123456789101112131415161718class Shape { Area:number constructor(a:number) { this.Area = a } } class Circle extends Shape { disp():void { console.log(\"圆的面积: \"+this.Area) } } var obj = new Circle(223); obj.disp()// 圆的面积: 223 ts中一个类只能继承一个父类，但是支持多重继承。 123456789101112class Root { str:string; } class Child extends Root {} class Leaf extends Child {} // 多重继承，继承了 Child 和 Root 类 var obj = new Leaf(); obj.str =\"hello\" console.log(obj.str)// hello 继承类的方法重写子类继承了父类以后，子类可以对父类的方法重写。 super 关键字是对父类的引用，可以使用 super 引用父类的属性和方法。 12345678910111213class PrinterClass { doPrint():void { console.log(\"父类的 doPrint() 方法。\") } } class StringPrinter extends PrinterClass { // 重写doPrint doPrint():void { super.doPrint() // 调用父类的函数 console.log(\"子类的 doPrint()方法。\") } } static关键字static 关键字用于定义类的数据成员（属性和方法）为静态，静态成员可以通过类名调用。 12345678910class StaticMem { static num:number; static disp():void { console.log(\"num 值为 \"+ StaticMem.num) } } StaticMem.num = 12 // 初始化静态变量StaticMem.disp() // 调用静态方法 instanceof运算符用于判断对象是否是指定的类型。 12345class Person{ } var obj = new Person() var isPerson = obj instanceof Person; console.log(\"obj 对象是 Person 类实例化来的吗？ \" + isPerson);// obj 对象是 Person 类实例化来的吗？ true 访问控制修饰符ts中可以使用访问控制修饰符来保护对类、变量、方法和构造方法的访问。 public：默认值，共有，在任何地方都可以被访问。 protected：受保护的，只可以被自己和子类和父类访问。 private：私有的，只能被其定义所在的类访问。 12345678class Encapsulate { str1:string = \"hello\" private str2:string = \"world\" } var obj = new Encapsulate() console.log(obj.str1) // 可访问 console.log(obj.str2) // 编译错误， str2 是私有的 类和接口类可以用 implements 关键字实现接口并将 interest 字段作为类的属性使用。 1234567891011121314151617interface ILoan { interest:number } class AgriLoan implements ILoan { interest:number rebate:number constructor(interest:number,rebate:number) { this.interest = interest this.rebate = rebate } } var obj = new AgriLoan(10,1) console.log(\"利润为 : \"+obj.interest+\"，抽成为 : \"+obj.rebate )// 利润为 : 10，抽成为 : 1 对象对象的定义对象是键值对的集合。 12345678var object_name = { key1: \"value1\", // 标量 key2: \"value\", key3: function() { // 函数 }, key4:[\"content1\", \"content2\"] //集合} 1234567var sites = { site1:\"Runoob\", site2:\"Google\" }; // 访问对象的值console.log(sites.site1) console.log(sites.site2) 类型模板js对象添加方法： 12345678var sites = { site1: \"Runoob\", site2: \"Google\"};sites.sayHello = function() { return \"hello\";} ts中的对象必须是特定类型的实例： 123456789var sites = { site1: \"Runoob\", site2: \"Google\", sayHello: function () { } // 类型模板};sites.sayHello = function () { console.log(\"hello \" + sites.site1);};sites.sayHello(); 鸭子类型鸭子类型是动态类型的一种风格，是多态的一种形式。 123456789101112131415interface IPoint { x:number y:number } function addPoints(p1:IPoint,p2:IPoint):IPoint { var x = p1.x + p2.x var y = p1.y + p2.y return {x:x,y:y} } // 正确var newPoint = addPoints({x:3,y:4},{x:5,y:1}) // 错误 var newPoint2 = addPoints({x:1},{x:4,y:3}) 命名空间命名空间是用来解决命名重名的问题。命名空间定义了标识符的可见范围。ts中使用 namespace 来定义命名空间。 定义命名空间： 1234namespace SomeNameSpaceName { export interface ISomeInterfaceName { } export class SomeClassName { } } 使用 export 关键字让外部可以调用 SomeNameSpaceName 中的类和接口。 在另一个命名空间调用： 1SomeNameSpaceName.SomeClassName; 如果一个命名空间在一个单独的ts文件中，使用 /// 引用它： 1/// &lt;reference path = \"SomeFileName.ts\" /&gt; 嵌套命名空间可以将一个命名空间定义在另一个命名空间里面, 成员的访问使用点号。 模块 TypeScript 模块的设计理念是可以更换的组织代码。模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的JavaScript模块加载器是服务于 Node.js 的 CommonJS 和服务于 Web 应用的 Require.js。此外还有有 SystemJs 和 Webpack。 使用 export 关键字导出模块： 1234// 文件名 : SomeInterface.ts export interface SomeInterface { // 代码部分} 使用 import 关键字导入上面的模块： 1import someInterfaceRef = require(\"./SomeInterface\"); 声明文件声明 TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。 实例：ts获取id在js中： 1234// js中使用jquery获取id$('#foo');// 或jQuery('#foo'); 在ts中： 123// 用declare关键字定义它的类型declare var jQuery: (selector: string) =&gt; any;jQuery('#foo'); 上面代码的编译结果是： 1jQuery('#foo'); 声明文件声明文件以 .d.ts 结尾。 声明文件或者模块： 12declare module Module_Name {} ts引入声明文件： 1/// &lt;reference path = \" runoob.d.ts\" /&gt; 实例：这是一个第三方库文件：CalcThirdPartyJsLib.js 1234567891011121314151617var Runoob;(function(Runoob) { var Calc = (function() { function Calc() {} }) Calc.prototype.doSum = function(limit) { var sum = 0; for (var i = 0; i &lt;= limit; i++) { sum = sum + i; } return sum; } Runoob.Calc = Calc; return Calc;})(Runoob || (Runoob = {}));var test = new Runoob.Calc(); 在ts中引用上面的文件，在声明文件中要这样写： 12345declare module Runoob { export class Calc { doSum(limit:number) : number; }} 把声明文件加入到ts中： 1234/// &lt;reference path = \"Calc.d.ts\" /&gt; var obj = new Runoob.Calc(); // obj.doSum(\"Hello\"); // 编译错误console.log(obj.doSum(10)); 然后编译ts文件。 然后在html中引入编译后的文件以及第三方库文件： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src=\"CalcThirdPartyJsLib.js\"&gt;&lt;/script&gt; &lt;script src=\"CalcTest.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 总结接口、类、对象、命名空间、模块以及声明文件需要再配合其他资料理解一下。 参考 https://www.runoob.com/typescript/ts-tutorial.html https://www.tslang.cn/docs/handbook/basic-types.html https://ts.xcatliu.com/","link":"/2020/12/03/typescript-tutorial/"},{"title":"对于当前社会中的学习的思考","text":"概述人类文明从工业革命开始直到现在的移动互联网时代以及即将到来的人工智能时代，其两百年间所取得的科学技术的成就远超过去几千年的总和。 \b在科学技术飞速发展的同时，借助于互联网和移动互联网的兴起，大量的知识和经验在其中被不断的输出到人类社会的知识库中，并且借助于终端设备和网络的普及使得大量的人可以以极低的成本和门槛接触到大量的专业知识。 同时，大量的专业知识也在其中得以被高速的迭代升级。举个例子：两百年前的一个普通人只要学会纺织或者打铁就能靠此技能安生立命一辈子。但是当代社会变化速度过快，\b几年前的技能已经不能满足当前的社会要求了，前端的发展甚至几个月都会又一次巨变。 持续学习、持续实践软件开发中有一个概念叫持续集成(CI)、持续部署(CD)。就我个人而言，我希望我自己可以做到持续学习(CL)、持续实践(CP)。持续学习、持续实践是什么意思呢？\b就是持续的吸收工作所需要的技术和适应当前社会生存所需要的各种技能和心态的调整，并且在持续的学习中进行对固化思维的持续更新。再在实际工作和生活中将学习的内容得以实践。 终身学习由持续学习便引来了终身学习。 大多数人怎么想我不管，对我来说，人生不只是：毕业&gt;结婚&gt;生娃&gt;养娃&gt;教育娃&gt;等娃结婚&gt;娃为自己养老送终，这么简单。 从很早我就发现我和常人不一样，我对自己的判断是：我和人群中的大多数人不一样，我是人群中能够翻出一些水花的人。 所以终身学习就成了我去年开始的slogan。我以前从来没立过slogna，但是我发现我现在需要终身学习，所以slogan就是博客的profile上面的那句”A lifelong learner”。 学习什么对于我一个互联网行业的从业者而言，学习的内容除了更新的技术和其他计算机技术之外，还有如下内容： 对于行业发展趋势的预测和判断。 对于国家政策推动产业的了解。 对于未来人们生活方式变化的了解。","link":"/2020/09/01/think-about-learning/"},{"title":"Vue2和Vue3的区别","text":"Vue2和Vue3的区别。 Vue2和Vue3的数据绑定原理发生了变化Vue2利用 Object.defineProperty() 完成的对数据的劫持，结合发布订阅来实现的双向数据绑定，但是只能监听某一个属性，不能对整个对象进行监听。 Vue3使用的是es6的 Proxy 的API来完成的双向数据绑定，可以监听整个对象。 Vue3支持多个根节点Vue2只支持一个页面根节点，vue3支持多个。 Vue3可以使用composition APIcomposition API可以让我们通过代码功能的不同来分组API，可以使得代码更加直观。 Vue2数据定义在 data 里面，方法定义在 methods 里面。 Vue3可以首先引入 reactive ， setup 中使用reactive将变量包装为响应式变量，在setup的最后 return 这些响应式变量，最后 template 中就可以使用这些变量。 生命周期的变化Vue2--------------Vue3 beforeCreate -&gt; setup() created -&gt; setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted activated -&gt; onActivated deactivated -&gt; onDeactivated errorCaptured -&gt; onErrorCapturedVue3可以按需引用Vue3按需引用api。","link":"/2022/08/30/vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Vue3学习笔记","text":"Vue只关注视图层，采用自底向上增量开发的设计。Vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。 实例： 123&lt;div id=\"hello-vue\" class=\"demo\"&gt; {{ message }}&lt;/div&gt; 起步安装 下载文件并引入(vue.global.js) cdn引入(vue.global.js) npm安装 1234567891011121314# 安装升级cnpmnpm install -g cnpm# 安装vue3cnpm install vue@next# 安装vue-clicnpm install -g @vue/cli# 查看版本vue --version# 如果已经安装了vue2，则cnpm install -g @vue/cli-init 创建项目12345# 创建项目，选项可以回车vue init webpack project_name# 运行cnpm run dev 还可以使用Vite构建vue项目。 123456789101112# 安装vitecnpm install -g create-vite-app# 使用vite创建vue项目create-vite-app project_namecva project_namecnpm init vite-app project_name# 运行cd project_namecnpm installcnpm run dev 构建生成dist目录，然后放到服务器。 1npm run build 搭建服务器12345# python serverpython -m http.server --directory [dist_dir]# npxnpx http-server 目录结构 src/App.vue12345678910111213141516171819&lt;!-- 展示模板 --&gt;&lt;template&gt; &lt;img alt=\"Vue logo\" src=\"./assets/logo.png\" /&gt; &lt;HelloWorld msg=\"Hello Vue 3.0 + Vite\" /&gt;&lt;/template&gt;&lt;!-- Vue 代码 --&gt;&lt;script&gt;/* 从 src/components/HelloWorld.vue 中引入 HelloWorld 组件 */import HelloWorld from './components/HelloWorld.vue'export default { name: 'App', components: { HelloWorld }}&lt;/script&gt; 起步学习Vue3阶段可以直接引入vue.global.js文件。 引入vue.global.js1&lt;script crossorigin=\"anonymous\" integrity=\"sha512-+i5dAv2T8IUOP7oRl2iqlAErpjtBOkNtREnW/Te+4VgQ52h4tAY5biFFQJmF03jVDWU4R7l47BwV8H6qQ+/MfA==\" src=\"https://lib.baomitu.com/vue/3.0.7/vue.global.js\"&gt;&lt;/script&gt; Vue3中的应用是通过使用 createApp 函数来创建的，语法格式如下： 1234567891011// 创建vue3应用const app = Vue.createApp({ /* 选项 选项用于配置根组件 mount()应用时，该组件被用作渲染的起点 */})// 配置根组件HelloVueApp，挂载应用到#hello-vueVue.createApp(HelloVueApp).mount('#hello-vue') 实例： 123456789101112131415&lt;div id=\"hello-vue\" class=\"demo\"&gt; &lt;!-- {{ }}用于输出对象属性和函数返回值 --&gt; {{ message }}&lt;/div&gt;​&lt;script&gt; const HelloVueApp = { data() { return { message: 'Hello Vue!!' } } }​ Vue.createApp(HelloVueApp).mount('#hello-vue')&lt;/script&gt; datadata 是一个函数，返回一个对象。 vm.$data.count == vm.count 123456789101112131415161718192021const app = Vue.createApp({ data() { return { count: 4 } }})const vm = app.mount('#app')document.write(vm.$data.count) // =&gt; 4document.write(\"&lt;br&gt;\")document.write(vm.count) // =&gt; 4document.write(\"&lt;br&gt;\")// 修改 vm.count 的值也会更新 $data.countvm.count = 5document.write(vm.$data.count) // =&gt; 5document.write(\"&lt;br&gt;\")// 反之亦然vm.$data.count = 6document.write(vm.count) // =&gt; 6 methods可以在组件中添加方法，使用 methods ， methods 是一个对象，包含了多个方法。 12345678910111213141516171819202122const app = Vue.createApp({ data() { return { count: 4 } }, methods: { // increment方法 increment() { // this指向该组件实例 this.count++ } }})const vm = app.mount('#app')document.write(vm.count) // =&gt; 4document.write(\"&lt;br&gt;\")vm.increment()document.write(vm.count) // =&gt; 5 在一个方法中调用另一个方法： 123456789101112131415161718const app = Vue.createApp({ data() { return { } }, methods: { func1() { }, func2() { // 在func2中调用func1 this.$options.methods.func1(); } }})const vm = app.mount('#app') 模板语法插值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!-- 文本插值，动态更新 --&gt;&lt;div id=\"app\"&gt; &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt;&lt;!-- 一次性插值 --&gt;&lt;span v-once&gt;这个将不会改变: {{ message }}&lt;/span&gt;&lt;!-- 插入html --&gt;&lt;div id=\"example1\" class=\"demo\"&gt; &lt;p&gt;使用双大括号的文本插值: {{ rawHtml }}&lt;/p&gt; &lt;p&gt;使用 v-html 指令: &lt;span v-html=\"rawHtml\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; const RenderHtmlApp = { data() { return { rawHtml: '&lt;span style=\"color: red\"&gt;这里会显示红色！&lt;/span&gt;' } } } Vue.createApp(RenderHtmlApp).mount('#example1')&lt;/script&gt;&lt;!-- 属性 --&gt;&lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt;&lt;button v-bind:disabled=\"isButtonDisabled\"&gt;按钮&lt;/button&gt;&lt;div id=\"app\"&gt; &lt;label for=\"r1\"&gt;修改颜色&lt;/label&gt;&lt;input type=\"checkbox\" v-model=\"use\" id=\"r1\"&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 如果use为true则使用class1 --&gt; &lt;div v-bind:class=\"{'class1': use}\"&gt; v-bind:class 指令 &lt;/div&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { use: false } } } Vue.createApp(app).mount('#app')&lt;/script&gt;&lt;!-- 表达式，每个绑定都只能包含单个表达式 --&gt;&lt;div id=\"app\"&gt; &lt;!-- 算术运算 --&gt; {{5+5}}&lt;br&gt; &lt;!-- 三元运算符 --&gt; {{ ok ? 'YES' : 'NO' }}&lt;br&gt; &lt;!-- js表达式 --&gt; {{ message.split('').reverse().join('') }} &lt;!-- 字符串连接 --&gt; &lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; const HelloVueApp = { data() { return { ok: true, message: 'message', id: 1 } } } Vue.createApp(HelloVueApp).mount('#hello-vue')&lt;/script&gt; tips：每个绑定只能包含单个表达式。指令指令是带有 v- 前缀的特殊属性。指令用于在表达式的值改变时，将某些行为应用到DOM上。 12345678910111213141516&lt;div id=\"app\"&gt; &lt;!-- v-if指令将根据表达式seen的值(true或false)来决定是否插入p元素。 --&gt; &lt;p v-if=\"seen\"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { seen: true /* 改为false，信息就无法显示 */ } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 12345678910111213141516171819202122232425262728&lt;!-- v-for指令可以绑定数组的数据来渲染一个项目列表 --&gt;&lt;div id=\"app\"&gt; &lt;ol&gt; &lt;li v-for=\"site in sites\"&gt; {{ site.text }} &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { sites: [{ text: 'Google' }, { text: 'facebook' }, { text: 'Taobao' } ] } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 参数：参数在指令后以冒号指明。例如： v-bind 指令被用来响应地更新HTML属性。 123456789101112131415&lt;div id=\"app\"&gt; &lt;p&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; const HelloVueApp = { data() { return { url: 'https://www.baidu.com' } } } Vue.createApp(HelloVueApp).mount('#app')&lt;/script&gt; v-on: 12345678&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt; ... &lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt; ... &lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]=\"doSomething\"&gt; ... &lt;/a&gt; 修饰符： 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 输入v-model 指令用来在input、select、textarea、checkbox、radio等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 1234567891011121314151617&lt;!-- 可以使用v-model指令来实现双向数据绑定 --&gt;&lt;div id=\"app\"&gt; &lt;p&gt;{{ message }}&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { message: 'baidu' } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 缩写Vue.js为两个最为常用的指令提供了特别的缩写： 123456789&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt;&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 条件语句条件判断使用 v-if 指令，指令的表达式返回 true 时才会显示。 v-if v-else v-else-if v-show 使用 v-show 指令来根据条件展示元素： 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; tips: 这里注意v-if和v-show的区别。循环语句循环使用 v-for 指令。v-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且 site 是数组元素迭代的别名。 123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;ol&gt; &lt;li v-for=\"site in sites\"&gt; {{ site.text }} &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { sites: [{ text: 'Google' }, { text: 'baidu' }, { text: 'Taobao' } ] } } } Vue.createApp(app).mount('#app')&lt;/script&gt; v-for 还支持一个可选的第二个参数，参数值为当前项的索引： 123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;ol&gt; &lt;li v-for=\"(site, index) in sites\"&gt; {{ index }} -{{ site.text }} &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { sites: [{ text: 'Google' }, { text: 'baidu' }, { text: 'Taobao' } ] } } } Vue.createApp(app).mount('#app')&lt;/script&gt; v-for迭代对象v-for 可以通过一个对象的属性来迭代数据： 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"value in object\"&gt; {{ value }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { object: { name: '链接', url: 'http://www.baidu.com', slogan: '学的不仅是技术，更是梦想！' } } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 也可以提供第二个的参数为键名： 1234567&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key) in object\"&gt; {{ key }} : {{ value }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 第三个参数为索引： 1234567&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key, index) in object\"&gt; {{ index }}. {{ key }} : {{ value }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; v-for 迭代整数： 1234567&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"n in 10\"&gt; {{ n }} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 显示过滤/排序后的结果：可以对数组的元素进行处理后再显示出来，一般可以通过创建一个计算属性，来返回过滤或排序后的数组。 123456&lt;!-- 输出数组中的偶数： --&gt;&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"n in evenNumbers\"&gt;{{ n }}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 组件注册组件组件（Component）可以扩展HTML元素，封装可重用的代码。可以使用多个组件构建大型应用。 注册全局组件： 1234567const app = Vue.createApp({ ...})app.component('my-component', {}) 使用该组件： 1&lt;my-component&gt;&lt;/my-component&gt; vue组件实例： 123456789101112131415&lt;!-- vue应用挂载点 --&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt; // 创建vue应用 const app = Vue.createApp({}) // 在应用上注册组件componentA app.component('componentA', { template: '&lt;h1&gt;组件A&lt;/h1&gt;' }) // 将应用挂载到页面 app.mount('#app')&lt;/script&gt; 实例： button-counter 组件，在每次点击后，计数器会加1。 123456789101112131415161718&lt;script&gt; const app = Vue.createApp({}) app.component('button-counter', { data() { return { count: 0 } }, template: ` &lt;button @click=\"count++\"&gt; 点了 {{ count }} 次！ &lt;/button&gt; ` }) app.mount('#app')&lt;/script&gt; 组件复用组件可以多次复用： 12345&lt;div id=\"components-demo\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 全局组件注册全局组件： 12345678910111213&lt;div id=\"app\"&gt; &lt;baidu&gt;&lt;/baidu&gt;&lt;/div&gt;&lt;script&gt; const app = Vue.createApp({}) app.component('globalComponent', { template: '&lt;h1&gt;全局组件&lt;/h1&gt;' }) app.mount('#app')&lt;/script&gt; 局部组件可以通过一个js对象来定义组件，然后在 components 字段中定义要使用的组件： 12345678910// 定义组件const componentA = {}const componentB = {}const componentC = {} 12345678// 使用组件const app = Vue.createApp({ // 创建应用，通过components字段配置所使用到的组件 components: { 'component-a': componentA, 'component-b': componentB }}) 实例中的局部组件，只能在该实例中使用： 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;part-component&gt;&lt;/part-component&gt;&lt;/div&gt;&lt;script&gt; var partComponent = { template: '&lt;h1&gt;局部组件&lt;/h1&gt;' } const app = Vue.createApp({ components: { 'part-component': partComponent } }) app.mount('#app')&lt;/script&gt; propprop 是子组件用来接受父组件传递的数据的属性。 父组件通过 props 将数据传给子组件，子组件需要用 props 声明 prop ： 12345678910111213141516171819&lt;div id=\"appo\"&gt; &lt;site-name title=\"Google\"&gt; &lt;/site-namet&gt; &lt;site-name title=\"baidu\"&gt; &lt;/site-namet&gt; &lt;site-name title=\"Taobao\"&gt;&lt;/site-name&gt;&lt;/div&gt;&lt;script&gt; const app = Vue.createApp({}) app.component('site-name', { // 将title属性暴露给子组件 props: ['title'], template: `&lt;h4&gt;{{ title }}&lt;/h4&gt;` }) app.mount('#app')&lt;/script&gt; 动态prop： 可以使用 v-bind 动态绑定props的值到父组件的数据中。 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"app\"&gt; &lt;site-info v-for=\"site in sites\" :id=\"site.id\" :title=\"site.title\"&gt;&lt;/site-info&gt;&lt;/div&gt;&lt;script&gt; const Site = { data() { return { sites: [{ id: 1, title: 'Google' }, { id: 2, title: 'baidu' }, { id: 3, title: 'Taobao' } ] } } } const app = Vue.createApp(Site) app.component('site-info', { props: ['id', 'title'], template: `&lt;h4&gt;{{ id }} - {{ title }}&lt;/h4&gt;` }) app.mount('#app')&lt;/script&gt; prop验证： 组件可以给 props 指定验证条件。 1234567891011121314151617181920212223242526272829303132333435Vue.component('my-component', { props: { // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function() { return { message: 'hello' } } }, // 自定义验证函数 propF: { validator: function(value) { // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 } } }}) type 可以是下面原生构造器： String Number Boolean Array Object Date Function Symbol type 也可以是一个自定义构造器，使用 instanceof 检测。 $emit$emit 用于子组件向父组件传递数据。 具体方法是：子组件使用 $emit 触发自定义事件，父组件使用 v-on 指令监听子组件的自定义事件。 12// 子组件触发事件，args为传递给父组件的参数vm.$emit(eventName, [...args]); .sync父组件调用子组件时使用sync修饰符可以做到父子组件的属性的双向数据绑定。 12&lt;!-- val是父组件的数据 --&gt;&lt;child :value.sync=\"val\"&gt;&lt;/child&gt; 计算计算： computed 实例：反转字符串 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;p&gt;原始字符串: {{ message }}&lt;/p&gt; &lt;p&gt;计算后反转字符串: {{ reversedMessage }}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { message: 'baidu!!' } }, computed: { // 计算属性的 getter reversedMessage: function() { // this指向 vm 实例 return this.message.split('').reverse().join('') } } } Vue.createApp(app).mount('#app')&lt;/script&gt; computed vs methods可以使用 methods 代替 computed 。但是computed依赖缓存，只有依赖关系发生变化才会重新计算。而methods在重新渲染时总是会重新执行。 12345methods: { reversedMessage2: function() { return this.message.split('').reverse().join('') }} computed settercomputed属性默认只有 getter ，也可以设置 setter ： 1234567891011121314151617181920212223242526var vm = new Vue({ el: '#app', data: { name: 'Google', url: 'http://www.google.com' }, computed: { site: { // getter get: function() { return this.name + ' ' + this.url }, // setter set: function(newValue) { var names = newValue.split(' ') this.name = names[0] this.url = names[names.length - 1] } } }})// 调用 setter， vm.name 和 vm.url 也会被对应更新vm.site = '百度 http://www.baidu.com';document.write('name: ' + vm.name);document.write('&lt;br&gt;');document.write('url: ' + vm.url); 监听可以使用监听属性 watch 来响应数据变化。 使用watch实现计数器： 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;p style=\"font-size:25px;\"&gt;计数器: {{ counter }}&lt;/p&gt; &lt;button @click=\"counter++\" style=\"font-size:25px;\"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { counter: 1 } } } vm = Vue.createApp(app).mount('#app') vm.$watch('counter', function(nval, oval) { alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!'); });&lt;/script&gt; 样式绑定可以使用 v-bind 绑定属性，可以绑定字符串、对象、数组。 v-bind:class === :class 绑定class1234567891011121314&lt;!-- 根据isActive是true还是false来是否添加active这个class --&gt;&lt;div :class=\"{'active': isActive }\"&gt;&lt;/div&gt;&lt;!-- isActive为true --&gt;&lt;div class=\"active\"&gt;&lt;/div&gt;&lt;!-- isActive为false --&gt;&lt;div class=\"\"&gt;&lt;/div&gt;&lt;!-- :class可以与class属性共存 --&gt;&lt;div class=\"static\" :class=\"{ 'active' : isActive, 'text-danger' : hasError }\"&gt;&lt;/div&gt;&lt;!-- 直接绑定一个data中的对象 --&gt;&lt;div class=\"static\" :class=\"classObject\"&gt;&lt;/div&gt; 绑定数组12345&lt;!-- 绑定数组 --&gt;&lt;div class=\"static\" :class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt;&lt;!-- 三元表达式 --&gt;&lt;div class=\"static\" :class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt; style可以 v-bind:style 设置内联样式。 1&lt;div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"&gt;&lt;/div&gt; 可以直接绑定到一个样式对象： 1&lt;div :style=\"styleObject\"&gt;&lt;/div&gt; 使用数组将多个样式对象绑定到一个元素上： 1&lt;div :style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 可以给css样式同一个属性提供不同的值： 1&lt;div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"&gt;&lt;/div&gt; 组件中使用class下面四个class都会有： 123456789101112131415&lt;div id=\"app\"&gt; &lt;baidu class=\"classC classD\"&gt;&lt;/baidu&gt;&lt;/div&gt;&lt;script&gt; // 创建一个Vue 应用 const app = Vue.createApp({}) // 定义一个名为 baidu的新全局组件 app.component('baidu', { template: '&lt;h1 class=\"classA classB\"&gt;I like baidu!&lt;/h1&gt;' }) app.mount('#app')&lt;/script&gt; 如果组件有多个根元素，通过 $attrs 属性定义那些部分接受这个class： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;baidu class=\"classA\"&gt;&lt;/baidu&gt;&lt;/div&gt;&lt;script&gt; const app = Vue.createApp({}) app.component('baidu', { template: ` &lt;p :class=\"$attrs.class\"&gt;I like baidu!&lt;/p&gt; &lt;span&gt;这是一个子组件&lt;/span&gt; ` }) app.mount('#app')&lt;/script&gt; 事件处理可以使用 v-on 监听DOM事件。 v-on 可以缩写为 @ 。 123v-on:click=\"func\"@click=\"func\" v-on : 12345678910111213141516&lt;div id=\"app\"&gt; &lt;button @click=\"counter += 1\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 {{ counter }} 次。&lt;/p&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { counter: 0 } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 实例2: 1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button @click=\"greet\"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { name: 'baidu' } }, methods: { greet(event) { // `methods` 内部的 `this` 指向当前活动实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM event if (event) { alert(event.target.tagName) } } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 实例3：可以绑定多个方法，逗号隔开 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;!-- 这两个 one() 和 two() 将执行按钮点击事件 --&gt; &lt;button @click=\"one($event), two($event)\"&gt; 点我 &lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app = { data() {}, methods: { one(event) { alert(\"第一个事件处理器逻辑...\") }, two(event) { alert(\"第二个事件处理器逻辑...\") } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 事件修饰符Vue通过由点 . 表示的指令后缀来调用修饰符。 .stop - 阻止冒泡 .prevent - 阻止默认事件 .capture - 阻止捕获 .self - 只监听触发该元素的事件 .once - 只触发一次 .left - 左键事件 .right - 右键事件 .middle - 中间滚轮事件 123456789101112131415&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- click 事件只能点击一次，2.1.4版本新增 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 按键修饰符Vue允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=\"submit\"&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 1234&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 全部的按键别名： .enter .tab .delete (捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right 系统修饰键： .ctrl .alt .shift .meta 鼠标按钮修饰符: .left .right .middle 12345&lt;p&gt; &lt;!-- Alt + C --&gt; &lt;input @keyup.alt.67=\"clear\"&gt; &lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; .exact修饰符.exact 允许精准控制系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl=\"onClick\"&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact=\"onClick\"&gt;A&lt;/button&gt; 表单可以使用 v-model 在 input 、 textarea 和 select 等元素上创建双向数据绑定。 v-model 会忽略所有表单元素的value、checked、selected属性的初始值，使用的是data选项中声明初始值。 v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件： text和textarea元素使用value属性和input事件； checkbox和radio使用checked属性和change事件； select字段将value作为属性并将change作为事件。 使用v-model实现双向数据绑定： 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;p&gt;input 元素：&lt;/p&gt; &lt;input v-model=\"message\" placeholder=\"编辑我……\"&gt; &lt;p&gt;input 表单消息是: {{ message }}&lt;/p&gt; &lt;p&gt;textarea 元素：&lt;/p&gt; &lt;textarea v-model=\"message2\" placeholder=\"多行文本输入……\"&gt;&lt;/textarea&gt; &lt;p&gt;textarea 表单消息是:&lt;/p&gt; &lt;p style=\"white-space: pre\"&gt;{{ message2 }}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { message: '', message2: '百度\\r\\nhttps://www.baidu.com' } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 在文本区域 textarea 插值是不起作用，需要使用 v-model 来代替： 12345&lt;!-- 错误 --&gt;&lt;textarea&gt;{{ text }}&lt;/textarea&gt;&lt;!-- 正确 --&gt;&lt;textarea v-model=\"text\"&gt;&lt;/textarea&gt; 复选框双向数据绑定： 12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; &lt;p&gt;单个复选框：&lt;/p&gt; &lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt; &lt;label for=\"checkbox\"&gt;{{ checked }}&lt;/label&gt; &lt;p&gt;多个复选框：&lt;/p&gt; &lt;input type=\"checkbox\" id=\"baidu\" value=\"baidu\" v-model=\"checkedNames\"&gt; &lt;label for=\"baidu\"&gt;baidu&lt;/label&gt; &lt;input type=\"checkbox\" id=\"google\" value=\"Google\" v-model=\"checkedNames\"&gt; &lt;label for=\"google\"&gt;Google&lt;/label&gt; &lt;input type=\"checkbox\" id=\"taobao\" value=\"Taobao\" v-model=\"checkedNames\"&gt; &lt;label for=\"taobao\"&gt;taobao&lt;/label&gt; &lt;br&gt; &lt;span&gt;选择的值为: {{ checkedNames }}&lt;/span&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { checked: false, checkedNames: [] } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 单选按钮： 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;input type=\"radio\" id=\"baidu\" value=\"baidu\" v-model=\"picked\"&gt; &lt;label for=\"baidu\"&gt;baidu&lt;/label&gt; &lt;br&gt; &lt;input type=\"radio\" id=\"google\" value=\"Google\" v-model=\"picked\"&gt; &lt;label for=\"google\"&gt;Google&lt;/label&gt; &lt;br&gt; &lt;span&gt;选中值为: {{ picked }}&lt;/span&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { picked: 'baidu' } } } Vue.createApp(app).mount('#app')&lt;/script&gt; select: 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;select v-model=\"selected\" name=\"fruit\"&gt; &lt;option value=\"\"&gt;选择一个网站&lt;/option&gt; &lt;option value=\"www.baidu.com\"&gt;baidu&lt;/option&gt; &lt;option value=\"www.google.com\"&gt;Google&lt;/option&gt; &lt;/select&gt; &lt;div id=\"output\"&gt; 选择的网站是: {{selected}} &lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { selected: '' } })&lt;/script&gt; v-for: 123456789101112131415161718192021222324252627282930313233&lt;div id=\"app\" class=\"demo\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" :value=\"option.value\"&gt; {{ option.text }} &lt;/option&gt; &lt;/select&gt; &lt;span&gt;选择的是: {{ selected }}&lt;/span&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return { selected: 'www.baidu.com', options: [{ text: 'baidu', value: 'www.baidu.com' }, { text: 'Google', value: 'www.google.com' }, { text: 'Taobao', value: 'www.taobao.com' } ] } } } Vue.createApp(app).mount('#app')&lt;/script&gt; 值绑定： 修饰符：.lazy ：在change事件中更新而不是在input事件中更新。 1&lt;input v-model.lazy=\"msg\"&gt; .number ：转化为Number类型。 .trim ：过滤输入的首尾空格。 1&lt;input v-model.trim=\"msg\"&gt; 自定义指令Vue允许注册自定义指令。 注册一个自定义的全局指令 v-focus ，功能是页面加载时元素获得焦点: 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt;&lt;/div&gt;&lt;script&gt; const app = Vue.createApp({}) // 注册一个全局自定义指令 `v-focus` app.directive('focus', { // 当被绑定的元素挂载到 DOM 中时…… mounted(el) { // 聚焦元素 el.focus() } }) app.mount('#app')&lt;/script&gt; 还可以在实例中directives注册局部指令： 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt;&lt;/div&gt;&lt;script&gt; const app = { data() { return {} }, directives: { focus: { // 指令的定义 mounted(el) { el.focus() } } } } Vue.createApp(app).mount('#app') 钩子函数指令定义函数提供了几个钩子函数（可选）： created : 在绑定元素的属性或事件监听器被应用之前调用。 beforeMount : 指令第一次绑定到元素并且在挂载父组件之前调用。。 mounted : 在绑定元素的父组件被挂载后调用。。 beforeUpdate: 在更新包含组件的 VNode 之前调用。。 updated: 在包含组件的 VNode 及其子组件的 VNode 更新后调用。 beforeUnmount: 当指令与元素解除绑定且父组件已卸载时，只调用一次。 unmounted: 当指令与元素解除绑定且父组件已卸载时，只调用一次。 实例： 12345678910111213141516171819202122232425262728293031import { createApp} from 'vue'const app = createApp({})// 注册app.directive('my-directive', { // 指令是具有一组生命周期的钩子： // 在绑定元素的 attribute 或事件监听器被应用之前调用 created() {}, // 在绑定元素的父组件挂载之前调用 beforeMount() {}, // 绑定元素的父组件被挂载时调用 mounted() {}, // 在包含组件的 VNode 更新之前调用 beforeUpdate() {}, // 在包含组件的 VNode 及其子组件的 VNode 更新之后调用 updated() {}, // 在绑定元素的父组件卸载之前调用 beforeUnmount() {}, // 卸载绑定元素的父组件时调用 unmounted() {}})// 注册 (功能指令)app.directive('my-directive', () =&gt; { // 这将被作为 `mounted` 和 `updated` 调用})// getter, 如果已注册，则返回指令定义const myDirective = app.directive('my-directive') 钩子函数参数 el: 绑定到的元素 binding: 一个对象，包含instance, value, oldValue, arg, modifiers, dir。 vnode prevNode 路由路由允许我们通过不同的url访问不同的内容。可以实现单页面多视图应用。 需要引入vue-router。 引入 引入文件: https://unpkg.com/vue-router@4.0.5/dist/vue-router.global.js npm安装：cnpm install vue-router@4 12345678910111213141516&lt;script src=\"https://unpkg.com/vue@3\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/vue-router@4\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!--使用 router-link 组件进行导航 --&gt; &lt;!--通过传递 `to` 来指定链接 --&gt; &lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt; &lt;router-link to=\"/\"&gt;Go to Home&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;Go to About&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; router-view将显示与url对应的组件。你可以把它放在任何地方，以适应你的布局。 混入混入（mixins）定义了一部分可复用的方法或者计算属性。 实例： 123456789101112131415161718// 定义混入对象const myMixin = { created() { this.hello() }, methods: { hello() { console.log('欢迎来到混入实例-baidu!') } }}// 定义一个应用，使用混入const app = Vue.createApp({ mixins: [myMixin]})app.mount('#app') // =&gt; \"欢迎来到混入实例-baidu!\" axiosaxios是一个基于 Promise 的http库。可用于浏览器和node。 安装： 直接引入文件。 npm：cnpm install axios -S 使用： 1234567891011Vue.axios.get(api).then((response) =&gt; { console.log(response.data);})this.axios.get(api).then((response) =&gt; { console.log(response.data);})this.$http.get(api).then((response) =&gt; { console.log(response.data);}) GET读取JSON123456789101112131415161718192021const app = { data() { return { info: 'Ajax 测试!!' } }, mounted () { axios .get('https://www.baidu.com/try/ajax/json_demo.json') .then(response =&gt; (this.info = response)) .catch(function (error) { // 请求失败处理 console.log(error); }); }} Vue.createApp(app).mount('#app') GET传参： 123456789101112131415161718192021// 直接在 URL 上添加参数 ID=12345axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // 也可以通过 params 设置参数：axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); POST12345678910111213141516new Vue({ el: '#app', data() { return { info: null } }, mounted() { axios .post('https://www.baidu.com/try/ajax/demo_axios_post.php') .then(response =&gt; (this.info = response)) .catch(function(error) { // 请求失败处理 console.log(error); }); }}) POST传参： 12345678910axios.post('/user', { firstName: 'Fred', // 参数 firstName lastName: 'Flintstone' // 参数 lastName }) .then(function(response) { console.log(response); }) .catch(function(error) { console.log(error); }); 执行多个并发请求1234567891011function getUserAccount() { return axios.get('/user/12345');}function getUserPermissions() { return axios.get('/user/12345/permissions');}axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function(acct, perms) { // 两个请求现在都执行完成 })); axios API可以通过向axios传递配置来创建请求： 12345678910111213141516171819202122axios(config)// 发送 POST 请求axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' }});// GET 请求远程图片axios({ method: 'get', url: 'http://bit.ly/2mTM3nY', responseType: 'stream' }) .then(function(response) { response.data.pipe(fs.createWriteStream('ada_lovelace.jpg')) });axios(url[, config])// 发送 GET 请求（默认的方法）axios('/user/12345'); 请求方法的别名： 1234567axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。并发： 12axios.all(iterable)axios.spread(callback) 创建实例： 12345678axios.create([config])const instance = axios.create({ baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: { 'X-Custom-Header': 'foobar' }}); 实例方法： 1234567axios #request(config)axios #get(url[, config])axios #delete(url[, config])axios #head(url[, config])axios #post(url[, data[, config]])axios #put(url[, data[, config]])axios #patch(url[, data[, config]]) 拦截器在请求被 then 或者 catch 处理之前拦截。 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function(config) { // 在发送请求之前做些什么 return config;}, function(error) { // 对请求错误做些什么 return Promise.reject(error);});// 添加响应拦截器axios.interceptors.response.use(function(response) { // 对响应数据做点什么 return response;}, function(error) { // 对响应错误做点什么 return Promise.reject(error);}); 移除拦截器： 1234var myInterceptor = axios.interceptors.request.use(function() { /*...*/});axios.interceptors.request.eject(myInterceptor); 常用钩子函数toRefs当使用reactive创建一个响应式对象后，如果想解构这个对象的属性，可能会失去这些属性的响应性。为了避免这种情况，可以使用toRefs。 toRefs可以用来解构响应式的对象，并且可以让解构出来的变量保持响应式。 123456789import { reactive, toRefs } from 'vue'let info = reactive({ name: 'Mason', age: 22, gender: 'male',})let { name, age, gender } = toRefs(info) 调试使用浏览器调试vue。 浏览器安装vue.js devtools插件 vue开启配置 main.js 添加： main.js1Vue.config.devtools = true ref https://v3.cn.vuejs.org/guide/introduction.html 《Vue 3.0从入门到精通》","link":"/2021/03/25/vue3-tutorial/"},{"title":"vue3中引入jquery","text":"安装jquerybash12# 1.x版本cnpm i jquery@1.12.4 -S 编辑vue.config.js文件根目录下创建vue.config.js文件： vue.config.js12345678910111213const webpack = require(\"webpack\");module.exports = { configureWebpack: { plugins: [ new webpack.ProvidePlugin({ $:\"jquery\", jQuery:\"jquery\", \"windows.jQuery\":\"jquery\" }) ] },}; 引用在组件中引用： js1import $ from 'jquery' 另一种方法ref: https://blog.nickschnee.ch/vuejquery/ 先安装jquery模块 在main.js中： js12345import jQuery from 'jquery'global.$ = jQuery// 或者Vue.prototype.$ = jquery 这样就可以全局使用$了。","link":"/2021/11/17/vue%E4%B8%AD%E5%BC%95%E5%85%A5jquery/"},{"title":"WebAssembly（wasm）入门","text":"WebAssembly（wasm）是一种新的二进制格式，他可以将c/c++（还有go、rust）等静态语言代码快速的运行在浏览器上。wasm的这个特点就为前端的计算密集型应用提供了无限可能，甚至可以将基于unity开发的游戏移植到web端。 wasm可以让web应用运行更快，文件体积小，启动速度快，运行速度快。其性能对比js而言提升非常明显。 参考 文档：https://www.wasm.com.cn/ 《深入浅出WebAssembly》","link":"/2020/09/22/wasm-tutorial/"},{"title":"youtube快捷键","text":"youtube网页按ctrl+/来查看youtube网页端快捷键。","link":"/2018/11/27/youtube-shortcut-key/"},{"title":"详解webpack loader","text":"webpack loader用于转换各种代码，比如loader可以将ts转为js、将内联图像转为data URL，以及可以直接import各种文件。 安装需要的loader1cnpm i -D css-loader ts-loader loader还支持sass, less, stylus, coffeescript等。 配置loader为不同文件配置不同的loader： webpack.config.js12345678module.exports = { module: { rules: [ { test: /\\.css$/, use: 'css-loader' }, { test: /\\.ts$/, use: 'ts-loader' } ] }}; ref https://www.webpackjs.com/loaders/","link":"/2019/01/07/webpack-loader/"},{"title":"乐观锁和悲观锁","text":"乐观锁和悲观锁是在并发控制中常用的两种策略。 他们用于处理在多个进程同时访问共享资源时的情况。 悲观锁（Pessimistic Locking）概念：悲观锁会假定发生并发冲突，所以在访问资源之前会获取锁，在使用期间保持锁定状态。 优点：悲观锁是一个有序队列，不存在冲突所以没有重试开销，可以处理并发冲突高的场景，保证了数据一致性和完整性。缺点：悲观锁可能会导致队列堵塞、并发度偏低。 乐观锁（Optimistic Locking）概念：乐观锁会假定不会发生并发冲突，所以在访问共享资源的时候不会立刻上锁，而是在执行更新操作时检查是否发生了冲突（检查数据是否发生了变动），如果发生了冲突，则重读数据重新执行更新操作。 那么乐观锁怎么知道是否发生了冲突呢，可以通过给记录加一个version字段来判断数据是否冲突。比如多个进程使用乐观锁操作同一个记录的amount字段时候，每个进程会先获取该记录的amount字段和version字段，然后执行业务操作，最后在写入的时候再获取一下verison字段，如果和之前一样则表示无冲突，则写入新的amount并更新version。如果version和之前不同，则回退并重新执行获取amount和version继续往下。 优点：任务不会堵塞，并发度高。缺点：处理冲突的开销高。 总结选择使用悲观锁还是乐观锁取决于应用场景和性能要求。 悲观锁适用于并发冲突概率较高的情况，保证数据的一致性和完整性。而乐观锁适用于并发冲突概率较低的情况，可以提高系统的并发性能。","link":"/2023/05/10/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"},{"title":"上手微信小程序开发","text":"小程序的css和js和其他前端项目一样，只是HTML换成了WXML标签，故而小程序的本质就是网页。 小程序和网页的区别是：小程序使用的是小程序内提供的API故而小程序不支持浏览器。 入门优势基于微信，故而可以调用微信的API比如拍照、支付、登录注册等，无需考虑平台差异因为微信小程序基于微信平台。 前置知识 js css 开发准备 到微信公众平台注册申请一个appid，得到一个appid和appsecret。 下载微信提供的小程序开发工具，用于运行和调试。 上手这里不使用微信新建小程序的功能，手动从头到尾写一下小程序的结构。 新建项目目录比如hello 新建app.js文件 app.js12// 新建一个小程序实例，可以传入一个配置对象App(); 新建配置文件app.json，记录了一些配置。 app.json123456{ // pages属性表明小程序包含哪些页面，值是一个数组，数组的每一项就是一个页面 \"pages\": [ \"pages/home/home\" ]} 其中 &quot;pages/home/home&quot; 中的pages存放所有的页面，每一个页面都有自己的目录，这里的页面的目录名是第一个home，小程序会加载页面目录下的home.js文件（扩展名可以省略），故而这个目录表示小程序加载pages目录下的home页面下的home.js文件，home.js文件名可以随便起名。 新建home页面目录和下面的home.js文件 12mkdir -p pages/hometouch pages/home/home.js home.js12// Page()方法由小程序提供用于初始化一个页面实例，参数是一个配置对象Page({}); 在pages/home下新建一个home.wxml文件，wxml是类似于html的微信页面标记语言。 1hello world 打开微信小程序开发工具，导入hello项目。 WXML语言wxml文件类似于html文件，也是在里面写各种标记语言。 不过使用的是微信小程序提供的wxml的标签。 常用标签： view：表示一个区块，用于区别其他区块，类似于div text：表示一段inline文本，类似span 项目结构|- app.json |- app.js |- pages |- home |- home.wxml |- home.js所有的小程序都是类似上面的结构。 项目配置文件app.json是小程序项目的全局配置文件。 app.json中还有window属性，用于设置小程序的窗口。 app.json123456789101112131415{ \"pages\": [ \"pages/home/home\" ], \"window\": { // window是一个对象 // 导航栏颜色 \"navigationBarBackgroundColor\": \"#ff0000\", // 导航栏文本颜色，black或者white（默认） \"navigationBarTextStyle\": \"white\", // 导航栏标题 \"navigationBarTitleText\": \"小程序 Demo\" }} 除此之外，app.json还可以配置各种组件，比如选项卡。 样式全局样式小程序允许在项目根目录防止一个app.wxss文件，他是一个全局样式文件，里面写css。 app.wxss123456789/* 页面选择器 */page { /* style */}/* text选择器 */text { /* style */} flex布局官方推荐使用flex布局。 如果要书写局部样式，比如要对pages/home这个页面写一个专门的样式文件，则需要在该目录下新建home.wxss文件，该文件的样式只对于home页面生效。 home页面的flex布局： home.wxss1234567891011page { /* 将页面高度设置为屏幕的高度 */ height: 100%; /* 将页面的宽度设置为屏幕的宽度，小程序的总宽度为750rpx */ width: 750rpx; display: flex; /* 页面一级子元素采用水平居中 */ justify-content: center; /* 页面一级子元素垂直居中 */ align-items: center;} weui腾讯提供了一套ui框架叫weui。 weui demo：weui.io weui的小程序版本是weui-wxss。 使用weui-wxss： 将weui.wxss文件复制到app.wxss头部。 给wxml文件加上weui-wxss的class，类似bootstrap。 home.wxml1234567891011&lt;view&gt; &lt;button class=\"weui-btn weui-btn_primary\"&gt; 主操作 &lt;/button&gt; &lt;button class=\"weui-btn weui-btn_primary weui-btn_loading\"&gt; &lt;i class=\"weui-loading\"&gt;&lt;/i&gt;正在加载 &lt;/button&gt; &lt;button class=\"weui-btn weui-btn_primary weui-btn_disabled\"&gt; 禁止点击 &lt;/button&gt;&lt;/view&gt; 用到什么class就查文档。 轮播图home.wxml1234567891011121314151617181920&lt;view&gt; &lt;!-- swiper是轮播图组件 --&gt; &lt;swiper indicator-dots=\"{{true}}\" autoplay=\"{{true}}\" style=\"width: 750rpx;\"&gt; &lt;!-- 图片一 --&gt; &lt;swiper-item&gt; &lt;image src=\"https://picsum.photos/200\"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;!-- 图片二 --&gt; &lt;swiper-item&gt; &lt;image src=\"https://picsum.photos/250\"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;!-- 图片三 --&gt; &lt;swiper-item&gt; &lt;image src=\"https://picsum.photos/300\"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt;&lt;/view&gt; 加入脚本数据绑定就是脚本里面的某些数据，可以自动成为页面的全局变量，两者绑定，也就是MVVM。 home.js12345Page({ data: { name: '张三' }}); home页面可以自动读取上面的data。 绑定到页面中： 123&lt;view&gt; &lt;text class=\"title\"&gt;hello {{name}}&lt;/text&gt;&lt;/view&gt; 如果需要在js中读取data中的变量则需要这样写：this.data.name 全局变量数据绑定只对于当前页面有效，如果需要页面之间共享数据则需要写入全局配置中。 app.js123456App({// 全局data globalData: { now: (new Date()).toLocaleString() }}); 现在全局变量配置好了，在页面中获取变量： home.js12345678// getApp方法用于获取app实例const app = getApp();Page({ data: { now: app.globalData.now }}); 事件小程序常用事件： tap：触摸后离开 longpress：长按，超过350ms触发 touchstart：触摸开始 touchmove：触摸后移动 touchcancel：触摸后被打断 touchend：触摸结束 事件的传播分两个阶段：捕获（从外层元素到内层元素捕获），然后是冒泡（从内层元素到外层元素传播），故而一个事件在同一个元素会触发两次。 小程序允许指定元素的触发阶段，方法是为事件属性名加上下面的前缀： capture-bind：捕获阶段触发。 capture-catch：捕获阶段触发，并中断事件，不再向下传播，即中断捕获阶段，并取消随后的冒泡阶段。 bind：冒泡阶段触发。 catch：冒泡阶段触发，并取消事件进一步向上冒泡。 home.wxml12345&lt;view&gt; &lt;text class=\"title\"&gt;hello {{name}}&lt;/text&gt; &lt;!-- 这里为button添加了一个bind属性，在tap事件后的冒泡阶段触发buttonHandler --&gt; &lt;button bind:tap=\"buttonHandler\"&gt;点击&lt;/button&gt;&lt;/view&gt; home.js12345678910111213Page({ data: { name: '张三' },// event是事件对象 buttonHandler(event) { // this指向页面实例 // 不能直接修改data，需要通过setData修改data，然后触发绑定机制导致页面上的全局变量发生变化 this.setData({ name: '李四' }); }}); 动态提示Toast小程序使用Toast给用户提示。 home.js123456789101112131415161718Page({ data: { name: '张三' }, buttonHandler(event) { // setData的第二个参数是回调函数 this.setData({ name: '李四' }, function () { // 调用Toast，传入一个配置对象 // wx对象是微信小程序提供的原生对象，所有的API都定义在这个对象上面 wx.showToast({ title: '操作完成', duration: 700 }); }), }}); 对话框Modal使用wx.showModal()可以新建一个对话框。 home.js12345678910111213141516171819202122232425262728293031323334Page({ data: { name: '张三' }, buttonHandler(event) { // 获取页面实例that const that = this; // 对于showModal方法传入一个配置对象 wx.showModal({ title: '操作确认', content: '你确认要修改吗？', // 成功后的回调方法 success (res) { // 使用res.confirm判断用户点击的是确定还是取消 if (res.confirm) { that.setData({ name: '李四' }, function () { wx.showToast({ title: '操作完成', duration: 700 }); }); } else if (res.cancel) { console.log('用户点击取消'); } }, // 失败后的回调 fail(res) { // 失败处理 } }); }}); APIWXML渲染语法12345Page({ data: { items: ['事项 A', '事项 B', '事项 C'] }}); wxml中遍历items： 12345&lt;view&gt; &lt;text class=\"title\" wx:for=\"{{items}}\"&gt; {{index}}、 {{item}} &lt;/text&gt;&lt;/view&gt; 客户端数据存储小程序允许将一部分数据保存在客户端（微信）中，方便读取。 本地存储（同步）：wx.setStorageSync(key, value)本地读取（同步）：wx.getStorageSync(key) 客户端存储主要用于缓存不重要的数据。 远程数据请求发布出去的小程序所请求的服务器域名都是要事先登记的，但是开发阶段没有限制（需要在本地设置里面勾选）。 请求：wx.request({})，参数是一个配置对象。 open-data组件&lt;open-data&gt;&lt;/open-data&gt;组件可以在页面上显式用户的身份信息。 12345&lt;view&gt; &lt;!-- type属性指定要显示的用户信息类型 --&gt; &lt;open-data type=\"userAvatarUrl\"&gt;&lt;/open-data&gt; &lt;open-data type=\"userNickName\"&gt;&lt;/open-data&gt;&lt;/view&gt; 其他信息类型： userNickName：用户昵称 userAvatarUrl：用户头像 userGender：用户性别 userCity：用户所在城市 userProvince：用户所在省份 userCountry：用户所在国家 userLanguage：用户的语言 获取用户个人信息获取用户个人信息需要得到授权，可以通过按钮获取用户授权。 wxml代码： 123456&lt;view&gt; &lt;text class=\"title\"&gt;hello {{name}}&lt;/text&gt; &lt;button open-type=\"getUserInfo\" bind:getuserinfo=\"buttonHandler\"&gt; 授权获取用户个人信息 &lt;/button&gt;&lt;/view&gt; js代码：获取用户信息 12345678910Page({ data: { name: '' }, buttonHandler(event) { // 实际开发中使用wx.getSetting()判断一下是否已经得到用户授权 if (!event.detail.userInfo) return; this.setData({ name: event.detail.userInfo.nickName }); }}); 页面跳转页面跳转的wxml方法： 小程序每个页面的路径都要放在配置文件app.json中的pages属性中。 pages数组第一个页面是小程序打开时默认展示的页面。 小程序页面之间通过navigator标签，url属性实现跳转。 页面跳转的js方法： 使用wx.navigateTo()方法，传入一个配置对象。 参考 微信小程序开发文档：https://developers.weixin.qq.com/miniprogram/dev/framework/ 微信小程序开发指南：https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a https://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-one.html https://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-two.html https://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-three.html https://www.ruanyifeng.com/blog/2020/11/wechat-miniprogram-tutorial-part-four.html 小程序面试题：https://vue3js.cn/interview/applet/applet.html","link":"/2022/07/07/%E4%B8%8A%E6%89%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"title":"为什么计算机无法产生真随机数","text":"为什么计算机无法产生真随机数？ 为什么计算机只能产生伪随机数现有计算机编程语言中产生随机数的算法都是伪随机数生成器（PRNG）。 算法是确定的计算机的随机数是由特定算法产生的，然而这些算法是确定的，对于这些算法输入相同的参数就会输出相同的结果。 故而随机数这个结果是由输入值确定的，所以计算机产生的是伪随机数（Pseudo-random Number）。 一般使用的算法有线性同余生成器（LCG）或梅森旋转器（Mersenne Twister）。 算法输出的结果是有限的由于计算机存在浮点数精度限制以及数字长度限制，所以输入到算法后输入的随机数也一定是精度有限的和长度有限的。 种子值决定了算法输出的结果伪随机数生成器产生的结果只依赖于种子值和算法，所以如果种子值是可以预测的，那么产生的随机数自然也是可以预测的。 如何产生真随机数获得一个真随机数生成器（TRNG）的关键在于如何获得一个不可预测的种子值，那么如何获得一个不可预测的种子值呢？ 计算机作为一个由数字电路构成的二进制电路是高度可预测的，故而计算机本身是无法产生随机的种子值的。 想要获得不可预测的种子值只能通过随机的物理事件。 在现有的物理学体系中可以产生随机事件的方式有下面几种： 热噪声热噪声是由导体内电子的热运动引起的随机电流或电压波动。通过测量这些波动，可以产生随机数。例如，一个电阻器或半导体器件在工作时会产生热噪声，通过放大和量化这些信号就可以得到随机数。 光电二极管噪声光电二极管在没有光照的情况下内部任然会有热运动和量子效应产生的噪声，通过放大和量化这些信号可以得到随机数。 量子力学中的不确定性根据海森堡不确定性原理，量子的位置和动量不能同时被精确测量，这两个量是随机的。量子的波函数坍塌是随机的。光量子在通过一个半反半透镜时是反射还是透过是随机的。光量子在通过量子分束器时通过的路径是随机的。 放射性元素衰变放射性元素的衰变间隔是随机的。 激光相位噪声激光产生的光具有内在的量子噪声，通过放大和量化光信号可以得到随机数。 混沌系统作为经典物理学中的最后一朵乌云，混沌系统对于初始条件的微小变化可以导致系统一段时间后具有完全不可预测的特性，可以量化后产生随机数。混沌系统比如湍流、混沌震荡器。 使用以上随机事件进行量化后作为种子值输入算法即可获取到真随机数。","link":"/2024/06/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%97%A0%E6%B3%95%E4%BA%A7%E7%94%9F%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"title":"分布式session","text":"在传统的单体应用中，后台只需要根据session获取用户身份的和信息既可。在集群中也只需要将用户的请求通过一种hash算法均匀的映射到多台服务器（且每次都映射到同一台服务器）既可，。而在分布式的应用中如何处理session呢？ 一个分布式的应用是由多个模块构成，模块可能不在一个服务器上，一个模块可能也部署了集群，如何保证集群+分布式应用上的session可用呢。 策略一：粘性session粘性session就是将用户的请求绑定到一台服务器上。 实现过程： 负载均衡服务器将用户的请求通过哈希算法均匀的映射到服务器上。 以后每次该用户的请求都会被负载均衡服务器转发到这个服务器上。 这样用户的session就会存储在一台服务器上。 策略二：session复制session复制就是对session增删改之后会将session广播给其他模块以保证session同步。 策略三：session共享通过redis、memcached共享session。 方案一：redis对于session的分布式，就是模块之间的session共享，将session放入缓存就实现了session的共享。 可以通过redis实现： 1redisTemplate.opsForValue().set(\"session\", json); 其他模块读取缓存： 1String json = redisTemplate.opsForValue().get(\"session\"); 方案二：SpringSessionSpring提供了SpringSession组件来解决模块之间的session共享。 在两个模块中都引入SpringSession依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; application.yml配置session用redis保存 12spring: session: store-type: redis 启动类加@EnableRedisHttpSession注解 策略四：session持久化创建一个数据库存储session。","link":"/2021/12/07/%E5%88%86%E5%B8%83%E5%BC%8Fsession/"},{"title":"webpack入门","text":"webpack是一个前端资源加载、打包工具。webpack会根据模块的依赖关系进行静态分析，将这些模块按照指定的规则生成对应的静态资源。webpack可以将多种静态资源转换成一个静态文件，减少了请求。 安装1cnpm install webpack -g 创建项目 新建项目目录 1mkdir app 创建index.html和test.js文件 index.html： 12345678&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"bundle.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; test.js文件： 1document.write(\"It works.\"); 打包1webpack test.js bundle.js 上面的命令将test.js编译成了bundle.js文件。 实例test2.js： 1module.exports = \"It works from test2.js.\"; 更新 test.js 文件： 1document.write(require(\"./test2.js\")); 使用webpack打包： 1webpack test.js bundle.js webpack会根据模块的依赖关系进行静态分析，这些文件会被打包进bundle.js中。webpack会给每一个模块分配一个唯一的id并通过这个id索引和访问模块。页面启动的时候，会先执行test.js中的代码，其他模块会在运行require的时候运行。 loaderwebpack本身只能处理js模块。如果要处理其他类型的文件需要使用loader进行转换。 在项目目录下安装css-loader和style-loader： 1cnpm install css-loader style-loader js文件中require css文件既可。 自动绑定需要的loader并打包： 1webpack test.js bundle.js --module-bind 'css=style-loader!css-loader' 配置文件可以将一些编译选项放在配置文件中便于管理。创建webpack.config.js文件： 12345678910111213module.exports = { entry: \"./test.js\", output: { path: __dirname, filename: \"bundle.js\" }, module: { loaders: [{ test: /\\.css$/, loader: \"style-loader!css-loader\" }] }}; 下面只需要执行webpack命令既可生成bundle.js文件： 1webpack webpack会默认载入当前目录下的webpack.config.js文件。 插件可以通过cnpm安装一些内置插件： 1cnpm install webpack --save-dev 下面安装BannerPlugin，用于在文件头部输出一些注释信息，下面修改webpack.config.js： 123456789101112131415161718var webpack = require('webpack');module.exports = { entry: \"./test.js\", output: { path: __dirname, filename: \"bundle.js\" }, module: { loaders: [{ test: /\\.css$/, loader: \"style-loader!css-loader\" }] }, plugins: [ new webpack.BannerPlugin('webpack实例') ]}; 然后运行 webpack 命令既可。 开发环境让编译的输出更加人性化： 1webpack --progress --colors 监听模式或者说增量编译： 1webpack --progress --colors --watch 可以使用webpack-dev-server，自动运行webpack自动编译和刷新页面： 12345# 安装cnpm install webpack-dev-server -g# 运行webpack-dev-server --progress --colors","link":"/2019/01/02/webpack-tutorial/"},{"title":"使用markdown写作","text":"markdown是一种简单的文本标记语言，本篇文章也是用markdown写的。 markdown可以用于微信公众号、简书、知乎以及hexo、wordpress等等文章的书写。 markdown文件的扩展名为.md。 markdown文件借助一些markdown编辑器比如Typora就可以导出为pdf、html、word、epub、LaTex、Media Wiki等文件格式。 以上的&lt;!-- more --&gt;是hexo中用来分割summary和article的语法。 推荐阅读书籍《了不起的Markdown》，不过掌握一个markdown好像也不需要专门读一本书。 目录用来生成文章目录，看渲染器是否支持。 1[toc] 标题123456# h1## h2### h3#### h4##### h5###### h6 12345一级标题=======二级标题------- 文本基本文本样式12345*斜体***粗体*****粗体斜体***~~删除线~~&lt;u&gt;下划线&lt;/u&gt; 脚注12需要添加角注的内容[^角注标题][^角注标题]: 角注内容 段落用一个空行来表示开启一个新的段落。 列表 列表可以与列表嵌套。 引用可以与列表互相嵌套。 无序列表使用-或者* +，以下使用-。 12- item1- item2 12345- item1 - item1.1- item2 - item2.1 - item2.2 有序列表121. item12. item2 清单123- [ ] 买衣服- [ ] 买菜- [ ] 学习 引用引用可以与列表互相嵌套。 单行： 1&gt; 这是一段引用的内容 多行： 123&gt; row1&gt; row2&gt; row3 嵌套： 123&gt; 第一层引用&gt; &gt; 第二层引用&gt; &gt; &gt; 第三层引用 分割线123---***+++ 表格Markdown制作表格使用 |来分隔不同的单元格，使用- 来分隔表头和其他行。 根据冒号的位置决定对齐方式。 语法： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 示例： 123| 姓名 | 性别 | 年龄 || :-- | --: | :--: || 小明 | 男 | 12 | 姓名 性别 年龄 小明 男 12 链接基本链接alt可以省略。 123[title](url \"alt\")或者&lt;url&gt; 高级链接 文档最下方先定义变量。 在文档中引用，给定链接名称和变量名。 12[谷歌官网][google][google]: https://www.google.com/ 图片基本用法1![title](url \"alt\") 高级用法高级用法同高级链接，先定义变量和值，再在文中引用链接名称和变量名。 12[风景图片][view][view]: image_url 其他用法markdown无法指定图片宽高，可以使用&lt;img&gt;标签代替。 1&lt;img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\"&gt; 代码小段代码 ，类似于行内元素： 1`code` 大段代码 ，类似于块元素： 先写三个反引号，紧接着加上语言，然后换行写代码，再在最后一行写三个反引号。 这里markdown中嵌套代码无法被hexo正确解析，所以不放代码了。 高级用法支持的html标签markdown支持的html标签：kbd b i em sup sub br等等。 1234567&lt;kbd&gt;ctrl&lt;/kbd&gt;&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;em&gt;强调&lt;/em&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;br&gt;换行 转义字符在特殊符号前面加上\\来表示该符号。 1\\* 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符$$ 包裹TeX 或 LaTeX格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： 12345678$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ 流程图 代码来自菜鸟教程 hexo无法解析流程图，故而在本博客看不到效果。 故而hexo只能使用制图软件作图 下面的代码都要放在三个反引号包裹的代码块内。 横向流程图 语言：mermaid 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 效果： 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 竖向流程图 语言：mermaid 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C{条件a} C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 效果： 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C{条件a} C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 标准流程图 语言：flow 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 效果： 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 标准流程图（横向） 语言：flow 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 效果： 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op UML时序图 语言：sequence 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ 效果： 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ UML时序图（复杂） sequence 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 效果： 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 UML时序图（标准） 语言：mermaid 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 效果： 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 甘特图 语言：mermaid 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h 效果： 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h","link":"/2020/03/10/%E4%BD%BF%E7%94%A8markdown%E5%86%99%E4%BD%9C/"},{"title":"列出页面上出现次数前n的标签名","text":"使用原生js列出页面上出现次数前n的标签名。 思路 获取页面上所有标签。 遍历标签，获取每个标签的标签名，如果第一次出现就置位1否则自增1. 列出页面上出现次数前n的标签名。 代码12345678910111213141516const getTopNTagNames = (n) =&gt; { let doms = document.querySelectorAll('*'); let countMap = {}; for (let i = 0, len = doms.length; i &lt; len; i++) { let tagName = doms[i].tagName.toLowerCase(); countMap[tagName] ? countMap[tagName]++ : countMap[tagName] = 1; } let topN = Object.entries(countMap).sort((a, b) =&gt; b[1] - a[1]).slice(0, n); topN.map((value, index, arr) =&gt; { arr[index] = value[0]; }); return topN;}","link":"/2022/05/02/%E5%88%97%E5%87%BA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%89%8Dn%E7%9A%84%E6%A0%87%E7%AD%BE%E5%90%8D/"},{"title":"前端下载文件的几种方案","text":"梳理一下前端下载文件的几种方案。 方案一：a标签下载创建a标签，手动触发点击事件下载。 创建的a标签形如：&lt;a href=&quot;file_url&quot; download=&quot;file_name&quot;&gt;file_title&lt;/a&gt;。 download 属性只在同源下生效。 ts1234567891011121314151617/** * a标签下载 * @param file 来自接口返回的blob或者文件路径 * @param fileName 文件名 * @returns */export function downloadFile(file: Blob | string, fileName: string) { const url = (file instanceof Blob) ? window.URL.createObjectURL(new Blob([file])) : file const a = document.createElement('a') a.style.display = 'none' a.href = url a.download = fileName document.body.appendChild(a) a.click() document.body.removeChild(a) window.URL.revokeObjectURL(url)} 方案二：window.openwindow.open 可以直接调用浏览器的下载。 方案三：使用插件可以使用js-file-downloader：https://www.npmjs.com/package/js-file-downloader 12345678910111213import JsFileDownloader from 'js-file-downloader';const fileUrl = 'http://...';new JsFileDownloader({ url: fileUrl}).then(function () { // 下载完毕回调函数}).catch(function (err) { //});","link":"/2023/06/12/%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/"},{"title":"前端开发中的各种引入","text":"总结一下前端开发中常使用的各种引入方式。 html中引入外部样式文件 123&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\"&gt;&lt;/head&gt; html中引入文档样式表 1&lt;style type=\"text/css\"&gt;&lt;/style&gt; @import引入外部样式表 写在style标签里面或者css文件里面。 3.1 在css文件中@import 1@import url(css/style.css); 3.2 在style标签中@import 123&lt;style type=\"text/css\"&gt; @import url(css/style.css);&lt;/style&gt; 3.3 指定样式媒体 123@import url(css/screen.css) screen;@import url(css/print.css) print;@import url(css/commom.css)screen print;","link":"/2019/06/30/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%95%E5%85%A5/"},{"title":"使用node.js爬取静态页面","text":"爬虫就是向目标url发送请求，然后把服务器的相应解析为我们需要的格式。下面爬取整个页面，也可以根据个人需求爬取自己需要的信息。 准备工作bash1234# request库用于发送请求cnpm install request --save# cheerio是jQuery核心代码, 用于操作请求返回的DOMcnpm install cheerio --save 编写代码spider.js1234567891011121314151617181920212223242526272829303132333435363738394041424344const request = require('request');const cheerio = require('cheerio');const readline = require('readline');const fs = require('fs');let url;let rl = readline.createInterface({ input: process.stdin, output: process.stdout});console.log('请输入要爬取的url:');rl.question('url:', function(res) { url = res; rl.close();});rl.on('close', function() { console.log('正在爬取...'); console.time('爬取耗时'); request(url, (err, res) =&gt; { if (err) { console.log('创建输出目录错误' + '' + err); } else { console.log('爬取成功！'); console.timeEnd('爬取耗时'); let $ = cheerio.load(res.body); let DOM = $('html').prop('outerHTML'); let now = new Date().getTime(); console.log('正在写入文件...'); console.time('写入耗时'); fs.writeFile('./output/output_'+ now + '.html', DOM, function(err) { if (err !== null) { console.log('写入失败，错误信息：' + err); } else { console.log('写入成功！'); console.timeEnd('写入耗时'); console.log('文件路径：' + __dirname + '/output/output_' + now + '.html'); } }); } });}); 运行bash1node spider.js 页面中引用的静态资源文件还没有爬。等等再写。","link":"/2021/09/29/%E4%BD%BF%E7%94%A8node-js%E7%88%AC%E5%8F%96%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/"},{"title":"剑指 Offer 03. 数组中重复的数字","text":"难度：简单 problem找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 solution brute force，这里注意两个指针不能同时移动到同一个index。 开一个对象，由于数组元素都是从0到length-1的数，故而可以将元素作为对象的key，每遍历一个元素就查看对象中对应的key的value是否存在，如果不存在则将其value置为1，若果存在则返回该key。 code 暴力 js123456789101112131415/** * @param {number[]} nums * @return {number} */var findRepeatNumber = function(nums) { const n = nums.length; for (let i = 0; i &lt; n; i++) { for (let j = 1; j &lt; n; j++) { if (i != j &amp;&amp; nums[i] == nums[j]) { return nums[i]; } } }}; 利用对象 js 12345678910111213141516/** * @param {number[]} nums * @return {number} */var findRepeatNumber = function(nums) { const n = nums.length; let obj = {}; for (let i = 0; i &lt; n; i++) { if (obj[nums[i]] != undefined) { return nums[i]; } else { obj[nums[i]] = 1; } }}; ref 题目全都来自leetcode上的《剑指offer》。","link":"/2021/03/08/%E5%89%91%E6%8C%87Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"剑指 Offer 04. 二维数组中的查找","text":"难度：中等 problem在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例： 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] [ [1, 4, 7, 11, 15, 18], [2, 5, 8, 12, 19, 21], [3, 6, 9, 16, 22, 23], [10, 13, 14, 17, 24, 27], [18, 21, 23, 26, 30, 31] ]给定 target = 5，返回 true。给定 target = 20，返回 false。 solution该二维数组的特性是从左上到右下递增。 在matrix[0][matrix[0].length - 1]处建立坐标系，将当前元素和target对比，如果相同则返回true，如果current小于target就下移，如果current大于target就左移。 codejs12345678910111213141516171819202122/** * @param {number[][]} matrix * @param {number} target * @return {boolean} */var findNumberIn2DArray = function(matrix, target) { if (!matrix.length) return false; // 宽度 const m = matrix.length; // 长度 const n = matrix[0].length; let i = 0; let j = n-1; while (i &lt; m &amp;&amp; j &gt;= 0) { let current = matrix[i][j]; if (current === target) return true; if (current &lt; target) i++; if (current &gt; target) j--; } return false;};","link":"/2021/03/08/%E5%89%91%E6%8C%87Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"title":"前端开发常用字体","text":"serif(衬线体)Times Georgia New Century Schoolbook sans-serif(非衬线体)Helvetica Geneva Verdana Arial Univers monospaceCourier Courier New Andale Mono cursive(手写体)Zapf Chancery Author Comic Sans fantasyWestern Woodblock Klingon","link":"/2018/12/09/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%AD%97%E4%BD%93/"},{"title":"剑指 Offer 05. 替换空格","text":"难度：简单 problem请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例： 现有矩阵 matrix 如下： 输入：s = &quot;We are happy.&quot; 输出：&quot;We%20are%20happy.&quot;solution 直接使用replaceAll() split() + join() 遍历拼接 codejs1234567/** * @param {string} s * @return {string} */var replaceSpace = function(s) { return s.replaceAll(' ', '%20');}; js1234567/** * @param {string} s * @return {string} */var replaceSpace = function(s) { return s.split(' ').join('%20');}; js123456789101112131415161718/** * @param {string} s * @return {string} */var replaceSpace = function(s) { let res = ''; for (let i = 0; i &lt; s.length; i++) { if (s[i] === ' ') { res += '%20'; } else { res += s[i]; } } return res;};","link":"/2021/10/12/%E5%89%91%E6%8C%87Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"},{"title":"剑指 Offer 07. 重建二叉树","text":"难度：中等 problem输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例1： Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7]示例2： Input: preorder = [-1], inorder = [-1] Output: [-1]solution先序遍历第一个元素是整个二叉树的根节点，找到这个根节点。 在中序遍历中找到根节点，根节点在中序遍历中将二叉树分为了左右两边。 再在左边的二叉树中找到根节点，根据中序遍历将其分为左右两边，右边的二叉树也同理，递归。 code123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */var buildTree = function(preorder, inorder) { if (preorder.length &lt;= 0) return null; let nodeVal = preorder[0]; let node = new TreeNode(nodeVal); let nodeIndexOfInorder = inorder.indexOf(nodeVal); let leftInorder = inorder.slice(0, nodeIndexOfInorder); let rightInorder = inorder.slice(nodeIndexOfInorder + 1); let leftPreorder = preorder.slice(1, 1 + nodeIndexOfInorder); let rightPreorder = preorder.slice(1 + nodeIndexOfInorder); node.left = buildTree(leftPreorder, leftInorder); node.right = buildTree(rightPreorder, rightInorder); return node;};","link":"/2021/10/18/%E5%89%91%E6%8C%87Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"剑指 Offer 06. 从尾到头打印链表","text":"难度：简单 problem输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例： 输入：head = [1,3,2] 输出：[2,3,1]solution遍历链表各个元素的val属性值，一次push到一个新数组中，最后返回这个数组的reverse()。 code1234567891011121314151617181920212223/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {number[]} */var reversePrint = function(head) { if (!head) return []; let current = head; let res = []; do { res.push(current.val); current = current.next; } while (current != null) return res.reverse();};","link":"/2021/10/18/%E5%89%91%E6%8C%87Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"title":"剑指 Offer 10- II. 青蛙跳台阶问题","text":"难度：简单 problem一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例1： 输入：n = 2 输出：2示例2： 输入：n = 7 输出：21示例3： 输入：n = 0 输出：1solution递归输入n为台阶个数，$f(n)$为方式种类个数。 $f(0) = 1$$f(1) = 1$$f(2) = 2$ 如果第一次跳一个台阶则这种情况下的方式个数为$f(n-1)$，如果第一次跳两个台阶则这种情况下方式个数为$f(n-2)$。 故而： $$f(n) = f(n-1) + f(n-2)$$ 斐波那契数列：1，1，2，3，5，8，13… 前两个数之和构成第三个数。 DPn级台阶，每次只能跳1级或者2级，就是1和2的排列组合，总和等于n。 求排列组合的个数。 code递归递归算法在leetcode直接timeout。 123456789/** * @param {number} n * @return {number} */var numWays = function(n) { if (n &lt;= 1) return 1; if (n === 2) return 2; return (numWays(n - 1) + numWays(n - 2)) % (1e9 + 7);}; DP1234567891011121314/** * @param {number} n * @return {number} */var numWays = function(n) { let tmp = [1, 1]; for (let i = 2; i &lt;= n; i++) { i % 2 === 0 ? tmp[0] = (tmp[0] + tmp[1]) % (1e9 + 7) : tmp[1] = (tmp[1] + tmp[0]) % (1e9 + 7); } if (n % 2 === 0) return tmp[0] % (1e9 + 7); return tmp[1] % (1e9 + 7);}; trap这个题的中间结果也要模1e9+7，实在是个大坑。","link":"/2021/10/20/%E5%89%91%E6%8C%87Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"},{"title":"剑指Offer-11-旋转数组的最小数字","text":"难度：简单 Description把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3, 4, 5, 1, 2] 为 [1, 2, 3, 4, 5] 的一次旋转，该数组的最小值为 1。 注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。 示例 1： 输入：numbers = [3, 4, 5, 1, 2] 输出：1示例 2： 输入：numbers = [2, 2, 2, 0, 1] 输出：0提示： n == numbers.length 1 &lt;= n &lt;= 5000 -5000 &lt;= numbers[i] &lt;= 5000 numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 Solution暴力遍历遍历数组，直到找到一个index，其元素值小于前面的一个元素值，如果没有则返回第一个元素值。 二分查找看代码 Code暴力法12345678910111213/** * @param {number[]} numbers * @return {number} */var minArray = function(numbers) { const len = numbers.length; if (len === 1) return numbers[0]; for (let i = 0; i &lt; len; i++) { if (numbers[i] &gt; numbers[i + 1]) return numbers[i + 1]; } return numbers[0];}; 二分查找12345678910111213141516171819202122232425/** * @param {number[]} numbers * @return {number} */var minArray = function(numbers) { const len = numbers.length; if (len === 1) return numbers[0]; let left = 0, right = len - 1; while (left &lt; right) { let mid = left + Number.parseInt((right - left) / 2); if (numbers[mid] &gt; numbers[right]) { left = mid + 1; } else if (numbers[mid] &lt; numbers[right]) { right = mid; } else { right--; } } return numbers[left];}; Trap注意：被旋转的数组后半部分最后一个值小于等于前半部分第一个值。","link":"/2022/05/25/%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"title":"原型与原型链","text":"构造函数、原型、原型链关系图： 原型和原型链js中的对象（js中一切皆对象）我们可以对它进行增删改查（CRUD）的操作。 如果新声明一个对象： let obj = {} ，会发现这个对象自带了一些属性和方法，这些属性和方法实际上是继承的。 比如： valueOf() , toString() , constructor 这些继承的属性和方法都在 obj.__proto__ 对象中， obj.__proto__ 对象继承自 Object.prototype 。想要调用继承的属性和方法只需要 obj.property_name ，js提供了 __proto__ 访问器来访问继承的属性和方法。 而 obj.__proto__ 中也有 __proto__ ，它的值是 null 。其实 obj.__proto__ 就是 Object ，而 obj.__proto__.__proto__ 就是 null ，也就是说 Object 的原型为 null 。 我们在调用 obj.valueOf() 的时候，js会先找obj自己本身有没有 valueOf() ，如果有就用自己的，如果没有就会在 obj.__proto__ 对象中找 valueOf() ，如果也没有就再在 obj.__proto__.__proto__ 中找，直到找到或者找不到为止，而这个找的路径就称之为原型链。 实际上如果再定义一个对象，其 __proto__ 对象也是和 obj.__proto__ 一样的。如果修改了其中一个对象的 __proto__ ，另一个对象的 __proto__ 也是被修改了，因为他们都继承自 Object.prototype 。 如果想要异化两个对象的 valueOf() 的行为，可以单独给两个对象添加 valueOf() 方法。 比如： 1234567obj.valueOf = function() { // ...}obj2.valueOf = function() { // ...} 对于上图的总结如下： 所有的对象都有_proto_属性，该属性对应该对象的原型 所有的函数对象都有prototype属性，该属性的值会被赋值给该函数创建的对象的_proto_属性 所有的原型对象都有constructor属性，该属性对应创建所有指向该原型的实例的构造函数 函数对象和原型对象通过prototype和constructor属性进行相互关联 只要记住一点，函数有原型对象（ prototype ），其他的对象就只有原型（ _proto_ ）。所以这两个通常被称为显式原型和隐式原型。 prototype和__proto__ 对于所有的对象，都有_proto_属性，这个属性对应该对象的原型。 对于函数对象，除了_proto_属性之外，还有prototype属性，当一个函数被用作构造函数来创建实例时，该函数的prototype属性值将被作为原型赋值给所有对象实例（也就是设置实例的_proto_属性） 实例： 123456789101112// 构造函数function Person(name) { this.name = name;}// 给Person原型链上添加age属性Person.prototype.age = 22;// 实例化Personlet p = new Person();// 结果：对象p继承了Person.prototype对象，通过p.[属性/方法]来调用Person.prototype对象中的属性和方法console.log(p.age); // 22 ref https://zhuanlan.zhihu.com/p/23090041 https://zhuanlan.zhihu.com/p/58605553 https://zhuanlan.zhihu.com/p/294808520 https://www.cnblogs.com/loveyaxin/p/11151586.html https://zhuanlan.zhihu.com/p/356980105","link":"/2022/02/28/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"剑指Offer10-I-斐波那契数列","text":"难度：简单 problem写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项（即F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：1示例 2： 输入：n = 5 输出：5solutiondp对于fib数列的前两位，直接返回。 从n为2开始，每一位都是前两位的和，故而只需要设置left和right两个变量存储前两位的值，cur就等于left+right，然后 codedp12345678910111213141516171819/** * @param {number} n * @return {number} */var fib = function(n) { if (n &lt; 2) return n; let left = 0, right = 1, cur = 0; for (let i = 2; i &lt;= n; i++) { cur = (left + right) % (1e9 + 7); left = right; right = cur; } return cur % (1e9 + 7);}; trap每次操作给cur赋值都要mod 1e9+7，真是浪费我好多时间排查。","link":"/2021/10/24/%E5%89%91%E6%8C%87Offer10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"title":"详解响应式网页设计","text":"总结一下响应式设计，包括响应式页面和响应式图片。 响应式页面包括根据不同设备&lt;link&gt;不同的css样式文件，还有css中使用@media规则。 响应式页面 首先在&lt;head&gt;中加入&lt;meta&gt;： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt; user-scalable=no 能够解决iPad切换横屏之后触摸才能回到具体尺寸的问题 表示网页默认宽度等于屏幕宽度，原始缩放比例为100%。 不能使用绝对宽度，只能用em,%。 对于元素宽度，不能使用px，只能用百分比或者auto。 123header { width: 80%;} 对于字体带下，不能使用px，只能使用em等相对单位。 123456789/*body字体大小设置为10px*/body { font-size: 62.5%;}/*h1字体大小设置为15px*/h1 { font-size: 1.5em;} 使用float使文档在横向放不下的时候自动换行，小心绝对定位的使用。 使用媒体查询选择性使用css 12345&lt;!-- 如果宽度小于400px则使用tinyScreen.css --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-device-width: 400px)\" href=\"tinyScreen.css\" /&gt;&lt;!-- 如果宽度在400到600则使用smallScreen.css --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (min-width: 400px) and (max-device-width: 600px)\" href=\"smallScreen.css\" /&gt; 也可以在css中引入外部样式： 1@import url(\"tinyScreen.css\") screen and (max-device-width: 400px); @media规则 以上媒体查询的作用是根据不同的宽度选择不同的css文件。 而@media的作用是根据不同的宽度选择不同的样式，也就是说只有符合@media后面的规则，声明块才会生效。 语法规则：@media media_type and （media_feature）{} 12345@media screen and (max-width: 400px) { body { background-color:#111; }} 设置多种屏幕宽度的样式： 12@media only screen and (min-width: 768px) and (max-width: 1024px) {}@media only screen and (min-width: 320px) and (max-width: 767px) {} 对于页面响应式设计，还可以通过写一个common.css，媒体查询为移动端后再写单独的mobile.css来覆写common.css里面的一些样式来达到响应式，或者直接就将多个适配样式写在一个css里面，像下面这样： 123@media only screen and (min-device-width : 320px) and (max-device-width : 480px) {}@media only screen and (min-width : 321px) {}@media only screen and (max-width : 320px) {} 关于媒体查询中的关键词：and only not only用来指定媒体类型： 1@media only screen and (max-width: 1920px;) {} not用来排除媒体类型： 1@media not print and (max-width: 1000px) {} max-device-width和max-width的区别： max-device-width是设备的屏幕宽度。 max-width是浏览器宽度。 区别就是，在pc上查看网页的时候，缩放网页，max-device-width不执行css，因为设备宽度没变。而max-width执行css，因为显示宽度发生了变化。 那么什么时候用max-device-width什么时候用max-width？ 通常来说，移动端用max-device-width，pc端用max-width。这也符合了我们的生活经验，使用手机缩放网页网页没有发生变化，而使用浏览器缩放网页网页会发生变动。 图片自适应 图片自适应：给图片指定最大宽度，如果超过就缩小，如果图片小就原尺寸显示。 1234img { width: auto; max-width: 100%;} 图片、视频自适应： 1234img,object { width: auto; max-width: 100%;} 老版本IE： 123img { width: 100%;} 此外，windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的专有命令： 123img { -ms-interpolation-mode: bicubic;} 或者，Ethan Marcotte的imgSizer.js。 1234addLoadEvent(function() { var imgs = document.getElementById(\"content\").getElementsByTagName(\"img\"); imgSizer.collate(imgs); }); 不过，最好还是根据不同大小的屏幕加载不同分辨率的图片。 响应式图片为此，img标签引入了srcset属性： 1x,1.5x,2x为像素密度描述符，用来让浏览器识别，1x可省略。 描述符还可以是320w,480w等等。 1234&lt;img srcset=\"pic-320.jpg 1x, pic-480.jpg 1.5x, pic-640.jpg 2x\" src=\"pic.jpg\"&gt; 浏览器会根据设备像素密度选择合适的图片，如果没有合适的则使用src图片。 还可以使用sizes指定不同规则的屏幕使用不同的图片： sizes属性后面可以有多个以逗号隔开的段，每段前面是一个媒体查询，空格后面是要给该规格屏幕所指定的图片显示宽度。最后256px为缺省值。 注意：100vw为100%的屏幕宽度。 1234567&lt;img srcset=\"pic-320.jpg 320w, pic-480.jpg 480w, pic-640.jpg 640w\" sizes=\"{max-width: 320px} 100vw, {max-wdith: 640px} 25vw, 256px\" src=\"pic.jpg\"&gt; 浏览器对以上代码的执行：根据设备屏幕宽度从sizes选择图片显示宽度，再从secset中找出最接近的图片加载。故而sizes是要和srcset配合使用的，src为缺省值。 picture标签picture是容器标签，内部有source和img。 写法如下： 12345&lt;picture&gt; &lt;source media=\"(max-width: 500px)\" srcset=\"cat-vertical.jpg\"&gt; &lt;source media=\"(min-width: 501px)\" srcset=\"cat-horizontal.jpg\"&gt; &lt;img src=\"cat.jpg\" alt=\"cat\"&gt;&lt;/picture&gt; 浏览器会根据source标签中的media依此判断设备屏幕是否符合，一旦遇到符合的media则选择其后面的srcset图片，如果所有source中的media都不符合则使用img标签中的src。 下面是一个综合例子： 1234567891011&lt;picture&gt; &lt;source srcset=\"homepage-person@desktop.png, homepage-person@desktop-2x.png 2x\" media=\"(min-width: 990px)\"&gt; &lt;source srcset=\"homepage-person@tablet.png, homepage-person@tablet-2x.png 2x\" media=\"(min-width: 750px)\"&gt; &lt;img srcset=\"homepage-person@mobile.png, homepage-person@mobile-2x.png 2x\" alt=\"Shopify Merchant, Corrine Anestopoulos\"&gt;&lt;/picture&gt; 使用source的type属性用来加载不同格式的图片： 12345&lt;picture&gt; &lt;source type=\"image/svg+xml\" srcset=\"logo.xml\"&gt; &lt;source type=\"image/webp\" srcset=\"logo.webp\"&gt; &lt;img src=\"logo.png\" alt=\"ACME Corp\"&gt;&lt;/picture&gt; 浏览器对以上代码，从上往下，依此检测是否支持image/svg+xml image/webp，一旦遇到支持的就使用这个srcset图片，若都不支持就使用img。","link":"/2020/03/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"},{"title":"如何使用记忆宫殿","text":"记忆宫殿这种记忆法在上初中的时候听说过。起初是看《读心神探》中的一个案件讲述了两个世界记忆大师，当时就觉得很震撼以为只是编剧效果而已，结果本科的时候发现图书馆里真的有记忆宫殿的书。现在感觉自己急需系统的记忆方法，故而学习一下记忆宫殿这种古老而又实用的记忆法。 ​ 在学习记忆宫殿之前，我先回忆一下我以往的记忆方法和记忆习惯，这非常重要。 对于语文中的古诗和宋词，我采用的是将每一句诗形象化为一张图片，第一句到最后一句就形成了类似放电影一样的小段场景，并且尽量使得场景要尽可能合理化。加之以朗读的方式加强口腔肌肉记忆和听觉记忆。 对于数字的记忆我并没有什么好的方法，基本就是靠读出来产生听觉记忆，比如圆周率pi前几位是$3.141592653$，阿伏伽德罗常数是$ 6.02 \\times 10^{23} $。 对于历史就是在大脑中模拟历史事件发生。 对于政治内容，由于政治课内容有一定的逻辑性，故而采用想象事件并使事件步骤化并且合理化步骤来记忆。 对于图形，比如地理中的各种地图、数学中的函数图像，我还是能很段时间就记住的，毕竟图像才是对不容易被大脑忽视的。 ​ 我总结下来的我所认为的记忆宫殿的方法（我发现记忆宫殿的效果真的很恐怖）： 建造宫殿，也就是先选择一个自己非常熟悉（熟悉到可以闭着眼睛想象场景里面什么位置有什么）的房间、建筑或者其他场景。并且这个场景还不能太单一，比如极简装修的客厅。这是不可以的，因为这直接决定了这个宫殿可以存储记忆的多少。 这里创建一个这样的场景：这是一个loft户型（有两层），一楼是一个客厅，客厅中间有一个木制的茶几，有三张独立的沙发椅放置在茶几的左边右边和后边，茶几的前面是客厅的墙壁，墙壁上挂着一台液晶电视，电视的下面是一个电视机柜，电视和电视机柜的右边是一个储物柜。电视的左边是一块空地，空地忘前面就是一个扶手梯用于进入二楼。 场景就是这么简单，我要做的就是做到在闭眼的情况下假设你坐在客厅的沙发上，你要想像出你坐在这个位置上以后这个客厅的其他东西的位置，一定要在脑子中渲染一遍这个模型，这样才会有身临其境的印象。将模型渲染为图像的过程是极其重要的。 比如现在我要记忆这么几个词语：成功，干红，苹果，电话，照射，花瓶，孩子，玩具，中国，红星，美女 一共11个词语，这些词语看似杂乱无章，限定时间让一般人记忆的话基本上都是靠机械性的朗读，然后也没记住几个。 这11个词语记忆的难点就是动词，名词都有。 现在你闭上眼睛，想象你自己处在你所建立的好的这个记忆宫殿也就是客厅里面，你是一个成功的企业家，电视机所在的位置为客厅的北边，你做在的位置是东边的沙发上，你看着南边（正对着电视）的沙发上坐着一个美女，她是你的妻子，你的妻子面前的茶几上放着一盘苹果。妻子左手边有一台电话以及一个落地灯，落地灯正开着并照射着沙发所在的区域。你站起来走过茶几来到客厅西边的一块空地，你的孩子正在空地上玩着玩具，你摸摸他的头，然后回到客厅中央，也就是电视和茶几中间，你看着电视上正在播放着新闻，新闻内容是南海某国渔船进入了我国南海海域非法作业，电视上出现了一副中国地图，地图上除了指出了事发海域坐标之外还有一颗红星非常显眼，那就是中国的首都北京。你看完了新闻继续走到了客厅的东边，还记得那里有什么吗？那里是一个储物柜，透过玻璃柜门，你选了一瓶法国波尔多的干红拿到茶几上起开酒瓶开始与你的妻子共享。 现在，你已经完成了这个事件的演绎，这个过程就称之为编码，什么是编码？就是将信息以特定的形式存储起来。现在你已经完成了对于这11个词语的存储！你已经将11个动词名词变成了客厅这个对象的属性和方法。 演绎的过程越真实，越有情节，越带感情，那么编码这个过程就会越牢固。 现在，我们已经完全记住了这11个单词。不信吗？我之前也不信，可是当我在两个小时前看完这个方法之后，我两个小时后再回忆这11个词，我竟然一个词都没忘记。 现在我们试着回忆刚才我们所演绎的场景，你闭上眼睛进入这个客厅，将你所扮演的角色和移动轨迹回忆一下，你将会回忆起所有的词语。一小时后你再回忆一下这个客厅以及你所扮演的角色和经过的地方，依然可以回忆出11个词。第二天再回忆一下，依然可以！ 当时我使用记忆宫殿记忆11个词的时间很短，也就大脑中演绎了一下，也没当回事。可是当我写这个文章的时候我才发现我真的一个词不少的全都记住了，我决定深入学习记忆宫殿这个记忆法。 我分析了一下我在记忆的过程中发生了什么：我创造了一个存放记忆的宫殿，我把自己带入这个宫殿扮演一个角色，我从一点到另外一个点，中间经历了一些东西和人，最后我走到终点。期间我所经过的所有东西和人都被我赋予了属性或者方法，我在回忆的过程中不断的经历和感受我演绎的时候所经历过的东西和人，我不断的联想起了这些东西的名称或者这些东西的方法名称。这就完成了读取记忆宫殿信息的过程，也就是对于信息的读取过程。 像平常记忆一样，经常回忆这个过程可以加深记忆，不过记忆宫殿可以达到长期记忆的作用。 ​ 待阅读书籍：《与爱因斯坦月球漫步》，《多米尼克的记忆魔法书》，《我最想要的记忆魔法书》。","link":"/2020/03/26/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BF%86%E5%AE%AB%E6%AE%BF/"},{"title":"在hexo中加入gitbook","text":"写一下如何在hexo中添加gitbook。 添加目录 进入blog/source/下 创建目录：mkdir gitbook 修改_config.yml文件 打开根目录下的_config.yml文件 找到skip_render，并按如下形式配置： 12345# 默认配置应该是这样的skip_render: README.md# 添加对gitbook目录的不解析，星号有两个代表对该目录下所有文件和目录都不解析skip_render: [README.md,gitbook/**] 工作流 gitbook放置在本地，每次gitbook build后就将build的内容cp到blog/source/gitbook目录下即可。 然后hexo d -g部署到服务器后，gitbook的路径比如我的ownpress.icu/gitbook即可，再写入配置文件增加新的连接或者按钮即可。","link":"/2020/06/27/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5gitbook/"},{"title":"如何实现一个栈(Stack)","text":"如何实现一个栈。 代码ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @desc 栈 */class Stack { /** * 构造方法 */ constructor() { /** * 初始化栈 */ this.stack = [] } /** * 向栈顶压入元素 */ push(element) { this.stack.push(element) } /** * 从栈顶弹出元素 */ pop(element) { if (this.isEmpty()) { return 'no element' } return this.stack.pop() } /** * 获取栈顶元素 */ peak() { return this.stack[this.stack.length - 1] } /** * 判断栈是否为空 */ isEmpty() { return this.stack.length === 0 } /** * 获取栈的大小 */ size() { return this.stack.length } /** * 清空栈 */ clear() { this.stack.length = 0 } /** * 打印栈 */ print() { console.log(this.stack.toString()) }}","link":"/2021/10/28/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88-Stack/"},{"title":"htop：一款unix交互进程管理器","text":"htop - an interactive process viewer for Unix 下载下载源码：http://hisham.hm/htop/releases/ 下载完毕后tar -zxvf解包。 安装进入解包完的目录 1234# 编译安装./configuresudo makesudo make install 疗效","link":"/2020/07/08/%E5%AE%89%E8%A3%85htop/"},{"title":"合并两个升序数组","text":"难度：简单 Description合并两个升序数组，返回合并后的数组，合并后的数组依然为升序，元素不能重复。 Solution方法一：从前往后一次对比两个数组的元素，小的 push 到新数组。 方法二：先拼接两个数组，再去重，最后排序。 排序导致了该方法效率低。 Code方法一12345678910111213141516171819202122232425262728293031323334353637let list1 = [1, 3, 5, 6, 7];let list2 = [2, 3, 4, 8, 9];mergeLists(list1, list2);const mergeLists = function(l1, l2) { const L1_LEN = l1.length; const L2_LEN = l2.length; if (!L1_LEN) return l2; if (!L2_LEN) return l1; let target = []; let i = 0, j = 0; while (i &lt; L1_LEN &amp;&amp; j &lt; L2_LEN) { if (l1[i] &lt; l2[j]) { target.push(l1[i]); i++; } else if (l1[i] &gt; l2[j]) { target.push(l2[j]); j++; } else { target.push(l1[i]); i++; j++; } } if (i &gt; j) { target = target.concat(l2.slice(j)); } else { target = target.concat(l1.slice(i)); } return target;}; 方法二12345678910111213let list1 = [1, 3, 5, 6, 7];let list2 = [2, 3, 4, 8, 9];mergeLists(list1, list2);const mergeLists = function(l1, l2) { if (!l1.length) return l2; if (!l2.length) return l1; let target = l1.concat(l2); target = [...new Set(target)]; return target.sort((a, b) =&gt; a - b);};","link":"/2021/12/18/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"实现call, apply和bind","text":"实现call思想实现一个call无非就是下面几点： 第一个参数传入null时，this指向window。 第一个参数传入对象时，this指向该对象。 接受剩余参数传入。 返回函数执行的结果。 代码123456789101112Function.prototype.newCall = function(context = window, ...args) { // 获取this需要指向的对象 const ctx = context || window; // 保存调用newCall的函数 ctx.fn = this; // 在新对象上执行函数，传入参数并执行，保存函数的返回值 const res = ctx.fn(...args); // 考虑到可能绑定到了window，故而删除fn delete ctx.fn; // 返回函数的返回值 return res;}; 实现apply思想实现一个apply和call类似： 第一个参数传入null时，this指向window。 第一个参数传入对象时，this指向该对象。 接受剩余参数以数组的形式传入。 返回函数执行的结果。 代码123456789101112Function.prototype.newApply = function(context = window, args = []) { // 获取this需要指向的对象 const ctx = context || window; // 保存调用newApply的函数 ctx.fn = this; // 在新对象上执行函数，传入参数并执行，保存函数的返回值 const res = ctx.fn(...args); // 考虑到可能绑定到了window，故而删除fn delete ctx.fn; // 返回函数的返回值 return res;}; 实现bind思想bind与call和apply不同，call和apply是执行后返回函数的返回值，而bind返回的是修改后的函数却不执行。 第一个参数传入null时，this指向window。 第一个参数传入对象时，this指向该对象。 接受剩余参数传入。 返回绑定了新对象的函数。 12345678910Function.prototype.newBind = function(context, ...args) { // 获取函数 const _fn = this; // 返回绑定了新对象的函数 return function Bind(...newArgs) { // 考虑是否此函数被继承 if (this instanceof Bind) return _fn.newApply(this, [...args, ...newArgs]); return _fn.newApply(context, [...args, ...newArgs]); }} ref https://segmentfault.com/a/1190000018832498 https://blog.csdn.net/qq_37288477/article/details/87884518","link":"/2022/03/02/%E5%AE%9E%E7%8E%B0call-apply-bind/"},{"title":"干掉Adobe Creative Cloud在Macos中的启动项","text":"Adobe Creative Cloud是安装PS、AI等Adobe软件安装时自动安装的，可是流氓的Adobe会在macos启动后自启动好几个Adobe的后台进程，研究了一下如何干掉所有的自启动进程。 结束相关进程首先，打开macos的活动监视器手动选中所有adobe的进程并强制结束。 删除相关文件在以下目录中寻找com.adobe开头的文件并删除。 ~/Library/LaunchAgents /Library/LaunchAgents /Library/LaunchDaemons 最好不要删除gc文件。 进入：/Applications/Utilities/Adobe Creative Cloud目录下，删除CCLibrary, CCXProcess, CoreSync文件夹。 修改设置进入：系统偏好设置&gt;扩展，关闭所有的adobe的扩展。 done!","link":"/2020/06/24/%E5%B9%B2%E6%8E%89Adobe-Creative-Cloud%E5%9C%A8Macos%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E9%A1%B9/"},{"title":"开启vim代码高亮","text":"vim安装完后默认没有开启代码高亮，尽管开发使用GUI的编辑器和IDE，但是但是有时候也需要用vim看一下或者临时小修改一下代码。 vim代码高亮配色文件的路径是：/usr/share/vim/vim/vim81/colors 上面的vim81为版本，直接cd到/usr/share/vim/vim/下进入版本目录下查看colors既可，配色文件都是.vim为扩展名。 添加配置信息： 1vim ~/.vimrc 123set nu colorscheme &lt;theme&gt;syntax on theme为配色文件名称。","link":"/2020/06/24/%E5%BC%80%E5%90%AFvim%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/"},{"title":"微信小程序实现watch","text":"最近做需求需要实现一个按钮根据页面字段来","link":"/2022/11/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0watch/"},{"title":"微信小程序生命周期","text":"","link":"/2022/11/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"微信小程序适配iphone底部任务条","text":"微信小程序适配iphone底部任务条。 获取底部安全距离并添加到globalDataapp.js: js12345678910111213App({ globalData: { bottomLift: 0 } onLaunch() { wx.getSystemInfo({ success: res =&gt; { this.globalData.bottomLift = res.screenHeight - res.safeArea.bottom } }) }}) 在页面js中引入页面中使用： js1234567const app = getApp()Page({ data: { bottomLift: app.globalData.bottomLift }}) 在wxml中使用然后就可以在页面中需要的地方使用这个bottomLift。","link":"/2022/10/31/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%82%E9%85%8Diphone%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%9D%A1/"},{"title":"所谓编译型语言和解释型语言的误区","text":"什么是解释型语言？什么是编译型语言？python是解释型语言？clang是编译型语言？java是解释型语言？no，no，no。其实这种根深蒂固的说法是错的。 一门编程语言本身并不具有是解释型语言还是编译型的属性，准确的说法是：某个语言的特定实现是编译型或者解释型的。 比如javascript这个语言，它既有解释型的实现比如早期浏览器的js引擎，也有编译型的实现比如chrome的v8引擎。 再拿一个后端的语言scheme为例，chichen scheme为scheme提供了两套实现方式，一个是解释器csi，另一个是编译器csc。 故而，所谓的编译型、解释型并不是一门语言本身固有的属性，而是语言实现的特性。","link":"/2020/09/02/%E6%89%80%E8%B0%93%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AF%E5%8C%BA/"},{"title":"所谓面向过程、面向对象以及函数式语言的误区","text":"java是面向对象语言？clang是面向过程语言？lisp是函数式编程语言？ 比如python和javascript，我们既可以用他们写出函数式编程的代码，也可以用他们写出面向对象风格的代码，还可以写出两者兼具的代码。 即使是java也可以用其写出函数式风格的代码。 还有common lisp这种函数式编程语言的代表也可以写出面向对象的代码。 因此，一刀切的将语言分为面向对象、面向过程、函数式是不科学的。 其实每一门语言都拥有多种特性。","link":"/2020/09/03/%E6%89%80%E8%B0%93%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80/"},{"title":"文件命名规范","text":"《中文技术文档写作规范》规定了文件的命名规范： “文件名建议只使用小写字母，不使用大写字母。” “为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。” 故而，一言以蔽之“文件名一律小写”。 有下面几点缘由： linux系统大小写敏感，windows和macos大小写不敏感。所以如何文件名大小写混用或者大写的话就可能造成文件识别问题。 小写字母更易读，这个我们从小就阅读的小写字母课本，自然不用说。 易用，与系统目录区分开来。 便携，大大减少了我们按shift来回切换大小写的不必要的工作量。 命令行下还不用-i参数。 总结： 文件名使用全小写或者小写加连词线。 比如： main.js index-header.vue","link":"/2020/03/25/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"title":"什么是新基建","text":"什么是新基建？ 新型基础设施建设（简称：新基建），主要包括5G基站建设、特高压、城际高速铁路和城市轨道交通、新能源汽车充电桩、大数据中心、人工智能、工业互联网七大领域，涉及诸多产业链 ，是以新发展理念为引领，以技术创新为驱动，以信息网络为基础，面向高质量发展需要，提供数字转型、智能升级、融合创新等服务的基础设施体系。2020年3月，中共中央政治局常务委员会召开会议提出，加快5G网络、数据中心等新型基础设施建设进度。2020年5月7日，从上海市政府新闻发布会上介绍的《上海市推进新型基础设施建设行动方案（2020-2022年）》获悉，上海初步梳理排摸了这一领域未来三年实施的第一批48个重大项目和工程包，预计总投资约2700亿元。2020年5月22日，《2020年国务院政府工作报告》提出，重点支持“两新一重”（新型基础设施建设，新型城镇化建设，交通、水利等重大工程建设）建设。 图片来自所长林超：https://www.bilibili.com/video/BV1H7411y7Hh?from=search&amp;seid=18115219843630947634 新基建的7个领域： 新基建机遇： 5G产业机会图： 4G发牌： 5G产业地图： 做内容需要有设计感、故事感、娱乐感、意义感、同理心，要去像人一样思考而不是像机器一样。 后动优势(late-mover advantage；Second-mover advantage；又称为次动优势、后发优势、先动劣势)是指相对于行业的先进入企业，后进入者由于较晚进入行业而获得的较先动企业不具有的竞争优势，通过观察先动者的行动及效果来减少自身面临的不确定性而采取相应行动，获得更多的市场份额。例如：研发成本优势、行业风险把握优势等。 出来卖的三个维度：","link":"/2020/06/22/%E6%96%B0%E5%9F%BA%E5%BB%BA/"},{"title":"构造大数","text":"给你三个3，你会用来怎么构造一个尽可能大的数呢？ 根据初等数学中的运算符，我们最多能进行如下构造： $3+3+3=9$ $3 * 3 * 3=27$ $3^{3^3}=3^{27}$ ${3!}^{ {3!}^{3!} }=6^{6^6}=6^{46656}$ $6^{46656}$这个数已经足够大了，但是我们最大只能构造出这个数吗？ 事实的确不是这样的。通过以上的几种构造方法，我们可以发现虽然可用的数只有三个3，但是我们仍然通过使用不同的数学运算符构造出了量级相差巨大的几个数。 那么思路很明显了！我们只需要创造一个新的运算符并且给定这个运算符特定的运算规则不就可以创造出比$6^{46656}$大的数了吗？ 答案是肯定的！ 介绍一个新的运算符：高德纳箭头 请看，高德纳箭头是由计算机科学家Donald Ervin Knuth提出的，而他又是Tex的创始人。高德纳箭头的运算规则如下： $3↑3=3^{3}=27$ $3↑↑3=3↑3↑3=3↑{3^3}=3^{3^{3} }$ 以此类推，运算符从右往左结合。 由此下面介绍葛立恒数： 这个数光它的箭头的位数的位数的位数的位数……..的位数就有$3↑↑↑↑3$这么庞大。（此处有63个位数，虽然严禁套娃，但是没办法，这个数字不套娃根本表示不出来） 请注意，光是$3↑↑↑↑3$已经是大到不可想象的数字了。你可以想象如果将宇宙分割成以普朗克尺度为边长的立方体，类似于切豆腐。即使是这样，以普朗克尺度为边长的立方的个数都远远小于$3↑↑↑↑3$，甚至比$3↑↑↑↑3$小到忽略不计，更别提葛立恒数$G(64)$本身有多大了！（括号内数字为葛立恒数的层数） 比葛立恒数大得多的数有很多，比较著名的一个叫tree(3)，不过国内关于tree(3)的资料太少了，有机会再补全tree(3)。 总结：我们要构造一个大数只需要创造一个新的运算符号以及给予它相应的运算规则就可以了。运算符就是一个符号，长什么样由自己决定，关键在于如何为这个运算符设计一个运算规则使得在两个基数经过这个运算符运算后能尽可能的大。 Tips: 这是我的第一篇数学文章，发现了hexo&amp;markdown中的数学公式的一些坑： 行内数学公式使用$包裹公式，块公式使用$$来包裹公式块。 相邻的符号之间用空格隔开。 运算块使用一对花括号{}来包裹式子。 更多的坑待挖掘。 参考： 1. 维基百科：葛立恒数","link":"/2020/03/20/%E6%9E%84%E9%80%A0%E5%A4%A7%E6%95%B0/"},{"title":"清除浮动","text":"前面的元素设置了float: left，那么后面的元素会识别不到前面的元素从而被前面的元素遮挡 12&lt;div class=\"box_1\"&gt;&lt;/div&gt;&lt;div class=\"box_2\"&gt;&lt;/div&gt; 123456789101112.box_1 { width: 100px; height: 100px; background-color: red; float: left;}.box_2 { width: 100px; height: 100px; background-color: yellow; clear: both;} 效果：.box_1和.box_2会各自独占一行。 如果一个元素设置了浮动，对于该元素清除浮动只需要对其父元素之后的元素清除浮动，然后父元素的高度就不会塌陷 这里使用伪元素来插入父元素之后的元素，并将其设置为clear: both 1234&lt;div class=\"parent\"&gt; &lt;div class=\"son_1\"&gt;&lt;/div&gt; &lt;div class=\"son_2\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.son_1 { width: 50%; float: left;}.son_2 { width: 50%; float: right;}.parent::after { content: ''; display: block; clear: both;} 编写.clearfix::after降低工作量 12345.clearfix::after { content: ''; display: block; clear: both;} 以后只需要在父元素class上加clearfix即可。","link":"/2018/06/01/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"title":"爬虫基础","text":"除了常用的java, python可以做爬虫之外，其实任何后端语言都可以做爬虫，其中也包括了node.js。node.js做爬虫的优势是异步和高并发。 流程获取需要的数据的流程是：抓取 - 存储 - 分析 - 展示。整个流程应该做到以上步骤的分离。 抓取第一步就是抓取需要的页面。 从效率上来讲需要爬虫能够异步和并发爬取。 抓取回来的页面会有很多问题待解决，比如cookie、认证、编码、文件处理、url合规、多线程多进程、压缩等问题。 存储抓取到的页面按照一定的策略存储(fs, db)起来. 分析分析链接。按需求提取数据。 展示数据可视化","link":"/2021/10/08/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"},{"title":"lambda表达式（箭头函数）获取传入的实参","text":"箭头函数无法使用 arguments 数组，使用剩余参数获取参数数组。 获取全部实参： 12345let func = (...rest) =&gt; { console.log(rest);};func(1, 2, 3, 4); // [1, 2, 3, 4] 获取剩余实参： 12345let func = (param1, param2, ...rest) =&gt; { console.log(rest);};func(1, 2, 3, 4); // [3, 4]","link":"/2021/09/08/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%AE%9E%E5%8F%82/"},{"title":"红墨水和蓝墨水混合问题","text":"今天看到个特别有意思的红墨水蓝墨水混合问题： 题：有一瓶红墨水，一瓶蓝墨水，从红墨水舀一勺到蓝瓶里，搅匀后再舀一勺到红瓶里。问：此时红墨水里含蓝墨水的量和蓝墨水里含红墨水的量关系是什么？大于、小于、等于？ 这个题目本身看起来不是一个难题，如果你通过取特殊值计算的结果来判断就不好，因为不具备普遍性。 如果我们从状态变化的角度来看这个问题，可以发现这个问题可以看做是状态的迁移。 初始态：红墨水和蓝墨水体积相等，红墨水中不含蓝墨水，蓝墨水中也不含红墨水。最终态：红墨水瓶中的水和蓝墨水瓶中的水体积依然相等，红墨水瓶中含蓝墨水，蓝墨水瓶中也含红墨水。 我们不关注两次舀水的过程，单单从状态变化的角度来看，可以发现初始态和最终态两个瓶子中的水的体积都相等，发生变化的是红墨水瓶子中多了蓝墨水而少了红墨水，蓝墨水瓶子中多了红墨水而少了蓝墨水。 而其实红墨水瓶子中多了的蓝墨水来自于蓝墨水瓶，少了的红墨水去到了蓝墨水瓶，而两者的体积是相等的，无论第一次舀水后是否搅匀，最终红墨水瓶中含有的蓝墨水永远等于蓝墨水瓶中含有的红墨水。","link":"/2022/03/02/%E7%BA%A2%E5%A2%A8%E6%B0%B4%E5%92%8C%E8%93%9D%E5%A2%A8%E6%B0%B4%E6%B7%B7%E5%90%88%E9%97%AE%E9%A2%98/"},{"title":"在Vue2中给data中的属性添加新属性的方法","text":"由于Vue2的双向绑定是基于 Object.defineProperty() 的，这个方法只能监听 data 里面已经存在的属性，并不能对于新添加的属性进行监听，故而直接给data添加新属性是无法被vue监听到并绑定到页面上的。 这里注意：是没办法添加data下的一级属性的，必须事先定义。 下面是几种给data中的属性添加新属性的方法。 $set()可以使用 Vue.set(target, key, value) 或者 this.$set(target, key, value) 来给data添加新属性。 Object.assign()可以通过重新赋值的方式添加属性。 example: 123456789101112131415data() { return { msg: { name: 'mason', age: 22 } }},methods: { updateMsg() { // 右边是一个新的对象，vue检测到msg地址的变化会更新msg this.msg = Object.assign({}, this.msg, {gender: 'male'}); }} $forceUpdate()不建议使用这个方法！ $forceUpdate() 可以强制更新vue实例。 example: 123456789101112131415data() { return { msg: { name: 'mason', age: 22 } }},methods: { updateMsg() { this.msg.gender = 'male'; this.$forceUpdate(); }}","link":"/2022/09/14/%E7%BB%99Vue2%E7%9A%84data%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"自定义html元素","text":"html5标准可以自定义的元素，但是没有默认样式。 我可以在html中加一个元素并在css中给它样式。这样就创造了一个元素。 这样我们就能写出语义非常好的html。 复用自定义元素123&lt;user-defined&gt; &lt;a href='#'&gt;链接&lt;/a&gt;&lt;/user-defined&gt; 现在将&lt;user-defined&gt;的元素和样式封装为user-defined.html就可以复用了。 先在&lt;head&gt;中引入： 1&lt;link rel=\"import\" href=\"user-defined.html\"&gt; 再使用： 1&lt;user-defined&gt;&lt;/user-defined&gt; 注意：自定义元素标准custom elements与HTML Imports，HTML Template、Shadow DOM构成了web components规范。目前这个规范只有chrome支持 custom elements自定义元素命名规范：必须包含-","link":"/2019/06/03/%E8%87%AA%E5%AE%9A%E4%B9%89html%E5%85%83%E7%B4%A0/"},{"title":"网页性能优化","text":"参考阮一峰老师的文章总结一下网页性能问题以及优化，包括css和js的方法。 网页生成过程 HTML代码转化成DOM。 CSS代码转化成CSSOM（CSS Object Model）。 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）。 生成布局（layout），即将所有渲染树的所有节点进行平面合成。 将布局绘制（paint）在屏幕上。 其中影响性能的是4和5。这两步称之为“渲染”，在网页使用的过程中最少渲染一次，在用户访问网页的过程中还可能发生多次渲染。 那么，什么情况下网页会重新渲染呢？ dom改变 样式改变 事件发生 以上任意一项发生改变，网页就会重拍和重绘。 重排必然导致重绘，而重绘不一定导致重排。 提高性能于是乎，我们提高性能的思路就是：降低重排和重绘的频率和单次成本以减少出发浏览器对于网页的重新渲染（重排，重绘）。 尽量不要把读操作和写操作放在一个语句里。 1234567891011// bad examplediv.style.left = div.offsetLeft + 10 + \"px\";div.style.top = div.offsetTop + 10 + \"px\";// 拆开写// good examplevar left = div.offsetLeft;var top = div.offsetTop;div.style.left = left + 10 + \"px\";div.style.top = top + 10 + \"px\"; 一般来说： 样式表越简单，重新渲染就越快。 DOM层级越高，成本越高。 table渲染成本高于div。 技巧： DOM的多个读操作放一起写，不要读写操作穿插。 对于重排而言，缓存可以提高性能避免下次不必要的重排。 不要一次次改变样式，尽量一次性改变样式。 尽量使用离线DOM来改变样式 如果将一个元素display: none，再对该元素进行100次操作，最后恢复原本display。总计用了两次渲染。避免了在元素显示的情况下不必要的100次渲染。 absolute fixed sticky渲染开销小，是由DOM决定的。 只在必要情况下将display设置为非none，这样可以极大减少渲染次数。对于visibility: hidden元素，只会重排一次，可能重绘多次。 可以使用虚拟DOM库。 使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染。 刷新率浏览器刷新率为60hz，当页面滚动时，浏览器会对网页以每秒60次的频率重新渲染。 也就是说，每隔$ 1000/60=16.7 $毫秒，浏览器就要渲染完毕一帧的画面。 解决办法是使用web worker，主线程用于ui渲染，worker线程用来渲染其他的任务。 network面板打开chrome开发者工具的network面板。 点击原点开始录制，然后模仿用户操作，再点一下原点完成录制。 事件模式：查看影响性能的原因。蓝色表示载入，黄色表示js，则色表示渲染，绿色表示重绘图。 帧模式：用于查看每帧耗时，越高耗时越多。 两条线，上面一条表示30帧，低于这条线就能以高于30帧的频率渲染，下面是60帧线，低于它代表可以达到每秒60帧以上。 window.requestAnimationFrame()使用一些js方法调节渲染提高性能。 这里 window.requestAnimationFrame() ，可以将一些代码放到下一次渲染时一起渲染。 这是一个让elements中的每一个元素高度增加一倍的方法 doubleHeight() 12345678function doubleHeight(element) { // read operation var currentHeight = element.clientHeight; // write operation element.style.height = (currentHeight * 2) + 'px'}elements.forEach(doubleHeight); 这里浏览器对于该方法的渲染过程是：依此渲染每一个 elements 中元素的高度，并且每一个元素都要进行一次read和一次write。这就严重影响了性能。 使用 window.requestAnimationFrame() 将read和write分离，使得所有的write放到下一次执行。 123456789function doubleHeight(element) { // read var currentHeight = element.clientHeight; // 使用window.requestAnimationFrame() window.requestAnimationFrame(function() { element.style.height = (currentHeight * 2) + 'px'; });}elements.forEach(doubleHeight); 这样浏览器会一次性读取每一个elements中元素的高度，并在浏览器下一次渲染时一次性将所有的elements中的元素高度写为原来的两倍。 window.requestAnimationFrame() 的应用场景： scroll 事件监听函数以及 animation 。 window.requestIdleCallback()这个函数指定当只有一帧的末尾有空闲时间才会执行毁掉函数。 1requestIdleCallback(fn, 1000); 上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。 1000表示指定毫秒数，作用是如果1000ms内每一帧都没有空闲时间，就强制执行 fn ，也就是一个deadline的作用。 函数 fn 可以接受一个 deadline 对象作为参数。 123456789requestIdleCallback(function someHeavyComputation(deadline) { while (deadline.timeRemaining() &gt; 0) { doWorkIfNeeded(); } if (thereIsMoreWorkToDo) { requestIdleCallback(someHeavyComputation); }}); 上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。 deadline对象有一个方法和一个属性： timeRemaining() 和 didTimeout 。 timeRemaining() 方法 timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮 requestIdleCallback 。 前面的示例代码之中，只要当前帧还有空闲时间，就不断调用doWorkIfNeeded方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮 requestIdleCallback 。 didTimeout属性 deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。 timeRemaining方法返回0 didTimeout 属性等于 true 因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。 123456789function myNonEssentialWork(deadline) { while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0) doWorkIfNeeded(); if (tasks.length &gt; 0) requestIdleCallback(myNonEssentialWork);}requestIdleCallback(myNonEssentialWork, 5000); 上面代码确保了，doWorkIfNeeded 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。 requestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有Chrome支持，不过其他浏览器可以用垫片库。 网络性能优化包括了静态文件做cdn，压缩代码，以及压缩图片等等。","link":"/2020/03/25/%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"解决github上图片无法显示的问题","text":"最近国内访问github会因为dns的原因导致图片不显示，可以修改本地hosts来解决。 找到hosts文件macos：路径：/etc/hosts windows:路径：C:\\Windows\\System32\\drivers\\etc\\hosts 修改hosts文件在hosts文件中追加以下配置信息： 123456789101112131415161718# GitHub Start 192.30.253.112 Build software better, together 192.30.253.119 gist.github.com151.101.184.133 assets-cdn.github.com151.101.184.133 raw.githubusercontent.com151.101.184.133 gist.githubusercontent.com151.101.184.133 cloud.githubusercontent.com151.101.184.133 camo.githubusercontent.com151.101.184.133 avatars0.githubusercontent.com151.101.184.133 avatars1.githubusercontent.com151.101.184.133 avatars2.githubusercontent.com151.101.184.133 avatars3.githubusercontent.com151.101.184.133 avatars4.githubusercontent.com151.101.184.133 avatars5.githubusercontent.com151.101.184.133 avatars6.githubusercontent.com151.101.184.133 avatars7.githubusercontent.com151.101.184.133 avatars8.githubusercontent.com # GitHub End 完美解决~ 参考 https://www.jianshu.com/p/752211238c1b https://sspai.com/post/43248 https://zhuanlan.zhihu.com/p/107196957","link":"/2020/06/23/%E8%A7%A3%E5%86%B3github%E4%B8%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"解决termius下不支持中文的问题","text":"发现在termius下中文文件名乱码的问题. 1vim ~/.zshrc 插入: 1export LANG=en_US.UTF-8 done!","link":"/2020/07/04/%E8%A7%A3%E5%86%B3termius%E4%B8%8B%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"解决vue页面加载时未解析完代码之前出现的源码问题","text":"使用插值的方式插入文本会造成页面解析完成之前闪烁出现源代码的问题。 可以用v-text代替，如果一定要用插值的方式则需要使用v-cloak指令。 使用 v-cloak 指令可以隐藏vue页面解析代码之前出现源码的问题。 1234567&lt;template v-cloak&gt;{{msg}}&lt;/template&gt;&lt;style&gt; [v-cloak] { display: none; }&lt;/style&gt;","link":"/2020/04/16/%E8%A7%A3%E5%86%B3vue%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%AA%E8%A7%A3%E6%9E%90%E5%AE%8C%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%89%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"详解css中的单位","text":"我看过的一些文章和《css权威指南》都没有太简洁明了的让我们理解css中的单位，反而css权威指南这本书还将简单问题复杂化了很多，故而我自己总结一下css中的单位。 绝对单位和相对单位我发现《css世界》和《css权威指南》里面对于绝对单位和相对单位的描述有出入，故而先介绍一下什么是绝对单位以及什么是相对单位。 绝对单位：比如，某公司规定员工工作日每天需要工作8小时，这个“小时”就是绝对单位，因为8小时是固定长度的。 相对单位：比如，某公司规定员工的工作时长需要符合手头工作量，工作量多就得加班，工作量少当然也不可能提前下班，这里“工作时长需要符合手头工作量”就是个相对单位，因为这个工作时长是相对于工作量而言的，是不确定的。 css中的单位css中的绝对单位就是单位配合数值后所确定的元素视觉大小是绝对的，而相对单位就是单位加上数值后表示的元素视觉大小是不确定的。 绝对单位有：pt,pc,in,cm,mm 相对单位有：em,ex,px,rem,vw,vh,vmin,vmax,%,ch px 相对单位，这个单位是网上文章中错误最多的单位，有的文章说是相对单位，有的说是绝对单位。其实px是相对单位，代表1像素，一个像素的大小是不确定的，比如：有两台电脑，一台是1080p分辨率，一台是2k分辨率，并且两台电脑屏幕比例和面积一样，像素的大小就是屏幕面积除以像素个数，故而很明显两台电脑的像素大小是不一样的，并且分辨率低的像素大小要大于分辨率高的像素大小。故而，同样是16px的字体，分辨率低的那个电脑显示出来的字体就要比分辨率高的字体大。 故而以下的字体为什么是相对单位以及为什么是绝对单位就明了了。 em 相对单位，相对于当前字体大小进行计算。 如果设置font-size：em相对于父元素字体大小计算。 关于em，可以用来调整浏览器默认字体大小基准： 浏览器默认16px，计算出10px = 0.625em，那么就将body的font-size声明为0.625em 123body { font-size: 62.5%;} 此时文档中的字体大小1em就是10px，以后我们要使用各种不同大小的字体只要： 1234a { /*12px*/ font-size: 1.2em;} 注意，如果嵌套的话： 123&lt;p class=\"p1\"&gt; &lt;p class=\"p2\"&gt;&lt;/p&gt;&lt;/p&gt; 123456789body { font-size: 62.5%;}.p1 { font-size: 1.2em;}.p2 { font-szie: 1.2em;} 这样就使得.p1变为12px，而.p2相对于.p1的1.2倍就是1.44em，也就是14.4px。 这里要.p2也使用12px就要这样写:font-size: 1em来继承.p1的大小。 ex 相对单位，相对于当前字体的小写x高度进行计算，x的高度通常是字体高度的一半（1ex = 0.5em）。 rem 相对单位，相对于root节点html元素的字体大小（16px）进行计算。 这个单位统一使用html元素大小为基准，避免了多层嵌套使用em后的大小叠加，可以用于需要多设备适配的项目。 先将html元素设置为10px作为基准： 123html { font-size: 62.5%;} vw 相对单位，相对于viewpoint width进行计算，1vw=视窗宽度的1%。 vh 相对单位，相对于viewpoint height进行计算，1vh=视窗高度的1%。 vmin 相对单位，取vw和vh中较小的那个值。 vmax 相对单位，取vw和vh中较大的那个值。 百分比% 相对单位，取相对于父元素的百分比。 in 绝对单位 cm 绝对单位 mm 绝对单位 pt 绝对单位，1 pt = 1/72 in pc 绝对单位，1 pc = 1/6 inch = 12 pt ch 相对单位，以当前字体中的数字0为基准计算。","link":"/2020/03/27/%E8%AF%A6%E8%A7%A3css%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BD%8D/"},{"title":"解决浏览器自动填充密码框的问题","text":"做项目的时候遇到了浏览器自动填充了密码框的问题。 解决方案创建完密码框后给密码框一个 readonly='true' 属性，在 focus 的时候再将 readonly 设为 false。 代码","link":"/2023/06/16/%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E5%AF%86%E7%A0%81%E6%A1%86%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"部署腾讯云轻量应用服务器","text":"买了新的腾讯云轻量应用服务器，记录一下部署服务器的过程。 部署系统我选择了部署OpenCloudOS系统。 切换shellbash123456789101112# 查看当前shellecho $SHELL# 列出所有的shellcat /etc/shells# 查看shell安装路径which bashwhich zsh# 切换shellchsh -s /usr/bin/zsh 最后重启终端即可。 安装tldr安装tldr方便查询命令。 bash1sudo yum install -y tldr 安装neofetch安装neofetch查看系统信息。 bash1sudo yum install -y neofetch 安装bat安装bat替代cat： bash123wget -c http://repo.openfusion.net/centos7-x86_64/bat-0.7.0-1.of.el7.x86_64.rpmyum install -y bat-0.7.0-1.of.el7.x86_64.rpm 安装Gitbash1sudo yum install -y git 安装nvm使用国内源安装nvm：https://gitee.com/RubyMetric/nvm-cn/ bash1234curl -o- https://gitee.com/RubyMetric/nvm-cn/raw/main/install.sh | bashchmod +x ~/.nvm/nvm.shsource ~/.bashrc npm换源：https://gitee.com/RubyMetric/chsrc nvm安装nodejsnvm命令： bash12345678910111213141516# 查看已安装的nodejsnvm listnvm ls# 查看远端可以安装的nodejsnvm ls-remote# 安装nodejsnvm install [version_name]# 切换nodejs版本nvm use systemnvm use [version_name]# 更新nvmnvm-update 这里安装了20的LTS版本： bash123nvm install v20.13.1 node -v 安装cnpm：https://npmmirror.com/ bash123npm install -g cnpm --registry=https://registry.npmmirror.comcnpm install [package] 安装PM2PM2: https://pm2.keymetrics.io/ bash123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 安装PM2npm install pm2 -g# 启动一个进程pm2 start app.js# 启动多个进程，进程个数应设置为CPU核心数pm2 start app.js -i 4# 启动一个进程，并命名该进程pm2 start app.js --name app_name# 监控已启动的进程pm2 monit# 查看进程的日志pm2 logs app.js# 查看所有进程的日志pm2 logs# 查看进程的详情pm2 show app.js# 列出所有的进程pm2 list# 停止进程pm2 stop app.js# 停止所有进程pm2 stop all# 杀掉所有进程pm2 kill# 重启进程pm2 restart app.js# 重启所有进程pm2 restart all# 重载进程pm2 reload app.js# 重载所有进程pm2 reload all# 删除进程pm2 delete app.js# 删除所有进程pm2 delete all# 开机启动pm2 startuppm2 save 安装pythonbash12# 安装3.9sudo yum install -y python39 安装nginxbash1234567891011121314151617# 安装nginxsudo yum install -y nginx# 查看nginx状态sudo systemctl status nginx# 启动nginxsudo systemctl start nginx# 停止nginxsudo systemctl stop nginx# 重启nginxsudo systemctl restart nginx# 系统启动时启动nginxsudo systemctl enable nginx 编辑nginx配置文件：/etc/nginx/nginx.conf conf12345678910server { listen 80; # 端口 server_name www.baidu.com; # 域名或者ip root /www/test; # 代码路径 include /etc/nginx/default.d/*.conf; location / { root /www/test; index index.jsp index.html index.htm; }} 修改完配置文件后需要重新载入配置文件： bash1sudo systemctl reload nginx 然后浏览器打开ip就发现nginx服务启动成功了。 最后再将前端项目通过SCP、SFTP等工具上传到/www/test下即可通过ip访问到页面。 bash1scp -r /path/to/your/local/vue-app/dist username@your_server_ip:/path/to/your/server/vue-app/ 实际开发中一般通过CI/CD将代码部署到服务器上。 安装caddybash12345# 安装sudo yum install -y caddy# 验证caddy version 安装htopbash1sudo yum install -y htop 配置防火墙规则这里配置了常用的规则。 然后设置服务器实例套用规则。 安装mysql-serverbash1234567891011121314151617181920# 安装serversudo yum install -y mysql-server# 启动serversudo systemctl start mysqld# 停止serversudo systemctl stop mysqld# 重启serversudo systemctl restart mysqld# 启动系统时自动启动mysql-serversudo systemctl enable mysqld# 运行安全安装向导mysql_secure_installation# 登录mysqlmysql -u root -p 安全安装向导： Securing the MySQL server deployment. Connecting to MySQL using a blank password. VALIDATE PASSWORD COMPONENT can be used to test passwords and improve security. It checks the strength of password and allows the users to set only those passwords which are secure enough. Would you like to setup VALIDATE PASSWORD component? Press y|Y for Yes, any other key for No: y #是否安装密码强度验证组件 There are three levels of password validation policy: LOW Length &gt;= 8 MEDIUM Length &gt;= 8, numeric, mixed case, and special characters STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary file Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 2 #选择密码强度 ##上面选择不安装密码强度验证组件布显示这个 Please set the password for root here. New password: #设置root密码 Re-enter new password: #确认root密码 Estimated strength of the password: 90 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y #是否确定使用上面的密码 By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? (Press y|Y for Yes, any other key for No) : y #是否删除匿名用户? Success. Normally, root should only be allowed to connect from &apos;localhost&apos;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n #是否禁止root远程登录 ... skipping. By default, MySQL comes with a database named &apos;test&apos; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y #是否删除test数据库 - Dropping test database... Success. - Removing privileges on test database... Success. Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y #是否现在重新加载特权表 Success. All done! mysql基本操作： mysql12345678910111213# 列出所有的数据库SHOW DATABASES;# 选择数据库USE database_name;# 列出数据库中所有的表SHOW TABLES;# 退出EXIT;QUIT;CTRL+D 安装javabash12345678910# 安装jdksudo yum install -y java-11-openjdk# 验证java --version# 配置环境变量echo 'export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.22.0.7-2.oc8.x86_64' &gt;&gt; ~/.bashrcecho 'export PATH=$PATH:$JAVA_HOME/bin' &gt;&gt; ~/.bashrcsource ~/.bashrc 安装Dockerbash123456789101112131415161718192021222324252627# 卸载已存在的dockersudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine# 安装yum-utilssudo yum install -y yum-utils# 配置yum源sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 安装docker相关包sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin# 启动dockersudo systemctl start docker# 开机启动sudo systemctl enable docker# 运行容器sudo docker run hello-world 购买域名购买域名后添加DNS解析记录： 域名备案要提交的材料越来越多，各种实名认证、签署各种承诺书、还需要录制承诺视频。 妈的实在是太恶心了。","link":"/2024/05/17/%E9%83%A8%E7%BD%B2%E8%85%BE%E8%AE%AF%E4%BA%91%E8%BD%BB%E9%87%8F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"防止SQL注入","text":"SQL注入是指用户在表单中提交恶意SQL语句企图欺骗后台执行恶意SQL。 为了防止出现SQL注入，我们假定用户的输入不安全并且需要对用户的输入做处理。 预防方法 对用户的输入进行校验、限制。 不要动态拼装SQL。 不要使用管理员权限操作数据库，做好账号权限划分。 对于敏感信息进行加密或者hash。 封装异常返回信息，伪装内部错误信息。 采用SQL辅助检测工具。","link":"/2022/05/31/%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/"},{"title":"预处理器less的使用","text":"css预处理器：使用一种新的语言书写css代码，通过编译后生成普通css文件，我们所要做的就是安装预处理器以及学习使用它的语法，然后编译生成目标css文件。 css预处理器的优势是：提供了css复用机制，减少冗余代码，同时也提高了代码的可维护性，极大提升了css开发效率。 sass和less都是css预处理器。 less扩展了css语言，加入了变量、Mixin、函数等特性。 less可以运行在node或者浏览器。 安装使用node引入： 安装 1234$ npm install -g less# 查看是否安装成功$ less --version 编译 12345678# 编译$ lessc common.less# 编译并指定目标文件$ lessc common.less common.css# 编译并指定目标文件并压缩$ lessc --clean-css common.less common.min.css 标签引入： 12&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\" /&gt;&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js\" &gt;&lt;/script&gt; less代码写在styles.less中，script标签引入less.js，可以使用国内静态资源库替换上面的。比如75cdn： 12&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\" /&gt;&lt;script crossorigin=\"anonymous\" integrity=\"sha384-Xx4jwiERWTGivWIlK2V3UtQRXPRlrLtnx0+zsIL2/eiJGcRkOQ6CpFTNXCX6jwAV\" src=\"https://lib.baomitu.com/less.js/3.10.3/less.min.js\"&gt;&lt;/script&gt; 变量变量书写形式：@var，只能在作用域内有效，不可以重复定义变量： 1234567@cos_width: 10px;@cos_height: @cos_width * 2;header { width: @cos_width; height: @cos_height;} 赋值：只要保持单位统一或可相互转换，就可以进行运算，包括颜色在内： 123456@base: 5%;@filler: @base * 2;@other: @base + @filler;color: #888 / 4;background-color: @base-color +#111; 混入mixin就是将一组属性从一个规则集混入到另一个规则集中。 比如，我们创造一组属性： 12345/*源规则集*/.bordered { border-top: 1px red solid; border-bottom: 1px #000 dotted;} 现在我们想要在其他地方使用这组属性，使用.bordered()语句： 12345// 目标规则集div { color: #111; .bordered();} 嵌套less嵌套和sass一样 普通css代码： 123456789#header { color: black;}#header .navigation { font-size: 12px;}#header .logo { width: 300px;} 使用less写： 123456789#header { color: black; .navigation { font-size: 12px; } .logo { width: 300px; }} 可以将伪元素选择器和混入以及嵌套一起用，比如这是一个.clearfix： 12345678910111213.clearfix { display: block; zoom: 1; &amp;:after { content: ' '; display: block; font-size: 0; height: 0; clear: both; visibility: hidden; }} 在元素中调用.clearfix，注意：以上代码中的&amp;代表父元素（同sass）。 123div { .clearfix();} @规则嵌套和冒泡@规则可以和选择器以相同的方式嵌套，@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡。 123456789101112.component { width: 300px; @media (min-width: 768px) { width: 600px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } @media (min-width: 1280px) { width: 800px; }} 计算less可以使用加减乘除对数字颜色以及变量使用。算术运算符在使用的时候会进行单位换算，以最左侧类型为准，若无意义则忽略单位。 1234567@var1: 5cm + 10mm; //6cm@var2: 2 - 3cm - 5mm //-1.5cm @var3: 5%;@var4: @var3 * 2; //10%@var5: 2cm * 3cm; //6cm 对颜色计算： 12@color_base: #248 / 2; //#124@color_new: @color_base + #111; //#235 对于calc()函数：less不会计算出来，会保留calc()让css运算。 转义比如给一个变量赋值min-width: 768px Less3.5开始，无需转义，可以直接简写为：@min768: (min-width: 768px) 123456@min768: (min-width: 768px);.element { @media @min768 { font-size: 1.2rem; }} 函数less内置了一些函数用于转换颜色、处理字符串、运算。 注意：less不提供自定义函数！sass可以自定义函数！ 12345678@base: #f04615;@width: 0.5;.class { width: percentage(@width); //50% color: saturate(@base,5%); background-color: spin(lighten(@base, 25%),8);} 命名空间和访问符有时，出于组织结构或仅仅是为了提供一些封装的目的，你希望对mixin进行分组。你可以用 less 更直观地实现这一需求。假设你希望将一些mixin和变量置于 #bundle 之下，为了以后方便重用或分发： 123456789101112#bundle() { .button { display: block; border: 1px solid black; background-color: grey; &amp;:hover { background-color: white; } } .tab { ... } .citation { ... }} 现在，如果我们希望把 .button 类混合到 #header a 中，我们可以这样做： 1234#header a { color: orange; #bundle.button(); // 还可以书写为 #bundle &gt; .button 形式} 注意：如果不希望它们出现在输出的 CSS 中，例如 #bundle .tab，请将 () 附加到命名空间（例如 #bundle()）后面。 映射mapsless3.5开始，可以将mixin和规则集作为一组值的映射使用： 123456789#colors() { main: blue; second: green;}.div { color: #colors[main]; border: 1px solid #colors[second];} 作用域1234567@var: red;div { @var: white; header { color: @var; // white }} 1234567@var: red;div { header { color: @var; // white } @var: white;} 以上代码只是第二层嵌套的@var顺序不一致，但是header中引用的都是white。故而变量随用随定义。 注释第一种：/*注释*/可以单行可以多行，在css文件中会被保留在原码中。 1/*注释*/ 第二种：//注释单行注释，在less文件中，但是编译后的css文件中没有。 1//注释 import123@import \"style.less\" //如果是.less文件，则扩展名可以省略@import \"style.css\"","link":"/2019/11/10/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8less%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"预处理器sass的使用","text":"sass是一种css预处理器，它是css的扩展语言。基本思想是：使用sass语言编写sass代码，最终编译为普通的css文件。sass让我们的css代码变得更加高效和可维护。但是sass也仅能够提高写css的效率，对于css而言还是要掌握好基础。 本篇文章总结一下sass的用法。 安装由于sass由ruby编译，故而需要先安装ruby，而mac自带ruby。下面开始安装sass： gem（需ruby）安装： 1234# gem换国内源$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/# gem安装sass，如果遇到提示说没有写权限就加上sudo$ sudo gem install sass npm（需node）安装： 123$ npm install -g sass# or$ cnpm install -g sass brew安装： 1$ brew install sass/sass/sass window choco安装： 1$ choco install sass 查看是否安装成功： 1$ sass --version 使用注意：sass文件扩展名为.scss 12345# 编译scss文件$ sass style.scss# 编译scss文件并保存至目标目录$ sass style.scss style.css sass提供四种编译风格： nested：默认值，嵌套缩进的css代码。 expanded：没有缩进、扩展的css代码。 compact：简介的css代码。 compressed： 压缩的css代码。 生产环境使用第四种： 1$ sass --style compressed style.scss style.css sass监听： 12345# 监听文件$ sass --watch style.scss:style.css# 监听目录$ sass --watch project/sass_dir 变量语法： 1$var: value; sass变量可以是字符串、数字、颜色值、布尔值、列表还有null。 sass变量使用$符号开头，变量可以重复定义。 同一个变量定义了多次是可以的，不过作用域不同。 定义并使用变量。 1234567/*声明变量*/$blue: rgb(0,99,99);/*使用变量*/div { color: $blue;} 如果变量需要嵌套在字符串中，就需要写在#{}中。 1234567/*声明变量*/$side: left;/*属性名嵌套变量*/.div { border-#{$side}-radius: 4px;} 计算 12345body { margin: (10px/2); madding: 10px + 20px; width: $var * 10%;} 嵌套 选择器嵌套 比如下面这个选择器是我们原生css的写法： 123article section { color: #000;} 在scss中的写法： 12345article { section { color: #000; }} !global关键字用来定义全局变量，如果有同名变量已经被定义过，则使用这个关键词可以覆盖： 12345678$mycolor: yellow;h1 { $mycolor: red !global; color: $mycolor; //red}p { color: $mycolor; //red} 以上$mycolor是一个全局变量，全局可用。 一般来说对于全局变量，我们将它统一放在一个global.scss文件中，然后要用的使用使用@include来包含。 属性嵌套 原生css写法： 1234p { border-color: red; border-width: 1px;} 改写带sass写法： 123456p { border: { color: red; width: 1px; }} 就是将属性视为选择器，但是注意所有属性的后面要加上冒号。 使用&amp;引用父元素： 原生css： 123a:hover { color: red;} 改写为sass: 12345a { &amp;:hover { color: red; }} 这里的&amp;就指代父元素a。 4.4 sass注释 三种注释方式按照权重排序：/*!重要注释*/ &gt; /*注释*/ &gt; //注释。 第一种：/*注释*/css原生注释，可以单行可以多行，在scss文件以及css文件中均被保留在原码中。 第二种：//注释，单行注释，在scss文件中，但是编译后的css文件中没有。 第三种：重要注释，写法： 123/*! 重要注释*/ 用出是表明这个注释非常重要，编译后依然存在，甚至压缩编译后依然存在。用于声明版权。 引入@import用来引入外部文件： 123456@import \"path/style.scss\";// import scss文件可以不带扩展名@import \"path/style\" // import css文件需要写全名@import \"path.style.css\"; 引入后就可以在当前文件使用import进来文件的变量 重用 继承 sass允许一个选择器继承另一个选择器，使用@extend selector 123456789// 先声明一个选择器的属性.class_1 { border: 1px red solid;}// 另一个选择器继承上面的.class_2 { @extend .class_1;} Mixin Mixin用于定义一个代码块，用于后续重用。 定义代码块：@mixin selector {}，调用代码@@include selector; 12345678910// 定义代码块@mixin block_left { float: left; margin-left: 10px;}// 调用代码块div { @include block_left;} 定义代码块的同时可以指定参数和缺省： 12345678910// 定义新的代码块和参数@mixin block_left($value: 10px) { float: left; margin-left: $value;}// 使用div { @include block_left(10px);} mixin中也可以混入： 1234@mixin mix3 { @include mix1; @include mix2;} 颜色函数sass颜色函数用于生成系列颜色。 1234lighten(#cc3,10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c partials如果你不希望将一个 Sass 的代码文件编译到一个 CSS 文件，你可以在文件名的开头添加一个下划线。这将告诉 Sass 不要将其编译到 CSS 文件，比如_filename.scss 但是，在导入语句中我们不需要添加下划线，导入：@import filename.scss 不要将带下划线与不带下划线的同名文件放置在同一个目录下，比如，_colors.scss 和 colors.scss 不能同时存在于同一个目录下，否则带下划线的文件将会被忽略。 条件@if 123p { @if 1+1=2 {border: red 1px solid}} @else 12345@if 2&gt;1 { border: 1px red solid;} @else { border: 1px blue solid;} 循环@for循环： 12345@for $i from 1 to 10 { .block-#{$1} { border: 1px red solid; }} @while循环： 12345678$i: 6;@while $i &gt; 0 { div#{$i} { border: 1px red solid; } $i: $i - 1;} @each，作用类似于for： 12345@each $member in a,b,c,d { .#{$member} { background-image: url(\"/image/#{$member}.jpg\"); }} 自定义函数123456789// 定义一个double函数用于将参数double@function double($n) { @return $n * 2;}// 调用double函数，并传参#sidebar { with: double(100px);} 注意点 如果scss文件中有中文，则需要在文件最上方加入： 1@charset \"utf-8\" sass中的-和_作用相同。","link":"/2019/11/09/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8sass%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Node.js开发笔记——Sequelize（ORM库）","text":"在 Node.js 项目中可以使用Sequelize这个ORM（对象关系映射）库来将项目中的 Model 和数据库表进行映射以及可以让我们可以使用 JavaScript 的对象和方法来操作数据库（CRUD），而不必编写原生 SQL 语句。 安装安装 Sequelizebash1npm install -S sequelize 安装对应数据库驱动bash1234567891011121314151617# 安装MySQL驱动npm install -S mysql2# 安装PostgreSQL驱动npm install -S pg pg-hstore# 安装SQLite驱动npm install -S sqlite3# 安装MSSQL驱动npm install -S tedious# 安装MariaDB驱动npm install -S mariadb# 安装Oracle数据库驱动npm install -S oracledb 使用Sequelize提供的大多数方法都是异步的，会返回Promise，所以可以使用Promise API。 创建 Sequelize 实例创建一个Sequelize实例并连接到数据库： models/index.js1234567891011121314151617181920const { Sequelize } = require(\"sequelize\");// 创建Sequelize实例，连接到MySQL数据库const sequelize = new Sequelize(\"database_name\", \"username\", \"password\", { host: \"localhost\", dialect: \"mysql\", // 选择数据库类型：'mysql' | 'postgres' | 'sqlite' | 'mssql'});// 测试连接是否成功sequelize .authenticate() .then(() =&gt; { console.log(\"Connection has been established successfully.\"); }) .catch((err) =&gt; { console.error(\"Unable to connect to the database:\", err); });// 导出Sequelize实例变量module.exports = sequelize; 定义模型（Model）在 Sequelize 中，模型代表数据库中的表。可以通过定义模型来映射数据库表及其字段。 models/user.js123456789101112131415161718192021222324252627282930const { DataTypes } = require(\"sequelize\");// 引入前面创建的 Sequelize 实例const sequelize = require(\"./index\");// 定义User模型const User = sequelize.define( \"User\", { username: { type: DataTypes.STRING, allowNull: false, unique: true, }, password: { type: DataTypes.STRING, allowNull: false, }, email: { type: DataTypes.STRING, allowNull: false, unique: true, }, }, { tableName: \"users\", // 自定义表名，如果不指定，Sequelize 会自动将模型名转换为复数形式作为表名 timestamps: true, // 自动添加 createdAt 和 updatedAt 字段 });module.exports = User; 同步模型与数据库在项目启动时同步模型和数据库。 在项目入口 js 文件中添加： index.js123456789101112const sequelize = require(\"./models/index\");const User = require(\"./models/user\");// 同步模型sequelize .sync({ force: false }) // { force: true } 会先删除表然后重新创建（慎用） .then(() =&gt; { console.log(\"Database &amp; tables created!\"); }) .catch((err) =&gt; { console.error(\"Failed to sync database:\", err); }); CRUD 操作可以调用模型的 CRUD 方法操作数据库。 Create js1234567891011User.create({ username: \"john_doe\", password: \"secret123\", email: \"john@example.com\",}) .then((user) =&gt; { console.log(\"User created:\", user.toJSON()); }) .catch((err) =&gt; { console.error(\"Failed to create user:\", err); }); Read js12345678910111213141516171819User.findOne({ where: { username: \"john_doe\" } }) .then((user) =&gt; { if (user) { console.log(\"User found:\", user.toJSON()); } else { console.log(\"User not found\"); } }) .catch((err) =&gt; { console.error(\"Failed to find user:\", err); });User.findAll() .then((users) =&gt; { console.log(\"All users:\", JSON.stringify(users, null, 2)); }) .catch((err) =&gt; { console.error(\"Failed to find users:\", err); }); Update js1234567User.update({ password: \"newpassword123\" }, { where: { username: \"john_doe\" } }) .then((rowsUpdated) =&gt; { console.log(\"Number of rows updated:\", rowsUpdated); }) .catch((err) =&gt; { console.error(\"Failed to update user:\", err); }); Delete js1234567User.destroy({ where: { username: \"john_doe\" } }) .then((rowsDeleted) =&gt; { console.log(\"Number of rows deleted:\", rowsDeleted); }) .catch((err) =&gt; { console.error(\"Failed to delete user:\", err); }); 记录日志默认情况下，Sequelize将记录控制台执行的每个SQL查询。可以使用options.logging参数来自定义每次 Sequelize记录某些内容时将执行的函数。默认值为console.log，使用该值时仅显示日志函数调用的第一个参数。例如，对于查询日志记录，第一个参数是原始查询，第二个参数(默认情况下是隐藏的)是Sequelize对象。 js12345678const sequelize = new Sequelize('sqlite::memory:', { // 选择一种日志记录参数 logging: console.log, // 默认值,显示日志函数调用的第一个参数 logging: (...msg) =&gt; console.log(msg), // 显示所有日志函数调用参数 logging: false, // 禁用日志记录 logging: msg =&gt; logger.debug(msg), // 使用自定义记录器(例如Winston 或 Bunyan),显示第一个参数 logging: logger.debug.bind(logger) // 使用自定义记录器的另一种方法,显示所有消息}); 关系映射Sequelize 支持定义表之间的关系（一对一、一对多、多对多）。 定义User和Post之间为一对多的关系： js1234567891011const Post = sequelize.define(\"Post\", { title: DataTypes.STRING, content: DataTypes.TEXT,});// 一对多关系：一个用户可以有多个帖子User.hasMany(Post);Post.belongsTo(User);// 在同步时，Sequelize 会自动设置外键sequelize.sync(); 查询生成器Sequelize 支持复杂的查询构建与聚合操作，可以轻松实现分页、排序、分组等操作。 js123456789101112User.findAll({ where: { email: { [Op.like]: \"%@example.com\" } }, order: [[\"createdAt\", \"DESC\"]], limit: 10, offset: 20,}) .then((users) =&gt; { console.log(\"Paged users:\", JSON.stringify(users, null, 2)); }) .catch((err) =&gt; { console.error(\"Failed to retrieve users:\", err); }); 事务处理（Transactions）通过sequelize.transaction()来管理事务，确保操作的原子性。 js1234567891011121314151617181920212223242526sequelize .transaction(async (t) =&gt; { const user = await User.create( { username: \"jane_doe\", password: \"password123\", email: \"jane@example.com\", }, { transaction: t } ); await Post.create( { title: \"Jane's first post\", content: \"This is Jane's first post\", userId: user.id, }, { transaction: t } ); }) .then(() =&gt; { console.log(\"Transaction has been committed\"); }) .catch((err) =&gt; { console.error(\"Transaction has been rolled back:\", err); }); 验证与钩子（Hooks）Sequelize 提供内置的验证机制，并允许你定义生命周期钩子，在模型操作前后执行代码。 js12345678910111213141516171819202122232425const User = sequelize.define( \"User\", { username: { type: DataTypes.STRING, allowNull: false, unique: true, validate: { len: [4, 20], // 验证用户名长度在 4 到 20 个字符之间 }, }, password: { type: DataTypes.STRING, allowNull: false, }, }, { hooks: { beforeCreate: (user) =&gt; { // 在创建用户前对密码进行哈希处理 user.password = hashPassword(user.password); }, }, }); 配置与环境变量可以通过环境变量或配置文件管理不同环境下的数据库连接配置： js123456789const sequelize = new Sequelize( process.env.DB_NAME, process.env.DB_USER, process.env.DB_PASSWORD, { host: process.env.DB_HOST, dialect: \"mysql\", }); 迁移与种子数据Sequelize CLI工具支持数据库迁移和种子数据管理。可以通过命令行生成和应用迁移来管理数据库的演进。 bash123npx sequelize-cli initnpx sequelize-cli model:generate --name User --attributes username:string,email:stringnpx sequelize-cli db:migrate 参考 https://www.sequelize.cn/","link":"/2024/08/29/nodejs-orm-sequelize/"},{"title":"Node.js开发笔记——Mongoose（ODM库）","text":"Mongoose是 Node.js的ODM库。 和Sequelize类似，Mongoose提供了node.js对于MongoDB进行操作的便利。 安装bash1npm install -S mongoose 使用 连接MongoDB js123456789const mongoose = require(\"mongoose\");mongoose .connect(\"mongodb://localhost:27017/mydatabase\", { useNewUrlParser: true, useUnifiedTopology: true, }) .then(() =&gt; console.log(\"Connected to MongoDB\")) .catch((err) =&gt; console.error(\"Could not connect to MongoDB...\", err)); 定义Schema Mongoose中使用Schema来定义文档结构。 js123456const userSchema = new mongoose.Schema({ name: { type: String, required: true }, age: Number, email: { type: String, required: true, unique: true }, created_at: { type: Date, default: Date.now }}); 创建模型Model 使用以上创建好的Schema来创建模型Model。 js1const User = mongoose.model('User', userSchema); 创建和保存 使用上面创建好的Model可以对数据进行CRUD。 js1234567891011// 创建user记录const user = new User({ name: 'John Doe', age: 30, email: 'johndoe@example.com'});// 保存user记录user.save() .then(doc =&gt; console.log('User saved:', doc)) .catch(err =&gt; console.error('Error saving user:', err)); 关闭连接 js1mongoose.connection.close(); CRUD Create js12345const user = new User({ name: 'John Doe', age: 30, email: 'johndoe@example.com'}); Read js1234567User.findOne({ name: 'John Doe' }) .then(user =&gt; console.log('User found:', user)) .catch(err =&gt; console.error('Error finding user:', err));User.find({ name: 'John Doe' }) .then(users =&gt; console.log('Users found:', users)) .catch(err =&gt; console.error('Error finding users:', err)); Update js1234567891011User.updateOne({ name: 'John Doe' }, { age: 31 }) .then(result =&gt; console.log('User updated:', result)) .catch(err =&gt; console.error('Error updating user:', err));User.updateMany({ name: 'John Doe' }, { age: 31 }) .then(result =&gt; console.log('User updated:', result)) .catch(err =&gt; console.error('Error updating user:', err));User.findByIdAndUpdate(userId, { age: 27 }, { new: true }) .then(user =&gt; console.log('Updated user:', user)) .catch(err =&gt; console.error('Error updating user:', err)); Delete js1234567User.deleteOne({ name: 'John Doe' }) .then(result =&gt; console.log('User deleted:', result)) .catch(err =&gt; console.error('Error deleting user:', err));User.findByIdAndDelete(userId) .then(user =&gt; console.log('Deleted user:', user)) .catch(err =&gt; console.error('Error deleting user:', err)); 中间件Mongoose还支持使用中间件（middleware）来执行一些预处理或后处理操作。 js12345// 在保存之前执行一些代码userSchema.pre('save', function(next) { console.log('Before saving a user'); next();}); 参考 https://mongoosejs.net/ https://mongoosejs.com/","link":"/2024/08/29/nodejs-odm-mongoose/"},{"title":"在Node.js项目微服务架构中使用RabbitMQ通信","text":"消息队列（MQ）可以让系统中不同部分的应用程序或者不同的微服务之间进行异步通信。 Node.js常用的MQ有RabbitMQ、Kafka、或Redis等。 安装搭建RabbitMQ服务器构建一个RabbitMQ服务器的Docker容器并暴露服务端口。 bash1docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management 5672端口是RabbitMQ的默认通信端口，15672端口是web管理界面的端口。 安装amqplib包在Node.js项目中安装amqplib： bash1npm install -S amqplib 使用连接RabbitMQ服务器并发送消息到队列创建一个消息生产者，连接RabbitMQ并发送消息到队列： js1234567891011121314151617181920212223242526272829303132333435const amqp = require('amqplib/callback_api');amqp.connect('amqp://localhost', function(error0, connection) { if (error0) { throw error0; } // 创建一个通道 connection.createChannel(function(error1, channel) { if (error1) { throw error1; } const queue = 'task_queue'; // 声明一个队列 channel.assertQueue(queue, { durable: true }); // 发送消息到队列 const msg = 'Hello World'; channel.sendToQueue(queue, Buffer.from(msg), { persistent: true }); console.log(\" [x] Sent '%s'\", msg); }); // 关闭连接 setTimeout(function() { connection.close(); process.exit(0); }, 500);}); 从队列中消费消息创建一个消息消费者，从消息队列中取出消息并消费： js12345678910111213141516171819202122232425262728293031323334353637const amqp = require('amqplib/callback_api');amqp.connect('amqp://localhost', function(error0, connection) { if (error0) { throw error0; } connection.createChannel(function(error1, channel) { if (error1) { throw error1; } const queue = 'task_queue'; channel.assertQueue(queue, { durable: true }); channel.prefetch(1); console.log(\" [*] Waiting for messages in %s. To exit press CTRL+C\", queue); // 消费消息 channel.consume(queue, function(msg) { const secs = msg.content.toString().split('.').length - 1; console.log(\" [x] Received %s\", msg.content.toString()); setTimeout(function() { console.log(\" [x] Done\"); channel.ack(msg); }, secs * 1000); }, { noAck: false }); });}); 持久化 队列持久化 消息消费者连接队列时开启durable: true可以实现队列持久化。 消息持久化 消息生产者发送消息时开启persistent: true可以实现消息持久化。","link":"/2024/08/31/nodejs-rabbitmq/"},{"title":"在Node.js项目微服务架构中使用Kafka通信","text":"Kafka相比于RabbitMQ性能更好。 安装安装Kafka客户端库bash1npm install -S kafkajs 配置Kafka broker集群通常会使用多个Kafka代理（broker）构成集群。 Kafka broker集群可以提高系统的可用性和吞吐量。 js12345678const kafka = new Kafka({ clientId: 'my-app', brokers: ['broker1:9092', 'broker2:9092'], // 重试机制 retry: { retries: 5 }}); 创建生产者Kafka生产者向Topic发送消息： js12345678910111213141516171819202122232425262728const { Kafka } = require('kafkajs');// 创建Kafka实例并指定Kafka代理（broker）的地址const kafka = new Kafka({ clientId: 'my-app', brokers: ['localhost:9092']});// 创建一个生产者const producer = kafka.producer();const run = async () =&gt; { // 连接生产者 await producer.connect(); // 发送一条消息到指定的主题 await producer.send({ topic: 'test-topic', messages: [ { value: 'Hello KafkaJS user!' }, ], }); // 断开连接 await producer.disconnect();};run().catch(console.error); 创建消费者Kafka消费者从Topic中读取消息并消费： js12345678910111213141516171819202122232425262728293031const { Kafka } = require('kafkajs');// 创建Kafka实例并指定Kafka代理（broker）的地址const kafka = new Kafka({ clientId: 'my-app', brokers: ['localhost:9092']});// 创建一个消费者并指定消费的组IDconst consumer = kafka.consumer({ groupId: 'test-group' });const run = async () =&gt; { // 连接消费者 await consumer.connect(); // 订阅主题 await consumer.subscribe({ topic: 'test-topic', fromBeginning: true }); // 处理消息 await consumer.run({ eachMessage: async ({ topic, partition, message }) =&gt; { console.log({ partition, offset: message.offset, value: message.value.toString(), }); }, });};run().catch(console.error);","link":"/2024/08/31/nodejs-kafka/"},{"title":"Docker学习笔记","text":"Docker是容器化平台，可以构建、打包、部署和运行应用程序。 Docker可以将应用程序及依赖打包成一个轻量级的便于移植的容器，然后部署到支持Docker的平台。 安装参照官网：https://www.docker.com/ 基本概念镜像（Image）Docker镜像是一个只读的模板，包含了创建Docker容器的指令。 还可以基于一个镜像来创建另一个镜像并在此基础上添加一些自定义配置。 容器（Container）Docker容器是一个独立的环境，它基于Docker镜像创建而来，Docker容器是镜像的实例，容器包含了应用程序及其运行时。 容器之间是相互隔离的，每个容器都有自己的文件系统。可以将容器看作是轻量的、便于移植的虚拟机。 DockerfileDockerfile是一个文本文件，包含了一系列指令，他告诉Docker如何构建镜像。 Docker VolumeDocker Volume是Docker提供的持久化存储机制。 Docker HubDocker Hub是一个存储Docker镜像的公共仓库，可以上传或者下载镜像。 命令bash123456789101112131415161718192021222324252627282930313233# 查看docker版本docker --version# 拉取镜像docker pull &lt;image_name&gt;# 例如：拉取最新的Ubuntu镜像docker pull ubuntu:latest# 运行容器docker run -it --name &lt;container_name&gt; &lt;image_name&gt;# 例如：运行一个基于Ubuntu的容器docker run -it --name my_ubuntu ubuntu:latest# 查看运行中的容器docker ps# 查看所有容器docker ps -a# 停止容器docker stop &lt;container_name&gt;# 启动容器docker start &lt;container_name&gt;# 进入运行中的容器docker exec -it &lt;container_name&gt; /bin/bash# 删除容器docker rm &lt;container_name&gt;# 删除镜像docker rmi &lt;image_name&gt; 创建镜像在项目目录下创建一个Dockerfile来创建镜像。 Dockerfile： Dockerfile1234567891011121314151617181920# 使用官方的Node.js镜像作为基础镜像FROM node:18# 设置工作目录WORKDIR /app# 复制 package.json 和 package-lock.jsonCOPY package*.json ./# 安装依赖RUN npm install# 复制项目文件COPY . .# 暴露应用程序的端口EXPOSE 3000# 启动应用CMD [\"node\", \"app.js\"] 带有TypeScript编译阶段的Dockerfile： Dockerfile12345678910111213141516171819202122232425# 构建阶段FROM node:18 AS builderWORKDIR /appCOPY package*.json ./RUN npm installCOPY . .# 假设项目使用 TypeScript，首先编译RUN npm run build# 生产阶段FROM node:18-slimWORKDIR /appCOPY --from=builder /app/package*.json ./COPY --from=builder /app/dist ./distCOPY --from=builder /app/node_modules ./node_modulesEXPOSE 3000CMD [\"node\", \"dist/app.js\"] 那么，上面的RUN和CMD有什么区别？ RUN是在image文件的构建阶段执行的，CMD是在容器启动后执行的。一个Dockerfile可以包含多个RUN，但是只能包含一个CMD。 构建镜像bash12# .代表Dockerfile所在目录docker build -t my-node-app . 运行容器bash12# 将本地的3000端口映射到容器的3000端口docker run -p 3000:3000 my-node-app 持久化比如对于数据库容器，每次部署数据库容器都会删除原来的容器，故而容器内的数据也会被删除。 可以将数据库的数据目录挂载到主机的一个目录（或者说映射），这样就不会在部署新容器后丢失数据。 使用Docker Volume 创建Docker Volume bash1docker volume create mysql_data 启动MySQL并挂载Volume到容器内目录 bash123456# 将mysql_data这个卷挂载到容器内的/var/lib/mysql，这个目录是MySQL数据库默认的存储位置docker run -d \\ --name mysql \\ -e MYSQL_ROOT_PASSWORD=my-secret-pw \\ -v mysql_data:/var/lib/mysql \\ mysql:latest 使用主机目录挂载还可以直接将主机上的一个目录挂载到容器的MySQL数据存储目录。 创建主机目录 bash1mkdir -p /my/mysql_data 启动MySQL容器并挂载目录 bash12345docker run -d \\ --name mysql \\ -e MYSQL_ROOT_PASSWORD=my-secret-pw \\ -v /my/own/datadir:/var/lib/mysql \\ mysql:latest Docker ComposeDocker Compose是一个用于定义和管理多容器Docker应用的工具。也可以使用k8s管理Docker容器。 可以使用docker-compose.yml文件来定义应用的服务、网络和卷等。 docker-compose.yml12345678version: '3'services: app: image: my-node-app build: context: . ports: - \"3000:3000\" 构建并启动docker-compose.yml中的所有服务： bash12345# 启动应用docker-compose up# 停止应用docker-compose down 参考 https://www.docker.com/ https://www.runoob.com/docker/docker-tutorial.html","link":"/2024/08/30/docker-notes/"},{"title":"Node.js项目实现微服务架构","text":"微服务是一种软件架构风格，在这种架构中，应用程序被构建为一组小的、独立的服务，每个服务负责处理特定的业务功能。这些服务可以独立开发、部署和扩展，并通过轻量级的通信机制（通常是 HTTP API）进行互相通信。 微服务的特点 模块化：每个微服务都是一个独立的模块，负责特定的业务功能。不同的团队可以独立地开发和维护不同的微服务。 独立部署：微服务可以独立部署和更新，而不必影响其他服务。这使得应用程序更具灵活性，能够快速响应变化。 技术多样性：不同的微服务可以使用不同的编程语言、数据库和技术栈，选择最适合其功能的技术。 可扩展性：由于微服务是独立的，特定的微服务可以独立扩展，从而优化资源利用。 容错性：因为微服务是分布式的，如果一个服务出现故障，通常不会导致整个系统崩溃。 Node.js实现微服务将应用拆分为多个服务首先，将单体应用拆分为多个独立的微服务。每个微服务应专注于一个特定的业务功能，例如用户管理、订单处理、支付等。 每个微服务可能会拥有自己的数据库，以实现服务之间的解耦。 数据库可能需要分片或者复制以提高性能和容错性。 在微服务之间或微服务与数据库之间使用缓存层（如 Redis、Memcached）来加速数据访问和减少数据库负载。 使用分布式数据库（如 Cassandra、CockroachDB）来存储和管理海量数据。 对于文件或大数据对象，可以使用分布式对象存储（如 AWS S3、MinIO）来存储和访问。 使用独立的代码库和包管理每个微服务应当拥有自己的代码库和独立的package.json文件。这使得它们可以独立管理依赖项，并能够使用不同的 Node.js 版本或第三方库。 选择合适的通信方式微服务之间需要通信。 微服务常见的通信方式： HTTP/RESTfull API：每个微服务暴露 RESTfull API 供其他服务调用。 消息队列（MQ）：可以使用 MQ 来异步传递消息，常用的 MQ 有 RabbitMQ、Apache Kafka、Redis Streams 等。 gRPC：是一种 RPC（远程过程调用）框架，适合高性能通信场景。 选择合适的 web 框架构建 RESTfull 微服务比如 Express 或者 Koa.js 等。 服务注册和发现可以使用微服务注册和发现工具来管理与发现这些微服务。 常用的：Consul、Eureka、etcd 配置管理每个微服务拥有自己的配置，可以使用配置管理工具来管理配置。 常用的：Consul、Vault 日志记录和监控常用的日志聚合工具：ELK（Elasticsearch, Logstash, Kibana） 常用的监控工具：Prometheus、Grafana 部署可以将每个微服务打包成 Docker 容器，再使用 Docker Compose 或者 K8s 自动化部署、扩展、管理这些容器。 CI/CD：使用 Jenkins、GitLab CI、CircleCI 等工具实现自动化的构建、测试和部署流程。 蓝绿部署/金丝雀发布：在发布新版本时，采用蓝绿部署或金丝雀发布策略，减少发布风险。 负载均衡和代理微服务层之间需要使用负载均衡器来实现流量分发，以实现高可用性和容错性。 常用的负载均衡器：HAProxy、Nginx、AWS ELB 还需要使用反向代理来分发来自 API 网关的请求到适当的微服务，常用 Nginx 反向代理。 API 网关可以使用 API 网关来统一管理和路由所有微服务的请求。 API 网关可以处理请求路由、认证、限流。 常用的 API 网关：Nginx、Kong、Express Gateway 等。 容错处理在分布式系统中可能会出现某个微服务失效。 可以使用熔断器比如 opossum 来防止级联故障，确保在某个微服务失败时，系统其他部分仍然可用。 Node.js微服务简单实例 为微服务创建一个目录，用于存放所有的微服务。 微服务项目目录结构： my-microservices-project/ ├── api-gateway/ │ ├── package.json │ ├── index.js ├── user-service/ │ ├── package.json │ ├── index.js ├── order-service/ │ ├── package.json │ ├── index.js ├── docker-compose.yml └── README.md 为每个微服务创建一个目录。 每个微服务拥有自己的目录以及package.json文件。 user-service/package.json12345678{ \"name\": \"user-service\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"dependencies\": { \"express\": \"^4.17.1\" }} 编写微服务，每个微服务都相当于是一个Node.js项目。 user-service/index.js1234567891011const express = require('express');const app = express();const port = 3001;app.get('/users', (req, res) =&gt; { res.json([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);});app.listen(port, () =&gt; { console.log(`User service running on port ${port}`);}); API Gateway 创建api-gateway/index.js文件，用于路由客户端的请求到对应的微服务。 api-gateway/index.js1234567891011121314151617const express = require('express');const httpProxy = require('http-proxy');const app = express();const port = 3000;const proxy = httpProxy.createProxyServer();app.get('/users', (req, res) =&gt; { proxy.web(req, res, { target: 'http://localhost:3001' });});app.get('/orders', (req, res) =&gt; { proxy.web(req, res, { target: 'http://localhost:3002' });});app.listen(port, () =&gt; { console.log(`API Gateway running on port ${port}`);}); 启动微服务 bash1234567891011121314# 启动gatewaycd api-gatewaynpm installnode index.js# 启动user-service服务cd user-servicenpm installnode index.js# 启动order-service服务cd order-servicenpm installnode index.js 现在api-gateway和微服务已经运行了： http://localhost:3000：运行了api-gateway，它将客户端请求路由到对应的微服务。 http://localhost:3001：运行了user-service服务。 http://localhost:3002：运行了order-service服务。 测试微服务 使用postman或者cURL测试微服务。 微服务容器化 为每个服务创建Dockerfile文件，然后使用Docker Compose或者K8s来编排这些服务的容器。 这里使用Docker Compose。 第一步：为每个服务创建Dockerfile文件 Dockerfile123456FROM node:14WORKDIR /appCOPY package.json /appRUN npm installCOPY . /appCMD [\"node\", \"index.js\"] 第二步：使用Docker Compose，创建docker-compose.yml文件来编排服务容器 docker-compose.yml1234567891011121314version: '3'services: user-service: build: ./user-service ports: - \"3001:3001\" order-service: build: ./order-service ports: - \"3002:3002\" api-gateway: build: ./api-gateway ports: - \"3000:3000\" 第三步：启动所有服务 bash1docker-compose up","link":"/2024/08/31/nodejs-microservices/"},{"title":"Kubernetes(K8s)学习笔记","text":"Kubernetes(K8s)用于自动化部署、扩展和管理容器化应用程序。 基本概念Container一个独立的、轻量级的可运行的包，包含应用程序和它的所有依赖。 PodPod是K8s中的最小部署单位，他可以包含一个或者多个容器。 NodeNode就是K8s集群中的一台机器，可以包含一个或者多个Pod。 ClusterCluster就是由多个Node组成的集群。 ServiceService为一组Pod提供持久的IP地址和负载均衡功能，使得Pod可以稳定的被外部访问。 NamespaceNamespace是K8s中的逻辑隔离单元，用于将集群中的资源划分到不同的虚拟子集。 DeploymentDeployment定义应用程序的部署方式和策略，支持滚动更新和回滚操作。 安装K8sMinikubeMinikube是本地的K8s集群，用于开发和测试。 bash12345678# 安装Minikubecurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/# 启动Minikubeminikube start# 查看Minikube状态minikube status kubectlkubectl是用于管理集群的命令行工具。 bash1234567# 安装kubectlcurl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"chmod +x kubectlsudo mv kubectl /usr/local/bin/# 查看是否安装成功kubectl version --client 创建K8s部署（Deployment）创建Deployment： bash123456# 创建一个nginx部署kubectl create deployment nginx --image=nginx# 查看创建的Deployment和Podkubectl get deploymentskubectl get pods 暴露服务： bash1234567# 对外暴露nginx部署kubectl expose deployment nginx --type=NodePort --port=80# 查看部署的服务信息kubectl get service nginxkubectl get servicesminikube service nginx --url 扩展和更新扩展Pod副本数bash1kubectl scale deployment nginx --replicas=3 更新容器镜像bash1kubectl set image deployment/nginx nginx=nginx:1.19 回滚bash1kubectl rollout undo deployment/nginx 删除服务和部署bash12kubectl delete service nginxkubectl delete deployment nginx","link":"/2024/08/30/kubernetes-k8s-notes/"},{"title":"fastjson学习笔记","text":"fastjson 是一个Java的JSON序列化库，用于在Java对象和JSON字符串之间的互相转换。 fastjson可以将Java对象转为JSON字符串（序列化），也可以将JSON字符串转为java对象（反序列化）。 安装官网：https://github.com/alibaba/fastjson 在Maven项目的 pom.xml 文件中添加fastjson依赖。 pom.xml123456&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt; 使用 引入fastjson和相关包 12345import java.util.List;import java.util.ArrayList;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject; fastjson的入口类是 com.alibaba.fastjson.JSON，提供了两个核心方法： JSON.toJSONString：将Java对象序列化为JSON字符串 JSON.parseObject：将JSON字符串解析为Java对象 创建JSON对象 12JSONObject jsonObject = new JSONObject();jsonObject.put(\"name\", \"Mason\"); 将List转为JSON 123456789101112// 构造ListList&lt;String&gt; list = new ArrayList&lt;string&gt;();list.add(\"item1\");list.add(\"item2\");list.add(\"item3\");// 方法一：先把List转为JSONArray，再使用toString()转为JSONJSONArray jsonArray = new JSONArray(list);String json = jsonArray.toString();// 方法二：使用JSON.toJSONString()直接将List转为JSONString json = JSON.toJSONString(list);","link":"/2023/09/07/fastjson-notes/"},{"title":"SQLite学习笔记","text":"SQLite是一个轻量级的嵌入式关系型数据库。 主要应用场景： 嵌入式设备 移动应用 桌面应用 安装SQLite是跨平台的（包括windows、macOS、Linux、iOS、Android等）。 官网下载安装：https://www.sqlite.org/download.html 创建数据库通过命令行创建数据库： bash1sqlite3 database_name.db 也可以在项目代码中创建数据库。 CRUDSQLite的CRUD和MySQL一样，都是用的SQL。 数据类型SQLite采用动态数据类型，插入什么数据类型就是什么数据类型，但最终插入表中的数据只能是以下五种类型。 SQLite中的数据类型 NULL: 空值 INTEGER: 有符号的整型 REAL: 浮点数 TEXT: 字符串 BLOB: 二进制对象 Affinity类型Affinity类型就是建议类型。 在插入数据时，SQLite会根据你传入的值来转为建议类型，如果不能转，则使用你传入的数据类型进行存储。 Boolean类型会被存储为0(false)或者1(true)。 Date类型会被存储为TEXT, REAL, INTEGER。 常见SQL数据库数据类型和SQLite数据类型对照 INTEGER: INT, INTEGER, TINYINT, SMALLINT, MEDIUMINT, BIGINT, UNSIGNED BIG INT REAL: REAL, FLOAT, DOUBLE, DOUBLE PRECISION TEXT: CHARACTER, VARCHAR, VARYING CHARACTER, NCHAR, NATIVE CHARACTER, NVARCHAR, TEXT, CLOB NUMERIC: NUMERIC, DECIMAL, BOOLEAN, DATE, DATETIME BLOB: BLOB 关闭数据库连接可以通过SQL命令关闭SQLite： sql1.quit 或者在项目代码中关闭SQLite。 备份和恢复SQLite数据库文件就是一个普通的文件，备份时复制它，需要恢复时复制回来即可。","link":"/2023/09/21/SQLite-notes/"},{"title":"Android开发笔记","text":"Android开发笔记 编程语言Java阅读Java文档。 Kotlin阅读Kotlin文档。 Android应用结构和基本组件包括四大基本组件Activity、Service、BroadcastReceiver、ContentProvider以及Fragment、Intent、View、Layout、Resources、Manifest等。 可以查看Android官方文档学习。 UI设计包括官方文档和Material Design。 数据存储包括SharedPreferences、读写文件、SQLite本地数据库、Room持久库。 网络通信包括Retrofit和Volley等库。 性能优化包括内存管理、电池优化、响应速度优化等。","link":"/2024/07/08/Android-notes/"},{"title":"Vue中的ref和reactive有什么区别","text":"Vue中的ref和reactive都是用于创建响应式数据的函数，那他们有什么区别呢？ refref主要用于创建原始类型的响应式数据，比如字符串、数字、布尔值等。也可以用来创建对象或者数组。 用ref创建出来的响应式数据会被包裹在value属性中，需要通过.value来访问和更新它的值。 当响应式数据的值发生变化时，Vue会更新View。 reactivereactive主要用于创建对象或者数组的响应式数据。 不同与ref需要通过.value来访问，reactive可以直接访问。 当响应式数据的值发生变化时，Vue会更新View。 使用场景那么什么时候用ref，什么时候用reactive？ 使用ref的场景：当有一个单独的值需要响应式管理时，如计数器、布尔开关、单一输入框的值等。使用reactive的场景：当需要管理一个复杂的状态比如对象或数组时，如表单数据、包含多个属性的状态对象等。","link":"/2022/09/14/vue-ref-reactive/"},{"title":"MySQL架构","text":"MySQL架构 连接池连接池的作用是复用连接，避免频繁 create, destroy。 分析器分析器就是解析 SQL 语句。 优化器优化器会分析 SQL 语句并对其优化。 执行器执行器会调用存储引擎的接口来执行 SQL 语句。 存储引擎MySQL 有多重存储引擎，用于不同场景。 InnoDB(最常用) MyISAM Memory CSV Archive Blackhole Merge Federated Example 存储引擎就是 MySQL 对于内存和磁盘的读写策略。 InnoDB 包括了：Buffer Pool(数据存储在其中)和 Log Buffer Buffer PoolMySQL 服务器的内存基本都会分配给 Buffer Pool，可以提升 MySQL 的性能。 页Buffer Pool 以页为单位存储。 一页包含了： 上一页，下一页两个指针 User Record(真正存储信息的地方，是一行一行的数据) 其余字段 其余字段包含了： Infimum 和 Supremum：此页中最大和最小的记录，用于做初步判断。 Page Directory：页面目录，用于快速查找记录。 索引InnoDB 底层采用的存储结构是 B 树和 B+树。 更新数据更新数据时，数据不一定在 buffer pool 中，因为不可能数据库中所有的数据都一直在内存中。 对于聚簇索引：如果数据不在 buffer pool 中，就会将其先加载到内存中再更新。 对于非聚簇索引：change buffer。 过期策略MySQL 使用的 LRU 算法的改进版，改进 LRU 算法是为了避免缓冲池污染（先前在 buffer pool 中的页被全部换出去，造成性能下降） Log Buffer用于存储即将被写入到磁盘中的日志。","link":"/2022/05/05/mysql-arch/"},{"title":"Learning MongoDB","text":"MongoDB is a type of NoSQL database suitable for storing large-scale data. MongoDB is a document based database, the data is stored in a JSON-like document format. MongoDB uses Collections to organize documents, and each document is composed of key-value pairs. Concepts Database: A container for storing data, similar to a database in relational database. Collection: A collection in database, similar to a table in relational database. Document: A data record in a collection, similar to a row in relational database, stored in BSON format. MongoDB stores data as a document, with a data structure consisting of key-value pairs. The document is similar to a JSON object, and field values can contain other documents, arrays, and document arrays. mapping: SQL Concept MongoDB Concept Remark database database database table collection databse table/collection row document data record column field data field index index index table joins MongoDB not supported primary key primary key MongoDB will set _id to primary key Installationbash12345# install community editionbrew install mongodb-community# start on startupbrew services start mongodb-community MongoDB Shell MongoDB Shell is a interactive interface provided by official, allowing users to interact with the MongoDB database, execute commands, and operate the database. The MongoDB Shell is based on JavaScript and allows users to operate the MongoDB database directly from the command line or within scripts using the JavaScript language. bash12345678910# start mongo shell# in older versionsmongo# in the new versionmongosh# connect to a remote mongodb servermongosh --host &lt;hostname&gt;:&lt;port&gt; Basic Operationsmongosh123456789101112131415161718192021222324# show current databasedb;# show database listshow dbs;# switch to the specified databaseuse &lt;db_name&gt;;# execute query operationdb.&lt;collection_name&gt;.find();# insert a documentdb.&lt;collection_name&gt;.insertOne({...});# update a documentdb.&lt;collection_name&gt;.updateOne({...}, {...});# delete a documentdb.&lt;collection_name&gt;.deleteOne({...});# exit shellquit()exit MongoDB Tools MongoDB Compass: A free GUI tool. Navicat: A paid GUI tool. Studio 3T: A paid GUI tool, with a good CRUD operations experience. References https://www.mongodb.com/docs/manual/introduction/ https://www.runoob.com/mongodb/mongodb-tutorial.html","link":"/2024/06/28/MongoDB-notes/"},{"title":"设计模式（ongoing）","text":"设计模式是在软件开发过程中对于问题的解决方案，也是软件开发的最佳实践。 比如如果某个接口的结构已经无法满足现在的需求，但是由于众多功能对于这个接口的依赖导致我们又不能改动这个接口，这个时候就可以使用适配器模式来解决这个问题。 适配器模式详细内容：https://www.runoob.com/design-pattern/adapter-pattern.html 常见的设计模式 单例模式：保证一个类只有一个实例，只提供一个全局访问点。先判断实例是否已经存在，如果存在就直接返回该实例，不存在就先创建实例。 工厂模式：工厂负责实现实例的内部逻辑。抽象产品是所有产品对象的父类，负责描述产品实例的所有公共接口。产品实例是抽象产品的实例。 策略模式：定义一系列单独封装的算法，且他们可以相互替换。其中分为策略类（可变，封装具体的算法，负责具体计算）和环境类（不变，接受客户请求，将请求分配给一个策略类）。 代理模式：给对象提供一个代理品或者占位符方便对它的访问。 中介者模式：通过中间对象实现各个相关部分的通信。 装饰者模式：不改变对象自身的基础上，运行期间动态的给对象添加方法。 单例模式单例模式会在全局作用域下只创建一个实例对象，所有代码都只调用这一个实例。 js实现单例模式： 单例模式12345678910111213141516171819202122232425262728293031323334353637// 单例构造函数function CreateSingleton(name) { this.name = name; this.getName();}// 添加getName方法CreateSingleton.prototype.getName = function() { console.log(this.name);}// 创建单例对象主函数const Singleton = (function() { let ins; return function(name) { // 还未创建，创建一个实例 if (!ins) { ins = new CreateSingleton(name); } // 已创建，直接返回实例 return ins; }})(); // new一个测试实例let insA = new Singleton('mason'); console.log(insA); // CreateSingleton { name: 'mason' }// 再new一个实例，看看是否使用的是上面new的实例let insB = new Singleton('alex'); console.log(insB); // CreateSingleton { name: 'mason' }console.log(insA === insB); // true 前端使用到单例模式的场景： 页面上同时一般只能最多有一个modal。 参考 https://www.runoob.com/design-pattern/design-pattern-tutorial.html https://vue3js.cn/interview/design/design.html","link":"/2022/07/11/design-pattern/"},{"title":"Node.js高并发方案","text":"Node.js高并发方案 集群Node.js是单线程的，可以利用Cluster模块创建多个子进程来利用多核CPU，子进程共享相同的端口，平均分发请求，提高并发处理能力。 反向代理常用的反向代理服务器有Nginx和HAProxy。 Nginx 使用Nginx作为反向代理服务器，将请求分发给多个Node.js实例。 还可以用Nginx处理静态文件、SSL卸载以减轻Node.js的压力。 HAProxy HAProxy也可以做负载均衡。 消息队列消息队列的作用有：解耦服务，异步任务处理，缓冲突发流量。 常用RabbitMQ、Kafka。 缓存内存缓存将频繁访问的数据写入内存。 可以使用内存数据库Redis、Memcached，将高频访问的数据写入内存数据库以提高响应速度。 HTTP缓存服务端设置HTTP header的某些字段来减少客户端对服务端的请求，可以降低服务端压力。 Cache-Control ETag 数据库优化读写分离通过主从复制将数据库读写操作分离，在从库读取，在主库写入。 索引优化确保查询语句有合适的索引，避免全表扫描。 分库分表（Database Sharding &amp; Table Sharding）分库分库就是将数据分散到多个数据库中。 分库又分为垂直分库和水平分库。 垂直分库 根据业务模块的不同，将数据按照业务模块的不同拆分到多个数据库中。优点是不同模块的读写操作互不影响。 比如，在电商系统中，可以将用户模块的数据放在一个数据库中，将订单模块数据放在另一个数据库中。 水平分库 将同一个表的数据按照某种规则拆分到多个数据库中。优点是可以均衡数据量和访问压力。 比如，在电商系统中，将用户表中的数据按照用户ID范围或者哈希值拆分到多个数据库中。 分表分表就是将一张表的数据分散到多张表中。 分表又分为垂直分表和水平分表。 垂直分表 将表中字段较多的表按照字段拆分为多张表。 比如，把用户表拆分为基本信息和扩展信息两张表，减少了表的宽度提高了查询效率。 水平分表 将同一张表的数据按照行拆分到多张表中。 比如，按照用户ID将用户表分为user_01和user_02等多张表，解决了单张表数据量过大导致的性能问题。 如何分库分表 选择分片键（Shard Key） 分库分表需要选择一个合理的分片键，这会影响数据的分布和性能。 一般选择主键、时间戳，或者均匀分布数据的字段（常用UUID）作为分片键。 路由策略 分库分表后，路由是需要知道访问的数据在哪个库或者表中。 事务处理 分库分表后，事务中可能会出现跨库、跨表的情况。可以使用分布式事务、最终一致性等机制解决。 数据迁移和扩容 数据迁移：在单库单表的基础上分库分表，需要进行数据迁移，可以编写脚本或者使用工具将数据迁移到新的分库分表架构中。 扩容：随着数据量的增长，需要考虑动态扩展数据库或者表的数量。 分库分表中间件 Mycat：分库分表中间件。 ShardingSphere：分库分表中间件，支持分布式事务。 TDDL：分布式数据库层，可以分库分表。 如果使用了Sequelize，还可以安装插件支持分库分表： Sharding插件 自定义ORM扩展：在ORM中自定义模型的数据库连接或查询方法，实现对不同数据库或表的访问。 性能监控和优化分库分表架构建立后，需要持续监控新架构的系统性能以及根据监控调整分库分表策略。 Node.js分库分表简单实现下面的实例将用户信息分散到了两个数据库中。 js1234567891011121314151617181920212223242526const mysql = require('mysql2/promise');// 两个数据库的配置信息const dbConfigs = [ { host: 'localhost', user: 'root', password: 'password', database: 'db1' }, { host: 'localhost', user: 'root', password: 'password', database: 'db2' },];// 为每个数据库创建连接池const pools = dbConfigs.map(config =&gt; mysql.createPool(config));// 根据id将用户请求分散到多个数据库上，计算数据库偏移量const getShard = (id) =&gt; id % dbConfigs.length;const getUser = async (userId) =&gt; { // 选择id为分片键 const shard = getShard(userId); const pool = pools[shard]; const conn = await pool.getConnection(); const [rows] = await conn.query('SELECT * FROM users WHERE id = ?', [userId]); conn.release(); return rows[0];};// 调用getUser(1234456).then(user =&gt; console.log(user)).catch(err =&gt; console.error(err)); 性能监控和调优监控工具：PM2，New Relic，Datadog 服务器扩展 垂直扩展 提升服务器硬件配置。 水平扩展 增加服务器数量。 CDN使用CDN缓存静态资源。 限流和降级 限流 限制流量避免系统宕机。 降级 系统压力较大时可以关闭部分非核心服务，有限保证核心服务。","link":"/2024/09/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"MySQL学习笔记","text":"MySQL是关系型数据库管理系统(RDBMS)。 MySQL操作SQL1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283-- 展示所有的数据库SHOW DATABASES;-- 创建数据库CREATE DATABASE db_name;-- 使用数据库USE db_name;-- 创建表CREATE TABLE table_name ( column1 datatype, column2 datatype, column3 datatype)-- 查看表结构DESCRIBE table_name;-- 删除数据库DROP DATABASE db_name;-- 删除表DROP TABLE table_name;-- 插入数据INSERT INTO table_name ( column1, column2, column3)VALUES ( value1, value2, value3)-- 查询数据SELECT column1, column2FROM table_nameWHERE condition;-- 更新数据UPDATE table_nameSET column1 = value1, column2 = value2WHERE condition;-- 删除数据DELETE FROM table_nameWHERE condition;-- 联表查询SELECT columnsFROM table1JOIN table2ON table1.column = table2.column;-- 子查询SELECT columnsFROM table_nameWHERE column_name = (SELECT column FROM another_table WHERE condition);-- 聚合函数，COUNT(), SUM(), AVG(), MAX(), MIN()SELECT COUNT(*) FROM table_name;-- 创建索引CREATE INDEX index_name ON table_name (column);-- 删除索引DROP INDEX index_name ON table_name;-- 分析查询性能EXPLAIN select * from table_name;-- 创建用户CREATE USER 'username'@'host' IDENTIFIED BY 'password';-- 授予权限GRANT ALL PRIVILEGES ON database_name.* TO 'username'@'host';-- 查看用户权限SHOW GRANTS FOR 'username'@'host';-- 撤销权限REVOKE ALL PRIVILEGES ON database_name.* FROM 'username'@'host'; 备份与恢复bash12345# 备份数据库mysqldump -u username -p database_name &gt; backup.sql# 恢复数据库mysql -u username -p database_name &lt; backup.sql 安全SQL12-- 设置root密码ALTER USER 'root'@'localhost' IDENTIFIED WITH 'mysql_native_password' BY 'new_password'; 常见问题 连接失败 可能是防火墙配置不正确、MySQL服务未启动、用户权限异常。 性能问题 分析查询日志，优化查询，增加索引。 参考 https://www.mysqlzh.com/ https://www.runoob.com/mysql/mysql-tutorial.html","link":"/2021/07/20/mysql-note/"},{"title":"MySQL中的锁","text":"MySQL中有哪些锁？这些锁的作用又是什么？ MySQL中的锁按照颗粒度从粗到细分为： 全局锁 表级锁 行级锁 SQL分类： DDL(Data Definition Language)数据定义语言：用来操作数据库、表、列等。常用语句：CREATE、ALTER、DROP。 DML(Data Manipulation Language)数据操作语言：用来操作数据库中表里的数据。常用语句：INSERT、 UPDATE、DELETE。 DCL(Data Control Language)数据控制语言：用来操作访问权限和安全级别。常用语句：GRANT、DENY。 DQL(Data Query Language)数据查询语言：用来查询数据。常用语句：SELECT。 全局锁（Global Lock）全局锁会锁住整个数据库并且数据库处于只读状态，只能进行DQL操作不能进行DDL（包括定义、改变表结构、数据类型、表之间链接的操作）和DML操作，适用于需要保证数据一致性的场景比如数据备份。 数据备份加锁步骤： 加全局锁，之后只能进行DQL操作。SQL1FLUSH TABLES WITH READ LOCK; 使用mysqldump备份数据库。bash1mysqldump --user user --password database_name --result-file=path/to/file.sql 备份完成后解开全局锁。SQL1UNLOCK TABLES; 正常进行DDL、DML、DQL操作。 表级锁表级锁分为： 表锁 元数据锁 意向锁 表锁（Table Lock）SQL12345-- 给表加锁LOCK TABLES table_name [READ | WRITE]-- 释放锁UNLOCK TABLES; 表锁锁的是整张表，表所细分为读锁和写锁。 读锁（Read Lock） 多个事务可以同时读表，但是无法写。 写锁（Write Lock） 一个事务在获取到写锁后其他事务无法读写这张表，等到写锁被释放其他事务才可以继续读写。 元数据锁（Meta Data Lock）元数据锁锁定的是表结构（包括表定义、索引定义），当执行改变表结构的操作（ALTER TABLE、DROP TABLE）时MySQL会自动给表加上元数据锁以防止并发的DDL操作（比如CREATE、ALTER、DROP）和DML（比如INSERT、UPDATE、DELETE）操作发生冲突。 意向锁（Intention Lock）意向锁是MySQL自动加的。 意向锁不会阻塞其他事务的表锁操作，只是用来表明某个事务打算对某些行加锁。 意向共享锁（Intention Shared Lock）：当一个事务想要在某些行上加共享锁时，首先需要在表级别加意向共享锁。 意向排他锁（Intention Exclusive Lock）：当一个事务想要在某些行上加排他锁时，首先需要在表级别加意向排他锁。 行级锁行级锁是粒度最小的锁，是针对于索引字段加的锁，只对于当前操作的一行或者多行进行加锁。 行级锁操作粒度最小，并发度高。但是加锁开销最大，可能出现死锁。 行级锁分为： 行锁 间隙锁 临键锁 行锁（Row Lock）行锁锁定表中的一行或者多行。 因为行锁只锁定特定的行，所以不影响整张表，是innoDB主要的锁类型。 行锁分为： 共享锁 如果给行加上共享锁，那么其他事务将不可获得排他锁，其他事务只能获取共享锁并且只能读这些行。 排他锁 只允许获取到排他锁的事务读写，其他事务将不能获取到共享锁和排他锁直到排他锁被释放。 间隙锁（Gap Lock）当用范围条件而不是相等条件索引数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做间隙。间隙锁帮我们解决幻读问题。 临键锁（Next-Key Lock）临键锁是行锁与间隙锁的组合，它的锁定范围既包含行又包含索引区间。 自增锁（AUTO-INC Lock）如果一个表中含有自增字段，MySQL会使用自增锁来确保并发插入操作时自增字段的唯一性和有序性。 自增锁在事务提交时释放。 外键锁（Foreign Key Lock）使用外键约束时，innoDB会对相关行加锁确保父表中的行在存在关联的子表行时不会被删除或者更新。","link":"/2024/09/04/mysql-lock/"},{"title":"MySQL中UPDATE和INSERT在加锁上有什么区别","text":"在MySQL中，UPDATE和INSERT在加锁上有一些区别。 锁的范围 UPDATE 使用UPDATE只会对需要更新的一行或者多行进行加锁，加的是行锁。 如果还使用了WHERE则还会加上间隙锁，锁住范围内不存在的索引项之间的间隙防止其他事务插入新行。 INSERT INSERT不会加行锁，它会对插入位置加上插入意向锁（Insert Intention Lock）以防止并发插入时死锁。 锁的类型 UPDATE UPDATE会使用排他锁锁住需要更新的行。 INSERT INSERT会使用排他锁来保证数据一致性，插入完成后释放锁。 锁的冲突 UPDATE UPDATE会使用排他锁，故而可能导致锁等待或者死锁。 INSERT 并发INSERT时一般不会发生锁冲突。","link":"/2024/09/04/mysql-update-insert-lock-diff/"},{"title":"Redis在实际业务中的使用场景","text":"Redis是一个高性能的KV内存数据库，实际业务中有很多使用场景。 缓存 可以将高频访问的数据缓存到Redis以降低后端数据库压力。 可以将查询耗时长的查询结果缓存到Redis避免重复查询。 会话存储在分布式系统中Redis可以用来存储用户会话数据，从而使不同的服务器可以共享用户的会话数据。 数据过期Redis可以设置键的过期时间，适合存储需要自动过期的数据，比如验证码、临时令牌。 分布式锁在分布式系统中，使用Redis的原子操作可以实现分布式锁，确保多个进程或者服务不会同时操作同一个资源。 消息队列 Redis支持发布/订阅模式，可以作为简单的消息队列使用。 可以使用Redis的列表数据结构实现任务队列，适合处理需要排队执行的任务。 任务调度Redis可以实现延迟任务。","link":"/2024/09/04/Redis%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"},{"title":"RPC学习笔记","text":"RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许程序在不同的地址空间中调用另一个程序的函数，就像调用本地函数一样。通过RPC，开发人员可以构建分布式系统，其中程序可以在不同的计算机或网络节点上运行，但仍能相互通信并调用对方的服务或方法。 RPC工作流程 客户端发起调用：客户端调用一个本地的代理函数（stub），并将参数传给它。 序列化参数：客户端stub将参数序列化。 发送请求：将请求发送到被调用的远程服务器。 远程服务器处理请求：远程服务器收到请求后反序列化参数，调用本地的目标函数。 远程服务器返回调用结果：远程服务器执行完函数后，将执行结果序列化并返回给客户端。 客户端接收结果：客户端接受到远程服务器的响应，然后反序列化结果，最后将它返回给最初调用的程序。 RPC框架主流的RPC框架有： gRPC Dubbo","link":"/2024/09/04/RPC/"}],"tags":[{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"二维数组","slug":"二维数组","link":"/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"MongoDB","slug":"MongoDB","link":"/categories/MongoDB/"},{"name":"Algorithms","slug":"Algorithms","link":"/categories/Algorithms/"},{"name":"Express","slug":"Node-js/Express","link":"/categories/Node-js/Express/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Macintosh","slug":"Macintosh","link":"/categories/Macintosh/"},{"name":"LaTeX","slug":"LaTeX","link":"/categories/LaTeX/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"SQLite","slug":"SQLite","link":"/categories/SQLite/"},{"name":"Mathematics","slug":"Mathematics","link":"/categories/Mathematics/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"UI","slug":"UI","link":"/categories/UI/"},{"name":"ASM","slug":"ASM","link":"/categories/ASM/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Deno","slug":"Deno","link":"/categories/Deno/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"Interview","slug":"Interview","link":"/categories/Interview/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"jQuery","slug":"jQuery","link":"/categories/jQuery/"},{"name":"Methodology","slug":"Methodology","link":"/categories/Methodology/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"Shell","slug":"Shell","link":"/categories/Shell/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"SVN","slug":"SVN","link":"/categories/SVN/"},{"name":"Tips","slug":"Tips","link":"/categories/Tips/"},{"name":"WASM","slug":"WASM","link":"/categories/WASM/"},{"name":"Mini Program","slug":"Mini-Program","link":"/categories/Mini-Program/"},{"name":"Crawler","slug":"Crawler","link":"/categories/Crawler/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/categories/C-C/"},{"name":"RPC","slug":"RPC","link":"/categories/RPC/"}]}